#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const Ajv = require('ajv');

class BackendGenerator {
    constructor() {
        this.ajv = new Ajv();
        this.schema = require('../problems/schema.json');
        this.validateProblem = this.ajv.compile(this.schema);
    }

    loadAllProblems() {
        const problemsDir = path.join(__dirname, '../problems');
        const phases = fs.readdirSync(problemsDir).filter(name => 
            fs.statSync(path.join(problemsDir, name)).isDirectory()
        );

        const problems = [];
        
        for (const phase of phases) {
            const phaseDir = path.join(problemsDir, phase);
            const files = fs.readdirSync(phaseDir).filter(f => f.endsWith('.json'));
            
            for (const file of files) {
                const filePath = path.join(phaseDir, file);
                try {
                    const problemData = JSON.parse(fs.readFileSync(filePath, 'utf8'));
                    
                    if (!this.validateProblem(problemData)) {
                        console.error(`‚ùå Invalid problem in ${filePath}:`, this.validateProblem.errors);
                        continue;
                    }
                    
                    // Only include problems with validation for backend
                    if (problemData.validation && 
                        (problemData.validation.exactRequirements || problemData.validation.testCases)) {
                        problems.push(problemData);
                    }
                } catch (error) {
                    console.error(`‚ùå Error loading ${filePath}:`, error.message);
                }
            }
        }

        return problems.sort((a, b) => a.id - b.id);
    }

    generateTestDefinition(problem) {
        const { validation } = problem;
        const { exactRequirements, testCases } = validation;

        const testDef = {
            name: problem.title,
            category: problem.phase,
            description: problem.description
        };

        // Add exact requirements
        if (exactRequirements) {
            testDef.exactRequirements = {};

            if (exactRequirements.functionNames) {
                testDef.exactRequirements.functionNames = exactRequirements.functionNames;
            }

            if (exactRequirements.variables) {
                testDef.exactRequirements.variables = exactRequirements.variables;
            }

            if (exactRequirements.outputMessages) {
                testDef.exactRequirements.outputMessages = exactRequirements.outputMessages;
            }

            if (exactRequirements.requiredIncludes) {
                testDef.exactRequirements.requiredIncludes = exactRequirements.requiredIncludes;
            }

            if (exactRequirements.mustContain) {
                testDef.exactRequirements.mustContain = exactRequirements.mustContain;
            }

            if (exactRequirements.structures) {
                testDef.exactRequirements.structures = exactRequirements.structures;
            }

            if (exactRequirements.moduleInfo) {
                testDef.exactRequirements.moduleInfo = exactRequirements.moduleInfo;
            }
        }

        // Add test cases
        if (testCases && testCases.length > 0) {
            testDef.testCases = testCases;
        }

        // Add multi-part info if present
        if (problem.multiPart) {
            testDef.multiPart = problem.multiPart;
        }

        return testDef;
    }

    generateBackendCode(problems) {
        const testDefinitions = problems.map(p => ({
            id: p.id,
            definition: this.generateTestDefinition(p)
        }));

        const template = `// Auto-generated from problems/ directory
// DO NOT EDIT THIS FILE DIRECTLY - Edit problems/*.json instead
// Generated at: ${new Date().toISOString()}

const generatedTestDefinitions = new Map();

${testDefinitions.map(({ id, definition }) => `
// Problem ${id}: ${definition.name}
generatedTestDefinitions.set(${id}, ${JSON.stringify(definition, null, 4)});
`).join('\n')}

module.exports = generatedTestDefinitions;
`;

        return template;
    }

    updateValidatorFile(problems) {
        const backendCode = this.generateBackendCode(problems);
        const outputPath = path.join(__dirname, '../backend/generated-test-definitions.js');
        
        fs.writeFileSync(outputPath, backendCode);
        console.log(`‚úÖ Generated backend test definitions: ${outputPath}`);
        console.log(`üìä Total problems with validation: ${problems.length}`);
        
        // Generate update instructions
        console.log('\nüìù To use in leetcode-style-validator.js:');
        console.log('1. Import: const generatedTestDefinitions = require("./generated-test-definitions.js");');
        console.log('2. In constructor, add: this.loadGeneratedDefinitions(generatedTestDefinitions);');
        console.log('3. Add method: loadGeneratedDefinitions(definitions) { for (const [id, def] of definitions) { this.testDefinitions.set(id, def); } }');
    }

    generateValidatorPatch() {
        const patchCode = `
    // Method to load generated test definitions
    loadGeneratedDefinitions(generatedDefinitions) {
        for (const [problemId, definition] of generatedDefinitions) {
            this.testDefinitions.set(problemId, definition);
            console.log(\`‚úÖ Loaded generated test definition for problem \${problemId}: \${definition.name}\`);
        }
    }
`;

        const patchPath = path.join(__dirname, '../backend/validator-patch.js');
        fs.writeFileSync(patchPath, patchCode);
        console.log(`‚úÖ Generated validator patch: ${patchPath}`);
    }

    run() {
        console.log('üöÄ Generating backend test definitions...');
        
        const problems = this.loadAllProblems();
        if (problems.length === 0) {
            console.log('‚ùå No problems with validation found');
            return;
        }

        this.updateValidatorFile(problems);
        this.generateValidatorPatch();
        
        console.log('\n‚úÖ Backend generation complete!');
        console.log('\nüîß Manual steps to integrate:');
        console.log('1. Add this to leetcode-style-validator.js constructor:');
        console.log('   const generatedTestDefinitions = require("./generated-test-definitions.js");');
        console.log('   this.loadGeneratedDefinitions(generatedTestDefinitions);');
        console.log('2. Copy the loadGeneratedDefinitions method from validator-patch.js');
    }
}

// Run if called directly
if (require.main === module) {
    const generator = new BackendGenerator();
    generator.run();
}

module.exports = BackendGenerator;
