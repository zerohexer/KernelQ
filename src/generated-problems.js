// Auto-generated from problems/ directory
// DO NOT EDIT THIS FILE DIRECTLY - Edit problems/*.json instead
// Generated at: 2025-07-08T18:36:22.602Z

const problemBank = [
  {
    "id": 1,
    "title": "Hello Kernel World",
    "difficulty": 1,
    "xp": 10,
    "phase": "foundations",
    "description": "Create your first kernel module that prints a greeting message when loaded and a goodbye message when unloaded. This is the traditional 'Hello World' for kernel programming.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// TODO: Implement hello_init function\n// TODO: Implement hello_exit function\n\n// TODO: Set module init and exit functions\n// TODO: Add module information\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"A simple Hello World kernel module\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "module_init",
      "module_exit",
      "printk",
      "MODULE_LICENSE",
      "kernel modules"
    ],
    "skills": [
      "Basic kernel programming",
      "Module lifecycle",
      "Kernel logging"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Hello from the kernel!",
        "Goodbye from the kernel!"
      ],
      "requirements": [
        "Use required function names: hello_init, hello_exit",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h",
        "Must include MODULE_LICENSE(\"GPL\")"
      ]
    }
  },
  {
    "id": 2,
    "title": "Variables and Data Types",
    "difficulty": 2,
    "xp": 15,
    "phase": "foundations",
    "description": "Learn to work with different data types in kernel space. Create variables of different types and print their values using printk. This introduces you to kernel-space variable declaration and printing.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// TODO: Declare variables with exact names and values:\n// int my_int = 42;\n// char my_char = 'K';\n// bool my_bool = true;\n\nstatic int __init datatypes_init(void) {\n    // TODO: Print the variables in exact format:\n    // printk(KERN_INFO \"Integer: %d\\n\", my_int);\n    // printk(KERN_INFO \"Character: %c\\n\", my_char);\n    // printk(KERN_INFO \"Boolean: %d\\n\", my_bool);\n    return 0;\n}\n\nstatic void __exit datatypes_exit(void) {\n    printk(KERN_INFO \"Datatypes module unloaded\\n\");\n}\n\nmodule_init(datatypes_init);\nmodule_exit(datatypes_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Data types demonstration module\");",
    "concepts": [
      "kernel data types",
      "variable declaration",
      "printk formatting",
      "static variables"
    ],
    "skills": [
      "Variable management",
      "Data type understanding",
      "Kernel logging with formatting"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Integer: 42",
        "Character: K",
        "Boolean: 1"
      ],
      "requirements": [
        "Use required function names: datatypes_init, datatypes_exit",
        "Use required variable names: my_int, my_char, my_bool",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h",
        "Code must contain: printk, KERN_INFO",
        "Must include MODULE_LICENSE(\"GPL\")"
      ]
    }
  },
  {
    "id": 3,
    "title": "Variable Declaration and Usage",
    "difficulty": 1,
    "xp": 30,
    "phase": "foundations",
    "description": "Declare integer and character variables, then print their values using proper format specifiers. The system will test both compilation and runtime output with hidden test cases.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int __init variables_init(void) {\n    // TODO: Declare an integer variable with any value\n    // TODO: Declare a character variable with any value\n    // TODO: Print both using printk with correct format specifiers\n    // Format: \"Integer value: %d\" and \"Character value: %c\"\n    \n    return 0;\n}\n\n// TODO: Add exit function\n// TODO: Register init/exit functions\n// TODO: Add module metadata\n\nMODULE_LICENSE(\"GPL\");",
    "concepts": [
      "C data types",
      "Format specifiers",
      "Variable declaration"
    ],
    "skills": [
      "Variable usage",
      "printk formatting",
      "Type safety"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Integer value: 42",
        "Character value: K"
      ],
      "requirements": [
        "Use required function names: variables_init, variables_exit",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h",
        "Code must contain: printk, module_init, module_exit",
        "Must include MODULE_LICENSE(\"GPL\")"
      ]
    }
  },
  {
    "id": 4,
    "title": "Arrays and Loops in Kernel Space",
    "difficulty": 2,
    "xp": 20,
    "phase": "foundations",
    "description": "Learn to work with arrays and loops in kernel space. Create an array of integers and use a for loop to print each element. This introduces fundamental C programming concepts in kernel context.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// TODO: Declare an array of integers called 'numbers' with values [10, 20, 30, 40, 50]\n// TODO: Use a for loop to print each element\n// Format: \"Element 0: 10\", \"Element 1: 20\", etc.\n\nstatic int __init arrays_init(void) {\n    // TODO: Implement array declaration and loop\n    return 0;\n}\n\nstatic void __exit arrays_exit(void) {\n    printk(KERN_INFO \"Arrays module unloaded\\n\");\n}\n\nmodule_init(arrays_init);\nmodule_exit(arrays_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Arrays and loops demonstration module\");",
    "concepts": [
      "arrays",
      "for loops",
      "array indexing",
      "iteration"
    ],
    "skills": [
      "Array manipulation",
      "Loop control",
      "Index-based access"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Element 0: 10",
        "Element 1: 20",
        "Element 2: 30",
        "Element 3: 40",
        "Element 4: 50"
      ],
      "requirements": [
        "Use required function names: arrays_init, arrays_exit",
        "Declare array with exact name 'numbers' and values [10, 20, 30, 40, 50]",
        "Use for loop to iterate through array",
        "Print in exact format: \"Element X: Y\"",
        "Must include proper kernel headers"
      ]
    }
  },
  {
    "id": 5,
    "title": "Arithmetic and Comparison Operations",
    "difficulty": 2,
    "xp": 25,
    "phase": "foundations",
    "description": "Master arithmetic operations (+, -, *, /, %) and comparison operators in kernel programming. Learn to perform calculations and make logical comparisons essential for kernel logic.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int __init arithmetic_init(void) {\n    int a = 25, b = 7;\n    int sum, diff, product, quotient, remainder;\n    bool greater, equal, not_equal;\n    \n    // TODO: Perform arithmetic operations\n    // sum = a + b\n    // diff = a - b  \n    // product = a * b\n    // quotient = a / b\n    // remainder = a % b\n    \n    // TODO: Perform comparison operations\n    // greater = (a > b)\n    // equal = (a == b)\n    // not_equal = (a != b)\n    \n    // TODO: Print results in exact format:\n    // \"Arithmetic Results:\"\n    // \"25 + 7 = 32\"\n    // \"25 - 7 = 18\"\n    // \"25 * 7 = 175\"\n    // \"25 / 7 = 3\"\n    // \"25 % 7 = 4\"\n    // \"Comparison Results:\"\n    // \"25 > 7: true (1)\"\n    // \"25 == 7: false (0)\"\n    // \"25 != 7: true (1)\"\n    \n    return 0;\n}\n\nstatic void __exit arithmetic_exit(void) {\n    printk(KERN_INFO \"Arithmetic operations module unloaded\\n\");\n}\n\nmodule_init(arithmetic_init);\nmodule_exit(arithmetic_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Arithmetic and comparison operations module\");",
    "concepts": [
      "arithmetic operators",
      "comparison operators",
      "integer division",
      "modulo operation",
      "boolean results"
    ],
    "skills": [
      "Mathematical calculations",
      "Logical comparisons",
      "Operator precedence",
      "Type understanding"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Arithmetic Results:",
        "25 + 7 = 32",
        "25 - 7 = 18",
        "25 * 7 = 175",
        "25 / 7 = 3",
        "25 % 7 = 4",
        "Comparison Results:",
        "25 > 7: true (1)",
        "25 == 7: false (0)",
        "25 != 7: true (1)"
      ],
      "requirements": [
        "Use required function names: arithmetic_init, arithmetic_exit",
        "Use exact variable names: a=25, b=7, sum, diff, product, quotient, remainder",
        "Use exact variable names for comparisons: greater, equal, not_equal",
        "Perform all arithmetic operations: +, -, *, /, %",
        "Perform all comparison operations: >, ==, !=",
        "Print results in exact format shown above",
        "Must show correct mathematical results"
      ]
    }
  },
  {
    "id": 6,
    "title": "Functions and Return Values",
    "difficulty": 3,
    "xp": 25,
    "phase": "foundations",
    "description": "Create custom functions that perform calculations and return values. Learn function declaration, parameter passing, and return values in kernel programming context.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// TODO: Create a function called 'calculate_sum' that takes two integers and returns their sum\n// TODO: Create a function called 'find_max' that takes two integers and returns the larger one\n\nstatic int __init functions_init(void) {\n    int a = 15, b = 25;\n    int sum, max;\n    \n    // TODO: Call calculate_sum and find_max functions\n    // TODO: Print results in exact format:\n    // \"Sum of 15 and 25 is: 40\"\n    // \"Maximum of 15 and 25 is: 25\"\n    \n    return 0;\n}\n\nstatic void __exit functions_exit(void) {\n    printk(KERN_INFO \"Functions module unloaded\\n\");\n}\n\nmodule_init(functions_init);\nmodule_exit(functions_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Functions and return values demonstration module\");",
    "concepts": [
      "function declaration",
      "function parameters",
      "return values",
      "function calls"
    ],
    "skills": [
      "Function design",
      "Parameter passing",
      "Return value handling",
      "Code organization"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Sum of 15 and 25 is: 40",
        "Maximum of 15 and 25 is: 25"
      ],
      "requirements": [
        "Use required function names: functions_init, functions_exit",
        "Create function 'calculate_sum' that takes two int parameters and returns int",
        "Create function 'find_max' that takes two int parameters and returns int",
        "Use exact variables: a=15, b=25",
        "Print in exact format shown above",
        "Functions must return correct values"
      ]
    }
  },
  {
    "id": 7,
    "title": "Conditional Statements and Control Flow",
    "difficulty": 3,
    "xp": 30,
    "phase": "foundations",
    "description": "Master if/else statements and logical operators for control flow in kernel programming. Learn to make decisions and control program execution based on conditions.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int __init conditional_init(void) {\n    int temperature = 75;\n    int humidity = 60;\n    bool is_summer = true;\n    int age = 25;\n    \n    // TODO: Use if/else to check temperature ranges\n    // if temperature >= 80: print \"Hot weather\"\n    // else if temperature >= 60: print \"Moderate weather\" \n    // else: print \"Cold weather\"\n    \n    // TODO: Use logical operators (&&, ||, !)\n    // if (temperature > 70 && humidity > 50): print \"Warm and humid\"\n    // if (is_summer || temperature > 85): print \"Summer conditions\"\n    // if (!is_summer): print \"Not summer\"\n    \n    // TODO: Use nested if statements\n    // if (age >= 18) {\n    //     if (age >= 65) print \"Senior citizen\"\n    //     else print \"Adult\"\n    // } else {\n    //     print \"Minor\"\n    // }\n    \n    // Expected output:\n    // \"Temperature Check: Moderate weather\"\n    // \"Condition Check: Warm and humid\" \n    // \"Season Check: Summer conditions\"\n    // \"Age Check: Adult\"\n    \n    return 0;\n}\n\nstatic void __exit conditional_exit(void) {\n    printk(KERN_INFO \"Conditional statements module unloaded\\n\");\n}\n\nmodule_init(conditional_init);\nmodule_exit(conditional_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Conditional statements and control flow module\");",
    "concepts": [
      "if/else statements",
      "logical operators",
      "nested conditions",
      "boolean logic",
      "control flow"
    ],
    "skills": [
      "Decision making",
      "Conditional logic",
      "Program flow control",
      "Boolean operations"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Temperature Check: Moderate weather",
        "Condition Check: Warm and humid",
        "Season Check: Summer conditions",
        "Age Check: Adult"
      ],
      "requirements": [
        "Use required function names: conditional_init, conditional_exit",
        "Use exact variable values: temperature=75, humidity=60, is_summer=true, age=25",
        "Implement if/else if/else for temperature check",
        "Use logical operators: && (AND), || (OR), ! (NOT)",
        "Implement nested if statements for age check",
        "Print results with exact prefixes: 'Temperature Check:', 'Condition Check:', etc.",
        "Must use actual conditional logic, not hardcoded prints"
      ]
    }
  },
  {
    "id": 8,
    "title": "Loop Structures and Iteration Control",
    "difficulty": 3,
    "xp": 30,
    "phase": "foundations",
    "description": "Master different loop types (while, do-while, for) and loop control statements (break, continue) in kernel programming. Essential for iterative operations and data processing.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int __init loops_init(void) {\n    int i, sum;\n    int numbers[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    int count = 0;\n    \n    // TODO: Use for loop to calculate sum of array elements\n    // for (i = 0; i < 10; i++) { sum += numbers[i]; }\n    // Print: \"For loop sum: 55\"\n    \n    // TODO: Use while loop to count even numbers\n    // i = 0; while (i < 10) { if even, increment count; i++; }\n    // Print: \"While loop even count: 5\"\n    \n    // TODO: Use do-while loop to find first number > 5\n    // i = 0; do { check numbers[i]; i++; } while (numbers[i-1] <= 5);\n    // Print: \"Do-while found number > 5 at index: 5\" (number 6)\n    \n    // TODO: Use for loop with break and continue\n    // Skip odd numbers (continue), break at 8\n    // Print even numbers: \"Loop control: 2 4 6 8\"\n    \n    return 0;\n}\n\nstatic void __exit loops_exit(void) {\n    printk(KERN_INFO \"Loops module unloaded\\n\");\n}\n\nmodule_init(loops_init);\nmodule_exit(loops_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Loop structures and iteration control module\");",
    "concepts": [
      "for loops",
      "while loops",
      "do-while loops",
      "break statement",
      "continue statement",
      "loop control"
    ],
    "skills": [
      "Iterative programming",
      "Loop design",
      "Flow control",
      "Array processing"
    ],
    "inputOutput": {
      "expectedOutput": [
        "For loop sum: 55",
        "While loop even count: 5",
        "Do-while found number > 5 at index: 5",
        "Loop control: 2 4 6 8"
      ],
      "requirements": [
        "Use required function names: loops_init, loops_exit",
        "Use provided array: numbers[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
        "Implement for loop to calculate sum of all array elements",
        "Implement while loop to count even numbers in array",
        "Implement do-while loop to find first number > 5",
        "Use break and continue statements in loop control example",
        "Print results in exact format shown above",
        "Must use actual loop logic, not hardcoded results"
      ]
    }
  },
  {
    "id": 9,
    "title": "Switch-Case Statements and Multi-way Branching",
    "difficulty": 3,
    "xp": 25,
    "phase": "foundations",
    "description": "Master switch-case statements for multi-way branching and understand when to use switch vs if-else. Learn proper use of break statements and default cases.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int __init switch_init(void) {\n    int operation = 2;\n    int a = 15, b = 5;\n    int result = 0;\n    char grade = 'B';\n    int day = 3;\n    \n    // TODO: Use switch statement for arithmetic operations\n    // case 1: addition (a + b)\n    // case 2: subtraction (a - b) \n    // case 3: multiplication (a * b)\n    // case 4: division (a / b)\n    // default: print \"Invalid operation\"\n    // Print: \"Operation 2 result: 10\"\n    \n    // TODO: Use switch statement for grade interpretation\n    // case 'A': print \"Excellent\"\n    // case 'B': print \"Good\"\n    // case 'C': print \"Average\" \n    // case 'D': print \"Below Average\"\n    // case 'F': print \"Fail\"\n    // default: print \"Invalid grade\"\n    // Print: \"Grade B: Good\"\n    \n    // TODO: Use switch with fall-through for day grouping\n    // case 1,2,3,4,5: print \"Weekday\"\n    // case 6,7: print \"Weekend\"\n    // default: print \"Invalid day\"\n    // Print: \"Day 3: Weekday\"\n    \n    return 0;\n}\n\nstatic void __exit switch_exit(void) {\n    printk(KERN_INFO \"Switch statements module unloaded\\n\");\n}\n\nmodule_init(switch_init);\nmodule_exit(switch_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Switch-case statements module\");",
    "concepts": [
      "switch statements",
      "case labels",
      "break statements",
      "default case",
      "fall-through behavior"
    ],
    "skills": [
      "Multi-way branching",
      "Switch vs if-else selection",
      "Control flow design",
      "Pattern matching"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Operation 2 result: 10",
        "Grade B: Good",
        "Day 3: Weekday"
      ],
      "requirements": [
        "Use required function names: switch_init, switch_exit",
        "Use exact variable values: operation=2, a=15, b=5, grade='B', day=3",
        "Implement switch statement for arithmetic operations (cases 1-4, default)",
        "Implement switch statement for grade interpretation (cases A-F, default)",
        "Implement switch statement with fall-through for weekday/weekend",
        "Use proper break statements to prevent fall-through where needed",
        "Include default cases in all switch statements",
        "Print results in exact format shown above"
      ]
    }
  },
  {
    "id": 10,
    "title": "Structures Basics - Part 1: Definition and Usage",
    "difficulty": 3,
    "xp": 30,
    "phase": "foundations",
    "description": "Learn to define and use structures in kernel programming. Understand structure declaration, member access, and initialization. This is fundamental for kernel data structures.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// TODO: Define a structure called 'student' with members:\n// - int id\n// - char name[20] \n// - int age\n// - float gpa\n\nstatic int __init structures_init(void) {\n    // TODO: Declare a variable 'stu' of type 'struct student'\n    // TODO: Initialize: id=101, name=\"Alice\", age=20, gpa=3.8\n    // TODO: Print all member values in exact format:\n    // \"Student ID: 101\"\n    // \"Student Name: Alice\"\n    // \"Student Age: 20\" \n    // \"Student GPA: 3\"\n    \n    return 0;\n}\n\nstatic void __exit structures_exit(void) {\n    printk(KERN_INFO \"Structures module unloaded\\n\");\n}\n\nmodule_init(structures_init);\nmodule_exit(structures_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Structures demonstration module\");",
    "concepts": [
      "structure definition",
      "structure members",
      "structure initialization",
      "member access operator"
    ],
    "skills": [
      "Data structure design",
      "Complex data types",
      "Structure manipulation",
      "Member access"
    ],
    "multiPart": {
      "part": 1,
      "totalParts": 3,
      "nextProblemId": 10,
      "previousProblemId": null
    },
    "inputOutput": {
      "expectedOutput": [
        "Student ID: 101",
        "Student Name: Alice",
        "Student Age: 20",
        "Student GPA: 3"
      ],
      "requirements": [
        "Use required function names: structures_init, structures_exit",
        "Define structure 'student' with exact members: id, name[20], age, gpa",
        "Declare variable 'stu' of type 'struct student'",
        "Initialize with exact values: id=101, name=\"Alice\", age=20, gpa=3.8",
        "Print using dot operator to access members",
        "Use exact format strings shown above"
      ]
    }
  },
  {
    "id": 11,
    "title": "Enums, Constants, and Symbolic Values",
    "difficulty": 3,
    "xp": 30,
    "phase": "foundations",
    "description": "Learn to use enums for named constants and symbolic values. Understand const keyword, #define macros, and proper constant management in kernel programming.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// TODO: Define preprocessor constants\n#define MAX_DEVICES 10\n#define DEVICE_NAME_LEN 32\n#define VERSION_MAJOR 2\n#define VERSION_MINOR 1\n\n// TODO: Define enum for device states\nenum device_state {\n    DEVICE_OFFLINE,\n    DEVICE_INITIALIZING,\n    DEVICE_READY, \n    DEVICE_BUSY,\n    DEVICE_ERROR\n};\n\n// TODO: Define enum for operation types\nenum operation_type {\n    OP_READ = 1,\n    OP_WRITE = 2,\n    OP_IOCTL = 4,\n    OP_MMAP = 8\n};\n\nstatic int __init enums_init(void) {\n    const int buffer_size = 1024;\n    const char *driver_name = \"test_driver\";\n    enum device_state current_state = DEVICE_READY;\n    enum operation_type allowed_ops = OP_READ | OP_WRITE;\n    int device_count = 5;\n    \n    // TODO: Print constant values\n    // \"Constants:\"\n    // \"MAX_DEVICES: 10\"\n    // \"DEVICE_NAME_LEN: 32\" \n    // \"Version: 2.1\"\n    // \"Buffer size: 1024\"\n    // \"Driver name: test_driver\"\n    \n    // TODO: Print enum values and their integer representations\n    // \"Device States:\"\n    // \"DEVICE_OFFLINE = 0\"\n    // \"DEVICE_READY = 2\" \n    // \"Current state: DEVICE_READY (2)\"\n    \n    // TODO: Use enums in conditional logic\n    // if (current_state == DEVICE_READY) print \"Device is ready\"\n    // if (device_count < MAX_DEVICES) print \"Can add more devices\"\n    // if (allowed_ops & OP_READ) print \"Read operation allowed\"\n    \n    return 0;\n}\n\nstatic void __exit enums_exit(void) {\n    printk(KERN_INFO \"Enums and constants module unloaded\\n\");\n}\n\nmodule_init(enums_init);\nmodule_exit(enums_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Enums and constants demonstration module\");",
    "concepts": [
      "enums",
      "#define macros",
      "const keyword",
      "symbolic constants",
      "enum values",
      "bitfield operations"
    ],
    "skills": [
      "Constant management",
      "Symbolic programming",
      "Type-safe constants",
      "Code maintainability"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Constants:",
        "MAX_DEVICES: 10",
        "DEVICE_NAME_LEN: 32",
        "Version: 2.1",
        "Buffer size: 1024",
        "Driver name: test_driver",
        "Device States:",
        "DEVICE_OFFLINE = 0",
        "DEVICE_READY = 2",
        "Current state: DEVICE_READY (2)",
        "Device is ready",
        "Can add more devices",
        "Read operation allowed"
      ],
      "requirements": [
        "Use required function names: enums_init, enums_exit",
        "Define preprocessor constants: MAX_DEVICES=10, DEVICE_NAME_LEN=32, VERSION_MAJOR=2, VERSION_MINOR=1",
        "Define enum device_state with exact values: DEVICE_OFFLINE, DEVICE_INITIALIZING, DEVICE_READY, DEVICE_BUSY, DEVICE_ERROR",
        "Define enum operation_type with exact values: OP_READ=1, OP_WRITE=2, OP_IOCTL=4, OP_MMAP=8",
        "Use const variables: buffer_size=1024, driver_name=\"test_driver\"",
        "Use enums in variables: current_state=DEVICE_READY, allowed_ops=OP_READ|OP_WRITE",
        "Print exact format shown above with enum values and their integer representations"
      ]
    }
  },
  {
    "id": 12,
    "title": "Kernel Logging with printk and Log Levels",
    "difficulty": 3,
    "xp": 30,
    "phase": "foundations",
    "description": "Master kernel logging using printk with different log levels. Understand when to use each log level and how kernel logging differs from userspace printf.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int __init printk_init(void) {\n    int error_code = -12;\n    int device_count = 3;\n    unsigned long memory_addr = 0xdeadbeef;\n    \n    // TODO: Use different printk log levels\n    // KERN_EMERG: System is unusable\n    // KERN_ALERT: Action must be taken immediately  \n    // KERN_CRIT: Critical conditions\n    // KERN_ERR: Error conditions\n    // KERN_WARNING: Warning conditions\n    // KERN_NOTICE: Normal but significant condition\n    // KERN_INFO: Informational\n    // KERN_DEBUG: Debug-level messages\n    \n    // TODO: Demonstrate each log level with appropriate messages\n    printk(KERN_INFO \"Module initialization started\\n\");\n    \n    // TODO: Simulate different scenarios with appropriate log levels\n    if (device_count > 0) {\n        printk(KERN_NOTICE \"Found %d devices during initialization\\n\", device_count);\n    }\n    \n    if (error_code < 0) {\n        printk(KERN_WARNING \"Non-critical error occurred: %d\\n\", error_code);\n    }\n    \n    // TODO: Show different format specifiers\n    printk(KERN_DEBUG \"Debug info: memory_addr=0x%lx, device_count=%d\\n\", \n           memory_addr, device_count);\n    \n    // TODO: Demonstrate pr_* macros (modern alternatives)\n    pr_info(\"Using pr_info macro for informational message\\n\");\n    pr_warn(\"Using pr_warn macro for warning message\\n\");\n    pr_err(\"Using pr_err macro for error message\\n\");\n    \n    // TODO: Rate-limited printing\n    printk_ratelimited(KERN_INFO \"This message is rate-limited\\n\");\n    \n    // Expected output (with appropriate log levels):\n    // \"Module initialization started\"\n    // \"Found 3 devices during initialization\" \n    // \"Non-critical error occurred: -12\"\n    // \"Debug info: memory_addr=0xdeadbeef, device_count=3\"\n    // \"Using pr_info macro for informational message\"\n    // \"Using pr_warn macro for warning message\"\n    // \"Using pr_err macro for error message\"\n    // \"This message is rate-limited\"\n    \n    return 0;\n}\n\nstatic void __exit printk_exit(void) {\n    printk(KERN_INFO \"Module cleanup completed\\n\");\n}\n\nmodule_init(printk_init);\nmodule_exit(printk_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Kernel logging with printk and log levels module\");",
    "concepts": [
      "printk function",
      "kernel log levels",
      "KERN_* constants",
      "pr_* macros",
      "format specifiers",
      "rate limiting",
      "kernel vs userspace logging"
    ],
    "skills": [
      "Kernel debugging",
      "Logging best practices",
      "Message categorization",
      "Format string usage"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Module initialization started",
        "Found 3 devices during initialization",
        "Non-critical error occurred: -12",
        "Debug info: memory_addr=0xdeadbeef, device_count=3",
        "Using pr_info macro for informational message",
        "Using pr_warn macro for warning message",
        "Using pr_err macro for error message",
        "This message is rate-limited"
      ],
      "requirements": [
        "Use required function names: printk_init, printk_exit",
        "Use exact variable values: error_code=-12, device_count=3, memory_addr=0xdeadbeef",
        "Use different printk log levels: KERN_INFO, KERN_NOTICE, KERN_WARNING, KERN_DEBUG",
        "Use pr_* macros: pr_info, pr_warn, pr_err",
        "Use printk_ratelimited for rate-limited message",
        "Use appropriate format specifiers: %d, %lx",
        "Match log levels to message content appropriately",
        "Print messages in exact format shown above"
      ]
    }
  },
  {
    "id": 13,
    "title": "Structures and Pointers - Part 2: Arrow Operator",
    "difficulty": 4,
    "xp": 35,
    "phase": "foundations",
    "description": "Learn to use pointers to structures and the arrow operator. Understand the difference between dot and arrow operators. This builds on Part 1 structure knowledge.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// From Part 1 - COMPLETED CODE (structure definition):\n// You learned structure definition, member access with dot operator\n\n// Define the same structure from Part 1:\nstruct student {\n    int id;\n    char name[20];\n    int age;\n    float gpa;\n};\n\n// Part 2 - NEW CONCEPTS:\n// TODO: Learn pointer to structure and arrow operator\n\nstatic int __init structures_pointers_init(void) {\n    struct student stu = {102, \"Bob\", 21, 3.5};\n    \n    // TODO: Declare a pointer 'stu_ptr' that points to 'stu'\n    // TODO: Print all member values using arrow operator:\n    // \"Student ID via pointer: 102\"\n    // \"Student Name via pointer: Bob\"\n    // \"Student Age via pointer: 21\"\n    // \"Student GPA via pointer: 3\"\n    \n    return 0;\n}\n\nstatic void __exit structures_pointers_exit(void) {\n    printk(KERN_INFO \"Structures and pointers module unloaded\\n\");\n}\n\nmodule_init(structures_pointers_init);\nmodule_exit(structures_pointers_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Structures and pointers demonstration module\");",
    "concepts": [
      "pointers to structures",
      "arrow operator",
      "structure pointer dereferencing",
      "dot vs arrow operator"
    ],
    "skills": [
      "Advanced structure usage",
      "Pointer-based structure access",
      "Operator selection",
      "Structure pointer manipulation"
    ],
    "multiPart": {
      "part": 2,
      "totalParts": 3,
      "nextProblemId": 11,
      "previousProblemId": 9
    },
    "inputOutput": {
      "expectedOutput": [
        "Student ID via pointer: 102",
        "Student Name via pointer: Bob",
        "Student Age via pointer: 21",
        "Student GPA via pointer: 3"
      ],
      "requirements": [
        "Use required function names: structures_pointers_init, structures_pointers_exit",
        "Use provided structure definition and initialization",
        "Declare pointer 'stu_ptr' that points to 'stu'",
        "Access all members using arrow operator (stu_ptr->member)",
        "Print in exact format shown above",
        "Must use arrow operator, not dot operator with pointer"
      ]
    }
  },
  {
    "id": 14,
    "title": "Pointers Basics - Part 1: Declaration and Dereferencing",
    "difficulty": 4,
    "xp": 30,
    "phase": "foundations",
    "description": "Learn fundamental pointer concepts in kernel programming. Understand pointer declaration, assignment, and dereferencing. This is the first part of the pointer series.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// TODO: Declare an integer variable 'num' with value 42\n// TODO: Declare a pointer 'ptr' that points to 'num'\n// TODO: Print the value of 'num' directly\n// TODO: Print the value of 'num' through the pointer\n// TODO: Print the address stored in the pointer\n\nstatic int __init pointers_init(void) {\n    // TODO: Implement pointer basics\n    // Expected output format:\n    // \"Direct value: 42\"\n    // \"Value through pointer: 42\"\n    // \"Address in pointer: 0x[hex_address]\"\n    \n    return 0;\n}\n\nstatic void __exit pointers_exit(void) {\n    printk(KERN_INFO \"Pointers module unloaded\\n\");\n}\n\nmodule_init(pointers_init);\nmodule_exit(pointers_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Pointers basics demonstration module\");",
    "concepts": [
      "pointers",
      "pointer declaration",
      "dereferencing",
      "address-of operator",
      "memory addresses"
    ],
    "skills": [
      "Pointer manipulation",
      "Memory understanding",
      "Indirection concepts",
      "Address arithmetic"
    ],
    "multiPart": {
      "part": 1,
      "totalParts": 3,
      "nextProblemId": 7,
      "previousProblemId": null
    },
    "inputOutput": {
      "expectedOutput": [
        "Direct value: 42",
        "Value through pointer: 42",
        "Address in pointer: (0x[hex] or (____ptrval____))"
      ],
      "requirements": [
        "Use required function names: pointers_init, pointers_exit",
        "Declare integer variable 'num' with value 42",
        "Declare pointer 'ptr' that points to 'num'",
        "Print direct value, dereferenced value, and address",
        "Use exact format strings shown above",
        "Address output should show pointer value (may be obfuscated as (____ptrval____) for security)"
      ]
    }
  },
  {
    "id": 15,
    "title": "Pointers and Arrays - Part 2: Array Traversal with Pointers",
    "difficulty": 4,
    "xp": 35,
    "phase": "foundations",
    "description": "Learn the relationship between pointers and arrays in kernel programming. Use pointers to traverse arrays and understand pointer arithmetic. This builds on Part 1 pointer knowledge.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// From Part 1 - COMPLETED CODE (pointer basics):\n// You learned pointer declaration, dereferencing, and address access\n\n// Part 2 - NEW CONCEPTS:\n// TODO: Declare an array 'values' with elements [100, 200, 300, 400, 500]\n// TODO: Declare a pointer 'arr_ptr' that points to the first element of the array\n// TODO: Use pointer arithmetic to traverse the array\n// TODO: Print each element using pointer notation\n\nstatic int __init pointers_arrays_init(void) {\n    // TODO: Implement array traversal with pointers\n    // Expected output format:\n    // \"Element 0: 100\"\n    // \"Element 1: 200\"\n    // \"Element 2: 300\"\n    // \"Element 3: 400\"\n    // \"Element 4: 500\"\n    \n    return 0;\n}\n\nstatic void __exit pointers_arrays_exit(void) {\n    printk(KERN_INFO \"Pointers and arrays module unloaded\\n\");\n}\n\nmodule_init(pointers_arrays_init);\nmodule_exit(pointers_arrays_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Pointers and arrays demonstration module\");",
    "concepts": [
      "pointer arithmetic",
      "array-pointer relationship",
      "pointer traversal",
      "array indexing with pointers"
    ],
    "skills": [
      "Advanced pointer usage",
      "Array manipulation via pointers",
      "Pointer arithmetic",
      "Memory traversal"
    ],
    "multiPart": {
      "part": 2,
      "totalParts": 3,
      "nextProblemId": 8,
      "previousProblemId": 6
    },
    "inputOutput": {
      "expectedOutput": [
        "Element 0: 100",
        "Element 1: 200",
        "Element 2: 300",
        "Element 3: 400",
        "Element 4: 500"
      ],
      "requirements": [
        "Use required function names: pointers_arrays_init, pointers_arrays_exit",
        "Declare array 'values' with exact elements [100, 200, 300, 400, 500]",
        "Declare pointer 'arr_ptr' that points to first array element",
        "Use pointer arithmetic (arr_ptr + i) to traverse array",
        "Print using pointer dereferencing *(arr_ptr + i)",
        "Use exact format strings shown above"
      ]
    }
  },
  {
    "id": 16,
    "title": "Pointers and Functions - Part 3: Pass by Reference",
    "difficulty": 5,
    "xp": 40,
    "phase": "foundations",
    "description": "Master passing pointers to functions to modify values by reference. Learn the difference between pass-by-value and pass-by-reference. This completes the pointer series foundation.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// From Parts 1-2 - COMPLETED CONCEPTS:\n// ✓ Pointer declaration and dereferencing\n// ✓ Array traversal with pointer arithmetic\n\n// Part 3 - NEW CONCEPTS:\n// TODO: Create function 'swap_values' that takes two int pointers and swaps their values\n// TODO: Create function 'double_value' that takes an int pointer and doubles the value\n\nstatic int __init pointers_functions_init(void) {\n    int x = 10, y = 20;\n    int z = 15;\n    \n    printk(KERN_INFO \"Before swap: x=%d, y=%d\\n\", x, y);\n    printk(KERN_INFO \"Before doubling: z=%d\\n\", z);\n    \n    // TODO: Call swap_values(&x, &y)\n    // TODO: Call double_value(&z)\n    \n    printk(KERN_INFO \"After swap: x=%d, y=%d\\n\", x, y);\n    printk(KERN_INFO \"After doubling: z=%d\\n\", z);\n    \n    return 0;\n}\n\nstatic void __exit pointers_functions_exit(void) {\n    printk(KERN_INFO \"Pointers and functions module unloaded\\n\");\n}\n\nmodule_init(pointers_functions_init);\nmodule_exit(pointers_functions_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Pointers and functions demonstration module\");",
    "concepts": [
      "pass by reference",
      "pointers as function parameters",
      "function pointer parameters",
      "value modification via pointers"
    ],
    "skills": [
      "Advanced function design",
      "Reference parameter handling",
      "Pointer-based value modification",
      "Function interface design"
    ],
    "multiPart": {
      "part": 3,
      "totalParts": 3,
      "nextProblemId": 9,
      "previousProblemId": 7
    },
    "inputOutput": {
      "expectedOutput": [
        "Before swap: x=10, y=20",
        "Before doubling: z=15",
        "After swap: x=20, y=10",
        "After doubling: z=30"
      ],
      "requirements": [
        "Use required function names: pointers_functions_init, pointers_functions_exit",
        "Create function 'swap_values' with parameters (int *a, int *b)",
        "Create function 'double_value' with parameter (int *val)",
        "Functions must modify values through pointers",
        "Use exact variable names and values: x=10, y=20, z=15",
        "Print in exact format shown above"
      ]
    }
  },
  {
    "id": 17,
    "title": "Bitwise Operations and Bit Manipulation",
    "difficulty": 4,
    "xp": 35,
    "phase": "foundations",
    "description": "Master bitwise operations (&, |, ^, ~, <<, >>) essential for kernel programming, device drivers, and hardware interaction. Learn bit manipulation techniques for flags and registers.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int __init bitwise_init(void) {\n    unsigned int a = 0x5A;  // 01011010 binary\n    unsigned int b = 0x3C;  // 00111100 binary\n    unsigned int flags = 0x00;\n    unsigned int mask;\n    \n    // TODO: Perform basic bitwise operations\n    // AND: a & b\n    // OR: a | b  \n    // XOR: a ^ b\n    // NOT: ~a\n    // Left shift: a << 2\n    // Right shift: a >> 2\n    \n    // TODO: Bit manipulation for flags\n    // Set bit 3: flags |= (1 << 3)\n    // Clear bit 5: flags &= ~(1 << 5) \n    // Toggle bit 7: flags ^= (1 << 7)\n    // Check if bit 3 is set: (flags & (1 << 3)) != 0\n    \n    // TODO: Create mask for bits 2-5: mask = 0x3C (00111100)\n    // Extract bits 2-5 from a: (a & mask) >> 2\n    \n    // Print results in hex format:\n    // \"Bitwise Operations:\"\n    // \"0x5A & 0x3C = 0x18\"\n    // \"0x5A | 0x3C = 0x7E\" \n    // \"0x5A ^ 0x3C = 0x66\"\n    // \"~0x5A = 0xFFFFFFA5\"\n    // \"0x5A << 2 = 0x168\"\n    // \"0x5A >> 2 = 0x16\"\n    // \"Flag Operations:\"\n    // \"After setting bit 3: 0x8\"\n    // \"Bit 3 is set: 1\"\n    // \"Extracted bits 2-5: 0x6\"\n    \n    return 0;\n}\n\nstatic void __exit bitwise_exit(void) {\n    printk(KERN_INFO \"Bitwise operations module unloaded\\n\");\n}\n\nmodule_init(bitwise_init);\nmodule_exit(bitwise_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Bitwise operations and bit manipulation module\");",
    "concepts": [
      "bitwise AND (&)",
      "bitwise OR (|)",
      "bitwise XOR (^)",
      "bitwise NOT (~)",
      "left shift (<<)",
      "right shift (>>)",
      "bit manipulation",
      "flag operations"
    ],
    "skills": [
      "Bit manipulation",
      "Hardware register access",
      "Flag operations",
      "Low-level programming"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Bitwise Operations:",
        "0x5A & 0x3C = 0x18",
        "0x5A | 0x3C = 0x7E",
        "0x5A ^ 0x3C = 0x66",
        "~0x5A = 0xFFFFFFA5",
        "0x5A << 2 = 0x168",
        "0x5A >> 2 = 0x16",
        "Flag Operations:",
        "After setting bit 3: 0x8",
        "Bit 3 is set: 1",
        "Extracted bits 2-5: 0x6"
      ],
      "requirements": [
        "Use required function names: bitwise_init, bitwise_exit",
        "Use exact values: a=0x5A, b=0x3C, flags=0x00",
        "Perform all bitwise operations: &, |, ^, ~, <<, >>",
        "Implement bit manipulation: set bit, clear bit, toggle bit, check bit",
        "Create and use bit mask for extraction",
        "Print results in hexadecimal format (0x prefix)",
        "Must use actual bitwise calculations, not hardcoded results"
      ]
    }
  },
  {
    "id": 18,
    "title": "String Manipulation and Character Arrays",
    "difficulty": 4,
    "xp": 35,
    "phase": "foundations",
    "description": "Master string handling in kernel space using character arrays and kernel string functions. Learn the difference between string literals, character arrays, and pointers to strings.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic int __init strings_init(void) {\n    char str1[50] = \"Hello\";\n    char str2[50] = \"World\";\n    char result[100];\n    char *dynamic_str;\n    const char *literal = \"Kernel Programming\";\n    int len1, len2, total_len;\n    int cmp_result;\n    \n    // TODO: Get string lengths using strlen\n    // len1 = strlen(str1)\n    // len2 = strlen(str2)\n    // total_len = strlen(literal)\n    \n    // TODO: String concatenation using strcat\n    // strcpy(result, str1)  // Copy \"Hello\" to result\n    // strcat(result, \" \")   // Append space\n    // strcat(result, str2)  // Append \"World\"\n    \n    // TODO: String comparison using strcmp\n    // cmp_result = strcmp(str1, str2)\n    \n    // TODO: Dynamic string allocation and copy\n    // dynamic_str = kstrdup(literal, GFP_KERNEL)\n    \n    // TODO: Character manipulation\n    // Convert first character of str1 to lowercase if uppercase\n    // if (str1[0] >= 'A' && str1[0] <= 'Z') str1[0] += 32\n    \n    // Print results:\n    // \"String Operations:\"\n    // \"str1 length: 5\"\n    // \"str2 length: 5\"\n    // \"literal length: 18\"\n    // \"Concatenated: Hello World\"\n    // \"strcmp(\\\"Hello\\\", \\\"World\\\"): -15\" (or negative value)\n    // \"Dynamic string: Kernel Programming\"\n    // \"First char converted: hello\"\n    \n    // TODO: Clean up dynamic allocation\n    if (dynamic_str)\n        kfree(dynamic_str);\n    \n    return 0;\n}\n\nstatic void __exit strings_exit(void) {\n    printk(KERN_INFO \"String manipulation module unloaded\\n\");\n}\n\nmodule_init(strings_init);\nmodule_exit(strings_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"String manipulation and character arrays module\");",
    "concepts": [
      "character arrays",
      "string literals",
      "strlen function",
      "strcpy function",
      "strcat function",
      "strcmp function",
      "dynamic strings",
      "character manipulation"
    ],
    "skills": [
      "String processing",
      "Memory-safe string operations",
      "Character array handling",
      "Dynamic string management"
    ],
    "inputOutput": {
      "expectedOutput": [
        "String Operations:",
        "str1 length: 5",
        "str2 length: 5",
        "literal length: 18",
        "Concatenated: Hello World",
        "strcmp(\"Hello\", \"World\"): -15",
        "Dynamic string: Kernel Programming",
        "First char converted: hello"
      ],
      "requirements": [
        "Use required function names: strings_init, strings_exit",
        "Include linux/string.h for string functions",
        "Use exact string values: str1=\"Hello\", str2=\"World\", literal=\"Kernel Programming\"",
        "Use kernel string functions: strlen, strcpy, strcat, strcmp",
        "Use kstrdup for dynamic string allocation with GFP_KERNEL",
        "Perform character manipulation using array indexing",
        "Use proper memory cleanup with kfree",
        "Print results in exact format shown above"
      ]
    }
  },
  {
    "id": 19,
    "title": "Macros and Preprocessor Directives",
    "difficulty": 4,
    "xp": 35,
    "phase": "foundations",
    "description": "Master preprocessor macros, conditional compilation, and function-like macros essential for kernel programming. Learn proper macro design and common kernel macro patterns.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// TODO: Define simple object-like macros\n#define BUFFER_SIZE 1024\n#define MAX_USERS 100\n#define DRIVER_VERSION \"1.2.3\"\n\n// TODO: Define function-like macros\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define SQUARE(x) ((x) * (x))\n#define IS_POWER_OF_2(x) (((x) != 0) && (((x) & ((x) - 1)) == 0))\n\n// TODO: Define conditional compilation macros\n#define DEBUG_ENABLED 1\n\n#if DEBUG_ENABLED\n#define DEBUG_PRINT(fmt, args...) printk(KERN_DEBUG fmt, ##args)\n#else\n#define DEBUG_PRINT(fmt, args...) do { } while (0)\n#endif\n\n// TODO: Define multi-line macro with do-while(0)\n#define INIT_DEVICE(dev, id, name) do { \\\n    (dev)->device_id = (id); \\\n    strncpy((dev)->device_name, (name), sizeof((dev)->device_name) - 1); \\\n    (dev)->device_name[sizeof((dev)->device_name) - 1] = '\\0'; \\\n    (dev)->status = 0; \\\n} while (0)\n\nstruct device {\n    int device_id;\n    char device_name[32];\n    int status;\n};\n\nstatic int __init macros_init(void) {\n    int a = 15, b = 25;\n    int num = 8;\n    struct device my_device;\n    \n    // TODO: Use simple macros\n    // Print buffer size, max users, and version\n    \n    // TODO: Use function-like macros\n    // Calculate and print MIN(a, b), MAX(a, b), SQUARE(num)\n    // Check if num is power of 2\n    \n    // TODO: Use conditional compilation\n    // Use DEBUG_PRINT to print debug message\n    \n    // TODO: Use multi-line macro\n    // Initialize device with id=1, name=\"test_device\"\n    \n    // Expected output:\n    // \"Macro Constants:\"\n    // \"Buffer size: 1024\"\n    // \"Max users: 100\"\n    // \"Driver version: 1.2.3\"\n    // \"Function Macros:\"\n    // \"MIN(15, 25) = 15\"\n    // \"MAX(15, 25) = 25\"\n    // \"SQUARE(8) = 64\"\n    // \"8 is power of 2: 1\"\n    // \"Debug message: Module initialized\"\n    // \"Device initialized: ID=1, Name=test_device\"\n    \n    return 0;\n}\n\nstatic void __exit macros_exit(void) {\n    printk(KERN_INFO \"Macros module unloaded\\n\");\n}\n\nmodule_init(macros_init);\nmodule_exit(macros_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Macros and preprocessor directives module\");",
    "concepts": [
      "object-like macros",
      "function-like macros",
      "conditional compilation",
      "#if/#else/#endif",
      "variadic macros",
      "do-while(0) idiom",
      "macro safety"
    ],
    "skills": [
      "Preprocessor programming",
      "Macro design",
      "Conditional compilation",
      "Code generation"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Macro Constants:",
        "Buffer size: 1024",
        "Max users: 100",
        "Driver version: 1.2.3",
        "Function Macros:",
        "MIN(15, 25) = 15",
        "MAX(15, 25) = 25",
        "SQUARE(8) = 64",
        "8 is power of 2: 1",
        "Debug message: Module initialized",
        "Device initialized: ID=1, Name=test_device"
      ],
      "requirements": [
        "Use required function names: macros_init, macros_exit",
        "Define object-like macros: BUFFER_SIZE=1024, MAX_USERS=100, DRIVER_VERSION=\"1.2.3\"",
        "Define function-like macros: MIN, MAX, SQUARE, IS_POWER_OF_2",
        "Implement conditional compilation with DEBUG_ENABLED and DEBUG_PRINT",
        "Define multi-line macro INIT_DEVICE using do-while(0) idiom",
        "Use exact variable values: a=15, b=25, num=8",
        "Use all defined macros in the code",
        "Print results in exact format shown above"
      ]
    }
  },
  {
    "id": 20,
    "title": "Unions, Type Casting, and Memory Layout",
    "difficulty": 4,
    "xp": 35,
    "phase": "foundations",
    "description": "Learn unions for overlapping memory layouts and type casting for data conversion. Essential for hardware registers, protocol headers, and low-level kernel programming.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// TODO: Define union for different data interpretations\nunion data_converter {\n    unsigned int full_value;      // 32-bit integer\n    unsigned short half_values[2]; // Two 16-bit values  \n    unsigned char bytes[4];        // Four 8-bit values\n    struct {\n        unsigned char b0:4;  // Lower 4 bits\n        unsigned char b1:4;  // Upper 4 bits of first byte\n        unsigned char b2:4;\n        unsigned char b3:4;\n        unsigned char b4:4;\n        unsigned char b5:4;\n        unsigned char b6:4;\n        unsigned char b7:4;\n    } nibbles;  // Bit fields\n};\n\n// TODO: Define union for network packet header\nunion packet_header {\n    struct {\n        unsigned char version:4;\n        unsigned char header_len:4;\n        unsigned char type_of_service;\n        unsigned short total_length;\n    } ip_header;\n    unsigned char raw_bytes[4];\n    unsigned int raw_value;\n};\n\nstatic int __init unions_init(void) {\n    union data_converter converter;\n    union packet_header packet;\n    void *generic_ptr;\n    int int_value = 0x12345678;\n    float float_value = 3.14;\n    \n    // TODO: Use union to interpret data differently\n    converter.full_value = 0x12345678;\n    \n    // TODO: Type casting examples\n    // Cast int to float and back\n    float_value = (float)int_value;\n    int_value = (int)float_value;\n    \n    // TODO: Pointer type casting\n    generic_ptr = &converter;\n    int *int_ptr = (int *)generic_ptr;\n    char *char_ptr = (char *)generic_ptr;\n    \n    // TODO: Initialize packet header\n    packet.ip_header.version = 4;\n    packet.ip_header.header_len = 5; \n    packet.ip_header.type_of_service = 0;\n    packet.ip_header.total_length = 1500;\n    \n    // Print results:\n    // \"Union Data Converter:\"\n    // \"Full value: 0x12345678\"\n    // \"Half values: 0x1234, 0x5678\" (or 0x5678, 0x1234 on little-endian)\n    // \"Bytes: 0x12, 0x34, 0x56, 0x78\" (or reversed on little-endian)\n    // \"Type Casting:\"\n    // \"int to float: 305419896.000000\"\n    // \"Pointer casting works\"\n    // \"Packet Header:\"\n    // \"Version: 4, Header Length: 5\"\n    // \"Total Length: 1500\"\n    // \"Raw header bytes: 0x45, 0x0, 0xDC, 0x5\" (endian-dependent)\n    \n    return 0;\n}\n\nstatic void __exit unions_exit(void) {\n    printk(KERN_INFO \"Unions and type casting module unloaded\\n\");\n}\n\nmodule_init(unions_init);\nmodule_exit(unions_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Unions and type casting demonstration module\");",
    "concepts": [
      "unions",
      "overlapping memory",
      "type casting",
      "bit fields",
      "endianness",
      "pointer casting",
      "memory layout"
    ],
    "skills": [
      "Low-level memory manipulation",
      "Data structure optimization",
      "Hardware interface programming",
      "Type system understanding"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Union Data Converter:",
        "Full value: 0x12345678",
        "Half values: 0x1234, 0x5678",
        "Bytes: 0x12, 0x34, 0x56, 0x78",
        "Type Casting:",
        "int to float: 305419896.000000",
        "Pointer casting works",
        "Packet Header:",
        "Version: 4, Header Length: 5",
        "Total Length: 1500",
        "Raw header bytes: 0x45, 0x0, 0xDC, 0x5"
      ],
      "requirements": [
        "Use required function names: unions_init, unions_exit",
        "Define union data_converter with overlapping int, short array, byte array, and bit fields",
        "Define union packet_header with IP header struct and raw data views",
        "Use exact values: converter.full_value=0x12345678, int_value=0x12345678, float_value=3.14",
        "Demonstrate type casting: int to float, pointer casting",
        "Initialize packet header: version=4, header_len=5, total_length=1500",
        "Print all union members to show overlapping memory",
        "Handle endianness correctly in output"
      ]
    }
  },
  {
    "id": 21,
    "title": "Variable Scope, Storage Classes, and Lifetime",
    "difficulty": 4,
    "xp": 35,
    "phase": "foundations",
    "description": "Master variable scope (global, local, static) and storage classes in kernel programming. Understand variable lifetime, initialization, and proper usage patterns for kernel modules.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// TODO: Global variables (module scope)\nstatic int global_counter = 0;\nstatic char global_buffer[100];\nconst char *global_name = \"test_module\";\n\n// TODO: Function with static local variable\nstatic int increment_static_counter(void) {\n    static int static_counter = 0;  // Retains value between calls\n    int local_temp = 10;            // Reset each call\n    \n    static_counter++;\n    local_temp++;\n    \n    printk(KERN_INFO \"Static counter: %d, Local temp: %d\\n\", static_counter, local_temp);\n    return static_counter;\n}\n\n// TODO: Function with automatic variables\nstatic void demonstrate_scope(int param) {\n    int local_var = param * 2;      // Automatic storage\n    \n    if (param > 5) {\n        int block_var = local_var + 1;  // Block scope\n        printk(KERN_INFO \"Block scope: param=%d, local_var=%d, block_var=%d\\n\", \n               param, local_var, block_var);\n    }\n    // block_var is not accessible here\n    \n    printk(KERN_INFO \"Function scope: param=%d, local_var=%d\\n\", param, local_var);\n}\n\n// TODO: Function demonstrating variable shadowing\nstatic void demonstrate_shadowing(void) {\n    int value = 100;  // Outer scope\n    \n    printk(KERN_INFO \"Outer scope value: %d\\n\", value);\n    \n    {\n        int value = 200;  // Inner scope - shadows outer\n        printk(KERN_INFO \"Inner scope value: %d\\n\", value);\n    }\n    \n    printk(KERN_INFO \"Back to outer scope value: %d\\n\", value);\n}\n\nstatic int __init scope_init(void) {\n    int local_init = 42;\n    \n    // TODO: Demonstrate global variable access\n    global_counter = 5;\n    strcpy(global_buffer, \"Hello from global\");\n    \n    printk(KERN_INFO \"Variable Scope Demonstration:\\n\");\n    printk(KERN_INFO \"Global counter: %d\\n\", global_counter);\n    printk(KERN_INFO \"Global buffer: %s\\n\", global_buffer);\n    printk(KERN_INFO \"Global name: %s\\n\", global_name);\n    printk(KERN_INFO \"Local init: %d\\n\", local_init);\n    \n    // TODO: Call functions to demonstrate static vs local\n    printk(KERN_INFO \"\\nStatic vs Local Variables:\\n\");\n    increment_static_counter();  // Should print: Static counter: 1, Local temp: 11\n    increment_static_counter();  // Should print: Static counter: 2, Local temp: 11\n    increment_static_counter();  // Should print: Static counter: 3, Local temp: 11\n    \n    // TODO: Demonstrate function scope\n    printk(KERN_INFO \"\\nFunction Scope:\\n\");\n    demonstrate_scope(3);  // param <= 5, no block scope\n    demonstrate_scope(8);  // param > 5, shows block scope\n    \n    // TODO: Demonstrate variable shadowing\n    printk(KERN_INFO \"\\nVariable Shadowing:\\n\");\n    demonstrate_shadowing();\n    \n    return 0;\n}\n\nstatic void __exit scope_exit(void) {\n    printk(KERN_INFO \"Final global counter: %d\\n\", global_counter);\n    printk(KERN_INFO \"Variable scope module unloaded\\n\");\n}\n\nmodule_init(scope_init);\nmodule_exit(scope_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Variable scope and storage classes module\");",
    "concepts": [
      "global variables",
      "local variables",
      "static variables",
      "automatic storage",
      "variable lifetime",
      "scope rules",
      "variable shadowing"
    ],
    "skills": [
      "Scope management",
      "Memory lifetime understanding",
      "Variable design patterns",
      "Code organization"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Variable Scope Demonstration:",
        "Global counter: 5",
        "Global buffer: Hello from global",
        "Global name: test_module",
        "Local init: 42",
        "Static vs Local Variables:",
        "Static counter: 1, Local temp: 11",
        "Static counter: 2, Local temp: 11",
        "Static counter: 3, Local temp: 11",
        "Function Scope:",
        "Function scope: param=3, local_var=6",
        "Block scope: param=8, local_var=16, block_var=17",
        "Function scope: param=8, local_var=16",
        "Variable Shadowing:",
        "Outer scope value: 100",
        "Inner scope value: 200",
        "Back to outer scope value: 100"
      ],
      "requirements": [
        "Use required function names: scope_init, scope_exit",
        "Define static global variables: global_counter, global_buffer, global_name",
        "Implement increment_static_counter with static local variable",
        "Implement demonstrate_scope showing local and block scope",
        "Implement demonstrate_shadowing showing variable shadowing",
        "Use exact values and demonstrate all scope types",
        "Show difference between static and automatic storage",
        "Print results in exact format shown above"
      ]
    }
  },
  {
    "id": 22,
    "title": "Stack vs Heap Memory Concepts",
    "difficulty": 3,
    "xp": 25,
    "phase": "foundations",
    "description": "Learn the fundamental difference between stack and heap memory allocation in kernel programming. Understand when to use each type and their limitations. This bridges the gap between simple variables and dynamic memory allocation.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// CONCEPT: Stack vs Heap Memory\n// Stack Memory:\n// - Automatic allocation/deallocation\n// - Limited size (usually 8KB in kernel)\n// - Fast allocation/deallocation\n// - Local variables, function parameters\n// - Memory is automatically freed when function exits\n//\n// Heap Memory:\n// - Manual allocation/deallocation\n// - Larger size available\n// - Slower allocation/deallocation\n// - Survives function calls\n// - Must be explicitly freed\n//\n// WHY: Understanding this is crucial before learning kmalloc/kfree\n\n// TODO: Demonstrate stack memory usage\nstatic void demonstrate_stack_memory(void)\n{\n    // Stack variables - automatically managed\n    int local_var = 42;           // On stack\n    char local_array[256];        // On stack - limited size\n    \n    // Stack memory is automatically freed when function exits\n    printk(KERN_INFO \"Stack variable: %d\\n\", local_var);\n    printk(KERN_INFO \"Stack array size: %zu bytes\\n\", sizeof(local_array));\n    \n    // TODO: Show stack limitations\n    // Large arrays can cause stack overflow\n    // char huge_array[8192];  // This might cause problems!\n    \n    printk(KERN_INFO \"Stack memory: automatic, limited, fast\\n\");\n}\n\n// TODO: Demonstrate stack limitations\nstatic void demonstrate_stack_limitations(void)\n{\n    // Stack has limited size (usually 8KB in kernel)\n    // Large data structures need heap allocation\n    \n    printk(KERN_INFO \"Stack limitations:\\n\");\n    printk(KERN_INFO \"- Limited size (typically 8KB)\\n\");\n    printk(KERN_INFO \"- Automatic cleanup\\n\");\n    printk(KERN_INFO \"- Fast allocation\\n\");\n    printk(KERN_INFO \"- Local scope only\\n\");\n}\n\n// TODO: Explain when heap is needed\nstatic void explain_heap_necessity(void)\n{\n    printk(KERN_INFO \"Heap memory needed when:\\n\");\n    printk(KERN_INFO \"- Large data structures\\n\");\n    printk(KERN_INFO \"- Data must survive function calls\\n\");\n    printk(KERN_INFO \"- Dynamic size requirements\\n\");\n    printk(KERN_INFO \"- Sharing data between functions\\n\");\n    \n    // Next problem will show how to use heap memory\n    printk(KERN_INFO \"Next: Learn kmalloc for heap allocation\\n\");\n}\n\nstatic int __init memory_concepts_init(void)\n{\n    printk(KERN_INFO \"Memory concepts module loaded\\n\");\n    printk(KERN_INFO \"Understanding Stack vs Heap Memory\\n\");\n    \n    demonstrate_stack_memory();\n    demonstrate_stack_limitations();\n    explain_heap_necessity();\n    \n    return 0;\n}\n\nstatic void __exit memory_concepts_exit(void)\n{\n    printk(KERN_INFO \"Memory concepts module unloaded\\n\");\n    printk(KERN_INFO \"Remember: Stack=automatic, Heap=manual\\n\");\n}\n\nmodule_init(memory_concepts_init);\nmodule_exit(memory_concepts_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Understanding stack vs heap memory concepts\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "stack_memory",
      "heap_memory",
      "memory_types",
      "variable_scope",
      "memory_limitations"
    ],
    "skills": [
      "memory_management_basics",
      "variable_lifetime",
      "memory_concepts"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Memory concepts module loaded",
        "Understanding Stack vs Heap Memory",
        "Stack variable: 42",
        "Stack memory: automatic, limited, fast",
        "Stack limitations:",
        "Heap memory needed when:",
        "Next: Learn kmalloc for heap allocation",
        "Memory concepts module unloaded"
      ],
      "requirements": [
        "Use required function names: memory_concepts_init, memory_concepts_exit, demonstrate_stack_memory, demonstrate_stack_limitations, explain_heap_necessity",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h",
        "Code must contain: local_var, local_array, sizeof(local_array)"
      ]
    }
  },
  {
    "id": 23,
    "title": "Introduction to Dynamic Memory Allocation",
    "difficulty": 4,
    "xp": 35,
    "phase": "foundations",
    "description": "Learn your first dynamic memory allocation using kmalloc and kfree. Understand the basic pattern of allocating, using, and freeing memory. This introduces heap memory management in a simple, controlled way.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n\n// CONCEPT: Dynamic Memory Allocation\n// kmalloc() - allocates memory from kernel heap\n// kfree() - frees memory allocated by kmalloc\n// GFP_KERNEL - memory allocation flags (can sleep, use in process context)\n//\n// Basic Pattern:\n// 1. ptr = kmalloc(size, GFP_KERNEL)\n// 2. Check if ptr is NULL (allocation failed)\n// 3. Use the memory\n// 4. kfree(ptr) when done\n//\n// WHY: When stack memory is too small or data must survive function calls\n\n// TODO: First dynamic memory allocation\nstatic int demonstrate_basic_kmalloc(void)\n{\n    char *dynamic_buffer;\n    \n    // Step 1: Allocate memory from heap\n    dynamic_buffer = kmalloc(256, GFP_KERNEL);\n    \n    // Step 2: Always check for allocation failure\n    if (!dynamic_buffer) {\n        printk(KERN_ERR \"Failed to allocate memory!\\n\");\n        return -ENOMEM;\n    }\n    \n    // Step 3: Use the memory\n    strcpy(dynamic_buffer, \"Hello from heap memory!\");\n    printk(KERN_INFO \"Dynamic buffer contains: %s\\n\", dynamic_buffer);\n    \n    // Step 4: Free the memory (very important!)\n    kfree(dynamic_buffer);\n    \n    printk(KERN_INFO \"Memory allocated, used, and freed successfully\\n\");\n    return 0;\n}\n\n// TODO: Demonstrate memory sizes\nstatic void demonstrate_memory_sizes(void)\n{\n    void *small_mem, *medium_mem, *large_mem;\n    \n    // Different sizes of memory allocation\n    small_mem = kmalloc(64, GFP_KERNEL);\n    medium_mem = kmalloc(1024, GFP_KERNEL);\n    large_mem = kmalloc(4096, GFP_KERNEL);\n    \n    printk(KERN_INFO \"Memory allocation sizes:\\n\");\n    printk(KERN_INFO \"Small (64 bytes): %s\\n\", small_mem ? \"Success\" : \"Failed\");\n    printk(KERN_INFO \"Medium (1KB): %s\\n\", medium_mem ? \"Success\" : \"Failed\");\n    printk(KERN_INFO \"Large (4KB): %s\\n\", large_mem ? \"Success\" : \"Failed\");\n    \n    // Always free what you allocate\n    if (small_mem) kfree(small_mem);\n    if (medium_mem) kfree(medium_mem);\n    if (large_mem) kfree(large_mem);\n    \n    printk(KERN_INFO \"All memory freed\\n\");\n}\n\n// TODO: Show what happens with allocation failure\nstatic void demonstrate_allocation_failure(void)\n{\n    void *huge_mem;\n    \n    // Try to allocate a very large amount (likely to fail)\n    huge_mem = kmalloc(1024 * 1024 * 10, GFP_KERNEL); // 10MB\n    \n    if (!huge_mem) {\n        printk(KERN_INFO \"Large allocation failed - this is normal\\n\");\n        printk(KERN_INFO \"Always check kmalloc return value!\\n\");\n    } else {\n        printk(KERN_INFO \"Large allocation succeeded\\n\");\n        kfree(huge_mem);\n    }\n}\n\nstatic int __init dynamic_memory_init(void)\n{\n    int ret;\n    \n    printk(KERN_INFO \"Dynamic memory module loaded\\n\");\n    printk(KERN_INFO \"Learning kmalloc and kfree\\n\");\n    \n    ret = demonstrate_basic_kmalloc();\n    if (ret) {\n        return ret;\n    }\n    \n    demonstrate_memory_sizes();\n    demonstrate_allocation_failure();\n    \n    printk(KERN_INFO \"Remember: Every kmalloc needs a kfree!\\n\");\n    return 0;\n}\n\nstatic void __exit dynamic_memory_exit(void)\n{\n    printk(KERN_INFO \"Dynamic memory module unloaded\\n\");\n    printk(KERN_INFO \"Pattern: kmalloc -> check -> use -> kfree\\n\");\n}\n\nmodule_init(dynamic_memory_init);\nmodule_exit(dynamic_memory_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Introduction to dynamic memory allocation\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "dynamic_memory",
      "kmalloc",
      "kfree",
      "memory_management",
      "heap_allocation"
    ],
    "skills": [
      "memory_allocation",
      "resource_management",
      "basic_debugging"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Dynamic memory module loaded",
        "Learning kmalloc and kfree",
        "Dynamic buffer contains: Hello from heap memory!",
        "Memory allocated, used, and freed successfully",
        "Memory allocation sizes:",
        "Always check kmalloc return value!",
        "Remember: Every kmalloc needs a kfree!",
        "Dynamic memory module unloaded"
      ],
      "requirements": [
        "Use required function names: dynamic_memory_init, dynamic_memory_exit, demonstrate_basic_kmalloc, demonstrate_memory_sizes, demonstrate_allocation_failure",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/slab.h",
        "Code must contain: kmalloc, kfree, GFP_KERNEL, if (!dynamic_buffer)"
      ]
    }
  },
  {
    "id": 24,
    "title": "Kernel Memory Management - Part 1: kmalloc and kfree",
    "difficulty": 5,
    "xp": 45,
    "phase": "foundations",
    "description": "Learn kernel memory allocation using kmalloc and kfree. Understand the difference between kernel and userspace memory management. This is the first part of kernel memory series.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n\n// TODO: Allocate memory for an array of 5 integers using kmalloc\n// TODO: Initialize the array with values [10, 20, 30, 40, 50]\n// TODO: Print each value\n// TODO: Free the memory using kfree\n\nstatic int __init kmalloc_init(void) {\n    // TODO: Declare a pointer to int called 'arr'\n    // TODO: Allocate memory: arr = kmalloc(5 * sizeof(int), GFP_KERNEL)\n    // TODO: Check if allocation succeeded (arr != NULL)\n    // TODO: Initialize and print values\n    // TODO: Free memory before returning\n    \n    return 0;\n}\n\nstatic void __exit kmalloc_exit(void) {\n    printk(KERN_INFO \"Kernel memory module unloaded\\n\");\n}\n\nmodule_init(kmalloc_init);\nmodule_exit(kmalloc_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Kernel memory management demonstration module\");",
    "concepts": [
      "kmalloc",
      "kfree",
      "GFP_KERNEL",
      "kernel memory allocation",
      "memory leak prevention"
    ],
    "skills": [
      "Kernel memory management",
      "Dynamic allocation",
      "Memory safety",
      "Resource cleanup"
    ],
    "multiPart": {
      "part": 1,
      "totalParts": 3,
      "nextProblemId": 13,
      "previousProblemId": null
    },
    "inputOutput": {
      "expectedOutput": [
        "Memory allocated successfully",
        "arr[0] = 10",
        "arr[1] = 20",
        "arr[2] = 30",
        "arr[3] = 40",
        "arr[4] = 50",
        "Memory freed successfully"
      ],
      "requirements": [
        "Use required function names: kmalloc_init, kmalloc_exit",
        "Include linux/slab.h for memory allocation functions",
        "Declare pointer 'arr' of type int*",
        "Use kmalloc(5 * sizeof(int), GFP_KERNEL) for allocation",
        "Check for allocation failure (NULL pointer)",
        "Initialize array with exact values [10, 20, 30, 40, 50]",
        "Print each element in format 'arr[i] = value'",
        "Use kfree(arr) to free memory",
        "Print allocation and free success messages"
      ]
    }
  },
  {
    "id": 25,
    "title": "Kernel Memory Management - Part 2: Dynamic Strings with kstrdup",
    "difficulty": 5,
    "xp": 45,
    "phase": "foundations",
    "description": "Learn kernel string management using kstrdup, strlen, and proper string handling. Understand kernel string functions vs userspace equivalents. This builds on Part 1 memory knowledge.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n// From Part 1 - COMPLETED CONCEPTS:\n// ✓ kmalloc and kfree for basic memory allocation\n// ✓ NULL pointer checking and memory safety\n\n// Part 2 - NEW CONCEPTS:\n// TODO: Learn kernel string functions and dynamic string allocation\n\nstatic int __init kstrings_init(void) {\n    const char *original = \"Hello Kernel World\";\n    char *copy1, *copy2;\n    \n    // TODO: Use kstrdup to create a copy of 'original'\n    // TODO: Use kmalloc + strcpy to create another copy\n    // TODO: Print both copies and their lengths\n    // TODO: Free both allocated strings\n    \n    // Expected output:\n    // \"Original: Hello Kernel World\"\n    // \"Copy1 (kstrdup): Hello Kernel World\"\n    // \"Copy2 (kmalloc+strcpy): Hello Kernel World\"\n    // \"String length: 18\"\n    // \"Strings freed successfully\"\n    \n    return 0;\n}\n\nstatic void __exit kstrings_exit(void) {\n    printk(KERN_INFO \"Kernel strings module unloaded\\n\");\n}\n\nmodule_init(kstrings_init);\nmodule_exit(kstrings_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Kernel string management demonstration module\");",
    "concepts": [
      "kstrdup",
      "kernel string functions",
      "strlen in kernel",
      "strcpy in kernel",
      "string memory management"
    ],
    "skills": [
      "Kernel string handling",
      "Dynamic string allocation",
      "String function usage",
      "Advanced memory management"
    ],
    "multiPart": {
      "part": 2,
      "totalParts": 3,
      "nextProblemId": 14,
      "previousProblemId": 12
    },
    "inputOutput": {
      "expectedOutput": [
        "Original: Hello Kernel World",
        "Copy1 (kstrdup): Hello Kernel World",
        "Copy2 (kmalloc+strcpy): Hello Kernel World",
        "String length: 18",
        "Strings freed successfully"
      ],
      "requirements": [
        "Use required function names: kstrings_init, kstrings_exit",
        "Include linux/string.h for string functions",
        "Use exact string: \"Hello Kernel World\"",
        "Create copy1 using kstrdup(original, GFP_KERNEL)",
        "Create copy2 using kmalloc + strcpy combination",
        "Check for allocation failures",
        "Use strlen to get string length",
        "Print in exact format shown above",
        "Free both allocated strings with kfree"
      ]
    }
  },
  {
    "id": 26,
    "title": "Kernel Memory Management - Part 3: Dynamic Structures",
    "difficulty": 6,
    "xp": 50,
    "phase": "foundations",
    "description": "Master dynamic allocation of structures in kernel space. Combine structure knowledge with kernel memory management. This completes the kernel memory series and prepares for advanced concepts.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n// From Parts 1-2 - COMPLETED CONCEPTS:\n// ✓ kmalloc/kfree for basic memory allocation\n// ✓ kstrdup and kernel string functions\n// ✓ Structure definition and usage\n\n// Define a kernel data structure:\nstruct device_info {\n    int device_id;\n    char *device_name;\n    int status;  // 0=inactive, 1=active\n    unsigned long timestamp;\n};\n\n// Part 3 - NEW CONCEPTS:\n// TODO: Dynamic allocation of structures with embedded pointers\n\nstatic int __init kmem_structures_init(void) {\n    struct device_info *dev;\n    \n    // TODO: Allocate memory for struct device_info using kmalloc\n    // TODO: Initialize: device_id=100, device_name=\"eth0\", status=1, timestamp=123456789\n    // TODO: Use kstrdup for device_name allocation\n    // TODO: Print all structure members\n    // TODO: Free device_name first, then the structure\n    \n    // Expected output:\n    // \"Device allocated successfully\"\n    // \"Device ID: 100\"\n    // \"Device Name: eth0\"\n    // \"Device Status: 1 (active)\"\n    // \"Device Timestamp: 123456789\"\n    // \"Device memory freed successfully\"\n    \n    return 0;\n}\n\nstatic void __exit kmem_structures_exit(void) {\n    printk(KERN_INFO \"Kernel memory structures module unloaded\\n\");\n}\n\nmodule_init(kmem_structures_init);\nmodule_exit(kmem_structures_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Kernel memory structures demonstration module\");",
    "concepts": [
      "dynamic structure allocation",
      "embedded pointers in structures",
      "complex memory cleanup",
      "kernel data structures",
      "memory management patterns"
    ],
    "skills": [
      "Advanced memory management",
      "Complex data structure handling",
      "Resource cleanup patterns",
      "Kernel programming best practices"
    ],
    "multiPart": {
      "part": 3,
      "totalParts": 3,
      "nextProblemId": 15,
      "previousProblemId": 13
    },
    "inputOutput": {
      "expectedOutput": [
        "Device allocated successfully",
        "Device ID: 100",
        "Device Name: eth0",
        "Device Status: 1 (active)",
        "Device Timestamp: 123456789",
        "Device memory freed successfully"
      ],
      "requirements": [
        "Use required function names: kmem_structures_init, kmem_structures_exit",
        "Use provided struct device_info definition",
        "Allocate structure using kmalloc(sizeof(struct device_info), GFP_KERNEL)",
        "Initialize with exact values: device_id=100, device_name=\"eth0\", status=1, timestamp=123456789",
        "Use kstrdup for device_name allocation",
        "Check for allocation failures",
        "Access members using arrow operator",
        "Free device_name first, then structure",
        "Print in exact format shown above"
      ]
    }
  },
  {
    "id": 27,
    "title": "Module Parameters and Configuration",
    "difficulty": 4,
    "xp": 40,
    "phase": "foundations",
    "description": "Learn to create configurable kernel modules using module parameters. Understand how to accept configuration from userspace during module loading. This is essential for production kernel modules.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/moduleparam.h>\n\n// TODO: Declare module parameters:\n// - int parameter 'debug_level' with default value 1\n// - string parameter 'device_name' with default value \"default_device\"\n// - bool parameter 'enable_logging' with default value true\n\n// TODO: Use module_param() to make parameters configurable\n// TODO: Use MODULE_PARM_DESC() to add parameter descriptions\n\nstatic int __init modparam_init(void) {\n    // TODO: Print current parameter values\n    // Expected format:\n    // \"Module loaded with parameters:\"\n    // \"Debug Level: X\"\n    // \"Device Name: Y\"\n    // \"Logging Enabled: Z\"\n    \n    return 0;\n}\n\nstatic void __exit modparam_exit(void) {\n    printk(KERN_INFO \"Module parameters module unloaded\\n\");\n}\n\nmodule_init(modparam_init);\nmodule_exit(modparam_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Module parameters demonstration\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "module parameters",
      "moduleparam.h",
      "module_param macro",
      "MODULE_PARM_DESC",
      "runtime configuration"
    ],
    "skills": [
      "Module configuration",
      "Parameter handling",
      "User-kernel interface",
      "Production module design"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Module loaded with parameters:",
        "Debug Level: 1",
        "Device Name: default_device",
        "Logging Enabled: 1"
      ],
      "requirements": [
        "Use required function names: modparam_init, modparam_exit",
        "Include linux/moduleparam.h",
        "Declare parameters: debug_level (int, default 1), device_name (string, default \"default_device\"), enable_logging (bool, default true)",
        "Use module_param() for each parameter",
        "Use MODULE_PARM_DESC() for parameter descriptions",
        "Print parameters in exact format shown above",
        "Use S_IRUGO permissions for parameters"
      ]
    }
  },
  {
    "id": 28,
    "title": "Kernel Error Handling and Return Codes",
    "difficulty": 5,
    "xp": 45,
    "phase": "foundations",
    "description": "Learn proper error handling in kernel space using standard Linux error codes. Understand error propagation and cleanup patterns essential for reliable kernel code.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\n// TODO: Create function 'allocate_buffer' that:\n// - Takes size parameter\n// - Returns pointer on success, NULL on failure\n// - Handles allocation errors properly\n\n// TODO: Create function 'process_data' that:\n// - Takes buffer pointer and size\n// - Returns 0 on success, negative error code on failure\n// - Validates parameters (returns -EINVAL for NULL pointer or zero size)\n\nstatic int __init error_handling_init(void) {\n    char *buffer;\n    int result;\n    int size = 1024;\n    \n    // TODO: Call allocate_buffer and handle errors\n    // TODO: Call process_data and handle errors\n    // TODO: Implement proper cleanup on errors\n    \n    // Expected output:\n    // \"Buffer allocated successfully (1024 bytes)\"\n    // \"Data processed successfully\"\n    // \"Cleanup completed\"\n    \n    return 0;\n}\n\nstatic void __exit error_handling_exit(void) {\n    printk(KERN_INFO \"Error handling module unloaded\\n\");\n}\n\nmodule_init(error_handling_init);\nmodule_exit(error_handling_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Error handling demonstration module\");",
    "concepts": [
      "kernel error codes",
      "error propagation",
      "cleanup patterns",
      "EINVAL, ENOMEM",
      "defensive programming"
    ],
    "skills": [
      "Error handling",
      "Defensive programming",
      "Resource cleanup",
      "Code reliability"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Buffer allocated successfully (1024 bytes)",
        "Data processed successfully",
        "Cleanup completed"
      ],
      "requirements": [
        "Use required function names: error_handling_init, error_handling_exit",
        "Include linux/errno.h for error codes",
        "Create function 'allocate_buffer' that returns char* (NULL on failure)",
        "Create function 'process_data' that returns int (0 success, negative error)",
        "Use standard error codes: -ENOMEM for allocation failure, -EINVAL for invalid parameters",
        "Handle all error conditions with proper cleanup",
        "Print success messages in exact format shown above",
        "Free allocated memory in all code paths"
      ]
    }
  },
  {
    "id": 29,
    "title": "Foundation Capstone: Complete Kernel Module",
    "difficulty": 6,
    "xp": 60,
    "phase": "foundations",
    "description": "Create a comprehensive kernel module that demonstrates all foundation concepts. This capstone project combines everything learned to build a production-ready kernel module with proper error handling, memory management, and configuration.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/moduleparam.h>\n#include <linux/errno.h>\n\n// TODO: Define a structure 'kernel_device' with:\n// - int device_id\n// - char *name\n// - int status (0=inactive, 1=active)\n// - void *data_buffer\n// - size_t buffer_size\n\n// TODO: Module parameters:\n// - int max_devices (default 5)\n// - int buffer_size (default 1024)\n// - bool debug_mode (default false)\n\n// TODO: Global variables:\n// - Array of pointers to kernel_device structures\n// - Counter for active devices\n\n// TODO: Functions to implement:\n// - create_device(int id, const char *name) -> returns pointer or NULL\n// - destroy_device(struct kernel_device *dev) -> cleanup function\n// - list_devices(void) -> print all active devices\n\nstatic int __init capstone_init(void) {\n    // TODO: Initialize module\n    // TODO: Create 3 test devices with IDs 1, 2, 3 and names \"dev1\", \"dev2\", \"dev3\"\n    // TODO: List all devices\n    // TODO: Handle all error conditions\n    \n    return 0;\n}\n\nstatic void __exit capstone_exit(void) {\n    // TODO: Cleanup all allocated resources\n    // TODO: Destroy all devices\n    printk(KERN_INFO \"Foundation capstone module unloaded\\n\");\n}\n\nmodule_init(capstone_init);\nmodule_exit(capstone_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Foundation capstone demonstration module\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "comprehensive module design",
      "integrated memory management",
      "error handling patterns",
      "module parameters",
      "resource cleanup",
      "production practices"
    ],
    "skills": [
      "Complete module development",
      "Integration of all foundation concepts",
      "Production-ready code",
      "Professional kernel programming"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Foundation Capstone Module loaded",
        "Module parameters: max_devices=5, buffer_size=1024, debug_mode=0",
        "Device 1 (dev1) created successfully",
        "Device 2 (dev2) created successfully",
        "Device 3 (dev3) created successfully",
        "Active devices:",
        "  Device 1: dev1 (status: 1, buffer: 1024 bytes)",
        "  Device 2: dev2 (status: 1, buffer: 1024 bytes)",
        "  Device 3: dev3 (status: 1, buffer: 1024 bytes)",
        "Total active devices: 3"
      ],
      "requirements": [
        "Use required function names: capstone_init, capstone_exit",
        "Define struct kernel_device with exact members specified",
        "Implement module parameters: max_devices, buffer_size, debug_mode with defaults",
        "Implement functions: create_device, destroy_device, list_devices",
        "Create exactly 3 devices with IDs 1,2,3 and names dev1,dev2,dev3",
        "Allocate buffer for each device using module parameter buffer_size",
        "Implement complete error handling with proper cleanup",
        "Print output in exact format shown above",
        "Free all resources in exit function"
      ]
    }
  },
  {
    "id": 30,
    "title": "Comprehensive Foundations Assessment",
    "difficulty": 7,
    "xp": 75,
    "phase": "foundations",
    "description": "Final comprehensive assessment integrating all foundation concepts: variables, functions, pointers, structures, memory management, control flow, and kernel-specific features. This validates complete mastery of kernel C foundations.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/moduleparam.h>\n#include <linux/errno.h>\n\n// TODO: Define preprocessor constants\n#define MAX_STUDENTS 50\n#define NAME_LENGTH 32\n#define GRADE_LEVELS 5\n\n// TODO: Define enum for student status\nenum student_status {\n    STATUS_ENROLLED,\n    STATUS_ACTIVE,\n    STATUS_GRADUATED,\n    STATUS_DROPPED\n};\n\n// TODO: Define student structure\nstruct student {\n    int student_id;\n    char *name;\n    enum student_status status;\n    float gpa;\n    int courses[4];\n    int course_count;\n};\n\n// TODO: Define union for grade data\nunion grade_data {\n    float numeric_grade;\n    char letter_grade;\n    struct {\n        unsigned int passed:1;\n        unsigned int honors:1;\n        unsigned int credits:6;\n    } flags;\n};\n\n// TODO: Module parameters\nstatic int max_capacity = 30;\nstatic bool debug_enabled = false;\nmodule_param(max_capacity, int, S_IRUGO);\nmodule_param(debug_enabled, bool, S_IRUGO);\n\n// TODO: Global variables\nstatic struct student **student_list = NULL;\nstatic int student_count = 0;\nstatic unsigned long statistics = 0;\n\n// TODO: Function prototypes and implementations\n\n// Function to create a new student\nstatic struct student *create_student(int id, const char *name, float gpa) {\n    struct student *new_student;\n    \n    // TODO: Allocate memory for student\n    // TODO: Allocate memory for name and copy\n    // TODO: Initialize all fields\n    // TODO: Return pointer or NULL on failure\n    \n    return NULL; // Placeholder\n}\n\n// Function to destroy a student and free memory\nstatic void destroy_student(struct student *student) {\n    // TODO: Free name memory\n    // TODO: Free student structure\n}\n\n// Function to calculate class statistics using pointers\nstatic void calculate_statistics(struct student **students, int count, \n                               float *avg_gpa, int *active_count) {\n    // TODO: Calculate average GPA of active students\n    // TODO: Count active students\n    // TODO: Use pointer arithmetic and dereferencing\n}\n\n// Function to process grades using unions and bitwise operations\nstatic void process_grades(union grade_data *grades, int count) {\n    // TODO: Process array of grade data\n    // TODO: Use bitwise operations on flags\n    // TODO: Print grade information\n}\n\n// Function demonstrating control flow\nstatic int enrollment_manager(void) {\n    int result = 0;\n    \n    // TODO: Use loops to create test students\n    // TODO: Use conditionals for validation\n    // TODO: Use switch for status processing\n    // TODO: Demonstrate break/continue\n    \n    return result;\n}\n\nstatic int __init assessment_init(void) {\n    float average_gpa = 0.0;\n    int active_students = 0;\n    union grade_data test_grades[3];\n    int i;\n    \n    pr_info(\"=== Comprehensive Foundations Assessment ===\\n\");\n    pr_info(\"Module parameters: max_capacity=%d, debug_enabled=%d\\n\", \n            max_capacity, debug_enabled);\n    \n    // TODO: Allocate memory for student list\n    student_list = kmalloc(sizeof(struct student *) * MAX_STUDENTS, GFP_KERNEL);\n    if (!student_list) {\n        pr_err(\"Failed to allocate student list\\n\");\n        return -ENOMEM;\n    }\n    \n    // TODO: Initialize student list to NULL\n    for (i = 0; i < MAX_STUDENTS; i++) {\n        student_list[i] = NULL;\n    }\n    \n    // TODO: Run enrollment manager\n    if (enrollment_manager() < 0) {\n        pr_err(\"Enrollment manager failed\\n\");\n        kfree(student_list);\n        return -EIO;\n    }\n    \n    // TODO: Calculate statistics\n    calculate_statistics(student_list, student_count, &average_gpa, &active_students);\n    \n    // TODO: Process test grades\n    test_grades[0].numeric_grade = 95.5;\n    test_grades[1].letter_grade = 'A';\n    test_grades[2].flags.passed = 1;\n    test_grades[2].flags.honors = 1;\n    test_grades[2].flags.credits = 3;\n    \n    process_grades(test_grades, 3);\n    \n    // TODO: Print final statistics\n    pr_info(\"Final Statistics: %d students, average GPA: %.2f\\n\", \n            active_students, average_gpa);\n    \n    return 0;\n}\n\nstatic void __exit assessment_exit(void) {\n    int i;\n    \n    // TODO: Clean up all allocated memory\n    if (student_list) {\n        for (i = 0; i < student_count; i++) {\n            if (student_list[i]) {\n                destroy_student(student_list[i]);\n            }\n        }\n        kfree(student_list);\n    }\n    \n    pr_info(\"Assessment module cleanup completed\\n\");\n}\n\nmodule_init(assessment_init);\nmodule_exit(assessment_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Comprehensive foundations assessment module\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "comprehensive integration",
      "memory management",
      "data structures",
      "pointers and references",
      "control flow",
      "error handling",
      "module parameters",
      "unions and bitfields",
      "preprocessor directives",
      "function design"
    ],
    "skills": [
      "Complete foundation mastery",
      "Integration of all concepts",
      "Production-ready code",
      "Complex problem solving",
      "Memory safety",
      "Error handling patterns"
    ],
    "inputOutput": {
      "expectedOutput": [
        "=== Comprehensive Foundations Assessment ===",
        "Module parameters: max_capacity=30, debug_enabled=0",
        "Created student: ID=1, Name=Alice, GPA=3.8",
        "Created student: ID=2, Name=Bob, GPA=3.5",
        "Created student: ID=3, Name=Charlie, GPA=3.9",
        "Processing grades:",
        "Grade 0: Numeric 95.5",
        "Grade 1: Letter A",
        "Grade 2: Passed=1, Honors=1, Credits=3",
        "Final Statistics: 3 students, average GPA: 3.73"
      ],
      "requirements": [
        "Use required function names: assessment_init, assessment_exit",
        "Implement all required functions: create_student, destroy_student, calculate_statistics, process_grades, enrollment_manager",
        "Use all foundation concepts: structs, unions, enums, pointers, arrays, loops, conditionals",
        "Implement proper memory management with kmalloc/kfree",
        "Use module parameters with proper declarations",
        "Implement comprehensive error handling",
        "Use bitwise operations and unions correctly",
        "Create at least 3 test students with proper data",
        "Calculate and display statistics correctly"
      ]
    }
  },
  {
    "id": 31,
    "title": "Basic Module Lifecycle",
    "difficulty": 3,
    "xp": 30,
    "phase": "kernel_core",
    "description": "Create a basic kernel module that demonstrates proper module lifecycle management. This module should load cleanly, perform basic initialization, and unload properly with appropriate cleanup. This is fundamental for all kernel development work.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// TODO: Add module information macros\n// TODO: Implement module initialization function\n// TODO: Implement module cleanup function\n// TODO: Register init and exit functions\n\nstatic int __init basic_module_init(void)\n{\n    // TODO: Add initialization code\n    // Should print \"Basic module loaded successfully\"\n    // Should return 0 on success\n    return 0;\n}\n\nstatic void __exit basic_module_exit(void)\n{\n    // TODO: Add cleanup code\n    // Should print \"Basic module unloaded cleanly\"\n}\n\n// TODO: Register the init and exit functions\n// TODO: Add module metadata",
    "concepts": [
      "module_init",
      "module_exit",
      "MODULE_LICENSE",
      "kernel_logging",
      "error_handling"
    ],
    "skills": [
      "module_development",
      "kernel_apis",
      "initialization",
      "cleanup",
      "debugging"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Basic module loaded successfully",
        "Basic module unloaded cleanly"
      ],
      "requirements": [
        "Use required function names: basic_module_init, basic_module_exit",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h",
        "Code must contain: module_init, module_exit, MODULE_LICENSE, MODULE_AUTHOR, MODULE_DESCRIPTION, __init, __exit",
        "Must include MODULE_LICENSE(\"GPL\")"
      ]
    }
  },
  {
    "id": 32,
    "title": "Module Parameters and Configuration",
    "difficulty": 4,
    "xp": 40,
    "phase": "kernel_core",
    "description": "Implement a kernel module that accepts runtime parameters to configure its behavior. This teaches parameter validation, default values, and runtime configuration - essential skills for production kernel modules used at companies like NVIDIA and Intel.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/moduleparam.h>\n\n// TODO: Declare module parameters:\n// - debug_level (int, default 1, range 0-3)\n// - device_name (string, default \"mydevice\")\n// - enable_feature (bool, default true)\n// - buffer_size (int, default 1024, must be power of 2)\n\n// TODO: Add parameter descriptions\n// TODO: Add parameter validation in init function\n\nstatic int __init param_module_init(void)\n{\n    // TODO: Validate parameters\n    // TODO: Print current configuration\n    // TODO: Return appropriate error codes for invalid params\n    \n    printk(KERN_INFO \"Module loaded with parameters:\\n\");\n    // TODO: Print all parameter values\n    \n    return 0;\n}\n\nstatic void __exit param_module_exit(void)\n{\n    printk(KERN_INFO \"Module with parameters unloaded\\n\");\n}\n\nmodule_init(param_module_init);\nmodule_exit(param_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Module parameter demonstration\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "module_param",
      "MODULE_PARM_DESC",
      "parameter_validation",
      "runtime_configuration"
    ],
    "skills": [
      "parameter_handling",
      "input_validation",
      "configuration_management",
      "production_practices"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Module loaded with parameters:",
        "Debug level: 1",
        "Device name: mydevice",
        "Feature enabled: 1",
        "Buffer size: 1024",
        "Module with parameters unloaded"
      ],
      "requirements": [
        "Use required function names: param_module_init, param_module_exit",
        "Use required variable names: debug_level, device_name, enable_feature, buffer_size",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/moduleparam.h",
        "Code must contain: module_param, MODULE_PARM_DESC, S_IRUGO"
      ]
    }
  },
  {
    "id": 33,
    "title": "Kernel Error Handling Patterns",
    "difficulty": 5,
    "xp": 50,
    "phase": "kernel_core",
    "description": "Master kernel error handling patterns including proper error codes, cleanup on failure, and resource management. This is critical for writing production-quality kernel code that can handle failures gracefully without causing system instability.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n\n// TODO: Implement proper error handling for multiple resource allocation\n// TODO: Use correct error codes (ENOMEM, EINVAL, etc.)\n// TODO: Implement proper cleanup patterns\n\nstatic void *buffer1 = NULL;\nstatic void *buffer2 = NULL;\nstatic struct proc_dir_entry *proc_entry = NULL;\n\n// TODO: Implement a function that allocates multiple resources\n// and handles failures properly\nstatic int allocate_resources(void)\n{\n    // TODO: Allocate buffer1 (1024 bytes)\n    // TODO: Allocate buffer2 (2048 bytes)  \n    // TODO: Create proc entry \"error_demo\"\n    // TODO: Handle each allocation failure with proper cleanup\n    // TODO: Return appropriate error codes\n    \n    return 0;\n}\n\n// TODO: Implement proper cleanup function\nstatic void cleanup_resources(void)\n{\n    // TODO: Clean up all allocated resources safely\n    // TODO: Handle NULL pointers correctly\n}\n\nstatic int __init error_module_init(void)\n{\n    int ret;\n    \n    printk(KERN_INFO \"Error handling module loading...\\n\");\n    \n    ret = allocate_resources();\n    if (ret) {\n        printk(KERN_ERR \"Resource allocation failed: %d\\n\", ret);\n        return ret;\n    }\n    \n    printk(KERN_INFO \"All resources allocated successfully\\n\");\n    return 0;\n}\n\nstatic void __exit error_module_exit(void)\n{\n    cleanup_resources();\n    printk(KERN_INFO \"Error handling module unloaded\\n\");\n}\n\nmodule_init(error_module_init);\nmodule_exit(error_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Error handling patterns demonstration\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "error_codes",
      "cleanup_patterns",
      "resource_management",
      "failure_handling",
      "ENOSYS",
      "ENOMEM",
      "EINVAL"
    ],
    "skills": [
      "error_handling",
      "resource_cleanup",
      "defensive_programming",
      "system_stability"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Error handling module loading...",
        "All resources allocated successfully",
        "Error handling module unloaded"
      ],
      "requirements": [
        "Use required function names: error_module_init, error_module_exit, allocate_resources, cleanup_resources",
        "Use required variable names: buffer1, buffer2, proc_entry",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/slab.h, linux/errno.h, linux/proc_fs.h",
        "Code must contain: kmalloc, kfree, ENOMEM, EINVAL, proc_create, proc_remove"
      ]
    }
  },
  {
    "id": 34,
    "title": "Proc Filesystem Interface",
    "difficulty": 6,
    "xp": 60,
    "phase": "kernel_core",
    "description": "Create a kernel module that implements a /proc interface for exposing kernel module information to userspace. This is fundamental for debugging, monitoring, and configuration in production systems used by enterprise kernel developers.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\n#define PROC_ENTRY_NAME \"kernel_stats\"\n#define MAX_BUFFER_SIZE 1024\n\nstatic struct proc_dir_entry *proc_entry = NULL;\nstatic char *info_buffer = NULL;\nstatic int access_count = 0;\nstatic unsigned long last_access_jiffies = 0;\n\n// TODO: Implement seq_show function for reading proc entry\nstatic int kernel_stats_show(struct seq_file *m, void *v)\n{\n    // TODO: Display module statistics:\n    // - Access count\n    // - Last access time (in jiffies)\n    // - Current jiffies\n    // - Buffer allocation status\n    // - Module load time\n    \n    return 0;\n}\n\n// TODO: Implement proc_open function\nstatic int kernel_stats_open(struct inode *inode, struct file *file)\n{\n    // TODO: Increment access count\n    // TODO: Update last access time\n    // TODO: Use single_open with seq_show function\n    return 0;\n}\n\n// TODO: Implement write function for proc entry\nstatic ssize_t kernel_stats_write(struct file *file, const char __user *buffer,\n                                  size_t count, loff_t *pos)\n{\n    // TODO: Handle write operations\n    // TODO: Support \"reset\" command to reset counters\n    // TODO: Support \"info <string>\" to update info buffer\n    // TODO: Validate input and handle errors\n    \n    return count;\n}\n\n// TODO: Define proc_ops structure\nstatic const struct proc_ops kernel_stats_proc_ops = {\n    // TODO: Set up proc operations\n};\n\nstatic int __init proc_module_init(void)\n{\n    // TODO: Allocate info buffer\n    // TODO: Create proc entry\n    // TODO: Initialize counters\n    // TODO: Handle allocation failures\n    \n    printk(KERN_INFO \"Proc interface module loaded\\n\");\n    printk(KERN_INFO \"Created /proc/%s\\n\", PROC_ENTRY_NAME);\n    return 0;\n}\n\nstatic void __exit proc_module_exit(void)\n{\n    // TODO: Remove proc entry\n    // TODO: Free allocated memory\n    // TODO: Clean up resources\n    \n    printk(KERN_INFO \"Proc interface module unloaded\\n\");\n}\n\nmodule_init(proc_module_init);\nmodule_exit(proc_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Proc filesystem interface demonstration\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "proc_fs",
      "seq_file",
      "userspace_interface",
      "kernel_debugging",
      "system_monitoring"
    ],
    "skills": [
      "proc_interface",
      "seq_operations",
      "user_kernel_communication",
      "debugging_interfaces"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Proc interface module loaded",
        "Created /proc/kernel_stats",
        "Proc interface module unloaded"
      ],
      "requirements": [
        "Use required function names: proc_module_init, proc_module_exit, kernel_stats_show, kernel_stats_open, kernel_stats_write",
        "Use required variable names: proc_entry, info_buffer, access_count, last_access_jiffies",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/proc_fs.h, linux/seq_file.h, linux/uaccess.h",
        "Code must contain: proc_create, proc_remove, seq_printf, single_open, copy_from_user, proc_ops"
      ]
    }
  },
  {
    "id": 35,
    "title": "Sysfs Attributes and Kobjects",
    "difficulty": 7,
    "xp": 70,
    "phase": "kernel_core",
    "description": "Create a kernel module that exposes configuration and status information through sysfs attributes. This teaches the sysfs interface used extensively in production systems for device configuration, monitoring, and debugging at enterprise kernel development companies.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/kobject.h>\n#include <linux/sysfs.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\n#define MAX_BUFFER_SIZE 64\n\nstatic struct kobject *sysfs_kobj;\nstatic char device_name[MAX_BUFFER_SIZE] = \"default_device\";\nstatic int debug_level = 1;\nstatic bool device_enabled = true;\nstatic unsigned long operation_count = 0;\n\n// TODO: Implement show function for device_name attribute\nstatic ssize_t device_name_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n    // TODO: Return current device name\n    return 0;\n}\n\n// TODO: Implement store function for device_name attribute\nstatic ssize_t device_name_store(struct kobject *kobj, struct kobj_attribute *attr,\n                                const char *buf, size_t count)\n{\n    // TODO: Validate input length\n    // TODO: Copy new device name (strip newline)\n    // TODO: Increment operation count\n    // TODO: Log the change\n    return count;\n}\n\n// TODO: Implement show function for debug_level attribute\nstatic ssize_t debug_level_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n    // TODO: Return current debug level\n    return 0;\n}\n\n// TODO: Implement store function for debug_level attribute\nstatic ssize_t debug_level_store(struct kobject *kobj, struct kobj_attribute *attr,\n                                const char *buf, size_t count)\n{\n    // TODO: Parse integer from buffer\n    // TODO: Validate range (0-3)\n    // TODO: Update debug_level\n    // TODO: Increment operation count\n    return count;\n}\n\n// TODO: Implement show function for device_enabled attribute\nstatic ssize_t device_enabled_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n    // TODO: Return device enabled status (0 or 1)\n    return 0;\n}\n\n// TODO: Implement store function for device_enabled attribute\nstatic ssize_t device_enabled_store(struct kobject *kobj, struct kobj_attribute *attr,\n                                   const char *buf, size_t count)\n{\n    // TODO: Parse boolean from buffer\n    // TODO: Update device_enabled\n    // TODO: Log state change\n    // TODO: Increment operation count\n    return count;\n}\n\n// TODO: Implement read-only show function for operation_count\nstatic ssize_t operation_count_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n    // TODO: Return current operation count\n    return 0;\n}\n\n// TODO: Define kobj_attribute structures\nstatic struct kobj_attribute device_name_attr = __ATTR(device_name, 0664, device_name_show, device_name_store);\nstatic struct kobj_attribute debug_level_attr = __ATTR(debug_level, 0664, debug_level_show, debug_level_store);\nstatic struct kobj_attribute device_enabled_attr = __ATTR(device_enabled, 0664, device_enabled_show, device_enabled_store);\nstatic struct kobj_attribute operation_count_attr = __ATTR_RO(operation_count);\n\n// TODO: Create attribute group\nstatic struct attribute *attrs[] = {\n    // TODO: Add all attributes\n    NULL,\n};\n\nstatic struct attribute_group attr_group = {\n    .attrs = attrs,\n};\n\nstatic int __init sysfs_module_init(void)\n{\n    int ret;\n    \n    // TODO: Create kobject under /sys/kernel/\n    // TODO: Create sysfs group\n    // TODO: Handle creation failures\n    \n    printk(KERN_INFO \"Sysfs module loaded successfully\\n\");\n    printk(KERN_INFO \"Sysfs interface created at /sys/kernel/demo_device\\n\");\n    return 0;\n}\n\nstatic void __exit sysfs_module_exit(void)\n{\n    // TODO: Remove sysfs group\n    // TODO: Put kobject\n    \n    printk(KERN_INFO \"Sysfs module unloaded\\n\");\n}\n\nmodule_init(sysfs_module_init);\nmodule_exit(sysfs_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Sysfs attributes demonstration\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "sysfs",
      "kobject",
      "device_attributes",
      "show_store_functions",
      "kernel_userspace_interface"
    ],
    "skills": [
      "sysfs_interface",
      "attribute_management",
      "kernel_objects",
      "userspace_communication"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Sysfs module loaded successfully",
        "Sysfs interface created at /sys/kernel/demo_device",
        "Sysfs module unloaded"
      ],
      "requirements": [
        "Use required function names: sysfs_module_init, sysfs_module_exit, device_name_show, device_name_store, debug_level_show, debug_level_store, device_enabled_show, device_enabled_store, operation_count_show",
        "Use required variable names: sysfs_kobj, device_name, debug_level, device_enabled, operation_count",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/kobject.h, linux/sysfs.h",
        "Code must contain: kobject_create_and_add, sysfs_create_group, sysfs_remove_group, kobject_put, __ATTR, __ATTR_RO"
      ]
    }
  },
  {
    "id": 36,
    "title": "Module Dependencies and Symbols",
    "difficulty": 8,
    "xp": 80,
    "phase": "kernel_core",
    "description": "Create a kernel module that depends on other modules and exports symbols for use by other modules. This teaches symbol export/import, module dependencies, and inter-module communication patterns used in large kernel subsystems at enterprise companies.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n// TODO: Define a structure for our exported data\nstruct demo_device {\n    char name[32];\n    int id;\n    bool active;\n    unsigned long created_jiffies;\n};\n\n// TODO: Static variables for this module\nstatic struct demo_device *global_device = NULL;\nstatic int device_counter = 0;\nstatic DEFINE_MUTEX(device_mutex);\n\n// TODO: Implement function to create a new device\n// This will be exported for other modules to use\nstruct demo_device *create_demo_device(const char *name)\n{\n    struct demo_device *dev;\n    \n    // TODO: Validate input\n    // TODO: Allocate memory for device\n    // TODO: Initialize device fields\n    // TODO: Use mutex for thread safety\n    // TODO: Increment device counter\n    // TODO: Log device creation\n    \n    return NULL;\n}\n\n// TODO: Implement function to destroy a device\nvoid destroy_demo_device(struct demo_device *dev)\n{\n    // TODO: Validate input\n    // TODO: Use mutex for thread safety\n    // TODO: Log device destruction\n    // TODO: Free device memory\n    // TODO: Decrement device counter\n}\n\n// TODO: Implement function to get device info\nint get_device_info(struct demo_device *dev, char *buffer, size_t size)\n{\n    // TODO: Validate inputs\n    // TODO: Format device information into buffer\n    // TODO: Return number of bytes written\n    return 0;\n}\n\n// TODO: Implement function to get global statistics\nint get_global_stats(void)\n{\n    // TODO: Return current device counter\n    return device_counter;\n}\n\n// TODO: Export symbols for other modules\n// Use EXPORT_SYMBOL_GPL for GPL-only access\n// Use EXPORT_SYMBOL for general access\n\nstatic int __init dependency_module_init(void)\n{\n    int ret = 0;\n    \n    // TODO: Initialize global device\n    global_device = create_demo_device(\"global_device\");\n    if (!global_device) {\n        printk(KERN_ERR \"Failed to create global device\\n\");\n        return -ENOMEM;\n    }\n    \n    printk(KERN_INFO \"Module dependencies demo loaded\\n\");\n    printk(KERN_INFO \"Exported symbols: create_demo_device, destroy_demo_device\\n\");\n    printk(KERN_INFO \"Device counter: %d\\n\", device_counter);\n    \n    return ret;\n}\n\nstatic void __exit dependency_module_exit(void)\n{\n    // TODO: Clean up global device\n    if (global_device) {\n        destroy_demo_device(global_device);\n        global_device = NULL;\n    }\n    \n    printk(KERN_INFO \"Module dependencies demo unloaded\\n\");\n    printk(KERN_INFO \"Final device counter: %d\\n\", device_counter);\n}\n\nmodule_init(dependency_module_init);\nmodule_exit(dependency_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Module dependencies and symbol export demonstration\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "EXPORT_SYMBOL",
      "EXPORT_SYMBOL_GPL",
      "module_dependencies",
      "symbol_lookup",
      "inter_module_communication"
    ],
    "skills": [
      "symbol_management",
      "module_architecture",
      "dependency_resolution",
      "kernel_apis"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Module dependencies demo loaded",
        "Exported symbols: create_demo_device, destroy_demo_device",
        "Device counter: 1",
        "Module dependencies demo unloaded",
        "Final device counter: 0"
      ],
      "requirements": [
        "Use required function names: dependency_module_init, dependency_module_exit, create_demo_device, destroy_demo_device, get_device_info, get_global_stats",
        "Use required variable names: global_device, device_counter, device_mutex",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/slab.h",
        "Code must contain: EXPORT_SYMBOL, EXPORT_SYMBOL_GPL, DEFINE_MUTEX, mutex_lock, mutex_unlock, kmalloc, kfree"
      ]
    }
  },
  {
    "id": 37,
    "title": "Kernel Debugging and Diagnostics",
    "difficulty": 7,
    "xp": 70,
    "phase": "kernel_core",
    "description": "Implement a kernel module with comprehensive debugging, tracing, and diagnostic capabilities. This teaches essential debugging techniques used in production kernel development at companies like Intel, NVIDIA, and Red Hat for troubleshooting complex kernel issues.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/trace_events.h>\n\n// TODO: Enable dynamic debug support\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n// TODO: Define debugging levels\n#define DEBUG_LEVEL_NONE    0\n#define DEBUG_LEVEL_ERROR   1  \n#define DEBUG_LEVEL_WARN    2\n#define DEBUG_LEVEL_INFO    3\n#define DEBUG_LEVEL_DEBUG   4\n\nstatic int debug_level = DEBUG_LEVEL_INFO;\nstatic struct dentry *debug_dir = NULL;\nstatic struct dentry *debug_file = NULL;\nstatic unsigned long function_calls = 0;\nstatic unsigned long error_count = 0;\nstatic unsigned long last_error_jiffies = 0;\n\n// TODO: Debug macro with level checking\n#define debug_print(level, fmt, ...) do { \\\n    if (debug_level >= level) { \\\n        pr_info(\"[%s:%d] \" fmt, __func__, __LINE__, ##__VA_ARGS__); \\\n    } \\\n} while (0)\n\n// TODO: Implement a function that can be traced\nstatic int debug_function_a(int param1, const char *param2)\n{\n    // TODO: Increment function call counter\n    // TODO: Add debug prints at different levels\n    // TODO: Validate parameters\n    // TODO: Simulate some work with different code paths\n    \n    debug_print(DEBUG_LEVEL_DEBUG, \"Called with param1=%d, param2=%s\\n\", \n                param1, param2 ? param2 : \"(null)\");\n    \n    if (!param2) {\n        debug_print(DEBUG_LEVEL_ERROR, \"Invalid parameter: param2 is NULL\\n\");\n        error_count++;\n        last_error_jiffies = jiffies;\n        return -EINVAL;\n    }\n    \n    if (param1 < 0) {\n        debug_print(DEBUG_LEVEL_WARN, \"Negative parameter: param1=%d\\n\", param1);\n    }\n    \n    // TODO: Add ftrace marker\n    trace_printk(\"debug_function_a: processing param1=%d\\n\", param1);\n    \n    debug_print(DEBUG_LEVEL_INFO, \"Successfully processed parameters\\n\");\n    return 0;\n}\n\n// TODO: Implement another traceable function with error handling\nstatic void *debug_function_b(size_t size)\n{\n    void *ptr;\n    \n    function_calls++;\n    debug_print(DEBUG_LEVEL_DEBUG, \"Allocating %zu bytes\\n\", size);\n    \n    if (size == 0) {\n        debug_print(DEBUG_LEVEL_ERROR, \"Invalid size: 0\\n\");\n        error_count++;\n        last_error_jiffies = jiffies;\n        return NULL;\n    }\n    \n    if (size > PAGE_SIZE) {\n        debug_print(DEBUG_LEVEL_WARN, \"Large allocation requested: %zu bytes\\n\", size);\n    }\n    \n    ptr = kmalloc(size, GFP_KERNEL);\n    if (!ptr) {\n        debug_print(DEBUG_LEVEL_ERROR, \"Memory allocation failed for %zu bytes\\n\", size);\n        error_count++;\n        last_error_jiffies = jiffies;\n        return NULL;\n    }\n    \n    trace_printk(\"debug_function_b: allocated %zu bytes at %p\\n\", size, ptr);\n    debug_print(DEBUG_LEVEL_INFO, \"Allocated %zu bytes at %p\\n\", size, ptr);\n    \n    return ptr;\n}\n\n// TODO: Implement debugfs show function\nstatic int debug_stats_show(struct seq_file *m, void *v)\n{\n    // TODO: Display debugging statistics\n    // TODO: Show function call counts, error counts, etc.\n    // TODO: Show current debug level\n    // TODO: Show last error time\n    \n    return 0;\n}\n\n// TODO: Implement debugfs open function\nstatic int debug_stats_open(struct inode *inode, struct file *file)\n{\n    return single_open(file, debug_stats_show, NULL);\n}\n\n// TODO: Implement debugfs write function for changing debug level\nstatic ssize_t debug_level_write(struct file *file, const char __user *buf,\n                               size_t count, loff_t *ppos)\n{\n    // TODO: Parse new debug level from user input\n    // TODO: Validate range (0-4)\n    // TODO: Update debug_level\n    // TODO: Log the change\n    \n    return count;\n}\n\n// TODO: Define debugfs file operations\nstatic const struct file_operations debug_fops = {\n    // TODO: Set up file operations\n};\n\nstatic int __init debug_module_init(void)\n{\n    int ret;\n    void *test_ptr;\n    \n    debug_print(DEBUG_LEVEL_INFO, \"Debug module initializing...\\n\");\n    \n    // TODO: Create debugfs directory\n    debug_dir = debugfs_create_dir(\"debug_demo\", NULL);\n    if (!debug_dir) {\n        pr_err(\"Failed to create debugfs directory\\n\");\n        return -ENOMEM;\n    }\n    \n    // TODO: Create debugfs file\n    debug_file = debugfs_create_file(\"stats\", 0644, debug_dir, NULL, &debug_fops);\n    if (!debug_file) {\n        pr_err(\"Failed to create debugfs file\\n\");\n        debugfs_remove_recursive(debug_dir);\n        return -ENOMEM;\n    }\n    \n    // TODO: Test our debug functions\n    ret = debug_function_a(42, \"test_string\");\n    debug_print(DEBUG_LEVEL_DEBUG, \"debug_function_a returned %d\\n\", ret);\n    \n    test_ptr = debug_function_b(1024);\n    if (test_ptr) {\n        debug_print(DEBUG_LEVEL_DEBUG, \"debug_function_b returned %p\\n\", test_ptr);\n        kfree(test_ptr);\n    }\n    \n    // TODO: Test error conditions\n    debug_function_a(-1, NULL);\n    debug_function_b(0);\n    \n    printk(KERN_INFO \"Debug module loaded successfully\\n\");\n    printk(KERN_INFO \"Debug level: %d, Function calls: %lu\\n\", debug_level, function_calls);\n    printk(KERN_INFO \"Debugfs interface: /sys/kernel/debug/debug_demo/\\n\");\n    \n    return 0;\n}\n\nstatic void __exit debug_module_exit(void)\n{\n    // TODO: Remove debugfs entries\n    debugfs_remove_recursive(debug_dir);\n    \n    debug_print(DEBUG_LEVEL_INFO, \"Debug module exiting...\\n\");\n    printk(KERN_INFO \"Debug module unloaded\\n\");\n    printk(KERN_INFO \"Final stats - Calls: %lu, Errors: %lu\\n\", function_calls, error_count);\n}\n\nmodule_init(debug_module_init);\nmodule_exit(debug_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Kernel debugging and diagnostics demonstration\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "pr_debug",
      "dynamic_debug",
      "ftrace",
      "debugfs",
      "kernel_tracing",
      "conditional_compilation"
    ],
    "skills": [
      "kernel_debugging",
      "diagnostic_tools",
      "production_debugging",
      "trace_analysis"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Debug module loaded successfully",
        "Debug level: 3, Function calls:",
        "Debugfs interface: /sys/kernel/debug/debug_demo/",
        "Debug module unloaded",
        "Final stats - Calls:"
      ],
      "requirements": [
        "Use required function names: debug_module_init, debug_module_exit, debug_function_a, debug_function_b, debug_stats_show, debug_stats_open, debug_level_write",
        "Use required variable names: debug_level, debug_dir, debug_file, function_calls, error_count",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/debugfs.h",
        "Code must contain: pr_fmt, pr_info, trace_printk, debugfs_create_dir, debugfs_create_file, debugfs_remove_recursive, seq_printf"
      ]
    }
  },
  {
    "id": 38,
    "title": "Workqueues and Timers",
    "difficulty": 8,
    "xp": 80,
    "phase": "kernel_core",
    "description": "Implement a kernel module that uses workqueues and timers for asynchronous task execution and periodic operations. This teaches essential kernel concurrency mechanisms used extensively in device drivers and kernel subsystems at enterprise companies.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/workqueue.h>\n#include <linux/timer.h>\n#include <linux/jiffies.h>\n#include <linux/slab.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n\n#define TIMER_INTERVAL_MS 5000\n#define WORK_DELAY_MS 1000\n#define MAX_WORK_ITEMS 10\n\n// TODO: Define work item structure\nstruct work_item_data {\n    struct work_struct work;\n    int item_id;\n    unsigned long created_jiffies;\n    char description[64];\n};\n\n// TODO: Define statistics structure\nstatic struct {\n    unsigned long timer_fires;\n    unsigned long work_executed;\n    unsigned long work_scheduled;\n    unsigned long work_failed;\n    unsigned long last_timer_jiffies;\n    unsigned long last_work_jiffies;\n} stats = {0};\n\n// TODO: Define kernel objects\nstatic struct timer_list periodic_timer;\nstatic struct workqueue_struct *demo_workqueue;\nstatic struct delayed_work delayed_demo_work;\nstatic struct proc_dir_entry *proc_entry;\nstatic int next_work_id = 1;\nstatic DEFINE_SPINLOCK(stats_lock);\n\n// TODO: Implement work function for individual work items\nstatic void work_item_handler(struct work_struct *work)\n{\n    struct work_item_data *item;\n    unsigned long flags;\n    \n    // TODO: Get container structure\n    item = container_of(work, struct work_item_data, work);\n    \n    // TODO: Process the work item\n    // TODO: Update statistics\n    // TODO: Log the work execution\n    // TODO: Free the work item\n    \n    printk(KERN_INFO \"Work item %d executed: %s\\n\", item->item_id, item->description);\n    \n    spin_lock_irqsave(&stats_lock, flags);\n    stats.work_executed++;\n    stats.last_work_jiffies = jiffies;\n    spin_unlock_irqrestore(&stats_lock, flags);\n    \n    kfree(item);\n}\n\n// TODO: Implement delayed work handler\nstatic void delayed_work_handler(struct work_struct *work)\n{\n    unsigned long flags;\n    \n    // TODO: Update statistics\n    // TODO: Schedule next delayed work\n    // TODO: Create and schedule a new work item\n    \n    printk(KERN_INFO \"Delayed work executed at jiffies=%lu\\n\", jiffies);\n    \n    spin_lock_irqsave(&stats_lock, flags);\n    stats.work_executed++;\n    stats.last_work_jiffies = jiffies;\n    spin_unlock_irqrestore(&stats_lock, flags);\n    \n    // TODO: Schedule next delayed work in WORK_DELAY_MS milliseconds\n    if (demo_workqueue) {\n        queue_delayed_work(demo_workqueue, &delayed_demo_work, msecs_to_jiffies(WORK_DELAY_MS));\n    }\n}\n\n// TODO: Implement timer callback function\nstatic void timer_callback(struct timer_list *timer)\n{\n    struct work_item_data *new_item;\n    unsigned long flags;\n    \n    // TODO: Update timer statistics\n    spin_lock_irqsave(&stats_lock, flags);\n    stats.timer_fires++;\n    stats.last_timer_jiffies = jiffies;\n    spin_unlock_irqrestore(&stats_lock, flags);\n    \n    printk(KERN_INFO \"Timer fired at jiffies=%lu\\n\", jiffies);\n    \n    // TODO: Create new work item\n    new_item = kmalloc(sizeof(*new_item), GFP_ATOMIC);\n    if (!new_item) {\n        spin_lock_irqsave(&stats_lock, flags);\n        stats.work_failed++;\n        spin_unlock_irqrestore(&stats_lock, flags);\n        printk(KERN_ERR \"Failed to allocate work item\\n\");\n        goto restart_timer;\n    }\n    \n    // TODO: Initialize work item\n    INIT_WORK(&new_item->work, work_item_handler);\n    new_item->item_id = next_work_id++;\n    new_item->created_jiffies = jiffies;\n    snprintf(new_item->description, sizeof(new_item->description), \n             \"Timer-generated work item %d\", new_item->item_id);\n    \n    // TODO: Queue work item\n    if (demo_workqueue) {\n        if (queue_work(demo_workqueue, &new_item->work)) {\n            spin_lock_irqsave(&stats_lock, flags);\n            stats.work_scheduled++;\n            spin_unlock_irqrestore(&stats_lock, flags);\n        } else {\n            spin_lock_irqsave(&stats_lock, flags);\n            stats.work_failed++;\n            spin_unlock_irqrestore(&stats_lock, flags);\n            kfree(new_item);\n        }\n    } else {\n        kfree(new_item);\n    }\n    \nrestart_timer:\n    // TODO: Restart timer for next interval\n    mod_timer(&periodic_timer, jiffies + msecs_to_jiffies(TIMER_INTERVAL_MS));\n}\n\n// TODO: Implement proc show function for statistics\nstatic int stats_proc_show(struct seq_file *m, void *v)\n{\n    unsigned long flags;\n    \n    spin_lock_irqsave(&stats_lock, flags);\n    \n    // TODO: Display comprehensive statistics\n    seq_printf(m, \"Workqueue and Timer Statistics\\n\");\n    seq_printf(m, \"==============================\\n\");\n    seq_printf(m, \"Timer fires: %lu\\n\", stats.timer_fires);\n    seq_printf(m, \"Work scheduled: %lu\\n\", stats.work_scheduled);\n    seq_printf(m, \"Work executed: %lu\\n\", stats.work_executed);\n    seq_printf(m, \"Work failed: %lu\\n\", stats.work_failed);\n    seq_printf(m, \"Last timer: %lu (jiffies)\\n\", stats.last_timer_jiffies);\n    seq_printf(m, \"Last work: %lu (jiffies)\\n\", stats.last_work_jiffies);\n    seq_printf(m, \"Current time: %lu (jiffies)\\n\", jiffies);\n    seq_printf(m, \"Next work ID: %d\\n\", next_work_id);\n    \n    spin_unlock_irqrestore(&stats_lock, flags);\n    \n    return 0;\n}\n\n// TODO: Implement proc open function\nstatic int stats_proc_open(struct inode *inode, struct file *file)\n{\n    return single_open(file, stats_proc_show, NULL);\n}\n\n// TODO: Define proc file operations\nstatic const struct proc_ops stats_proc_ops = {\n    .proc_open = stats_proc_open,\n    .proc_read = seq_read,\n    .proc_lseek = seq_lseek,\n    .proc_release = single_release,\n};\n\nstatic int __init workqueue_module_init(void)\n{\n    int ret = 0;\n    \n    printk(KERN_INFO \"Workqueue and timer module initializing...\\n\");\n    \n    // TODO: Create dedicated workqueue\n    demo_workqueue = create_singlethread_workqueue(\"demo_wq\");\n    if (!demo_workqueue) {\n        printk(KERN_ERR \"Failed to create workqueue\\n\");\n        return -ENOMEM;\n    }\n    \n    // TODO: Initialize timer\n    timer_setup(&periodic_timer, timer_callback, 0);\n    \n    // TODO: Initialize delayed work\n    INIT_DELAYED_WORK(&delayed_demo_work, delayed_work_handler);\n    \n    // TODO: Create proc entry for statistics\n    proc_entry = proc_create(\"workqueue_stats\", 0444, NULL, &stats_proc_ops);\n    if (!proc_entry) {\n        printk(KERN_ERR \"Failed to create proc entry\\n\");\n        destroy_workqueue(demo_workqueue);\n        return -ENOMEM;\n    }\n    \n    // TODO: Start timer and delayed work\n    mod_timer(&periodic_timer, jiffies + msecs_to_jiffies(TIMER_INTERVAL_MS));\n    queue_delayed_work(demo_workqueue, &delayed_demo_work, msecs_to_jiffies(WORK_DELAY_MS));\n    \n    printk(KERN_INFO \"Workqueue and timer module loaded successfully\\n\");\n    printk(KERN_INFO \"Timer interval: %d ms, Work delay: %d ms\\n\", TIMER_INTERVAL_MS, WORK_DELAY_MS);\n    printk(KERN_INFO \"Statistics available at /proc/workqueue_stats\\n\");\n    \n    return ret;\n}\n\nstatic void __exit workqueue_module_exit(void)\n{\n    // TODO: Cancel timer\n    del_timer_sync(&periodic_timer);\n    \n    // TODO: Cancel delayed work\n    cancel_delayed_work_sync(&delayed_demo_work);\n    \n    // TODO: Flush and destroy workqueue\n    if (demo_workqueue) {\n        flush_workqueue(demo_workqueue);\n        destroy_workqueue(demo_workqueue);\n    }\n    \n    // TODO: Remove proc entry\n    if (proc_entry) {\n        proc_remove(proc_entry);\n    }\n    \n    printk(KERN_INFO \"Workqueue and timer module unloaded\\n\");\n    printk(KERN_INFO \"Final statistics - Timer: %lu, Work: %lu, Failed: %lu\\n\",\n           stats.timer_fires, stats.work_executed, stats.work_failed);\n}\n\nmodule_init(workqueue_module_init);\nmodule_exit(workqueue_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Workqueues and timers demonstration\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "workqueue",
      "timer_list",
      "delayed_work",
      "periodic_timers",
      "asynchronous_execution",
      "kernel_threads"
    ],
    "skills": [
      "async_programming",
      "timer_management",
      "workqueue_usage",
      "kernel_concurrency"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Workqueue and timer module loaded successfully",
        "Timer interval: 5000 ms, Work delay: 1000 ms",
        "Statistics available at /proc/workqueue_stats",
        "Workqueue and timer module unloaded",
        "Final statistics - Timer:"
      ],
      "requirements": [
        "Use required function names: workqueue_module_init, workqueue_module_exit, work_item_handler, delayed_work_handler, timer_callback, stats_proc_show, stats_proc_open",
        "Use required variable names: periodic_timer, demo_workqueue, delayed_demo_work, stats_lock",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/workqueue.h, linux/timer.h",
        "Code must contain: timer_setup, mod_timer, del_timer_sync, create_singlethread_workqueue, destroy_workqueue, INIT_WORK, INIT_DELAYED_WORK, queue_work, queue_delayed_work, container_of, spin_lock_irqsave, spin_unlock_irqrestore"
      ]
    }
  },
  {
    "id": 39,
    "title": "Understanding Concurrency in Kernel",
    "difficulty": 5,
    "xp": 45,
    "phase": "kernel_core",
    "description": "Learn what concurrency means in kernel programming and why synchronization is critical. Understand multiple execution contexts, race conditions, and the problems that arise when multiple threads access shared data simultaneously.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\n// CONCEPT: Concurrency and Race Conditions\n// Concurrency = Multiple things happening at the same time\n// Race Condition = Unpredictable results when multiple threads access shared data\n// \n// In kernel:\n// - Multiple processes can call your module simultaneously\n// - Interrupt handlers can run while your code is executing\n// - SMP systems have multiple CPUs running code in parallel\n//\n// WHY: Without proper synchronization, data corruption and crashes occur\n\n// Shared data that multiple threads will access\nstatic int shared_counter = 0;\nstatic int final_expected_value = 0;\n\n// TODO: Demonstrate race condition (unsafe)\nstatic int unsafe_thread_function(void *data)\n{\n    int thread_id = (long)data;\n    int i;\n    \n    printk(KERN_INFO \"Thread %d started\\n\", thread_id);\n    \n    // Each thread increments counter 1000 times\n    for (i = 0; i < 1000; i++) {\n        // DANGEROUS: No synchronization!\n        // Multiple threads can read/modify shared_counter simultaneously\n        shared_counter++;\n        \n        // Small delay to increase chance of race condition\n        if (i % 100 == 0) {\n            msleep(1);\n        }\n    }\n    \n    printk(KERN_INFO \"Thread %d finished\\n\", thread_id);\n    return 0;\n}\n\n// TODO: Demonstrate what happens without synchronization\nstatic void demonstrate_race_condition(void)\n{\n    struct task_struct *thread1, *thread2;\n    \n    printk(KERN_INFO \"=== Demonstrating Race Condition ===\");\n    printk(KERN_INFO \"Starting 2 threads, each incrementing counter 1000 times\\n\");\n    printk(KERN_INFO \"Expected final value: 2000\\n\");\n    \n    shared_counter = 0;\n    final_expected_value = 2000;\n    \n    // Create two threads that will compete for shared_counter\n    thread1 = kthread_run(unsafe_thread_function, (void *)1, \"unsafe_thread1\");\n    thread2 = kthread_run(unsafe_thread_function, (void *)2, \"unsafe_thread2\");\n    \n    if (IS_ERR(thread1) || IS_ERR(thread2)) {\n        printk(KERN_ERR \"Failed to create threads\\n\");\n        return;\n    }\n    \n    // Wait for threads to complete\n    msleep(3000);\n    \n    printk(KERN_INFO \"Threads completed\\n\");\n    printk(KERN_INFO \"Final counter value: %d\\n\", shared_counter);\n    printk(KERN_INFO \"Expected value: %d\\n\", final_expected_value);\n    \n    if (shared_counter != final_expected_value) {\n        printk(KERN_WARNING \"RACE CONDITION DETECTED!\\n\");\n        printk(KERN_WARNING \"Counter value is incorrect due to unsynchronized access\\n\");\n    } else {\n        printk(KERN_INFO \"No race condition detected this time (but it's still unsafe!)\\n\");\n    }\n}\n\n// TODO: Explain different types of execution contexts\nstatic void explain_execution_contexts(void)\n{\n    printk(KERN_INFO \"=== Kernel Execution Contexts ===\");\n    printk(KERN_INFO \"1. Process Context:\\n\");\n    printk(KERN_INFO \"   - System calls, kernel threads\\n\");\n    printk(KERN_INFO \"   - Can sleep, use mutexes\\n\");\n    printk(KERN_INFO \"   - Most kernel code runs here\\n\");\n    \n    printk(KERN_INFO \"2. Interrupt Context:\\n\");\n    printk(KERN_INFO \"   - Hardware interrupts, softirqs\\n\");\n    printk(KERN_INFO \"   - Cannot sleep, atomic only\\n\");\n    printk(KERN_INFO \"   - Must be very fast\\n\");\n    \n    printk(KERN_INFO \"3. Multiple CPUs (SMP):\\n\");\n    printk(KERN_INFO \"   - Code can run simultaneously on different CPUs\\n\");\n    printk(KERN_INFO \"   - Shared data needs protection\\n\");\n}\n\n// TODO: Explain why synchronization is needed\nstatic void explain_synchronization_need(void)\n{\n    printk(KERN_INFO \"=== Why Synchronization is Critical ===\");\n    printk(KERN_INFO \"Problems without synchronization:\\n\");\n    printk(KERN_INFO \"- Data corruption (lost updates)\\n\");\n    printk(KERN_INFO \"- Inconsistent state\\n\");\n    printk(KERN_INFO \"- System crashes\\n\");\n    printk(KERN_INFO \"- Unpredictable behavior\\n\");\n    \n    printk(KERN_INFO \"Solutions (next problems will teach):\\n\");\n    printk(KERN_INFO \"- Mutexes (for process context)\\n\");\n    printk(KERN_INFO \"- Spinlocks (for interrupt context)\\n\");\n    printk(KERN_INFO \"- Atomic operations\\n\");\n    printk(KERN_INFO \"- RCU (Read-Copy-Update)\\n\");\n}\n\nstatic int __init concurrency_init(void)\n{\n    printk(KERN_INFO \"Concurrency concepts module loaded\\n\");\n    printk(KERN_INFO \"Learning about race conditions and synchronization\\n\");\n    \n    explain_execution_contexts();\n    explain_synchronization_need();\n    demonstrate_race_condition();\n    \n    return 0;\n}\n\nstatic void __exit concurrency_exit(void)\n{\n    printk(KERN_INFO \"Concurrency concepts module unloaded\\n\");\n    printk(KERN_INFO \"Remember: Shared data needs synchronization!\\n\");\n}\n\nmodule_init(concurrency_init);\nmodule_exit(concurrency_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Understanding concurrency and race conditions\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "concurrency",
      "race_conditions",
      "shared_data",
      "execution_contexts",
      "synchronization_need"
    ],
    "skills": [
      "concurrency_concepts",
      "race_condition_identification",
      "synchronization_awareness"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Concurrency concepts module loaded",
        "Learning about race conditions and synchronization",
        "=== Demonstrating Race Condition ===",
        "Expected final value: 2000",
        "RACE CONDITION DETECTED!",
        "=== Kernel Execution Contexts ===",
        "=== Why Synchronization is Critical ===",
        "Remember: Shared data needs synchronization!"
      ],
      "requirements": [
        "Use required function names: concurrency_init, concurrency_exit, unsafe_thread_function, demonstrate_race_condition, explain_execution_contexts, explain_synchronization_need",
        "Use required variable names: shared_counter, final_expected_value",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/kthread.h, linux/delay.h",
        "Code must contain: shared_counter++, kthread_run, msleep, IS_ERR"
      ]
    }
  },
  {
    "id": 40,
    "title": "Basic Mutex Usage for Synchronization",
    "difficulty": 6,
    "xp": 55,
    "phase": "kernel_core",
    "description": "Learn to use mutexes (mutual exclusion locks) to prevent race conditions. Understand how mutexes provide synchronized access to shared resources and fix the concurrency problems from the previous lesson.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\n// CONCEPT: Mutex (Mutual Exclusion)\n// Mutex = Only one thread can hold the lock at a time\n// Critical Section = Code that accesses shared data\n// \n// Pattern:\n// 1. mutex_lock(&my_mutex)    // Acquire lock\n// 2. /* access shared data */  // Critical section\n// 3. mutex_unlock(&my_mutex)  // Release lock\n//\n// WHY: Prevents race conditions by serializing access to shared data\n\n// Shared data protected by mutex\nstatic int protected_counter = 0;\nstatic DEFINE_MUTEX(counter_mutex);  // Declare and initialize mutex\n\n// TODO: Thread function with proper synchronization\nstatic int safe_thread_function(void *data)\n{\n    int thread_id = (long)data;\n    int i;\n    \n    printk(KERN_INFO \"Thread %d started (with mutex protection)\\n\", thread_id);\n    \n    // Each thread increments counter 1000 times\n    for (i = 0; i < 1000; i++) {\n        // SAFE: Use mutex to protect shared data\n        mutex_lock(&counter_mutex);     // Acquire lock\n        \n        // Critical section - only one thread can be here at a time\n        protected_counter++;\n        \n        mutex_unlock(&counter_mutex);   // Release lock\n        \n        // Small delay to show that synchronization works\n        if (i % 100 == 0) {\n            msleep(1);\n        }\n    }\n    \n    printk(KERN_INFO \"Thread %d finished (protected access)\\n\", thread_id);\n    return 0;\n}\n\n// TODO: Demonstrate proper synchronization with mutex\nstatic void demonstrate_mutex_protection(void)\n{\n    struct task_struct *thread1, *thread2;\n    \n    printk(KERN_INFO \"=== Demonstrating Mutex Protection ===\");\n    printk(KERN_INFO \"Starting 2 threads with mutex synchronization\\n\");\n    printk(KERN_INFO \"Expected final value: 2000\\n\");\n    \n    protected_counter = 0;\n    \n    // Create two threads that will safely access shared data\n    thread1 = kthread_run(safe_thread_function, (void *)1, \"safe_thread1\");\n    thread2 = kthread_run(safe_thread_function, (void *)2, \"safe_thread2\");\n    \n    if (IS_ERR(thread1) || IS_ERR(thread2)) {\n        printk(KERN_ERR \"Failed to create threads\\n\");\n        return;\n    }\n    \n    // Wait for threads to complete\n    msleep(3000);\n    \n    printk(KERN_INFO \"Threads completed\\n\");\n    printk(KERN_INFO \"Final counter value: %d\\n\", protected_counter);\n    printk(KERN_INFO \"Expected value: 2000\\n\");\n    \n    if (protected_counter == 2000) {\n        printk(KERN_INFO \"SUCCESS: Mutex prevented race condition!\\n\");\n    } else {\n        printk(KERN_WARNING \"Unexpected result: %d\\n\", protected_counter);\n    }\n}\n\n// TODO: Demonstrate mutex properties\nstatic void demonstrate_mutex_properties(void)\n{\n    printk(KERN_INFO \"=== Mutex Properties ===\");\n    \n    // Show mutex can be locked\n    printk(KERN_INFO \"Trying to acquire mutex...\\n\");\n    mutex_lock(&counter_mutex);\n    printk(KERN_INFO \"Mutex acquired successfully\\n\");\n    \n    // Show mutex is exclusive (only one holder)\n    printk(KERN_INFO \"Mutex is now locked - no other thread can acquire it\\n\");\n    \n    // Simulate some work\n    msleep(100);\n    \n    // Release the mutex\n    mutex_unlock(&counter_mutex);\n    printk(KERN_INFO \"Mutex released - other threads can now acquire it\\n\");\n}\n\n// TODO: Explain mutex best practices\nstatic void explain_mutex_best_practices(void)\n{\n    printk(KERN_INFO \"=== Mutex Best Practices ===\");\n    printk(KERN_INFO \"1. Always unlock what you lock\\n\");\n    printk(KERN_INFO \"2. Keep critical sections small\\n\");\n    printk(KERN_INFO \"3. Don't hold mutex too long\\n\");\n    printk(KERN_INFO \"4. Can sleep while holding mutex\\n\");\n    printk(KERN_INFO \"5. Use DEFINE_MUTEX() for static mutexes\\n\");\n    printk(KERN_INFO \"6. Use mutex_init() for dynamic mutexes\\n\");\n    \n    printk(KERN_INFO \"When NOT to use mutex:\\n\");\n    printk(KERN_INFO \"- In interrupt context (use spinlocks)\\n\");\n    printk(KERN_INFO \"- Very short critical sections (use spinlocks)\\n\");\n    printk(KERN_INFO \"- High-frequency operations (consider atomics)\\n\");\n}\n\nstatic int __init mutex_demo_init(void)\n{\n    printk(KERN_INFO \"Mutex demonstration module loaded\\n\");\n    printk(KERN_INFO \"Learning proper synchronization with mutexes\\n\");\n    \n    explain_mutex_best_practices();\n    demonstrate_mutex_properties();\n    demonstrate_mutex_protection();\n    \n    return 0;\n}\n\nstatic void __exit mutex_demo_exit(void)\n{\n    printk(KERN_INFO \"Mutex demonstration module unloaded\\n\");\n    printk(KERN_INFO \"Remember: mutex_lock() -> critical section -> mutex_unlock()\\n\");\n}\n\nmodule_init(mutex_demo_init);\nmodule_exit(mutex_demo_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Basic mutex usage for synchronization\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "mutex",
      "synchronization",
      "critical_section",
      "mutual_exclusion",
      "thread_safety"
    ],
    "skills": [
      "mutex_usage",
      "synchronization_programming",
      "thread_safe_code"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Mutex demonstration module loaded",
        "Learning proper synchronization with mutexes",
        "=== Demonstrating Mutex Protection ===",
        "SUCCESS: Mutex prevented race condition!",
        "=== Mutex Properties ===",
        "Mutex acquired successfully",
        "=== Mutex Best Practices ===",
        "Remember: mutex_lock() -> critical section -> mutex_unlock()"
      ],
      "requirements": [
        "Use required function names: mutex_demo_init, mutex_demo_exit, safe_thread_function, demonstrate_mutex_protection, demonstrate_mutex_properties, explain_mutex_best_practices",
        "Use required variable names: protected_counter, counter_mutex",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/mutex.h, linux/kthread.h, linux/delay.h",
        "Code must contain: DEFINE_MUTEX, mutex_lock, mutex_unlock, protected_counter++"
      ]
    }
  },
  {
    "id": 41,
    "title": "Advanced Synchronization Primitives",
    "difficulty": 10,
    "xp": 100,
    "phase": "kernel_core",
    "description": "Master advanced kernel synchronization including RCU, completion objects, atomic operations, and memory barriers. This teaches the sophisticated concurrency control mechanisms used in high-performance kernel subsystems at enterprise companies.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/rwlock.h>\n#include <linux/completion.h>\n#include <linux/atomic.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n\n// TODO: Define data structures for demonstration\nstruct shared_data {\n    struct rcu_head rcu;\n    atomic_t reference_count;\n    int value;\n    char name[32];\n    unsigned long timestamp;\n};\n\nstruct sync_stats {\n    atomic64_t rcu_reads;\n    atomic64_t rcu_updates; \n    atomic64_t completion_waits;\n    atomic64_t completion_signals;\n    atomic64_t atomic_operations;\n    atomic64_t barrier_calls;\n};\n\n// TODO: Global synchronization objects\nstatic struct shared_data __rcu *global_data = NULL;\nstatic DEFINE_MUTEX(update_mutex);\nstatic DEFINE_SPINLOCK(stats_lock);\nstatic DEFINE_RWLOCK(config_lock);\nstatic DECLARE_COMPLETION(init_complete);\nstatic DECLARE_COMPLETION(worker_complete);\n\n// TODO: Statistics and configuration\nstatic struct sync_stats stats;\nstatic atomic_t worker_count = ATOMIC_INIT(0);\nstatic atomic_t config_version = ATOMIC_INIT(1);\nstatic bool module_stopping = false;\n\n// TODO: Worker threads\nstatic struct task_struct *reader_thread = NULL;\nstatic struct task_struct *writer_thread = NULL;\nstatic struct task_struct *monitor_thread = NULL;\n\n// TODO: RCU callback for freeing old data\nstatic void free_shared_data_rcu(struct rcu_head *head)\n{\n    struct shared_data *data = container_of(head, struct shared_data, rcu);\n    \n    printk(KERN_INFO \"RCU callback: freeing data %p\\n\", data);\n    kfree(data);\n}\n\n// TODO: Implement RCU-protected read function\nstatic int read_shared_data(int *value, char *name, size_t name_size)\n{\n    struct shared_data *data;\n    int ret = 0;\n    \n    // TODO: Enter RCU read-side critical section\n    rcu_read_lock();\n    \n    // TODO: Get RCU-protected pointer\n    data = rcu_dereference(global_data);\n    if (data) {\n        // TODO: Read data under RCU protection\n        *value = data->value;\n        strncpy(name, data->name, name_size - 1);\n        name[name_size - 1] = '\\0';\n        \n        // TODO: Update statistics atomically\n        atomic64_inc(&stats.rcu_reads);\n        ret = 1;\n    }\n    \n    // TODO: Exit RCU read-side critical section\n    rcu_read_unlock();\n    \n    return ret;\n}\n\n// TODO: Implement RCU-protected update function\nstatic int update_shared_data(int new_value, const char *new_name)\n{\n    struct shared_data *new_data, *old_data;\n    \n    // TODO: Allocate new data structure\n    new_data = kmalloc(sizeof(*new_data), GFP_KERNEL);\n    if (!new_data) {\n        return -ENOMEM;\n    }\n    \n    // TODO: Initialize new data\n    atomic_set(&new_data->reference_count, 1);\n    new_data->value = new_value;\n    strncpy(new_data->name, new_name, sizeof(new_data->name) - 1);\n    new_data->name[sizeof(new_data->name) - 1] = '\\0';\n    new_data->timestamp = jiffies;\n    \n    // TODO: Update under mutex protection\n    mutex_lock(&update_mutex);\n    \n    // TODO: Get old data and update pointer\n    old_data = rcu_dereference_protected(global_data, lockdep_is_held(&update_mutex));\n    rcu_assign_pointer(global_data, new_data);\n    \n    // TODO: Memory barrier to ensure ordering\n    smp_wmb();\n    \n    // TODO: Update configuration version atomically\n    atomic_inc(&config_version);\n    \n    mutex_unlock(&update_mutex);\n    \n    // TODO: Wait for RCU grace period and free old data\n    if (old_data) {\n        call_rcu(&old_data->rcu, free_shared_data_rcu);\n    }\n    \n    // TODO: Update statistics\n    atomic64_inc(&stats.rcu_updates);\n    atomic64_inc(&stats.atomic_operations);\n    \n    printk(KERN_INFO \"Updated shared data: value=%d, name=%s\\n\", new_value, new_name);\n    return 0;\n}\n\n// TODO: Reader thread function\nstatic int reader_thread_fn(void *data)\n{\n    int value;\n    char name[32];\n    int read_count = 0;\n    \n    printk(KERN_INFO \"Reader thread started\\n\");\n    \n    // TODO: Signal completion of initialization\n    complete(&init_complete);\n    \n    while (!kthread_should_stop() && !module_stopping) {\n        // TODO: Read shared data using RCU\n        if (read_shared_data(&value, name, sizeof(name))) {\n            read_count++;\n            if (read_count % 100 == 0) {\n                printk(KERN_INFO \"Reader: read %d times, current value=%d, name=%s\\n\",\n                       read_count, value, name);\n            }\n        }\n        \n        // TODO: Small delay to avoid overwhelming the system\n        usleep_range(1000, 2000);\n        \n        // TODO: Check for completion signal\n        if (read_count >= 500) {\n            complete(&worker_complete);\n            read_count = 0;\n        }\n    }\n    \n    printk(KERN_INFO \"Reader thread exiting\\n\");\n    return 0;\n}\n\n// TODO: Writer thread function\nstatic int writer_thread_fn(void *data)\n{\n    int update_count = 0;\n    char name_buffer[32];\n    \n    printk(KERN_INFO \"Writer thread started\\n\");\n    \n    // TODO: Wait for initialization to complete\n    wait_for_completion(&init_complete);\n    \n    while (!kthread_should_stop() && !module_stopping) {\n        // TODO: Create new data for update\n        snprintf(name_buffer, sizeof(name_buffer), \"update_%d\", update_count);\n        \n        // TODO: Update shared data\n        if (update_shared_data(update_count * 10, name_buffer) == 0) {\n            update_count++;\n            \n            // TODO: Use memory barrier\n            smp_mb();\n            atomic64_inc(&stats.barrier_calls);\n        }\n        \n        // TODO: Longer delay between updates\n        msleep(100);\n        \n        // TODO: Check for worker completion\n        if (update_count % 5 == 0) {\n            if (wait_for_completion_timeout(&worker_complete, msecs_to_jiffies(1000))) {\n                atomic64_inc(&stats.completion_waits);\n                printk(KERN_INFO \"Writer: received completion signal\\n\");\n            }\n        }\n    }\n    \n    printk(KERN_INFO \"Writer thread exiting\\n\");\n    return 0;\n}\n\n// TODO: Monitor thread function\nstatic int monitor_thread_fn(void *data)\n{\n    unsigned long last_reads, last_updates;\n    \n    printk(KERN_INFO \"Monitor thread started\\n\");\n    \n    last_reads = atomic64_read(&stats.rcu_reads);\n    last_updates = atomic64_read(&stats.rcu_updates);\n    \n    while (!kthread_should_stop() && !module_stopping) {\n        msleep(5000); // Monitor every 5 seconds\n        \n        unsigned long current_reads = atomic64_read(&stats.rcu_reads);\n        unsigned long current_updates = atomic64_read(&stats.rcu_updates);\n        \n        printk(KERN_INFO \"Monitor: reads/sec=%lu, updates/sec=%lu, config_version=%d\\n\",\n               (current_reads - last_reads) / 5,\n               (current_updates - last_updates) / 5,\n               atomic_read(&config_version));\n        \n        last_reads = current_reads;\n        last_updates = current_updates;\n        \n        // TODO: Signal completion periodically\n        complete(&worker_complete);\n        atomic64_inc(&stats.completion_signals);\n    }\n    \n    printk(KERN_INFO \"Monitor thread exiting\\n\");\n    return 0;\n}\n\n// TODO: Proc interface for statistics\nstatic int sync_stats_show(struct seq_file *m, void *v)\n{\n    seq_printf(m, \"Advanced Synchronization Statistics\\n\");\n    seq_printf(m, \"===================================\\n\");\n    seq_printf(m, \"RCU reads: %llu\\n\", atomic64_read(&stats.rcu_reads));\n    seq_printf(m, \"RCU updates: %llu\\n\", atomic64_read(&stats.rcu_updates));\n    seq_printf(m, \"Completion waits: %llu\\n\", atomic64_read(&stats.completion_waits));\n    seq_printf(m, \"Completion signals: %llu\\n\", atomic64_read(&stats.completion_signals));\n    seq_printf(m, \"Atomic operations: %llu\\n\", atomic64_read(&stats.atomic_operations));\n    seq_printf(m, \"Memory barriers: %llu\\n\", atomic64_read(&stats.barrier_calls));\n    seq_printf(m, \"Worker count: %d\\n\", atomic_read(&worker_count));\n    seq_printf(m, \"Config version: %d\\n\", atomic_read(&config_version));\n    \n    return 0;\n}\n\nstatic int sync_stats_open(struct inode *inode, struct file *file)\n{\n    return single_open(file, sync_stats_show, NULL);\n}\n\nstatic const struct proc_ops sync_stats_ops = {\n    .proc_open = sync_stats_open,\n    .proc_read = seq_read,\n    .proc_lseek = seq_lseek,\n    .proc_release = single_release,\n};\n\nstatic int __init sync_module_init(void)\n{\n    int ret;\n    \n    printk(KERN_INFO \"Advanced synchronization module initializing...\\n\");\n    \n    // TODO: Initialize statistics\n    atomic64_set(&stats.rcu_reads, 0);\n    atomic64_set(&stats.rcu_updates, 0);\n    atomic64_set(&stats.completion_waits, 0);\n    atomic64_set(&stats.completion_signals, 0);\n    atomic64_set(&stats.atomic_operations, 0);\n    atomic64_set(&stats.barrier_calls, 0);\n    \n    // TODO: Create initial shared data\n    ret = update_shared_data(42, \"initial_data\");\n    if (ret) {\n        printk(KERN_ERR \"Failed to create initial data\\n\");\n        return ret;\n    }\n    \n    // TODO: Create proc entry\n    if (!proc_create(\"sync_stats\", 0444, NULL, &sync_stats_ops)) {\n        printk(KERN_ERR \"Failed to create proc entry\\n\");\n        return -ENOMEM;\n    }\n    \n    // TODO: Start worker threads\n    reader_thread = kthread_run(reader_thread_fn, NULL, \"sync_reader\");\n    if (IS_ERR(reader_thread)) {\n        proc_remove(\"sync_stats\");\n        return PTR_ERR(reader_thread);\n    }\n    \n    writer_thread = kthread_run(writer_thread_fn, NULL, \"sync_writer\");\n    if (IS_ERR(writer_thread)) {\n        kthread_stop(reader_thread);\n        proc_remove(\"sync_stats\");\n        return PTR_ERR(writer_thread);\n    }\n    \n    monitor_thread = kthread_run(monitor_thread_fn, NULL, \"sync_monitor\");\n    if (IS_ERR(monitor_thread)) {\n        kthread_stop(writer_thread);\n        kthread_stop(reader_thread);\n        proc_remove(\"sync_stats\");\n        return PTR_ERR(monitor_thread);\n    }\n    \n    atomic_set(&worker_count, 3);\n    \n    printk(KERN_INFO \"Advanced synchronization module loaded successfully\\n\");\n    printk(KERN_INFO \"Worker threads: reader, writer, monitor\\n\");\n    printk(KERN_INFO \"Statistics available at /proc/sync_stats\\n\");\n    \n    return 0;\n}\n\nstatic void __exit sync_module_exit(void)\n{\n    struct shared_data *data;\n    \n    printk(KERN_INFO \"Stopping advanced synchronization module...\\n\");\n    \n    // TODO: Signal threads to stop\n    module_stopping = true;\n    smp_wmb(); // Ensure visibility\n    \n    // TODO: Stop worker threads\n    if (monitor_thread) {\n        kthread_stop(monitor_thread);\n    }\n    if (writer_thread) {\n        kthread_stop(writer_thread);\n    }\n    if (reader_thread) {\n        kthread_stop(reader_thread);\n    }\n    \n    // TODO: Remove proc entry\n    proc_remove(\"sync_stats\");\n    \n    // TODO: Clean up shared data\n    mutex_lock(&update_mutex);\n    data = rcu_dereference_protected(global_data, lockdep_is_held(&update_mutex));\n    RCU_INIT_POINTER(global_data, NULL);\n    mutex_unlock(&update_mutex);\n    \n    // TODO: Wait for grace period and free\n    if (data) {\n        synchronize_rcu();\n        kfree(data);\n    }\n    \n    printk(KERN_INFO \"Advanced synchronization module unloaded\\n\");\n    printk(KERN_INFO \"Final stats - RCU reads: %llu, updates: %llu\\n\",\n           atomic64_read(&stats.rcu_reads), atomic64_read(&stats.rcu_updates));\n}\n\nmodule_init(sync_module_init);\nmodule_exit(sync_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Advanced synchronization primitives demonstration\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "RCU",
      "completion",
      "atomic_operations",
      "memory_barriers",
      "lockless_programming",
      "read_write_locks"
    ],
    "skills": [
      "advanced_synchronization",
      "lockless_design",
      "memory_ordering",
      "high_performance_concurrency"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Advanced synchronization module loaded successfully",
        "Worker threads: reader, writer, monitor",
        "Statistics available at /proc/sync_stats",
        "Advanced synchronization module unloaded",
        "Final stats - RCU reads:"
      ],
      "requirements": [
        "Use required function names: sync_module_init, sync_module_exit, read_shared_data, update_shared_data, free_shared_data_rcu, reader_thread_fn, writer_thread_fn, monitor_thread_fn, sync_stats_show",
        "Use required variable names: global_data, update_mutex, stats_lock, worker_count, config_version",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/atomic.h, linux/rcupdate.h, linux/completion.h",
        "Code must contain: rcu_read_lock, rcu_read_unlock, rcu_dereference, rcu_assign_pointer, call_rcu, synchronize_rcu, atomic64_inc, atomic64_read, complete, wait_for_completion, smp_wmb, smp_mb, container_of"
      ]
    }
  },
  {
    "id": 42,
    "title": "IOCTL Interface Design",
    "difficulty": 9,
    "xp": 90,
    "phase": "kernel_core",
    "description": "Implement a kernel module with a proper IOCTL interface for userspace communication. This teaches advanced userspace-kernel communication patterns used in device drivers and system interfaces at enterprise companies like NVIDIA and Intel.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ioctl.h>\n\n#define DEVICE_NAME \"demo_ioctl\"\n#define CLASS_NAME \"demo\"\n\n// TODO: Define IOCTL magic number and commands\n#define DEMO_IOC_MAGIC 'D'\n\n// TODO: Define IOCTL command structures\nstruct demo_config {\n    int mode;\n    int threshold;\n    char name[32];\n    bool enabled;\n};\n\nstruct demo_stats {\n    unsigned long operation_count;\n    unsigned long error_count;\n    unsigned long last_operation_jiffies;\n    int current_mode;\n};\n\nstruct demo_buffer {\n    char *data;\n    size_t size;\n    size_t used;\n};\n\n// TODO: Define IOCTL commands using _IO macros\n#define DEMO_IOC_GET_CONFIG    _IOR(DEMO_IOC_MAGIC, 1, struct demo_config)\n#define DEMO_IOC_SET_CONFIG    _IOW(DEMO_IOC_MAGIC, 2, struct demo_config)\n#define DEMO_IOC_GET_STATS     _IOR(DEMO_IOC_MAGIC, 3, struct demo_stats)\n#define DEMO_IOC_RESET_STATS   _IO(DEMO_IOC_MAGIC, 4)\n#define DEMO_IOC_READ_BUFFER   _IOWR(DEMO_IOC_MAGIC, 5, struct demo_buffer)\n#define DEMO_IOC_WRITE_BUFFER  _IOW(DEMO_IOC_MAGIC, 6, struct demo_buffer)\n#define DEMO_IOC_MAXNR 6\n\n// TODO: Module state variables\nstatic int major_number;\nstatic struct class *demo_class = NULL;\nstatic struct device *demo_device = NULL;\nstatic DEFINE_MUTEX(device_mutex);\n\n// TODO: Device state\nstatic struct demo_config device_config = {\n    .mode = 0,\n    .threshold = 100,\n    .name = \"default\",\n    .enabled = true\n};\n\nstatic struct demo_stats device_stats = {0};\nstatic char *device_buffer = NULL;\nstatic size_t buffer_size = 4096;\nstatic size_t buffer_used = 0;\n\n// TODO: Implement IOCTL handler function\nstatic long demo_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n    int ret = 0;\n    struct demo_config config;\n    struct demo_stats stats;\n    struct demo_buffer buffer_info;\n    void __user *argp = (void __user *)arg;\n    \n    // TODO: Validate IOCTL command\n    if (_IOC_TYPE(cmd) != DEMO_IOC_MAGIC) {\n        return -ENOTTY;\n    }\n    \n    if (_IOC_NR(cmd) > DEMO_IOC_MAXNR) {\n        return -ENOTTY;\n    }\n    \n    // TODO: Check access permissions\n    if (_IOC_DIR(cmd) & _IOC_READ) {\n        ret = !access_ok(argp, _IOC_SIZE(cmd));\n        if (ret) return -EFAULT;\n    }\n    \n    if (_IOC_DIR(cmd) & _IOC_WRITE) {\n        ret = !access_ok(argp, _IOC_SIZE(cmd));\n        if (ret) return -EFAULT;\n    }\n    \n    mutex_lock(&device_mutex);\n    \n    switch (cmd) {\n    case DEMO_IOC_GET_CONFIG:\n        // TODO: Copy current config to userspace\n        ret = copy_to_user(argp, &device_config, sizeof(device_config));\n        if (ret) {\n            ret = -EFAULT;\n            break;\n        }\n        device_stats.operation_count++;\n        printk(KERN_INFO \"Config read by userspace\\n\");\n        break;\n        \n    case DEMO_IOC_SET_CONFIG:\n        // TODO: Copy new config from userspace\n        ret = copy_from_user(&config, argp, sizeof(config));\n        if (ret) {\n            ret = -EFAULT;\n            break;\n        }\n        \n        // TODO: Validate configuration\n        if (config.mode < 0 || config.mode > 3) {\n            ret = -EINVAL;\n            device_stats.error_count++;\n            break;\n        }\n        \n        if (config.threshold < 0 || config.threshold > 1000) {\n            ret = -EINVAL;\n            device_stats.error_count++;\n            break;\n        }\n        \n        // TODO: Apply new configuration\n        device_config = config;\n        device_stats.operation_count++;\n        device_stats.last_operation_jiffies = jiffies;\n        printk(KERN_INFO \"Config updated: mode=%d, threshold=%d, name=%s\\n\",\n               config.mode, config.threshold, config.name);\n        break;\n        \n    case DEMO_IOC_GET_STATS:\n        // TODO: Prepare current statistics\n        stats = device_stats;\n        stats.current_mode = device_config.mode;\n        \n        ret = copy_to_user(argp, &stats, sizeof(stats));\n        if (ret) {\n            ret = -EFAULT;\n            break;\n        }\n        device_stats.operation_count++;\n        printk(KERN_INFO \"Statistics read by userspace\\n\");\n        break;\n        \n    case DEMO_IOC_RESET_STATS:\n        // TODO: Reset statistics\n        device_stats.operation_count = 0;\n        device_stats.error_count = 0;\n        device_stats.last_operation_jiffies = jiffies;\n        printk(KERN_INFO \"Statistics reset\\n\");\n        break;\n        \n    case DEMO_IOC_READ_BUFFER:\n        // TODO: Read data from device buffer\n        ret = copy_from_user(&buffer_info, argp, sizeof(buffer_info));\n        if (ret) {\n            ret = -EFAULT;\n            break;\n        }\n        \n        if (!buffer_info.data || buffer_info.size == 0) {\n            ret = -EINVAL;\n            break;\n        }\n        \n        // TODO: Copy available data to userspace\n        buffer_info.used = min(buffer_used, buffer_info.size);\n        if (buffer_info.used > 0 && device_buffer) {\n            ret = copy_to_user(buffer_info.data, device_buffer, buffer_info.used);\n            if (ret) {\n                ret = -EFAULT;\n                break;\n            }\n        }\n        \n        // TODO: Return updated buffer info\n        ret = copy_to_user(argp, &buffer_info, sizeof(buffer_info));\n        if (ret) {\n            ret = -EFAULT;\n            break;\n        }\n        \n        device_stats.operation_count++;\n        printk(KERN_INFO \"Buffer read: %zu bytes\\n\", buffer_info.used);\n        break;\n        \n    case DEMO_IOC_WRITE_BUFFER:\n        // TODO: Write data to device buffer\n        ret = copy_from_user(&buffer_info, argp, sizeof(buffer_info));\n        if (ret) {\n            ret = -EFAULT;\n            break;\n        }\n        \n        if (!buffer_info.data || buffer_info.size == 0) {\n            ret = -EINVAL;\n            break;\n        }\n        \n        if (buffer_info.size > buffer_size) {\n            ret = -ENOSPC;\n            device_stats.error_count++;\n            break;\n        }\n        \n        if (!device_buffer) {\n            ret = -ENOMEM;\n            device_stats.error_count++;\n            break;\n        }\n        \n        // TODO: Copy data from userspace to device buffer\n        ret = copy_from_user(device_buffer, buffer_info.data, buffer_info.size);\n        if (ret) {\n            ret = -EFAULT;\n            break;\n        }\n        \n        buffer_used = buffer_info.size;\n        device_stats.operation_count++;\n        device_stats.last_operation_jiffies = jiffies;\n        printk(KERN_INFO \"Buffer written: %zu bytes\\n\", buffer_info.size);\n        break;\n        \n    default:\n        ret = -ENOTTY;\n        device_stats.error_count++;\n        break;\n    }\n    \n    mutex_unlock(&device_mutex);\n    return ret;\n}\n\n// TODO: Implement basic file operations\nstatic int demo_open(struct inode *inode, struct file *file)\n{\n    printk(KERN_INFO \"Device opened\\n\");\n    return 0;\n}\n\nstatic int demo_release(struct inode *inode, struct file *file)\n{\n    printk(KERN_INFO \"Device closed\\n\");\n    return 0;\n}\n\n// TODO: Define file operations structure\nstatic const struct file_operations demo_fops = {\n    .owner = THIS_MODULE,\n    .open = demo_open,\n    .release = demo_release,\n    .unlocked_ioctl = demo_ioctl,\n    .compat_ioctl = demo_ioctl,\n};\n\nstatic int __init ioctl_module_init(void)\n{\n    int ret;\n    \n    printk(KERN_INFO \"IOCTL demo module initializing...\\n\");\n    \n    // TODO: Allocate device buffer\n    device_buffer = kmalloc(buffer_size, GFP_KERNEL);\n    if (!device_buffer) {\n        printk(KERN_ERR \"Failed to allocate device buffer\\n\");\n        return -ENOMEM;\n    }\n    \n    // TODO: Register character device\n    major_number = register_chrdev(0, DEVICE_NAME, &demo_fops);\n    if (major_number < 0) {\n        printk(KERN_ERR \"Failed to register character device\\n\");\n        kfree(device_buffer);\n        return major_number;\n    }\n    \n    // TODO: Create device class\n    demo_class = class_create(THIS_MODULE, CLASS_NAME);\n    if (IS_ERR(demo_class)) {\n        unregister_chrdev(major_number, DEVICE_NAME);\n        kfree(device_buffer);\n        return PTR_ERR(demo_class);\n    }\n    \n    // TODO: Create device\n    demo_device = device_create(demo_class, NULL, MKDEV(major_number, 0), NULL, DEVICE_NAME);\n    if (IS_ERR(demo_device)) {\n        class_destroy(demo_class);\n        unregister_chrdev(major_number, DEVICE_NAME);\n        kfree(device_buffer);\n        return PTR_ERR(demo_device);\n    }\n    \n    device_stats.last_operation_jiffies = jiffies;\n    \n    printk(KERN_INFO \"IOCTL demo module loaded successfully\\n\");\n    printk(KERN_INFO \"Device registered: /dev/%s (major %d)\\n\", DEVICE_NAME, major_number);\n    printk(KERN_INFO \"IOCTL commands: GET_CONFIG=0x%x, SET_CONFIG=0x%x\\n\", \n           DEMO_IOC_GET_CONFIG, DEMO_IOC_SET_CONFIG);\n    \n    return 0;\n}\n\nstatic void __exit ioctl_module_exit(void)\n{\n    // TODO: Clean up device and class\n    device_destroy(demo_class, MKDEV(major_number, 0));\n    class_destroy(demo_class);\n    unregister_chrdev(major_number, DEVICE_NAME);\n    \n    // TODO: Free device buffer\n    kfree(device_buffer);\n    \n    printk(KERN_INFO \"IOCTL demo module unloaded\\n\");\n    printk(KERN_INFO \"Final stats - Operations: %lu, Errors: %lu\\n\",\n           device_stats.operation_count, device_stats.error_count);\n}\n\nmodule_init(ioctl_module_init);\nmodule_exit(ioctl_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"IOCTL interface demonstration\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "ioctl",
      "_IO_macros",
      "copy_from_user",
      "copy_to_user",
      "file_operations",
      "device_interface"
    ],
    "skills": [
      "ioctl_design",
      "userspace_interface",
      "data_marshaling",
      "device_communication"
    ],
    "inputOutput": {
      "expectedOutput": [
        "IOCTL demo module loaded successfully",
        "Device registered: /dev/demo_ioctl",
        "IOCTL commands: GET_CONFIG=",
        "IOCTL demo module unloaded",
        "Final stats - Operations:"
      ],
      "requirements": [
        "Use required function names: ioctl_module_init, ioctl_module_exit, demo_ioctl, demo_open, demo_release",
        "Use required variable names: major_number, demo_class, demo_device, device_mutex",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/fs.h, linux/device.h, linux/uaccess.h, linux/ioctl.h",
        "Code must contain: _IO, _IOR, _IOW, _IOWR, _IOC_TYPE, _IOC_NR, _IOC_DIR, _IOC_SIZE, copy_from_user, copy_to_user, access_ok, register_chrdev, class_create, device_create"
      ]
    }
  },
  {
    "id": 43,
    "title": "Basic Character Device Registration",
    "difficulty": 6,
    "xp": 60,
    "phase": "kernel_core",
    "description": "Create a basic character device driver that registers a device, allocates a major/minor number, and implements basic file operations. This is fundamental for all Linux device driver development at enterprise companies.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\n#define DEVICE_NAME \"mychardev\"\n#define CLASS_NAME \"mychar\"\n#define MINOR_COUNT 1\n\n// TODO: Define device state structure\nstruct char_device_data {\n    struct cdev cdev;\n    struct device *device;\n    struct class *class;\n    dev_t dev_num;\n    int major;\n    int minor;\n    char *buffer;\n    size_t buffer_size;\n    struct mutex device_mutex;\n};\n\nstatic struct char_device_data char_dev;\n\n// TODO: Implement device open function\nstatic int device_open(struct inode *inode, struct file *file)\n{\n    // TODO: Get device data from inode\n    // TODO: Store device data in file private_data\n    // TODO: Initialize any per-open state\n    // TODO: Log device open\n    \n    printk(KERN_INFO \"Character device opened\\n\");\n    return 0;\n}\n\n// TODO: Implement device release function\nstatic int device_release(struct inode *inode, struct file *file)\n{\n    // TODO: Clean up any per-open state\n    // TODO: Log device close\n    \n    printk(KERN_INFO \"Character device closed\\n\");\n    return 0;\n}\n\n// TODO: Implement device read function\nstatic ssize_t device_read(struct file *file, char __user *user_buffer,\n                          size_t count, loff_t *offset)\n{\n    struct char_device_data *dev_data;\n    ssize_t bytes_read = 0;\n    \n    // TODO: Get device data from file\n    dev_data = (struct char_device_data *)file->private_data;\n    if (!dev_data || !dev_data->buffer) {\n        return -EINVAL;\n    }\n    \n    // TODO: Use mutex for thread safety\n    if (mutex_lock_interruptible(&dev_data->device_mutex)) {\n        return -ERESTARTSYS;\n    }\n    \n    // TODO: Check offset bounds\n    if (*offset >= dev_data->buffer_size) {\n        mutex_unlock(&dev_data->device_mutex);\n        return 0; // EOF\n    }\n    \n    // TODO: Calculate bytes to read\n    bytes_read = min(count, dev_data->buffer_size - *offset);\n    \n    // TODO: Copy data to user space\n    if (copy_to_user(user_buffer, dev_data->buffer + *offset, bytes_read)) {\n        mutex_unlock(&dev_data->device_mutex);\n        return -EFAULT;\n    }\n    \n    // TODO: Update offset\n    *offset += bytes_read;\n    \n    mutex_unlock(&dev_data->device_mutex);\n    \n    printk(KERN_INFO \"Device read: %zu bytes\\n\", bytes_read);\n    return bytes_read;\n}\n\n// TODO: Implement device write function\nstatic ssize_t device_write(struct file *file, const char __user *user_buffer,\n                           size_t count, loff_t *offset)\n{\n    struct char_device_data *dev_data;\n    ssize_t bytes_written = 0;\n    \n    // TODO: Get device data from file\n    dev_data = (struct char_device_data *)file->private_data;\n    if (!dev_data || !dev_data->buffer) {\n        return -EINVAL;\n    }\n    \n    // TODO: Use mutex for thread safety\n    if (mutex_lock_interruptible(&dev_data->device_mutex)) {\n        return -ERESTARTSYS;\n    }\n    \n    // TODO: Check offset bounds\n    if (*offset >= dev_data->buffer_size) {\n        mutex_unlock(&dev_data->device_mutex);\n        return -ENOSPC;\n    }\n    \n    // TODO: Calculate bytes to write\n    bytes_written = min(count, dev_data->buffer_size - *offset);\n    \n    // TODO: Copy data from user space\n    if (copy_from_user(dev_data->buffer + *offset, user_buffer, bytes_written)) {\n        mutex_unlock(&dev_data->device_mutex);\n        return -EFAULT;\n    }\n    \n    // TODO: Update offset\n    *offset += bytes_written;\n    \n    mutex_unlock(&dev_data->device_mutex);\n    \n    printk(KERN_INFO \"Device write: %zu bytes\\n\", bytes_written);\n    return bytes_written;\n}\n\n// TODO: Define file operations structure\nstatic const struct file_operations char_dev_fops = {\n    .owner = THIS_MODULE,\n    .open = device_open,\n    .release = device_release,\n    .read = device_read,\n    .write = device_write,\n};\n\nstatic int __init char_dev_init(void)\n{\n    int ret;\n    \n    printk(KERN_INFO \"Character device driver initializing...\\n\");\n    \n    // TODO: Initialize mutex\n    mutex_init(&char_dev.device_mutex);\n    \n    // TODO: Allocate device buffer\n    char_dev.buffer_size = 1024;\n    char_dev.buffer = kmalloc(char_dev.buffer_size, GFP_KERNEL);\n    if (!char_dev.buffer) {\n        printk(KERN_ERR \"Failed to allocate device buffer\\n\");\n        return -ENOMEM;\n    }\n    \n    // TODO: Initialize buffer with default data\n    strcpy(char_dev.buffer, \"Hello from character device!\\n\");\n    \n    // TODO: Allocate device number dynamically\n    ret = alloc_chrdev_region(&char_dev.dev_num, 0, MINOR_COUNT, DEVICE_NAME);\n    if (ret < 0) {\n        printk(KERN_ERR \"Failed to allocate device number\\n\");\n        kfree(char_dev.buffer);\n        return ret;\n    }\n    \n    char_dev.major = MAJOR(char_dev.dev_num);\n    char_dev.minor = MINOR(char_dev.dev_num);\n    \n    // TODO: Initialize character device\n    cdev_init(&char_dev.cdev, &char_dev_fops);\n    char_dev.cdev.owner = THIS_MODULE;\n    \n    // TODO: Add character device to system\n    ret = cdev_add(&char_dev.cdev, char_dev.dev_num, MINOR_COUNT);\n    if (ret < 0) {\n        printk(KERN_ERR \"Failed to add character device\\n\");\n        unregister_chrdev_region(char_dev.dev_num, MINOR_COUNT);\n        kfree(char_dev.buffer);\n        return ret;\n    }\n    \n    // TODO: Create device class\n    char_dev.class = class_create(THIS_MODULE, CLASS_NAME);\n    if (IS_ERR(char_dev.class)) {\n        printk(KERN_ERR \"Failed to create device class\\n\");\n        cdev_del(&char_dev.cdev);\n        unregister_chrdev_region(char_dev.dev_num, MINOR_COUNT);\n        kfree(char_dev.buffer);\n        return PTR_ERR(char_dev.class);\n    }\n    \n    // TODO: Create device file\n    char_dev.device = device_create(char_dev.class, NULL, char_dev.dev_num, \n                                   NULL, DEVICE_NAME);\n    if (IS_ERR(char_dev.device)) {\n        printk(KERN_ERR \"Failed to create device\\n\");\n        class_destroy(char_dev.class);\n        cdev_del(&char_dev.cdev);\n        unregister_chrdev_region(char_dev.dev_num, MINOR_COUNT);\n        kfree(char_dev.buffer);\n        return PTR_ERR(char_dev.device);\n    }\n    \n    printk(KERN_INFO \"Character device driver loaded successfully\\n\");\n    printk(KERN_INFO \"Device registered: /dev/%s (major %d, minor %d)\\n\",\n           DEVICE_NAME, char_dev.major, char_dev.minor);\n    \n    return 0;\n}\n\nstatic void __exit char_dev_exit(void)\n{\n    // TODO: Clean up in reverse order\n    device_destroy(char_dev.class, char_dev.dev_num);\n    class_destroy(char_dev.class);\n    cdev_del(&char_dev.cdev);\n    unregister_chrdev_region(char_dev.dev_num, MINOR_COUNT);\n    kfree(char_dev.buffer);\n    \n    printk(KERN_INFO \"Character device driver unloaded\\n\");\n}\n\nmodule_init(char_dev_init);\nmodule_exit(char_dev_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Basic character device driver\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "character_device",
      "major_minor",
      "device_registration",
      "file_operations",
      "cdev"
    ],
    "skills": [
      "device_driver_basics",
      "device_registration",
      "kernel_device_model",
      "file_operations"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Character device driver loaded successfully",
        "Device registered: /dev/mychardev",
        "Character device driver unloaded"
      ],
      "requirements": [
        "Use required function names: char_dev_init, char_dev_exit, device_open, device_release, device_read, device_write",
        "Use required variable names: char_dev, char_dev_fops",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/fs.h, linux/device.h, linux/cdev.h, linux/uaccess.h",
        "Code must contain: alloc_chrdev_region, cdev_init, cdev_add, class_create, device_create, copy_to_user, copy_from_user"
      ]
    }
  },
  {
    "id": 44,
    "title": "Understanding Hardware Interrupts",
    "difficulty": 6,
    "xp": 55,
    "phase": "kernel_core",
    "description": "Learn what hardware interrupts are and how they work in the kernel. Understand the difference between process context and interrupt context, and why interrupt handlers have special requirements.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/timer.h>\n#include <linux/jiffies.h>\n#include <linux/interrupt.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n\n// CONCEPT: Hardware Interrupts\n// Interrupt = Asynchronous signal from hardware to CPU\n// Examples: Keyboard press, mouse movement, network packet, disk I/O complete\n// \n// Process Context vs Interrupt Context:\n// - Process Context: Normal code execution (syscalls, kernel threads)\n// - Interrupt Context: Handling hardware events (interrupt handlers)\n//\n// WHY: Hardware events need immediate attention, can't wait for normal scheduling\n\n// Timer to simulate hardware interrupts\nstatic struct timer_list interrupt_simulator;\nstatic unsigned long interrupt_count = 0;\nstatic unsigned long last_interrupt_time = 0;\n\n// TODO: Simulate an interrupt handler\nstatic void simulated_interrupt_handler(struct timer_list *timer)\n{\n    unsigned long current_time = jiffies;\n    unsigned long time_diff = current_time - last_interrupt_time;\n    \n    // This code runs in INTERRUPT CONTEXT\n    interrupt_count++;\n    last_interrupt_time = current_time;\n    \n    printk(KERN_INFO \"INTERRUPT #%lu: Hardware event occurred!\\n\", interrupt_count);\n    printk(KERN_INFO \"  Time since last interrupt: %lu jiffies\\n\", time_diff);\n    printk(KERN_INFO \"  Running in INTERRUPT CONTEXT\\n\");\n    \n    // Demonstrate interrupt context properties\n    printk(KERN_INFO \"  - Cannot sleep (no msleep allowed)\\n\");\n    printk(KERN_INFO \"  - Cannot use mutex (would sleep)\\n\");\n    printk(KERN_INFO \"  - Must be fast and atomic\\n\");\n    printk(KERN_INFO \"  - Can use spinlocks\\n\");\n    \n    // Schedule next \"interrupt\" in 2 seconds\n    mod_timer(&interrupt_simulator, jiffies + msecs_to_jiffies(2000));\n}\n\n// TODO: Demonstrate process context\nstatic void demonstrate_process_context(void)\n{\n    printk(KERN_INFO \"=== PROCESS CONTEXT DEMONSTRATION ===\");\n    printk(KERN_INFO \"This code runs in PROCESS CONTEXT\\n\");\n    \n    // In process context, we CAN:\n    printk(KERN_INFO \"Process context capabilities:\\n\");\n    printk(KERN_INFO \"  - Can sleep (msleep allowed)\\n\");\n    printk(KERN_INFO \"  - Can use mutexes\\n\");\n    printk(KERN_INFO \"  - Can allocate memory with GFP_KERNEL\\n\");\n    printk(KERN_INFO \"  - Can access user space\\n\");\n    \n    // Demonstrate sleeping in process context\n    printk(KERN_INFO \"Sleeping for 100ms in process context...\\n\");\n    msleep(100);\n    printk(KERN_INFO \"Woke up! This proves we're in process context\\n\");\n}\n\n// TODO: Demonstrate interrupt context restrictions\nstatic void demonstrate_interrupt_context_restrictions(void)\n{\n    printk(KERN_INFO \"=== INTERRUPT CONTEXT RESTRICTIONS ===\");\n    printk(KERN_INFO \"Interrupt handlers CANNOT:\\n\");\n    printk(KERN_INFO \"  - Sleep (no msleep, no mutex_lock)\\n\");\n    printk(KERN_INFO \"  - Access user space\\n\");\n    printk(KERN_INFO \"  - Use GFP_KERNEL (must use GFP_ATOMIC)\\n\");\n    printk(KERN_INFO \"  - Take too long (impacts system responsiveness)\\n\");\n    \n    printk(KERN_INFO \"Interrupt handlers CAN:\\n\");\n    printk(KERN_INFO \"  - Use spinlocks\\n\");\n    printk(KERN_INFO \"  - Access kernel data structures\\n\");\n    printk(KERN_INFO \"  - Schedule work for later (workqueues)\\n\");\n    printk(KERN_INFO \"  - Use atomic operations\\n\");\n}\n\n// TODO: Explain why interrupts are important\nstatic void explain_interrupt_importance(void)\n{\n    printk(KERN_INFO \"=== WHY INTERRUPTS ARE IMPORTANT ===\");\n    printk(KERN_INFO \"Hardware events need immediate attention:\\n\");\n    printk(KERN_INFO \"  - Network packet arrived (must be processed quickly)\\n\");\n    printk(KERN_INFO \"  - Disk I/O completed (data is ready)\\n\");\n    printk(KERN_INFO \"  - Timer expired (time-critical operations)\\n\");\n    printk(KERN_INFO \"  - Keyboard/mouse input (user interaction)\\n\");\n    \n    printk(KERN_INFO \"Without interrupts:\\n\");\n    printk(KERN_INFO \"  - CPU would have to constantly poll hardware\\n\");\n    printk(KERN_INFO \"  - Waste CPU cycles\\n\");\n    printk(KERN_INFO \"  - Poor responsiveness\\n\");\n    printk(KERN_INFO \"  - Missed events\\n\");\n}\n\n// TODO: Explain interrupt handling strategy\nstatic void explain_interrupt_handling_strategy(void)\n{\n    printk(KERN_INFO \"=== INTERRUPT HANDLING STRATEGY ===\");\n    printk(KERN_INFO \"Good interrupt handler design:\\n\");\n    printk(KERN_INFO \"  1. Acknowledge the interrupt\\n\");\n    printk(KERN_INFO \"  2. Read minimal data from hardware\\n\");\n    printk(KERN_INFO \"  3. Schedule work for later if needed\\n\");\n    printk(KERN_INFO \"  4. Return quickly\\n\");\n    \n    printk(KERN_INFO \"Top-half vs Bottom-half (next lesson):\\n\");\n    printk(KERN_INFO \"  - Top-half: Interrupt handler (fast, atomic)\\n\");\n    printk(KERN_INFO \"  - Bottom-half: Deferred work (can sleep)\\n\");\n}\n\nstatic int __init interrupt_concepts_init(void)\n{\n    printk(KERN_INFO \"Interrupt concepts module loaded\\n\");\n    printk(KERN_INFO \"Learning about hardware interrupts and contexts\\n\");\n    \n    // This runs in process context (module initialization)\n    demonstrate_process_context();\n    demonstrate_interrupt_context_restrictions();\n    explain_interrupt_importance();\n    explain_interrupt_handling_strategy();\n    \n    // Set up timer to simulate hardware interrupts\n    timer_setup(&interrupt_simulator, simulated_interrupt_handler, 0);\n    \n    printk(KERN_INFO \"Starting interrupt simulation...\\n\");\n    mod_timer(&interrupt_simulator, jiffies + msecs_to_jiffies(1000));\n    \n    return 0;\n}\n\nstatic void __exit interrupt_concepts_exit(void)\n{\n    printk(KERN_INFO \"Stopping interrupt simulation...\\n\");\n    \n    // Stop the timer (prevent further \"interrupts\")\n    del_timer_sync(&interrupt_simulator);\n    \n    printk(KERN_INFO \"Interrupt concepts module unloaded\\n\");\n    printk(KERN_INFO \"Total simulated interrupts: %lu\\n\", interrupt_count);\n    printk(KERN_INFO \"Remember: Interrupt context is special!\\n\");\n}\n\nmodule_init(interrupt_concepts_init);\nmodule_exit(interrupt_concepts_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Understanding hardware interrupts and execution contexts\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "interrupts",
      "hardware_events",
      "interrupt_context",
      "process_context",
      "asynchronous_events"
    ],
    "skills": [
      "interrupt_concepts",
      "context_awareness",
      "hardware_understanding"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Interrupt concepts module loaded",
        "Learning about hardware interrupts and contexts",
        "=== PROCESS CONTEXT DEMONSTRATION ===",
        "This code runs in PROCESS CONTEXT",
        "=== INTERRUPT CONTEXT RESTRICTIONS ===",
        "=== WHY INTERRUPTS ARE IMPORTANT ===",
        "=== INTERRUPT HANDLING STRATEGY ===",
        "Starting interrupt simulation...",
        "INTERRUPT #1: Hardware event occurred!",
        "Running in INTERRUPT CONTEXT",
        "Total simulated interrupts:",
        "Remember: Interrupt context is special!"
      ],
      "requirements": [
        "Use required function names: interrupt_concepts_init, interrupt_concepts_exit, simulated_interrupt_handler, demonstrate_process_context, demonstrate_interrupt_context_restrictions, explain_interrupt_importance, explain_interrupt_handling_strategy",
        "Use required variable names: interrupt_simulator, interrupt_count, last_interrupt_time",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/timer.h, linux/jiffies.h, linux/interrupt.h",
        "Code must contain: timer_setup, mod_timer, del_timer_sync, jiffies, msleep"
      ]
    }
  },
  {
    "id": 45,
    "title": "Atomic Context Programming",
    "difficulty": 7,
    "xp": 65,
    "phase": "kernel_core",
    "description": "Learn how to write code that works correctly in atomic context (interrupt handlers). Understand the restrictions, proper memory allocation flags, and safe programming practices for interrupt-safe code.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/timer.h>\n#include <linux/jiffies.h>\n#include <linux/spinlock.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n\n// CONCEPT: Atomic Context Programming\n// Atomic Context = Code that cannot sleep or be interrupted\n// Examples: Interrupt handlers, spinlock-protected code, some kernel timers\n// \n// Rules for Atomic Context:\n// 1. Cannot sleep (no msleep, no mutex_lock)\n// 2. Use GFP_ATOMIC for memory allocation\n// 3. Use spinlocks, not mutexes\n// 4. Keep code fast and simple\n//\n// WHY: Sleeping in atomic context can cause deadlocks and system crashes\n\n// Data structures for demonstration\nstruct atomic_data {\n    atomic_t counter;\n    spinlock_t lock;\n    char *buffer;\n    size_t buffer_size;\n    unsigned long last_update;\n};\n\nstatic struct atomic_data demo_data;\nstatic struct timer_list atomic_timer;\nstatic unsigned long atomic_context_calls = 0;\n\n// TODO: Demonstrate proper atomic context programming\nstatic void atomic_context_handler(struct timer_list *timer)\n{\n    unsigned long flags;\n    char *temp_buffer;\n    \n    // This runs in ATOMIC CONTEXT (timer interrupt)\n    atomic_context_calls++;\n    \n    printk(KERN_INFO \"=== ATOMIC CONTEXT HANDLER #%lu ===\", atomic_context_calls);\n    printk(KERN_INFO \"Running in atomic context - following strict rules\\n\");\n    \n    // Rule 1: Use atomic operations for simple counters\n    atomic_inc(&demo_data.counter);\n    printk(KERN_INFO \"Atomic counter incremented to: %d\\n\", atomic_read(&demo_data.counter));\n    \n    // Rule 2: Use spinlocks, not mutexes\n    spin_lock_irqsave(&demo_data.lock, flags);\n    \n    // Rule 3: Use GFP_ATOMIC for memory allocation\n    temp_buffer = kmalloc(64, GFP_ATOMIC);\n    if (temp_buffer) {\n        snprintf(temp_buffer, 64, \"atomic_call_%lu\", atomic_context_calls);\n        printk(KERN_INFO \"Allocated buffer in atomic context: %s\\n\", temp_buffer);\n        \n        // Update shared data while holding spinlock\n        demo_data.last_update = jiffies;\n        \n        // Free immediately (just for demonstration)\n        kfree(temp_buffer);\n    } else {\n        printk(KERN_WARNING \"GFP_ATOMIC allocation failed (this is normal under memory pressure)\\n\");\n    }\n    \n    spin_unlock_irqrestore(&demo_data.lock, flags);\n    \n    // Rule 4: Keep it fast and simple\n    printk(KERN_INFO \"Atomic context handler completed quickly\\n\");\n    \n    // Schedule next call\n    if (atomic_context_calls < 10) {\n        mod_timer(&atomic_timer, jiffies + msecs_to_jiffies(1500));\n    }\n}\n\n// TODO: Demonstrate what NOT to do in atomic context\nstatic void demonstrate_atomic_context_violations(void)\n{\n    printk(KERN_INFO \"=== ATOMIC CONTEXT VIOLATIONS (DO NOT DO THIS!) ===\");\n    printk(KERN_INFO \"The following would cause problems in atomic context:\\n\");\n    \n    printk(KERN_INFO \"1. msleep() - FORBIDDEN (would sleep)\\n\");\n    printk(KERN_INFO \"   // msleep(100); // CRASH!\\n\");\n    \n    printk(KERN_INFO \"2. mutex_lock() - FORBIDDEN (might sleep)\\n\");\n    printk(KERN_INFO \"   // mutex_lock(&some_mutex); // CRASH!\\n\");\n    \n    printk(KERN_INFO \"3. kmalloc(..., GFP_KERNEL) - FORBIDDEN (might sleep)\\n\");\n    printk(KERN_INFO \"   // kmalloc(size, GFP_KERNEL); // CRASH!\\n\");\n    \n    printk(KERN_INFO \"4. copy_from_user() - FORBIDDEN (might sleep)\\n\");\n    printk(KERN_INFO \"   // copy_from_user(dest, src, size); // CRASH!\\n\");\n    \n    printk(KERN_INFO \"5. Taking too long - BAD (delays other interrupts)\\n\");\n    printk(KERN_INFO \"   // for (i = 0; i < 1000000; i++) {...} // BAD!\\n\");\n}\n\n// TODO: Demonstrate proper atomic context alternatives\nstatic void demonstrate_atomic_context_alternatives(void)\n{\n    printk(KERN_INFO \"=== ATOMIC CONTEXT ALTERNATIVES ===\");\n    printk(KERN_INFO \"Instead of forbidden operations, use:\\n\");\n    \n    printk(KERN_INFO \"1. Instead of msleep() -> udelay() (microsecond delays only)\\n\");\n    printk(KERN_INFO \"2. Instead of mutex_lock() -> spin_lock_irqsave()\\n\");\n    printk(KERN_INFO \"3. Instead of GFP_KERNEL -> GFP_ATOMIC\\n\");\n    printk(KERN_INFO \"4. Instead of copy_from_user() -> defer to workqueue\\n\");\n    printk(KERN_INFO \"5. Instead of long processing -> defer to bottom half\\n\");\n    \n    printk(KERN_INFO \"Next lesson: Top-half/Bottom-half processing\\n\");\n}\n\n// TODO: Demonstrate atomic operations\nstatic void demonstrate_atomic_operations(void)\n{\n    atomic_t test_atomic;\n    \n    printk(KERN_INFO \"=== ATOMIC OPERATIONS DEMONSTRATION ===\");\n    \n    // Initialize atomic variable\n    atomic_set(&test_atomic, 100);\n    printk(KERN_INFO \"Initial atomic value: %d\\n\", atomic_read(&test_atomic));\n    \n    // Demonstrate various atomic operations\n    atomic_inc(&test_atomic);\n    printk(KERN_INFO \"After atomic_inc: %d\\n\", atomic_read(&test_atomic));\n    \n    atomic_dec(&test_atomic);\n    printk(KERN_INFO \"After atomic_dec: %d\\n\", atomic_read(&test_atomic));\n    \n    atomic_add(10, &test_atomic);\n    printk(KERN_INFO \"After atomic_add(10): %d\\n\", atomic_read(&test_atomic));\n    \n    atomic_sub(5, &test_atomic);\n    printk(KERN_INFO \"After atomic_sub(5): %d\\n\", atomic_read(&test_atomic));\n    \n    // Test and set operations\n    if (atomic_dec_and_test(&test_atomic)) {\n        printk(KERN_INFO \"atomic_dec_and_test returned true (value is 0)\\n\");\n    } else {\n        printk(KERN_INFO \"atomic_dec_and_test returned false (value is %d)\\n\", atomic_read(&test_atomic));\n    }\n    \n    printk(KERN_INFO \"Atomic operations are safe in any context\\n\");\n}\n\n// TODO: Demonstrate proper spinlock usage\nstatic void demonstrate_spinlock_usage(void)\n{\n    unsigned long flags;\n    \n    printk(KERN_INFO \"=== SPINLOCK USAGE DEMONSTRATION ===\");\n    \n    // Proper spinlock usage in atomic context\n    spin_lock_irqsave(&demo_data.lock, flags);\n    \n    printk(KERN_INFO \"Spinlock acquired with interrupts disabled\\n\");\n    printk(KERN_INFO \"This is safe in atomic context\\n\");\n    \n    // Simulate critical section\n    demo_data.last_update = jiffies;\n    \n    spin_unlock_irqrestore(&demo_data.lock, flags);\n    \n    printk(KERN_INFO \"Spinlock released and interrupts restored\\n\");\n    \n    printk(KERN_INFO \"Why spin_lock_irqsave?\\n\");\n    printk(KERN_INFO \"- Disables interrupts on this CPU\\n\");\n    printk(KERN_INFO \"- Prevents deadlocks with interrupt handlers\\n\");\n    printk(KERN_INFO \"- Safe to use in both process and interrupt context\\n\");\n}\n\nstatic int __init atomic_context_init(void)\n{\n    printk(KERN_INFO \"Atomic context programming module loaded\\n\");\n    printk(KERN_INFO \"Learning interrupt-safe programming techniques\\n\");\n    \n    // Initialize data structures\n    atomic_set(&demo_data.counter, 0);\n    spin_lock_init(&demo_data.lock);\n    demo_data.buffer = kmalloc(256, GFP_KERNEL); // OK in process context\n    demo_data.buffer_size = 256;\n    demo_data.last_update = jiffies;\n    \n    if (!demo_data.buffer) {\n        printk(KERN_ERR \"Failed to allocate buffer\\n\");\n        return -ENOMEM;\n    }\n    \n    // This all runs in process context\n    demonstrate_atomic_context_violations();\n    demonstrate_atomic_context_alternatives();\n    demonstrate_atomic_operations();\n    demonstrate_spinlock_usage();\n    \n    // Set up timer to demonstrate atomic context\n    timer_setup(&atomic_timer, atomic_context_handler, 0);\n    printk(KERN_INFO \"Starting atomic context demonstrations...\\n\");\n    mod_timer(&atomic_timer, jiffies + msecs_to_jiffies(1000));\n    \n    return 0;\n}\n\nstatic void __exit atomic_context_exit(void)\n{\n    printk(KERN_INFO \"Stopping atomic context demonstrations...\\n\");\n    \n    // Stop timer\n    del_timer_sync(&atomic_timer);\n    \n    // Clean up\n    kfree(demo_data.buffer);\n    \n    printk(KERN_INFO \"Atomic context programming module unloaded\\n\");\n    printk(KERN_INFO \"Total atomic context calls: %lu\\n\", atomic_context_calls);\n    printk(KERN_INFO \"Final atomic counter: %d\\n\", atomic_read(&demo_data.counter));\n    printk(KERN_INFO \"Remember: GFP_ATOMIC, spinlocks, be fast!\\n\");\n}\n\nmodule_init(atomic_context_init);\nmodule_exit(atomic_context_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Atomic context programming techniques\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "atomic_context",
      "interrupt_context",
      "gfp_atomic",
      "spinlocks",
      "atomic_operations"
    ],
    "skills": [
      "atomic_programming",
      "interrupt_safe_code",
      "proper_memory_allocation"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Atomic context programming module loaded",
        "Learning interrupt-safe programming techniques",
        "=== ATOMIC CONTEXT HANDLER #1 ===",
        "Running in atomic context - following strict rules",
        "=== ATOMIC CONTEXT VIOLATIONS (DO NOT DO THIS!) ===",
        "=== ATOMIC CONTEXT ALTERNATIVES ===",
        "=== ATOMIC OPERATIONS DEMONSTRATION ===",
        "=== SPINLOCK USAGE DEMONSTRATION ===",
        "Remember: GFP_ATOMIC, spinlocks, be fast!"
      ],
      "requirements": [
        "Use required function names: atomic_context_init, atomic_context_exit, atomic_context_handler, demonstrate_atomic_context_violations, demonstrate_atomic_context_alternatives, demonstrate_atomic_operations, demonstrate_spinlock_usage",
        "Use required variable names: demo_data, atomic_timer, atomic_context_calls",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/timer.h, linux/spinlock.h, linux/atomic.h, linux/slab.h",
        "Code must contain: GFP_ATOMIC, spin_lock_irqsave, spin_unlock_irqrestore, atomic_inc, atomic_read, atomic_set"
      ]
    }
  },
  {
    "id": 46,
    "title": "Interrupt-Driven I/O and Bottom Halves",
    "difficulty": 9,
    "xp": 90,
    "phase": "kernel_core",
    "description": "Implement interrupt-driven I/O with proper top-half/bottom-half processing using tasklets and workqueues. This teaches critical interrupt handling patterns used in high-performance device drivers at enterprise companies.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/interrupt.h>\n#include <linux/timer.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/jiffies.h>\n\n#define DEVICE_NAME \"irqdev\"\n#define CLASS_NAME \"irqclass\"\n#define BUFFER_SIZE 4096\n#define IRQ_SIMULATION_INTERVAL 3000  // 3 seconds\n\n// TODO: Interrupt statistics structure\nstruct irq_stats {\n    unsigned long irq_count;\n    unsigned long tasklet_count;\n    unsigned long workqueue_count;\n    unsigned long data_ready_count;\n    unsigned long last_irq_jiffies;\n    unsigned long total_processing_time;\n};\n\n// TODO: Data packet structure (simulates hardware data)\nstruct data_packet {\n    struct list_head list;\n    char data[64];\n    size_t len;\n    unsigned long timestamp;\n    int sequence;\n};\n\n// TODO: Device structure\nstruct irq_device {\n    struct cdev cdev;\n    struct device *device;\n    struct class *class;\n    dev_t dev_num;\n    \n    // Interrupt simulation\n    struct timer_list irq_timer;\n    int irq_number;\n    bool irq_enabled;\n    \n    // Buffers and queues\n    char *user_buffer;\n    size_t buffer_used;\n    struct list_head packet_queue;\n    \n    // Bottom half processing\n    struct tasklet_struct data_tasklet;\n    struct work_struct data_work;\n    struct workqueue_struct *irq_workqueue;\n    \n    // Synchronization\n    spinlock_t irq_lock;     // For interrupt context\n    struct mutex device_mutex;  // For process context\n    wait_queue_head_t read_wait;\n    \n    // Statistics\n    struct irq_stats stats;\n    atomic_t packet_sequence;\n};\n\nstatic struct irq_device irq_dev;\n\n// TODO: Simulated interrupt handler (top half)\nstatic irqreturn_t irq_handler(int irq, void *dev_data)\n{\n    struct irq_device *dev = (struct irq_device *)dev_data;\n    struct data_packet *packet;\n    unsigned long flags;\n    ktime_t start_time;\n    \n    start_time = ktime_get();\n    \n    // This is interrupt context - must be fast and atomic\n    spin_lock_irqsave(&dev->irq_lock, flags);\n    \n    dev->stats.irq_count++;\n    dev->stats.last_irq_jiffies = jiffies;\n    \n    // Create new data packet (simulates reading from hardware)\n    packet = kmalloc(sizeof(*packet), GFP_ATOMIC);  // Must use GFP_ATOMIC in IRQ context\n    if (packet) {\n        packet->len = snprintf(packet->data, sizeof(packet->data),\n                              \"IRQ_Data_%d_Time_%lu\\n\",\n                              atomic_inc_return(&dev->packet_sequence),\n                              jiffies);\n        packet->timestamp = jiffies;\n        packet->sequence = atomic_read(&dev->packet_sequence);\n        \n        // Add to packet queue for bottom half processing\n        list_add_tail(&packet->list, &dev->packet_queue);\n        \n        // Schedule bottom half processing\n        tasklet_schedule(&dev->data_tasklet);\n        \n        // Also schedule workqueue for complex processing\n        queue_work(dev->irq_workqueue, &dev->data_work);\n    }\n    \n    spin_unlock_irqrestore(&dev->irq_lock, flags);\n    \n    // Update timing statistics\n    dev->stats.total_processing_time += ktime_to_ns(ktime_sub(ktime_get(), start_time));\n    \n    printk(KERN_INFO \"IRQ %d handled: packet_count=%lu\\n\", irq, dev->stats.irq_count);\n    \n    return IRQ_HANDLED;\n}\n\n// TODO: Tasklet function (bottom half - atomic context)\nstatic void data_tasklet_handler(unsigned long data)\n{\n    struct irq_device *dev = (struct irq_device *)data;\n    struct data_packet *packet, *tmp;\n    unsigned long flags;\n    size_t bytes_to_copy;\n    \n    spin_lock_irqsave(&dev->irq_lock, flags);\n    \n    dev->stats.tasklet_count++;\n    \n    // Process packets from interrupt (fast processing only)\n    list_for_each_entry_safe(packet, tmp, &dev->packet_queue, list) {\n        // Check if we have space in user buffer\n        if (dev->buffer_used + packet->len <= BUFFER_SIZE) {\n            bytes_to_copy = packet->len;\n            memcpy(dev->user_buffer + dev->buffer_used, packet->data, bytes_to_copy);\n            dev->buffer_used += bytes_to_copy;\n            dev->stats.data_ready_count++;\n        }\n        \n        // Remove packet from queue\n        list_del(&packet->list);\n        kfree(packet);\n    }\n    \n    spin_unlock_irqrestore(&dev->irq_lock, flags);\n    \n    // Wake up any waiting readers\n    if (dev->buffer_used > 0) {\n        wake_up_interruptible(&dev->read_wait);\n    }\n    \n    printk(KERN_INFO \"Tasklet processed: buffer_used=%zu\\n\", dev->buffer_used);\n}\n\n// TODO: Work function (bottom half - process context)\nstatic void data_work_handler(struct work_struct *work)\n{\n    struct irq_device *dev = container_of(work, struct irq_device, data_work);\n    unsigned long flags;\n    \n    // This runs in process context - can sleep, use GFP_KERNEL, etc.\n    \n    spin_lock_irqsave(&dev->irq_lock, flags);\n    dev->stats.workqueue_count++;\n    spin_unlock_irqrestore(&dev->irq_lock, flags);\n    \n    // Simulate complex processing that can't be done in interrupt context\n    msleep(10);  // This would crash in interrupt context\n    \n    printk(KERN_INFO \"Workqueue processed: can sleep and do complex work\\n\");\n    \n    // Could perform tasks like:\n    // - Complex data processing\n    // - Memory allocation with GFP_KERNEL\n    // - File I/O operations\n    // - Network operations\n}\n\n// TODO: Timer callback to simulate hardware interrupts\nstatic void irq_simulation_timer(struct timer_list *timer)\n{\n    struct irq_device *dev = container_of(timer, struct irq_device, irq_timer);\n    \n    if (dev->irq_enabled) {\n        // Simulate hardware interrupt\n        irq_handler(dev->irq_number, dev);\n        \n        // Restart timer for next \"interrupt\"\n        mod_timer(&dev->irq_timer, jiffies + msecs_to_jiffies(IRQ_SIMULATION_INTERVAL));\n    }\n}\n\nstatic int device_open(struct inode *inode, struct file *file)\n{\n    struct irq_device *dev = &irq_dev;\n    \n    file->private_data = dev;\n    \n    mutex_lock(&dev->device_mutex);\n    \n    // Start interrupt simulation\n    if (!dev->irq_enabled) {\n        dev->irq_enabled = true;\n        mod_timer(&dev->irq_timer, jiffies + msecs_to_jiffies(1000));\n        printk(KERN_INFO \"Interrupt simulation started\\n\");\n    }\n    \n    mutex_unlock(&dev->device_mutex);\n    \n    printk(KERN_INFO \"IRQ device opened\\n\");\n    return 0;\n}\n\nstatic int device_release(struct inode *inode, struct file *file)\n{\n    struct irq_device *dev = file->private_data;\n    \n    printk(KERN_INFO \"IRQ device closed\\n\");\n    return 0;\n}\n\n// TODO: Read function with interrupt-driven data\nstatic ssize_t device_read(struct file *file, char __user *user_buffer,\n                          size_t count, loff_t *offset)\n{\n    struct irq_device *dev = file->private_data;\n    ssize_t bytes_read = 0;\n    unsigned long flags;\n    \n    // Wait for data to be available (filled by interrupt handler)\n    if (file->f_flags & O_NONBLOCK) {\n        spin_lock_irqsave(&dev->irq_lock, flags);\n        if (dev->buffer_used == 0) {\n            spin_unlock_irqrestore(&dev->irq_lock, flags);\n            return -EAGAIN;\n        }\n        spin_unlock_irqrestore(&dev->irq_lock, flags);\n    } else {\n        if (wait_event_interruptible(dev->read_wait, dev->buffer_used > 0)) {\n            return -ERESTARTSYS;\n        }\n    }\n    \n    mutex_lock(&dev->device_mutex);\n    spin_lock_irqsave(&dev->irq_lock, flags);\n    \n    if (dev->buffer_used > 0) {\n        bytes_read = min(count, dev->buffer_used);\n        \n        if (copy_to_user(user_buffer, dev->user_buffer, bytes_read)) {\n            spin_unlock_irqrestore(&dev->irq_lock, flags);\n            mutex_unlock(&dev->device_mutex);\n            return -EFAULT;\n        }\n        \n        // Move remaining data to beginning\n        if (bytes_read < dev->buffer_used) {\n            memmove(dev->user_buffer, dev->user_buffer + bytes_read,\n                   dev->buffer_used - bytes_read);\n        }\n        \n        dev->buffer_used -= bytes_read;\n    }\n    \n    spin_unlock_irqrestore(&dev->irq_lock, flags);\n    mutex_unlock(&dev->device_mutex);\n    \n    if (bytes_read > 0) {\n        printk(KERN_INFO \"Read %zu bytes of interrupt-driven data\\n\", bytes_read);\n    }\n    \n    return bytes_read;\n}\n\n// TODO: Write function to show statistics\nstatic ssize_t device_write(struct file *file, const char __user *user_buffer,\n                           size_t count, loff_t *offset)\n{\n    struct irq_device *dev = file->private_data;\n    char cmd[32];\n    unsigned long flags;\n    \n    if (count >= sizeof(cmd)) {\n        return -EINVAL;\n    }\n    \n    if (copy_from_user(cmd, user_buffer, count)) {\n        return -EFAULT;\n    }\n    \n    cmd[count] = '\\0';\n    \n    if (strncmp(cmd, \"stats\", 5) == 0) {\n        spin_lock_irqsave(&dev->irq_lock, flags);\n        printk(KERN_INFO \"IRQ Statistics:\\n\");\n        printk(KERN_INFO \"  IRQ Count: %lu\\n\", dev->stats.irq_count);\n        printk(KERN_INFO \"  Tasklet Count: %lu\\n\", dev->stats.tasklet_count);\n        printk(KERN_INFO \"  Workqueue Count: %lu\\n\", dev->stats.workqueue_count);\n        printk(KERN_INFO \"  Data Ready Count: %lu\\n\", dev->stats.data_ready_count);\n        printk(KERN_INFO \"  Last IRQ: %lu jiffies ago\\n\", \n               jiffies - dev->stats.last_irq_jiffies);\n        printk(KERN_INFO \"  Avg Processing Time: %lu ns\\n\",\n               dev->stats.irq_count > 0 ? \n               dev->stats.total_processing_time / dev->stats.irq_count : 0);\n        spin_unlock_irqrestore(&dev->irq_lock, flags);\n    } else if (strncmp(cmd, \"reset\", 5) == 0) {\n        spin_lock_irqsave(&dev->irq_lock, flags);\n        memset(&dev->stats, 0, sizeof(dev->stats));\n        atomic_set(&dev->packet_sequence, 0);\n        spin_unlock_irqrestore(&dev->irq_lock, flags);\n        printk(KERN_INFO \"Statistics reset\\n\");\n    }\n    \n    return count;\n}\n\nstatic const struct file_operations irq_dev_fops = {\n    .owner = THIS_MODULE,\n    .open = device_open,\n    .release = device_release,\n    .read = device_read,\n    .write = device_write,\n};\n\nstatic int __init irq_dev_init(void)\n{\n    int ret;\n    \n    printk(KERN_INFO \"Interrupt-driven device initializing...\\n\");\n    \n    // TODO: Initialize device structure\n    memset(&irq_dev, 0, sizeof(irq_dev));\n    mutex_init(&irq_dev.device_mutex);\n    spin_lock_init(&irq_dev.irq_lock);\n    init_waitqueue_head(&irq_dev.read_wait);\n    INIT_LIST_HEAD(&irq_dev.packet_queue);\n    atomic_set(&irq_dev.packet_sequence, 0);\n    \n    // TODO: Allocate buffer\n    irq_dev.user_buffer = kzalloc(BUFFER_SIZE, GFP_KERNEL);\n    if (!irq_dev.user_buffer) {\n        return -ENOMEM;\n    }\n    \n    // TODO: Initialize timer for interrupt simulation\n    timer_setup(&irq_dev.irq_timer, irq_simulation_timer, 0);\n    irq_dev.irq_number = 42;  // Fake IRQ number for simulation\n    \n    // TODO: Initialize tasklet\n    tasklet_init(&irq_dev.data_tasklet, data_tasklet_handler, (unsigned long)&irq_dev);\n    \n    // TODO: Initialize workqueue\n    irq_dev.irq_workqueue = create_singlethread_workqueue(\"irq_workqueue\");\n    if (!irq_dev.irq_workqueue) {\n        kfree(irq_dev.user_buffer);\n        return -ENOMEM;\n    }\n    \n    INIT_WORK(&irq_dev.data_work, data_work_handler);\n    \n    // TODO: Register character device\n    ret = alloc_chrdev_region(&irq_dev.dev_num, 0, 1, DEVICE_NAME);\n    if (ret < 0) {\n        destroy_workqueue(irq_dev.irq_workqueue);\n        kfree(irq_dev.user_buffer);\n        return ret;\n    }\n    \n    cdev_init(&irq_dev.cdev, &irq_dev_fops);\n    irq_dev.cdev.owner = THIS_MODULE;\n    \n    ret = cdev_add(&irq_dev.cdev, irq_dev.dev_num, 1);\n    if (ret < 0) {\n        unregister_chrdev_region(irq_dev.dev_num, 1);\n        destroy_workqueue(irq_dev.irq_workqueue);\n        kfree(irq_dev.user_buffer);\n        return ret;\n    }\n    \n    // TODO: Create device class and device\n    irq_dev.class = class_create(THIS_MODULE, CLASS_NAME);\n    if (IS_ERR(irq_dev.class)) {\n        cdev_del(&irq_dev.cdev);\n        unregister_chrdev_region(irq_dev.dev_num, 1);\n        destroy_workqueue(irq_dev.irq_workqueue);\n        kfree(irq_dev.user_buffer);\n        return PTR_ERR(irq_dev.class);\n    }\n    \n    irq_dev.device = device_create(irq_dev.class, NULL, irq_dev.dev_num,\n                                  NULL, DEVICE_NAME);\n    if (IS_ERR(irq_dev.device)) {\n        class_destroy(irq_dev.class);\n        cdev_del(&irq_dev.cdev);\n        unregister_chrdev_region(irq_dev.dev_num, 1);\n        destroy_workqueue(irq_dev.irq_workqueue);\n        kfree(irq_dev.user_buffer);\n        return PTR_ERR(irq_dev.device);\n    }\n    \n    printk(KERN_INFO \"Interrupt-driven device loaded successfully\\n\");\n    printk(KERN_INFO \"Device: /dev/%s with interrupt simulation\\n\", DEVICE_NAME);\n    printk(KERN_INFO \"Write 'stats' to show statistics, 'reset' to reset\\n\");\n    \n    return 0;\n}\n\nstatic void __exit irq_dev_exit(void)\n{\n    struct data_packet *packet, *tmp;\n    \n    printk(KERN_INFO \"Interrupt-driven device unloading...\\n\");\n    \n    // TODO: Stop interrupt simulation\n    irq_dev.irq_enabled = false;\n    del_timer_sync(&irq_dev.irq_timer);\n    \n    // TODO: Cleanup tasklet and workqueue\n    tasklet_kill(&irq_dev.data_tasklet);\n    flush_workqueue(irq_dev.irq_workqueue);\n    destroy_workqueue(irq_dev.irq_workqueue);\n    \n    // TODO: Clean up any remaining packets\n    list_for_each_entry_safe(packet, tmp, &irq_dev.packet_queue, list) {\n        list_del(&packet->list);\n        kfree(packet);\n    }\n    \n    // TODO: Wake up any waiting processes\n    wake_up_interruptible_all(&irq_dev.read_wait);\n    \n    // TODO: Clean up device\n    device_destroy(irq_dev.class, irq_dev.dev_num);\n    class_destroy(irq_dev.class);\n    cdev_del(&irq_dev.cdev);\n    unregister_chrdev_region(irq_dev.dev_num, 1);\n    kfree(irq_dev.user_buffer);\n    \n    printk(KERN_INFO \"Interrupt-driven device unloaded\\n\");\n    printk(KERN_INFO \"Final IRQ stats - Total: %lu, Tasklets: %lu, Work: %lu\\n\",\n           irq_dev.stats.irq_count, irq_dev.stats.tasklet_count, \n           irq_dev.stats.workqueue_count);\n}\n\nmodule_init(irq_dev_init);\nmodule_exit(irq_dev_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Interrupt-driven character device with top/bottom half processing\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "interrupt_handling",
      "top_half_bottom_half",
      "tasklets",
      "workqueues",
      "interrupt_context",
      "deferred_work"
    ],
    "skills": [
      "interrupt_programming",
      "deferred_processing",
      "performance_optimization",
      "real_time_systems"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Interrupt-driven device loaded successfully",
        "Device: /dev/irqdev with interrupt simulation",
        "Write 'stats' to show statistics, 'reset' to reset",
        "Interrupt-driven device unloaded",
        "Final IRQ stats - Total:"
      ],
      "requirements": [
        "Use required function names: irq_dev_init, irq_dev_exit, irq_handler, data_tasklet_handler, data_work_handler, irq_simulation_timer",
        "Use required variable names: irq_dev, irq_dev_fops",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/interrupt.h, linux/timer.h, linux/workqueue.h",
        "Code must contain: irqreturn_t, IRQ_HANDLED, tasklet_init, tasklet_schedule, create_singlethread_workqueue, queue_work, GFP_ATOMIC, spin_lock_irqsave, spin_unlock_irqrestore"
      ]
    }
  },
  {
    "id": 47,
    "title": "Memory Hierarchy and Cache Coherency",
    "difficulty": 7,
    "xp": 65,
    "phase": "kernel_core",
    "description": "Understand the memory hierarchy from CPU caches to main memory and the cache coherency problems that arise in modern systems. Learn why special memory management is needed for hardware DMA operations.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cache.h>\n\n// CONCEPT: Memory Hierarchy and Cache Coherency\n// Memory Hierarchy (fastest to slowest):\n// 1. CPU Registers (fastest)\n// 2. L1 Cache (per-core)\n// 3. L2 Cache (per-core or shared)\n// 4. L3 Cache (shared)\n// 5. Main Memory (RAM)\n// 6. Storage (disk/SSD)\n//\n// Cache Coherency Problem:\n// - Multiple CPUs have their own caches\n// - Same memory location can be cached in different CPUs\n// - Updates in one CPU's cache may not be visible to other CPUs\n//\n// WHY: Understanding this is crucial for DMA and multi-processor programming\n\n// Test data structure aligned to cache line\nstruct cache_test_data {\n    volatile int value;\n    char padding[L1_CACHE_BYTES - sizeof(int)];\n} __attribute__((aligned(L1_CACHE_BYTES)));\n\nstatic struct cache_test_data *shared_data;\nstatic atomic_t test_counter = ATOMIC_INIT(0);\nstatic volatile bool test_running = false;\n\n// TODO: Demonstrate cache line effects\nstatic void demonstrate_cache_line_effects(void)\n{\n    struct cache_test_data *test_array;\n    int i;\n    ktime_t start, end;\n    s64 sequential_time, random_time;\n    \n    printk(KERN_INFO \"=== CACHE LINE EFFECTS DEMONSTRATION ===\");\n    printk(KERN_INFO \"Cache line size: %d bytes\\n\", L1_CACHE_BYTES);\n    \n    // Allocate test array\n    test_array = kmalloc(sizeof(struct cache_test_data) * 1000, GFP_KERNEL);\n    if (!test_array) {\n        printk(KERN_ERR \"Failed to allocate test array\\n\");\n        return;\n    }\n    \n    // Initialize array\n    for (i = 0; i < 1000; i++) {\n        test_array[i].value = i;\n    }\n    \n    // Test 1: Sequential access (cache-friendly)\n    start = ktime_get();\n    for (i = 0; i < 1000; i++) {\n        test_array[i].value *= 2;\n    }\n    end = ktime_get();\n    sequential_time = ktime_to_ns(ktime_sub(end, start));\n    \n    // Test 2: Random access (cache-unfriendly)\n    start = ktime_get();\n    for (i = 0; i < 1000; i++) {\n        int index = (i * 37) % 1000; // Pseudo-random pattern\n        test_array[index].value *= 2;\n    }\n    end = ktime_get();\n    random_time = ktime_to_ns(ktime_sub(end, start));\n    \n    printk(KERN_INFO \"Sequential access time: %lld ns\\n\", sequential_time);\n    printk(KERN_INFO \"Random access time: %lld ns\\n\", random_time);\n    printk(KERN_INFO \"Random is %lld%% slower (cache misses)\\n\", \n           (random_time - sequential_time) * 100 / sequential_time);\n    \n    kfree(test_array);\n}\n\n// TODO: Cache coherency test thread\nstatic int cache_coherency_test_thread(void *data)\n{\n    int cpu = smp_processor_id();\n    int local_counter = 0;\n    \n    printk(KERN_INFO \"Cache coherency test thread started on CPU %d\\n\", cpu);\n    \n    while (test_running && !kthread_should_stop()) {\n        // Each CPU modifies shared data\n        shared_data->value = cpu * 1000 + local_counter;\n        \n        // Memory barrier to ensure write is visible\n        smp_wmb();\n        \n        // Increment atomic counter\n        atomic_inc(&test_counter);\n        \n        local_counter++;\n        \n        // Small delay\n        usleep_range(1000, 2000);\n        \n        // Stop after 50 iterations\n        if (local_counter >= 50) {\n            break;\n        }\n    }\n    \n    printk(KERN_INFO \"Cache coherency test thread on CPU %d completed\\n\", cpu);\n    return 0;\n}\n\n// TODO: Demonstrate cache coherency issues\nstatic void demonstrate_cache_coherency(void)\n{\n    struct task_struct *threads[NR_CPUS];\n    int cpu, active_cpus = 0;\n    \n    printk(KERN_INFO \"=== CACHE COHERENCY DEMONSTRATION ===\");\n    printk(KERN_INFO \"Number of CPUs: %d\\n\", num_online_cpus());\n    \n    // Allocate shared data\n    shared_data = kmalloc(sizeof(struct cache_test_data), GFP_KERNEL);\n    if (!shared_data) {\n        printk(KERN_ERR \"Failed to allocate shared data\\n\");\n        return;\n    }\n    \n    shared_data->value = 0;\n    atomic_set(&test_counter, 0);\n    test_running = true;\n    \n    // Start threads on different CPUs\n    for_each_online_cpu(cpu) {\n        if (active_cpus >= 4) break; // Limit to 4 threads\n        \n        threads[active_cpus] = kthread_create(cache_coherency_test_thread, \n                                             NULL, \"cache_test_%d\", cpu);\n        if (!IS_ERR(threads[active_cpus])) {\n            kthread_bind(threads[active_cpus], cpu);\n            wake_up_process(threads[active_cpus]);\n            active_cpus++;\n        }\n    }\n    \n    // Wait for threads to complete\n    msleep(3000);\n    test_running = false;\n    \n    // Wait for all threads to finish\n    for (cpu = 0; cpu < active_cpus; cpu++) {\n        if (!IS_ERR(threads[cpu])) {\n            kthread_stop(threads[cpu]);\n        }\n    }\n    \n    printk(KERN_INFO \"Final shared value: %d\\n\", shared_data->value);\n    printk(KERN_INFO \"Total atomic operations: %d\\n\", atomic_read(&test_counter));\n    \n    kfree(shared_data);\n}\n\n// TODO: Explain memory barriers\nstatic void explain_memory_barriers(void)\n{\n    printk(KERN_INFO \"=== MEMORY BARRIERS EXPLANATION ===\");\n    printk(KERN_INFO \"Memory barriers ensure ordering of memory operations\\n\");\n    \n    printk(KERN_INFO \"Types of memory barriers:\\n\");\n    printk(KERN_INFO \"1. smp_mb() - Full memory barrier\\n\");\n    printk(KERN_INFO \"   - Ensures all memory operations before/after are ordered\\n\");\n    \n    printk(KERN_INFO \"2. smp_wmb() - Write memory barrier\\n\");\n    printk(KERN_INFO \"   - Ensures all writes before barrier complete first\\n\");\n    \n    printk(KERN_INFO \"3. smp_rmb() - Read memory barrier\\n\");\n    printk(KERN_INFO \"   - Ensures all reads before barrier complete first\\n\");\n    \n    printk(KERN_INFO \"When memory barriers are needed:\\n\");\n    printk(KERN_INFO \"- Multi-processor systems (SMP)\\n\");\n    printk(KERN_INFO \"- DMA operations\\n\");\n    printk(KERN_INFO \"- Device driver programming\\n\");\n    printk(KERN_INFO \"- Lock-free programming\\n\");\n}\n\n// TODO: Explain DMA cache problems\nstatic void explain_dma_cache_problems(void)\n{\n    printk(KERN_INFO \"=== DMA AND CACHE PROBLEMS ===\");\n    printk(KERN_INFO \"Why DMA needs special memory management:\\n\");\n    \n    printk(KERN_INFO \"Problem 1: Cache Coherency\\n\");\n    printk(KERN_INFO \"- CPU caches data in L1/L2/L3 caches\\n\");\n    printk(KERN_INFO \"- DMA controller accesses main memory directly\\n\");\n    printk(KERN_INFO \"- CPU and DMA may see different values!\\n\");\n    \n    printk(KERN_INFO \"Problem 2: Write Ordering\\n\");\n    printk(KERN_INFO \"- CPU writes may be reordered by processor\\n\");\n    printk(KERN_INFO \"- DMA may see writes in wrong order\\n\");\n    printk(KERN_INFO \"- Results in corrupted data\\n\");\n    \n    printk(KERN_INFO \"Solutions (next lesson):\\n\");\n    printk(KERN_INFO \"- Coherent memory allocation\\n\");\n    printk(KERN_INFO \"- Cache synchronization functions\\n\");\n    printk(KERN_INFO \"- Memory barriers\\n\");\n    printk(KERN_INFO \"- DMA mapping API\\n\");\n}\n\n// TODO: Demonstrate cache alignment importance\nstatic void demonstrate_cache_alignment(void)\n{\n    struct {\n        int value1;\n        int value2;\n    } unaligned_data;\n    \n    struct {\n        int value1;\n        char padding[L1_CACHE_BYTES - sizeof(int)];\n        int value2;\n    } aligned_data;\n    \n    printk(KERN_INFO \"=== CACHE ALIGNMENT DEMONSTRATION ===\");\n    printk(KERN_INFO \"Unaligned structure size: %zu bytes\\n\", sizeof(unaligned_data));\n    printk(KERN_INFO \"Aligned structure size: %zu bytes\\n\", sizeof(aligned_data));\n    \n    printk(KERN_INFO \"Cache line size: %d bytes\\n\", L1_CACHE_BYTES);\n    printk(KERN_INFO \"False sharing occurs when different variables share cache lines\\n\");\n    printk(KERN_INFO \"Aligned structures prevent false sharing\\n\");\n    \n    printk(KERN_INFO \"Memory addresses:\\n\");\n    printk(KERN_INFO \"  unaligned_data.value1: %p\\n\", &unaligned_data.value1);\n    printk(KERN_INFO \"  unaligned_data.value2: %p\\n\", &unaligned_data.value2);\n    printk(KERN_INFO \"  aligned_data.value1: %p\\n\", &aligned_data.value1);\n    printk(KERN_INFO \"  aligned_data.value2: %p\\n\", &aligned_data.value2);\n}\n\nstatic int __init memory_hierarchy_init(void)\n{\n    printk(KERN_INFO \"Memory hierarchy and cache coherency module loaded\\n\");\n    printk(KERN_INFO \"Learning about CPU caches and memory architecture\\n\");\n    \n    demonstrate_cache_line_effects();\n    demonstrate_cache_alignment();\n    explain_memory_barriers();\n    explain_dma_cache_problems();\n    demonstrate_cache_coherency();\n    \n    return 0;\n}\n\nstatic void __exit memory_hierarchy_exit(void)\n{\n    printk(KERN_INFO \"Memory hierarchy and cache coherency module unloaded\\n\");\n    printk(KERN_INFO \"Remember: Cache coherency is critical for DMA!\\n\");\n}\n\nmodule_init(memory_hierarchy_init);\nmodule_exit(memory_hierarchy_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Memory hierarchy and cache coherency concepts\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "memory_hierarchy",
      "cpu_caches",
      "cache_coherency",
      "cache_lines",
      "memory_barriers"
    ],
    "skills": [
      "memory_architecture",
      "cache_understanding",
      "coherency_concepts"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Memory hierarchy and cache coherency module loaded",
        "Learning about CPU caches and memory architecture",
        "=== CACHE LINE EFFECTS DEMONSTRATION ===",
        "Cache line size:",
        "Sequential access time:",
        "Random access time:",
        "=== CACHE COHERENCY DEMONSTRATION ===",
        "Number of CPUs:",
        "=== MEMORY BARRIERS EXPLANATION ===",
        "=== DMA AND CACHE PROBLEMS ===",
        "=== CACHE ALIGNMENT DEMONSTRATION ===",
        "Remember: Cache coherency is critical for DMA!"
      ],
      "requirements": [
        "Use required function names: memory_hierarchy_init, memory_hierarchy_exit, demonstrate_cache_line_effects, cache_coherency_test_thread, demonstrate_cache_coherency, explain_memory_barriers, explain_dma_cache_problems, demonstrate_cache_alignment",
        "Use required variable names: shared_data, test_counter, test_running",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/slab.h, linux/smp.h, linux/cache.h",
        "Code must contain: L1_CACHE_BYTES, smp_wmb, smp_mb, smp_rmb, ktime_get, num_online_cpus"
      ]
    }
  },
  {
    "id": 48,
    "title": "Introduction to DMA Concepts",
    "difficulty": 8,
    "xp": 75,
    "phase": "kernel_core",
    "description": "Learn the fundamental concepts of Direct Memory Access (DMA) and why it's essential for high-performance I/O operations. Understand the difference between programmed I/O and DMA, and the basic requirements for DMA-safe memory.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/jiffies.h>\n#include <linux/string.h>\n\n// CONCEPT: Direct Memory Access (DMA)\n// Programmed I/O: CPU moves data between memory and device\n// DMA: Device controller moves data directly to/from memory\n// \n// Why DMA is needed:\n// 1. CPU efficiency - CPU can do other work while DMA transfers data\n// 2. Performance - DMA can transfer data faster than CPU\n// 3. Bandwidth - Multiple DMA channels can work simultaneously\n//\n// WHY: Modern devices (network, storage, graphics) require high-speed data transfer\n\n// Simulate different I/O methods\nstruct io_performance_test {\n    char *source_buffer;\n    char *dest_buffer;\n    size_t buffer_size;\n    unsigned long programmed_io_time;\n    unsigned long dma_simulation_time;\n};\n\nstatic struct io_performance_test perf_test;\nstatic struct timer_list dma_simulation_timer;\nstatic volatile bool dma_transfer_complete = false;\nstatic size_t dma_bytes_transferred = 0;\n\n// TODO: Simulate programmed I/O (CPU does all the work)\nstatic void simulate_programmed_io(void)\n{\n    ktime_t start, end;\n    int i;\n    \n    printk(KERN_INFO \"=== PROGRAMMED I/O SIMULATION ===\");\n    printk(KERN_INFO \"CPU manually transfers data byte by byte\\n\");\n    \n    start = ktime_get();\n    \n    // Simulate CPU transferring data manually\n    for (i = 0; i < perf_test.buffer_size; i++) {\n        // Simulate reading from device (slow)\n        char data = perf_test.source_buffer[i];\n        \n        // Simulate processing delay (device is slow)\n        udelay(1); // 1 microsecond per byte\n        \n        // Simulate writing to memory\n        perf_test.dest_buffer[i] = data;\n        \n        // CPU is busy the entire time!\n    }\n    \n    end = ktime_get();\n    perf_test.programmed_io_time = ktime_to_us(ktime_sub(end, start));\n    \n    printk(KERN_INFO \"Programmed I/O completed in %lu microseconds\\n\", \n           perf_test.programmed_io_time);\n    printk(KERN_INFO \"CPU was busy for the entire transfer\\n\");\n    printk(KERN_INFO \"Bytes transferred: %zu\\n\", perf_test.buffer_size);\n}\n\n// TODO: DMA simulation timer callback\nstatic void dma_simulation_callback(struct timer_list *timer)\n{\n    const size_t chunk_size = 64; // Transfer 64 bytes at a time\n    \n    // Simulate DMA controller transferring data\n    if (dma_bytes_transferred < perf_test.buffer_size) {\n        size_t bytes_to_transfer = min(chunk_size, \n                                     perf_test.buffer_size - dma_bytes_transferred);\n        \n        // DMA controller copies data (CPU is free!)\n        memcpy(perf_test.dest_buffer + dma_bytes_transferred,\n               perf_test.source_buffer + dma_bytes_transferred,\n               bytes_to_transfer);\n        \n        dma_bytes_transferred += bytes_to_transfer;\n        \n        // Schedule next DMA transfer\n        mod_timer(&dma_simulation_timer, jiffies + usecs_to_jiffies(10));\n        \n        printk(KERN_INFO \"DMA transferred %zu bytes (total: %zu/%zu)\\n\",\n               bytes_to_transfer, dma_bytes_transferred, perf_test.buffer_size);\n    } else {\n        // DMA transfer complete\n        dma_transfer_complete = true;\n        printk(KERN_INFO \"DMA transfer completed!\\n\");\n    }\n}\n\n// TODO: Simulate DMA transfer\nstatic void simulate_dma_transfer(void)\n{\n    ktime_t start, end;\n    \n    printk(KERN_INFO \"=== DMA SIMULATION ===\");\n    printk(KERN_INFO \"DMA controller transfers data while CPU does other work\\n\");\n    \n    start = ktime_get();\n    \n    // Reset DMA state\n    dma_transfer_complete = false;\n    dma_bytes_transferred = 0;\n    \n    // Start DMA transfer\n    timer_setup(&dma_simulation_timer, dma_simulation_callback, 0);\n    mod_timer(&dma_simulation_timer, jiffies + usecs_to_jiffies(10));\n    \n    // CPU can do other work while DMA transfers data\n    printk(KERN_INFO \"CPU is free to do other work while DMA transfers data\\n\");\n    \n    // Simulate CPU doing other work\n    while (!dma_transfer_complete) {\n        // CPU can process other tasks\n        printk(KERN_INFO \"CPU doing other work...\\n\");\n        msleep(50);\n    }\n    \n    end = ktime_get();\n    perf_test.dma_simulation_time = ktime_to_us(ktime_sub(end, start));\n    \n    // Stop the timer\n    del_timer_sync(&dma_simulation_timer);\n    \n    printk(KERN_INFO \"DMA simulation completed in %lu microseconds\\n\", \n           perf_test.dma_simulation_time);\n}\n\n// TODO: Compare I/O methods\nstatic void compare_io_methods(void)\n{\n    printk(KERN_INFO \"=== I/O METHODS COMPARISON ===\");\n    printk(KERN_INFO \"Programmed I/O: %lu microseconds\\n\", perf_test.programmed_io_time);\n    printk(KERN_INFO \"DMA simulation: %lu microseconds\\n\", perf_test.dma_simulation_time);\n    \n    if (perf_test.programmed_io_time > perf_test.dma_simulation_time) {\n        printk(KERN_INFO \"DMA is %lu%% faster!\\n\", \n               ((perf_test.programmed_io_time - perf_test.dma_simulation_time) * 100) / \n               perf_test.programmed_io_time);\n    }\n    \n    printk(KERN_INFO \"\\nProgrammed I/O characteristics:\\n\");\n    printk(KERN_INFO \"- CPU is busy during entire transfer\\n\");\n    printk(KERN_INFO \"- Simple to implement\\n\");\n    printk(KERN_INFO \"- Good for small transfers\\n\");\n    printk(KERN_INFO \"- CPU utilization: 100%%\\n\");\n    \n    printk(KERN_INFO \"\\nDMA characteristics:\\n\");\n    printk(KERN_INFO \"- CPU is free during transfer\\n\");\n    printk(KERN_INFO \"- Complex to implement\\n\");\n    printk(KERN_INFO \"- Good for large transfers\\n\");\n    printk(KERN_INFO \"- CPU utilization: Low\\n\");\n}\n\n// TODO: Explain DMA requirements\nstatic void explain_dma_requirements(void)\n{\n    printk(KERN_INFO \"=== DMA REQUIREMENTS ===\");\n    printk(KERN_INFO \"For DMA to work correctly, memory must be:\\n\");\n    \n    printk(KERN_INFO \"1. Physically contiguous\\n\");\n    printk(KERN_INFO \"   - DMA controller uses physical addresses\\n\");\n    printk(KERN_INFO \"   - Virtual memory may be fragmented\\n\");\n    \n    printk(KERN_INFO \"2. Cache coherent\\n\");\n    printk(KERN_INFO \"   - CPU and DMA must see same data\\n\");\n    printk(KERN_INFO \"   - Requires cache management\\n\");\n    \n    printk(KERN_INFO \"3. Accessible to device\\n\");\n    printk(KERN_INFO \"   - Within device's addressing range\\n\");\n    printk(KERN_INFO \"   - Some devices have 32-bit limitations\\n\");\n    \n    printk(KERN_INFO \"4. Properly aligned\\n\");\n    printk(KERN_INFO \"   - Many devices require specific alignment\\n\");\n    printk(KERN_INFO \"   - Usually cache line or page aligned\\n\");\n}\n\n// TODO: Explain bus addresses vs virtual addresses\nstatic void explain_address_types(void)\n{\n    void *virtual_addr;\n    \n    printk(KERN_INFO \"=== ADDRESS TYPES IN DMA ===\");\n    \n    virtual_addr = kmalloc(1024, GFP_KERNEL);\n    if (virtual_addr) {\n        printk(KERN_INFO \"Virtual address: %p\\n\", virtual_addr);\n        printk(KERN_INFO \"Physical address: %llx\\n\", \n               (unsigned long long)virt_to_phys(virtual_addr));\n        \n        kfree(virtual_addr);\n    }\n    \n    printk(KERN_INFO \"\\nAddress types:\\n\");\n    printk(KERN_INFO \"1. Virtual Address\\n\");\n    printk(KERN_INFO \"   - What CPU/kernel sees\\n\");\n    printk(KERN_INFO \"   - Managed by MMU\\n\");\n    printk(KERN_INFO \"   - May not be contiguous\\n\");\n    \n    printk(KERN_INFO \"2. Physical Address\\n\");\n    printk(KERN_INFO \"   - Real RAM address\\n\");\n    printk(KERN_INFO \"   - What DMA controller needs\\n\");\n    printk(KERN_INFO \"   - Must be contiguous for DMA\\n\");\n    \n    printk(KERN_INFO \"3. Bus Address (dma_addr_t)\\n\");\n    printk(KERN_INFO \"   - Address as seen by device\\n\");\n    printk(KERN_INFO \"   - May differ from physical address\\n\");\n    printk(KERN_INFO \"   - Handled by IOMMU if present\\n\");\n}\n\n// TODO: Explain DMA directions\nstatic void explain_dma_directions(void)\n{\n    printk(KERN_INFO \"=== DMA TRANSFER DIRECTIONS ===\");\n    printk(KERN_INFO \"DMA transfers can be:\\n\");\n    \n    printk(KERN_INFO \"1. DMA_TO_DEVICE\\n\");\n    printk(KERN_INFO \"   - Memory -> Device\\n\");\n    printk(KERN_INFO \"   - Example: Sending data to network card\\n\");\n    \n    printk(KERN_INFO \"2. DMA_FROM_DEVICE\\n\");\n    printk(KERN_INFO \"   - Device -> Memory\\n\");\n    printk(KERN_INFO \"   - Example: Receiving data from network card\\n\");\n    \n    printk(KERN_INFO \"3. DMA_BIDIRECTIONAL\\n\");\n    printk(KERN_INFO \"   - Both directions\\n\");\n    printk(KERN_INFO \"   - Example: Disk I/O\\n\");\n    \n    printk(KERN_INFO \"Next lesson: Implementing actual DMA operations\\n\");\n}\n\nstatic int __init dma_concepts_init(void)\n{\n    printk(KERN_INFO \"DMA concepts module loaded\\n\");\n    printk(KERN_INFO \"Learning Direct Memory Access fundamentals\\n\");\n    \n    // Allocate test buffers\n    perf_test.buffer_size = 1024;\n    perf_test.source_buffer = kmalloc(perf_test.buffer_size, GFP_KERNEL);\n    perf_test.dest_buffer = kmalloc(perf_test.buffer_size, GFP_KERNEL);\n    \n    if (!perf_test.source_buffer || !perf_test.dest_buffer) {\n        printk(KERN_ERR \"Failed to allocate test buffers\\n\");\n        kfree(perf_test.source_buffer);\n        kfree(perf_test.dest_buffer);\n        return -ENOMEM;\n    }\n    \n    // Initialize source buffer with test data\n    memset(perf_test.source_buffer, 0xAA, perf_test.buffer_size);\n    memset(perf_test.dest_buffer, 0x00, perf_test.buffer_size);\n    \n    // Run demonstrations\n    explain_dma_requirements();\n    explain_address_types();\n    explain_dma_directions();\n    simulate_programmed_io();\n    simulate_dma_transfer();\n    compare_io_methods();\n    \n    return 0;\n}\n\nstatic void __exit dma_concepts_exit(void)\n{\n    // Clean up timer if still active\n    del_timer_sync(&dma_simulation_timer);\n    \n    // Free test buffers\n    kfree(perf_test.source_buffer);\n    kfree(perf_test.dest_buffer);\n    \n    printk(KERN_INFO \"DMA concepts module unloaded\\n\");\n    printk(KERN_INFO \"Remember: DMA needs special memory management!\\n\");\n}\n\nmodule_init(dma_concepts_init);\nmodule_exit(dma_concepts_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Direct Memory Access concepts and fundamentals\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "dma",
      "direct_memory_access",
      "programmed_io",
      "bus_addresses",
      "dma_coherency"
    ],
    "skills": [
      "dma_concepts",
      "hardware_understanding",
      "io_performance"
    ],
    "inputOutput": {
      "expectedOutput": [
        "DMA concepts module loaded",
        "Learning Direct Memory Access fundamentals",
        "=== PROGRAMMED I/O SIMULATION ===",
        "CPU manually transfers data byte by byte",
        "=== DMA SIMULATION ===",
        "DMA controller transfers data while CPU does other work",
        "=== I/O METHODS COMPARISON ===",
        "=== DMA REQUIREMENTS ===",
        "=== ADDRESS TYPES IN DMA ===",
        "=== DMA TRANSFER DIRECTIONS ===",
        "Remember: DMA needs special memory management!"
      ],
      "requirements": [
        "Use required function names: dma_concepts_init, dma_concepts_exit, simulate_programmed_io, dma_simulation_callback, simulate_dma_transfer, compare_io_methods, explain_dma_requirements, explain_address_types, explain_dma_directions",
        "Use required variable names: perf_test, dma_simulation_timer, dma_transfer_complete, dma_bytes_transferred",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/slab.h, linux/timer.h, linux/jiffies.h",
        "Code must contain: virt_to_phys, timer_setup, mod_timer, del_timer_sync, ktime_get, memcpy"
      ]
    }
  },
  {
    "id": 49,
    "title": "DMA Operations and Coherent Memory",
    "difficulty": 10,
    "xp": 100,
    "phase": "kernel_core",
    "description": "Implement DMA (Direct Memory Access) operations with coherent memory allocation and proper cache management. This teaches advanced memory management and DMA techniques critical for high-performance device drivers.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmapool.h>\n#include <linux/platform_device.h>\n#include <linux/completion.h>\n#include <linux/timer.h>\n#include <linux/jiffies.h>\n\n#define DEVICE_NAME \"dmadev\"\n#define CLASS_NAME \"dmaclass\"\n#define DMA_BUFFER_SIZE 4096\n#define MAX_DMA_TRANSFERS 8\n#define DMA_POOL_SIZE 1024\n#define DMA_POOL_ALIGN 64\n\n// TODO: DMA transfer descriptor\nstruct dma_transfer {\n    struct list_head list;\n    void *cpu_addr;          // CPU virtual address\n    dma_addr_t dma_addr;     // Bus address for DMA\n    size_t size;\n    enum dma_data_direction direction;\n    struct completion completion;\n    int transfer_id;\n    unsigned long start_jiffies;\n    bool completed;\n};\n\n// TODO: DMA statistics\nstruct dma_stats {\n    unsigned long transfers_started;\n    unsigned long transfers_completed;\n    unsigned long transfers_failed;\n    unsigned long coherent_allocs;\n    unsigned long streaming_maps;\n    unsigned long cache_syncs;\n    unsigned long total_bytes_transferred;\n};\n\n// TODO: Device structure\nstruct dma_device {\n    struct cdev cdev;\n    struct device *device;\n    struct class *class;\n    dev_t dev_num;\n    \n    // Platform device for DMA operations\n    struct platform_device *pdev;\n    \n    // DMA management\n    void *coherent_buffer;\n    dma_addr_t coherent_dma_addr;\n    size_t coherent_size;\n    \n    struct dma_pool *dma_pool;\n    \n    // Transfer management\n    struct list_head active_transfers;\n    struct list_head completed_transfers;\n    struct mutex transfer_mutex;\n    atomic_t next_transfer_id;\n    \n    // Simulation\n    struct timer_list dma_completion_timer;\n    \n    // Statistics\n    struct dma_stats stats;\n    \n    // User buffer for data\n    char *user_buffer;\n    size_t buffer_used;\n};\n\nstatic struct dma_device dma_dev;\n\n// TODO: DMA completion simulation timer\nstatic void dma_completion_timer_callback(struct timer_list *timer)\n{\n    struct dma_device *dev = container_of(timer, struct dma_device, dma_completion_timer);\n    struct dma_transfer *transfer, *tmp;\n    bool found_active = false;\n    \n    mutex_lock(&dev->transfer_mutex);\n    \n    // Simulate completion of oldest active transfer\n    list_for_each_entry_safe(transfer, tmp, &dev->active_transfers, list) {\n        if (jiffies - transfer->start_jiffies >= msecs_to_jiffies(2000)) {\n            // Mark transfer as completed\n            transfer->completed = true;\n            complete(&transfer->completion);\n            \n            // Move to completed list\n            list_del(&transfer->list);\n            list_add_tail(&transfer->list, &dev->completed_transfers);\n            \n            dev->stats.transfers_completed++;\n            dev->stats.total_bytes_transferred += transfer->size;\n            \n            printk(KERN_INFO \"DMA transfer %d completed (size: %zu, direction: %d)\\n\",\n                   transfer->transfer_id, transfer->size, transfer->direction);\n            \n            break;\n        }\n        found_active = true;\n    }\n    \n    mutex_unlock(&dev->transfer_mutex);\n    \n    // Restart timer if there are still active transfers\n    if (found_active) {\n        mod_timer(&dev->dma_completion_timer, jiffies + msecs_to_jiffies(500));\n    }\n}\n\n// TODO: Allocate coherent DMA memory\nstatic int allocate_coherent_memory(struct dma_device *dev)\n{\n    dev->coherent_size = DMA_BUFFER_SIZE;\n    \n    // Allocate coherent memory (uncached, suitable for DMA)\n    dev->coherent_buffer = dma_alloc_coherent(&dev->pdev->dev,\n                                             dev->coherent_size,\n                                             &dev->coherent_dma_addr,\n                                             GFP_KERNEL);\n    \n    if (!dev->coherent_buffer) {\n        printk(KERN_ERR \"Failed to allocate coherent DMA memory\\n\");\n        return -ENOMEM;\n    }\n    \n    dev->stats.coherent_allocs++;\n    \n    printk(KERN_INFO \"Allocated coherent memory: CPU addr=%p, DMA addr=0x%llx, size=%zu\\n\",\n           dev->coherent_buffer, (unsigned long long)dev->coherent_dma_addr, dev->coherent_size);\n    \n    // Initialize buffer with pattern\n    memset(dev->coherent_buffer, 0xAA, dev->coherent_size);\n    \n    return 0;\n}\n\n// TODO: Free coherent DMA memory\nstatic void free_coherent_memory(struct dma_device *dev)\n{\n    if (dev->coherent_buffer) {\n        dma_free_coherent(&dev->pdev->dev,\n                         dev->coherent_size,\n                         dev->coherent_buffer,\n                         dev->coherent_dma_addr);\n        dev->coherent_buffer = NULL;\n    }\n}\n\n// TODO: Start a DMA transfer\nstatic struct dma_transfer *start_dma_transfer(struct dma_device *dev,\n                                              void *data, size_t size,\n                                              enum dma_data_direction direction)\n{\n    struct dma_transfer *transfer;\n    void *pool_addr;\n    dma_addr_t pool_dma_addr;\n    \n    if (size > DMA_POOL_SIZE) {\n        printk(KERN_ERR \"Transfer size %zu exceeds pool size %d\\n\", size, DMA_POOL_SIZE);\n        return ERR_PTR(-EINVAL);\n    }\n    \n    // Allocate transfer descriptor\n    transfer = kzalloc(sizeof(*transfer), GFP_KERNEL);\n    if (!transfer) {\n        return ERR_PTR(-ENOMEM);\n    }\n    \n    // Allocate DMA pool memory\n    pool_addr = dma_pool_alloc(dev->dma_pool, GFP_KERNEL, &pool_dma_addr);\n    if (!pool_addr) {\n        kfree(transfer);\n        return ERR_PTR(-ENOMEM);\n    }\n    \n    // Initialize transfer\n    transfer->cpu_addr = pool_addr;\n    transfer->dma_addr = pool_dma_addr;\n    transfer->size = size;\n    transfer->direction = direction;\n    transfer->transfer_id = atomic_inc_return(&dev->next_transfer_id);\n    transfer->start_jiffies = jiffies;\n    transfer->completed = false;\n    init_completion(&transfer->completion);\n    \n    // Copy data for TO_DEVICE transfers\n    if (direction == DMA_TO_DEVICE && data) {\n        memcpy(pool_addr, data, size);\n    }\n    \n    // Map for DMA (streaming mapping)\n    dma_sync_single_for_device(&dev->pdev->dev,\n                              pool_dma_addr,\n                              size,\n                              direction);\n    \n    dev->stats.streaming_maps++;\n    dev->stats.cache_syncs++;\n    \n    mutex_lock(&dev->transfer_mutex);\n    list_add_tail(&transfer->list, &dev->active_transfers);\n    dev->stats.transfers_started++;\n    mutex_unlock(&dev->transfer_mutex);\n    \n    // Start completion timer if not already running\n    if (!timer_pending(&dev->dma_completion_timer)) {\n        mod_timer(&dev->dma_completion_timer, jiffies + msecs_to_jiffies(500));\n    }\n    \n    printk(KERN_INFO \"Started DMA transfer %d: addr=0x%llx, size=%zu, direction=%d\\n\",\n           transfer->transfer_id, (unsigned long long)pool_dma_addr, size, direction);\n    \n    return transfer;\n}\n\n// TODO: Wait for DMA transfer completion\nstatic int wait_for_transfer(struct dma_device *dev, struct dma_transfer *transfer,\n                           void *user_data, size_t user_size)\n{\n    int ret;\n    \n    // Wait for completion (with timeout)\n    ret = wait_for_completion_timeout(&transfer->completion, msecs_to_jiffies(5000));\n    if (ret == 0) {\n        printk(KERN_ERR \"DMA transfer %d timed out\\n\", transfer->transfer_id);\n        dev->stats.transfers_failed++;\n        return -ETIMEDOUT;\n    }\n    \n    // Sync cache after DMA completion\n    dma_sync_single_for_cpu(&dev->pdev->dev,\n                           transfer->dma_addr,\n                           transfer->size,\n                           transfer->direction);\n    \n    dev->stats.cache_syncs++;\n    \n    // Copy data for FROM_DEVICE transfers\n    if (transfer->direction == DMA_FROM_DEVICE && user_data) {\n        size_t copy_size = min(user_size, transfer->size);\n        memcpy(user_data, transfer->cpu_addr, copy_size);\n    }\n    \n    printk(KERN_INFO \"DMA transfer %d completed successfully\\n\", transfer->transfer_id);\n    return 0;\n}\n\n// TODO: Cleanup completed transfer\nstatic void cleanup_transfer(struct dma_device *dev, struct dma_transfer *transfer)\n{\n    mutex_lock(&dev->transfer_mutex);\n    list_del(&transfer->list);\n    mutex_unlock(&dev->transfer_mutex);\n    \n    // Free DMA pool memory\n    dma_pool_free(dev->dma_pool, transfer->cpu_addr, transfer->dma_addr);\n    kfree(transfer);\n}\n\nstatic int device_open(struct inode *inode, struct file *file)\n{\n    file->private_data = &dma_dev;\n    printk(KERN_INFO \"DMA device opened\\n\");\n    return 0;\n}\n\nstatic int device_release(struct inode *inode, struct file *file)\n{\n    printk(KERN_INFO \"DMA device closed\\n\");\n    return 0;\n}\n\n// TODO: Read function using DMA\nstatic ssize_t device_read(struct file *file, char __user *user_buffer,\n                          size_t count, loff_t *offset)\n{\n    struct dma_device *dev = file->private_data;\n    struct dma_transfer *transfer;\n    char *temp_buffer;\n    ssize_t bytes_read = 0;\n    int ret;\n    \n    if (count == 0) {\n        return 0;\n    }\n    \n    count = min(count, (size_t)DMA_POOL_SIZE);\n    \n    temp_buffer = kzalloc(count, GFP_KERNEL);\n    if (!temp_buffer) {\n        return -ENOMEM;\n    }\n    \n    // Start DMA transfer from device (simulated read from coherent buffer)\n    memcpy(temp_buffer, dev->coherent_buffer, min(count, dev->coherent_size));\n    \n    transfer = start_dma_transfer(dev, temp_buffer, count, DMA_FROM_DEVICE);\n    if (IS_ERR(transfer)) {\n        kfree(temp_buffer);\n        return PTR_ERR(transfer);\n    }\n    \n    // Wait for transfer completion\n    ret = wait_for_transfer(dev, transfer, temp_buffer, count);\n    if (ret) {\n        cleanup_transfer(dev, transfer);\n        kfree(temp_buffer);\n        return ret;\n    }\n    \n    // Copy to user space\n    if (copy_to_user(user_buffer, temp_buffer, count)) {\n        cleanup_transfer(dev, transfer);\n        kfree(temp_buffer);\n        return -EFAULT;\n    }\n    \n    bytes_read = count;\n    cleanup_transfer(dev, transfer);\n    kfree(temp_buffer);\n    \n    printk(KERN_INFO \"DMA read completed: %zu bytes\\n\", bytes_read);\n    return bytes_read;\n}\n\n// TODO: Write function using DMA\nstatic ssize_t device_write(struct file *file, const char __user *user_buffer,\n                           size_t count, loff_t *offset)\n{\n    struct dma_device *dev = file->private_data;\n    struct dma_transfer *transfer;\n    char *temp_buffer;\n    ssize_t bytes_written = 0;\n    int ret;\n    \n    if (count == 0) {\n        return 0;\n    }\n    \n    count = min(count, (size_t)DMA_POOL_SIZE);\n    \n    temp_buffer = kzalloc(count, GFP_KERNEL);\n    if (!temp_buffer) {\n        return -ENOMEM;\n    }\n    \n    // Copy from user space\n    if (copy_from_user(temp_buffer, user_buffer, count)) {\n        kfree(temp_buffer);\n        return -EFAULT;\n    }\n    \n    // Start DMA transfer to device\n    transfer = start_dma_transfer(dev, temp_buffer, count, DMA_TO_DEVICE);\n    if (IS_ERR(transfer)) {\n        kfree(temp_buffer);\n        return PTR_ERR(transfer);\n    }\n    \n    // Wait for transfer completion\n    ret = wait_for_transfer(dev, transfer, NULL, 0);\n    if (ret) {\n        cleanup_transfer(dev, transfer);\n        kfree(temp_buffer);\n        return ret;\n    }\n    \n    // Simulate writing to coherent buffer\n    memcpy(dev->coherent_buffer, temp_buffer, min(count, dev->coherent_size));\n    \n    bytes_written = count;\n    cleanup_transfer(dev, transfer);\n    kfree(temp_buffer);\n    \n    printk(KERN_INFO \"DMA write completed: %zu bytes\\n\", bytes_written);\n    return bytes_written;\n}\n\nstatic const struct file_operations dma_dev_fops = {\n    .owner = THIS_MODULE,\n    .open = device_open,\n    .release = device_release,\n    .read = device_read,\n    .write = device_write,\n};\n\nstatic int __init dma_dev_init(void)\n{\n    int ret;\n    \n    printk(KERN_INFO \"DMA device driver initializing...\\n\");\n    \n    // TODO: Initialize device structure\n    memset(&dma_dev, 0, sizeof(dma_dev));\n    mutex_init(&dma_dev.transfer_mutex);\n    INIT_LIST_HEAD(&dma_dev.active_transfers);\n    INIT_LIST_HEAD(&dma_dev.completed_transfers);\n    atomic_set(&dma_dev.next_transfer_id, 0);\n    \n    // TODO: Create platform device for DMA operations\n    dma_dev.pdev = platform_device_register_simple(\"dma-demo\", -1, NULL, 0);\n    if (IS_ERR(dma_dev.pdev)) {\n        return PTR_ERR(dma_dev.pdev);\n    }\n    \n    // TODO: Set DMA mask\n    ret = dma_set_mask_and_coherent(&dma_dev.pdev->dev, DMA_BIT_MASK(32));\n    if (ret) {\n        platform_device_unregister(dma_dev.pdev);\n        return ret;\n    }\n    \n    // TODO: Allocate coherent memory\n    ret = allocate_coherent_memory(&dma_dev);\n    if (ret) {\n        platform_device_unregister(dma_dev.pdev);\n        return ret;\n    }\n    \n    // TODO: Create DMA pool\n    dma_dev.dma_pool = dma_pool_create(\"demo_pool\",\n                                      &dma_dev.pdev->dev,\n                                      DMA_POOL_SIZE,\n                                      DMA_POOL_ALIGN,\n                                      0);\n    if (!dma_dev.dma_pool) {\n        free_coherent_memory(&dma_dev);\n        platform_device_unregister(dma_dev.pdev);\n        return -ENOMEM;\n    }\n    \n    // TODO: Initialize timer\n    timer_setup(&dma_dev.dma_completion_timer, dma_completion_timer_callback, 0);\n    \n    // TODO: Allocate user buffer\n    dma_dev.user_buffer = kzalloc(DMA_BUFFER_SIZE, GFP_KERNEL);\n    if (!dma_dev.user_buffer) {\n        dma_pool_destroy(dma_dev.dma_pool);\n        free_coherent_memory(&dma_dev);\n        platform_device_unregister(dma_dev.pdev);\n        return -ENOMEM;\n    }\n    \n    // TODO: Register character device\n    ret = alloc_chrdev_region(&dma_dev.dev_num, 0, 1, DEVICE_NAME);\n    if (ret < 0) {\n        kfree(dma_dev.user_buffer);\n        dma_pool_destroy(dma_dev.dma_pool);\n        free_coherent_memory(&dma_dev);\n        platform_device_unregister(dma_dev.pdev);\n        return ret;\n    }\n    \n    cdev_init(&dma_dev.cdev, &dma_dev_fops);\n    dma_dev.cdev.owner = THIS_MODULE;\n    \n    ret = cdev_add(&dma_dev.cdev, dma_dev.dev_num, 1);\n    if (ret < 0) {\n        unregister_chrdev_region(dma_dev.dev_num, 1);\n        kfree(dma_dev.user_buffer);\n        dma_pool_destroy(dma_dev.dma_pool);\n        free_coherent_memory(&dma_dev);\n        platform_device_unregister(dma_dev.pdev);\n        return ret;\n    }\n    \n    // TODO: Create device class and device\n    dma_dev.class = class_create(THIS_MODULE, CLASS_NAME);\n    if (IS_ERR(dma_dev.class)) {\n        cdev_del(&dma_dev.cdev);\n        unregister_chrdev_region(dma_dev.dev_num, 1);\n        kfree(dma_dev.user_buffer);\n        dma_pool_destroy(dma_dev.dma_pool);\n        free_coherent_memory(&dma_dev);\n        platform_device_unregister(dma_dev.pdev);\n        return PTR_ERR(dma_dev.class);\n    }\n    \n    dma_dev.device = device_create(dma_dev.class, NULL, dma_dev.dev_num,\n                                  NULL, DEVICE_NAME);\n    if (IS_ERR(dma_dev.device)) {\n        class_destroy(dma_dev.class);\n        cdev_del(&dma_dev.cdev);\n        unregister_chrdev_region(dma_dev.dev_num, 1);\n        kfree(dma_dev.user_buffer);\n        dma_pool_destroy(dma_dev.dma_pool);\n        free_coherent_memory(&dma_dev);\n        platform_device_unregister(dma_dev.pdev);\n        return PTR_ERR(dma_dev.device);\n    }\n    \n    printk(KERN_INFO \"DMA device driver loaded successfully\\n\");\n    printk(KERN_INFO \"Device: /dev/%s with DMA support\\n\", DEVICE_NAME);\n    printk(KERN_INFO \"Coherent buffer: %zu bytes, DMA pool: %d bytes\\n\",\n           dma_dev.coherent_size, DMA_POOL_SIZE);\n    \n    return 0;\n}\n\nstatic void __exit dma_dev_exit(void)\n{\n    struct dma_transfer *transfer, *tmp;\n    \n    printk(KERN_INFO \"DMA device driver unloading...\\n\");\n    \n    // TODO: Stop timer and clean up transfers\n    del_timer_sync(&dma_dev.dma_completion_timer);\n    \n    // TODO: Clean up any remaining transfers\n    mutex_lock(&dma_dev.transfer_mutex);\n    list_for_each_entry_safe(transfer, tmp, &dma_dev.active_transfers, list) {\n        list_del(&transfer->list);\n        dma_pool_free(dma_dev.dma_pool, transfer->cpu_addr, transfer->dma_addr);\n        kfree(transfer);\n    }\n    list_for_each_entry_safe(transfer, tmp, &dma_dev.completed_transfers, list) {\n        list_del(&transfer->list);\n        dma_pool_free(dma_dev.dma_pool, transfer->cpu_addr, transfer->dma_addr);\n        kfree(transfer);\n    }\n    mutex_unlock(&dma_dev.transfer_mutex);\n    \n    // TODO: Clean up device\n    device_destroy(dma_dev.class, dma_dev.dev_num);\n    class_destroy(dma_dev.class);\n    cdev_del(&dma_dev.cdev);\n    unregister_chrdev_region(dma_dev.dev_num, 1);\n    \n    // TODO: Clean up DMA resources\n    kfree(dma_dev.user_buffer);\n    dma_pool_destroy(dma_dev.dma_pool);\n    free_coherent_memory(&dma_dev);\n    platform_device_unregister(dma_dev.pdev);\n    \n    printk(KERN_INFO \"DMA device driver unloaded\\n\");\n    printk(KERN_INFO \"Final DMA stats - Started: %lu, Completed: %lu, Failed: %lu, Bytes: %lu\\n\",\n           dma_dev.stats.transfers_started, dma_dev.stats.transfers_completed,\n           dma_dev.stats.transfers_failed, dma_dev.stats.total_bytes_transferred);\n}\n\nmodule_init(dma_dev_init);\nmodule_exit(dma_dev_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Character device with DMA operations\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "DMA",
      "coherent_memory",
      "cache_coherency",
      "bus_addresses",
      "dma_mapping",
      "streaming_dma"
    ],
    "skills": [
      "dma_programming",
      "memory_coherency",
      "cache_management",
      "bus_architecture",
      "high_performance_io"
    ],
    "inputOutput": {
      "expectedOutput": [
        "DMA device driver loaded successfully",
        "Device: /dev/dmadev with DMA support",
        "Coherent buffer:",
        "bytes, DMA pool:",
        "DMA device driver unloaded",
        "Final DMA stats - Started:"
      ],
      "requirements": [
        "Use required function names: dma_dev_init, dma_dev_exit, allocate_coherent_memory, free_coherent_memory, start_dma_transfer, wait_for_transfer, cleanup_transfer, dma_completion_timer_callback",
        "Use required variable names: dma_dev, dma_dev_fops",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/dma-mapping.h, linux/dmapool.h, linux/platform_device.h, linux/completion.h",
        "Code must contain: dma_alloc_coherent, dma_free_coherent, dma_pool_create, dma_pool_alloc, dma_pool_free, dma_sync_single_for_device, dma_sync_single_for_cpu, dma_set_mask_and_coherent, DMA_TO_DEVICE, DMA_FROM_DEVICE"
      ]
    }
  },
  {
    "id": 50,
    "title": "Device Power Management and Runtime PM",
    "difficulty": 8,
    "xp": 80,
    "phase": "kernel_core",
    "description": "Implement device power management with runtime power management support, including suspend/resume operations and power state transitions. This teaches power management techniques essential for mobile and embedded device drivers.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/platform_device.h>\n#include <linux/timer.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n\n#define DEVICE_NAME \"pmdev\"\n#define CLASS_NAME \"pmclass\"\n#define BUFFER_SIZE 1024\n#define IDLE_TIMEOUT_MS 5000\n\n// TODO: Power states enumeration\nenum pm_device_state {\n    PM_STATE_ACTIVE,\n    PM_STATE_IDLE,\n    PM_STATE_SUSPENDED,\n    PM_STATE_OFF\n};\n\n// TODO: Power statistics\nstruct pm_stats {\n    unsigned long suspend_count;\n    unsigned long resume_count;\n    unsigned long runtime_suspend_count;\n    unsigned long runtime_resume_count;\n    unsigned long idle_count;\n    unsigned long active_time_ms;\n    unsigned long suspended_time_ms;\n    unsigned long last_activity_jiffies;\n    unsigned long state_change_count;\n};\n\n// TODO: Device structure with power management\nstruct pm_device {\n    struct cdev cdev;\n    struct device *device;\n    struct class *class;\n    dev_t dev_num;\n    \n    // Platform device for PM operations\n    struct platform_device *pdev;\n    \n    // Power management state\n    enum pm_device_state current_state;\n    enum pm_device_state previous_state;\n    struct mutex pm_mutex;\n    \n    // Runtime PM\n    bool runtime_pm_enabled;\n    struct timer_list idle_timer;\n    struct work_struct suspend_work;\n    \n    // Device data\n    char *buffer;\n    size_t buffer_used;\n    struct mutex device_mutex;\n    \n    // Statistics\n    struct pm_stats stats;\n    unsigned long state_enter_jiffies;\n    \n    // Configuration\n    bool auto_suspend_enabled;\n    int auto_suspend_delay_ms;\n};\n\nstatic struct pm_device pm_dev;\n\n// TODO: State transition helper\nstatic void pm_change_state(struct pm_device *dev, enum pm_device_state new_state)\n{\n    unsigned long now = jiffies;\n    unsigned long duration;\n    \n    mutex_lock(&dev->pm_mutex);\n    \n    if (dev->current_state == new_state) {\n        mutex_unlock(&dev->pm_mutex);\n        return;\n    }\n    \n    // Calculate time in previous state\n    duration = jiffies_to_msecs(now - dev->state_enter_jiffies);\n    \n    switch (dev->current_state) {\n    case PM_STATE_ACTIVE:\n        dev->stats.active_time_ms += duration;\n        break;\n    case PM_STATE_SUSPENDED:\n        dev->stats.suspended_time_ms += duration;\n        break;\n    default:\n        break;\n    }\n    \n    dev->previous_state = dev->current_state;\n    dev->current_state = new_state;\n    dev->state_enter_jiffies = now;\n    dev->stats.state_change_count++;\n    \n    printk(KERN_INFO \"Power state changed: %d -> %d (duration: %lu ms)\\n\",\n           dev->previous_state, new_state, duration);\n    \n    mutex_unlock(&dev->pm_mutex);\n}\n\n// TODO: Update activity timestamp\nstatic void pm_update_activity(struct pm_device *dev)\n{\n    dev->stats.last_activity_jiffies = jiffies;\n    \n    // Mark device as active for runtime PM\n    if (dev->runtime_pm_enabled && dev->pdev) {\n        pm_runtime_mark_last_busy(&dev->pdev->dev);\n        \n        // Request resume if suspended\n        if (dev->current_state == PM_STATE_SUSPENDED) {\n            pm_runtime_get_sync(&dev->pdev->dev);\n        }\n    }\n}\n\n// TODO: Idle timer callback\nstatic void idle_timer_callback(struct timer_list *timer)\n{\n    struct pm_device *dev = container_of(timer, struct pm_device, idle_timer);\n    unsigned long inactive_time;\n    \n    inactive_time = jiffies - dev->stats.last_activity_jiffies;\n    \n    if (jiffies_to_msecs(inactive_time) >= dev->auto_suspend_delay_ms) {\n        if (dev->current_state == PM_STATE_ACTIVE) {\n            pm_change_state(dev, PM_STATE_IDLE);\n            dev->stats.idle_count++;\n            \n            // Schedule suspend work\n            if (dev->auto_suspend_enabled) {\n                schedule_work(&dev->suspend_work);\n            }\n        }\n    } else {\n        // Restart timer\n        mod_timer(&dev->idle_timer, jiffies + msecs_to_jiffies(1000));\n    }\n}\n\n// TODO: Suspend work function\nstatic void suspend_work_handler(struct work_struct *work)\n{\n    struct pm_device *dev = container_of(work, struct pm_device, suspend_work);\n    \n    if (dev->current_state == PM_STATE_IDLE && dev->runtime_pm_enabled) {\n        // Request runtime suspend\n        pm_runtime_put_sync(&dev->pdev->dev);\n    }\n}\n\n// TODO: Runtime suspend callback\nstatic int pm_runtime_suspend(struct device *device)\n{\n    struct platform_device *pdev = to_platform_device(device);\n    struct pm_device *dev = platform_get_drvdata(pdev);\n    \n    printk(KERN_INFO \"Runtime suspend called\\n\");\n    \n    if (dev->current_state == PM_STATE_SUSPENDED) {\n        return 0;\n    }\n    \n    // Simulate device power down\n    pm_change_state(dev, PM_STATE_SUSPENDED);\n    dev->stats.runtime_suspend_count++;\n    \n    // Stop idle timer\n    del_timer_sync(&dev->idle_timer);\n    \n    printk(KERN_INFO \"Device runtime suspended\\n\");\n    return 0;\n}\n\n// TODO: Runtime resume callback\nstatic int pm_runtime_resume(struct device *device)\n{\n    struct platform_device *pdev = to_platform_device(device);\n    struct pm_device *dev = platform_get_drvdata(pdev);\n    \n    printk(KERN_INFO \"Runtime resume called\\n\");\n    \n    if (dev->current_state == PM_STATE_ACTIVE) {\n        return 0;\n    }\n    \n    // Simulate device power up\n    pm_change_state(dev, PM_STATE_ACTIVE);\n    dev->stats.runtime_resume_count++;\n    \n    // Update activity and restart idle timer\n    pm_update_activity(dev);\n    \n    if (dev->auto_suspend_enabled) {\n        mod_timer(&dev->idle_timer, jiffies + msecs_to_jiffies(1000));\n    }\n    \n    printk(KERN_INFO \"Device runtime resumed\\n\");\n    return 0;\n}\n\n// TODO: System suspend callback\nstatic int pm_suspend(struct device *device)\n{\n    struct platform_device *pdev = to_platform_device(device);\n    struct pm_device *dev = platform_get_drvdata(pdev);\n    \n    printk(KERN_INFO \"System suspend called\\n\");\n    \n    mutex_lock(&dev->device_mutex);\n    \n    // Save device state and power down\n    pm_change_state(dev, PM_STATE_SUSPENDED);\n    dev->stats.suspend_count++;\n    \n    // Stop timers and work\n    del_timer_sync(&dev->idle_timer);\n    cancel_work_sync(&dev->suspend_work);\n    \n    mutex_unlock(&dev->device_mutex);\n    \n    printk(KERN_INFO \"Device system suspended\\n\");\n    return 0;\n}\n\n// TODO: System resume callback\nstatic int pm_resume(struct device *device)\n{\n    struct platform_device *pdev = to_platform_device(device);\n    struct pm_device *dev = platform_get_drvdata(pdev);\n    \n    printk(KERN_INFO \"System resume called\\n\");\n    \n    mutex_lock(&dev->device_mutex);\n    \n    // Restore device state and power up\n    pm_change_state(dev, PM_STATE_ACTIVE);\n    dev->stats.resume_count++;\n    \n    // Update activity and restart timers if needed\n    pm_update_activity(dev);\n    \n    if (dev->auto_suspend_enabled) {\n        mod_timer(&dev->idle_timer, jiffies + msecs_to_jiffies(1000));\n    }\n    \n    mutex_unlock(&dev->device_mutex);\n    \n    printk(KERN_INFO \"Device system resumed\\n\");\n    return 0;\n}\n\n// TODO: Define power management operations\nstatic const struct dev_pm_ops pm_dev_pm_ops = {\n    .suspend = pm_suspend,\n    .resume = pm_resume,\n    .runtime_suspend = pm_runtime_suspend,\n    .runtime_resume = pm_runtime_resume,\n};\n\nstatic int device_open(struct inode *inode, struct file *file)\n{\n    struct pm_device *dev = &pm_dev;\n    \n    file->private_data = dev;\n    \n    // Mark device as active\n    pm_update_activity(dev);\n    \n    // Ensure device is resumed\n    if (dev->runtime_pm_enabled && dev->current_state == PM_STATE_SUSPENDED) {\n        pm_runtime_get_sync(&dev->pdev->dev);\n    }\n    \n    printk(KERN_INFO \"PM device opened\\n\");\n    return 0;\n}\n\nstatic int device_release(struct inode *inode, struct file *file)\n{\n    struct pm_device *dev = file->private_data;\n    \n    // Update activity timestamp\n    pm_update_activity(dev);\n    \n    // Allow device to be suspended\n    if (dev->runtime_pm_enabled) {\n        pm_runtime_put(&dev->pdev->dev);\n    }\n    \n    printk(KERN_INFO \"PM device closed\\n\");\n    return 0;\n}\n\nstatic ssize_t device_read(struct file *file, char __user *user_buffer,\n                          size_t count, loff_t *offset)\n{\n    struct pm_device *dev = file->private_data;\n    ssize_t bytes_read = 0;\n    \n    // Update activity\n    pm_update_activity(dev);\n    \n    // Ensure device is active\n    if (dev->current_state != PM_STATE_ACTIVE) {\n        if (dev->runtime_pm_enabled) {\n            int ret = pm_runtime_get_sync(&dev->pdev->dev);\n            if (ret < 0) {\n                return ret;\n            }\n        }\n    }\n    \n    mutex_lock(&dev->device_mutex);\n    \n    if (*offset >= dev->buffer_used) {\n        mutex_unlock(&dev->device_mutex);\n        goto out;\n    }\n    \n    bytes_read = min(count, dev->buffer_used - *offset);\n    \n    if (copy_to_user(user_buffer, dev->buffer + *offset, bytes_read)) {\n        mutex_unlock(&dev->device_mutex);\n        bytes_read = -EFAULT;\n        goto out;\n    }\n    \n    *offset += bytes_read;\n    \n    mutex_unlock(&dev->device_mutex);\n    \n    printk(KERN_INFO \"Read %zu bytes (state: %d)\\n\", bytes_read, dev->current_state);\n    \nout:\n    if (dev->runtime_pm_enabled) {\n        pm_runtime_put(&dev->pdev->dev);\n    }\n    \n    return bytes_read;\n}\n\nstatic ssize_t device_write(struct file *file, const char __user *user_buffer,\n                           size_t count, loff_t *offset)\n{\n    struct pm_device *dev = file->private_data;\n    ssize_t bytes_written = 0;\n    \n    // Update activity\n    pm_update_activity(dev);\n    \n    // Ensure device is active\n    if (dev->current_state != PM_STATE_ACTIVE) {\n        if (dev->runtime_pm_enabled) {\n            int ret = pm_runtime_get_sync(&dev->pdev->dev);\n            if (ret < 0) {\n                return ret;\n            }\n        }\n    }\n    \n    mutex_lock(&dev->device_mutex);\n    \n    if (*offset >= BUFFER_SIZE) {\n        mutex_unlock(&dev->device_mutex);\n        bytes_written = -ENOSPC;\n        goto out;\n    }\n    \n    bytes_written = min(count, BUFFER_SIZE - *offset);\n    \n    if (copy_from_user(dev->buffer + *offset, user_buffer, bytes_written)) {\n        mutex_unlock(&dev->device_mutex);\n        bytes_written = -EFAULT;\n        goto out;\n    }\n    \n    *offset += bytes_written;\n    if (*offset > dev->buffer_used) {\n        dev->buffer_used = *offset;\n    }\n    \n    mutex_unlock(&dev->device_mutex);\n    \n    printk(KERN_INFO \"Wrote %zu bytes (state: %d)\\n\", bytes_written, dev->current_state);\n    \nout:\n    if (dev->runtime_pm_enabled) {\n        pm_runtime_put(&dev->pdev->dev);\n    }\n    \n    return bytes_written;\n}\n\nstatic const struct file_operations pm_dev_fops = {\n    .owner = THIS_MODULE,\n    .open = device_open,\n    .release = device_release,\n    .read = device_read,\n    .write = device_write,\n};\n\n// TODO: Platform driver structure\nstatic struct platform_driver pm_platform_driver = {\n    .driver = {\n        .name = \"pm-demo\",\n        .pm = &pm_dev_pm_ops,\n    },\n};\n\nstatic int __init pm_dev_init(void)\n{\n    int ret;\n    \n    printk(KERN_INFO \"Power management device initializing...\\n\");\n    \n    // TODO: Initialize device structure\n    memset(&pm_dev, 0, sizeof(pm_dev));\n    mutex_init(&pm_dev.device_mutex);\n    mutex_init(&pm_dev.pm_mutex);\n    \n    // TODO: Initialize power management state\n    pm_dev.current_state = PM_STATE_ACTIVE;\n    pm_dev.runtime_pm_enabled = true;\n    pm_dev.auto_suspend_enabled = true;\n    pm_dev.auto_suspend_delay_ms = IDLE_TIMEOUT_MS;\n    pm_dev.state_enter_jiffies = jiffies;\n    pm_dev.stats.last_activity_jiffies = jiffies;\n    \n    // TODO: Allocate buffer\n    pm_dev.buffer = kzalloc(BUFFER_SIZE, GFP_KERNEL);\n    if (!pm_dev.buffer) {\n        return -ENOMEM;\n    }\n    \n    // Initialize buffer with device info\n    pm_dev.buffer_used = snprintf(pm_dev.buffer, BUFFER_SIZE,\n                                 \"Power Management Device\\nState: Active\\nTimestamp: %lu\\n\",\n                                 jiffies);\n    \n    // TODO: Register platform driver\n    ret = platform_driver_register(&pm_platform_driver);\n    if (ret) {\n        kfree(pm_dev.buffer);\n        return ret;\n    }\n    \n    // TODO: Create platform device\n    pm_dev.pdev = platform_device_register_simple(\"pm-demo\", -1, NULL, 0);\n    if (IS_ERR(pm_dev.pdev)) {\n        platform_driver_unregister(&pm_platform_driver);\n        kfree(pm_dev.buffer);\n        return PTR_ERR(pm_dev.pdev);\n    }\n    \n    // TODO: Set driver data\n    platform_set_drvdata(pm_dev.pdev, &pm_dev);\n    \n    // TODO: Enable runtime PM\n    pm_runtime_enable(&pm_dev.pdev->dev);\n    pm_runtime_set_autosuspend_delay(&pm_dev.pdev->dev, pm_dev.auto_suspend_delay_ms);\n    pm_runtime_use_autosuspend(&pm_dev.pdev->dev);\n    \n    // TODO: Initialize timer and work\n    timer_setup(&pm_dev.idle_timer, idle_timer_callback, 0);\n    INIT_WORK(&pm_dev.suspend_work, suspend_work_handler);\n    \n    // TODO: Start idle timer\n    mod_timer(&pm_dev.idle_timer, jiffies + msecs_to_jiffies(1000));\n    \n    // TODO: Register character device\n    ret = alloc_chrdev_region(&pm_dev.dev_num, 0, 1, DEVICE_NAME);\n    if (ret < 0) {\n        del_timer_sync(&pm_dev.idle_timer);\n        pm_runtime_disable(&pm_dev.pdev->dev);\n        platform_device_unregister(pm_dev.pdev);\n        platform_driver_unregister(&pm_platform_driver);\n        kfree(pm_dev.buffer);\n        return ret;\n    }\n    \n    cdev_init(&pm_dev.cdev, &pm_dev_fops);\n    pm_dev.cdev.owner = THIS_MODULE;\n    \n    ret = cdev_add(&pm_dev.cdev, pm_dev.dev_num, 1);\n    if (ret < 0) {\n        unregister_chrdev_region(pm_dev.dev_num, 1);\n        del_timer_sync(&pm_dev.idle_timer);\n        pm_runtime_disable(&pm_dev.pdev->dev);\n        platform_device_unregister(pm_dev.pdev);\n        platform_driver_unregister(&pm_platform_driver);\n        kfree(pm_dev.buffer);\n        return ret;\n    }\n    \n    // TODO: Create device class and device\n    pm_dev.class = class_create(THIS_MODULE, CLASS_NAME);\n    if (IS_ERR(pm_dev.class)) {\n        cdev_del(&pm_dev.cdev);\n        unregister_chrdev_region(pm_dev.dev_num, 1);\n        del_timer_sync(&pm_dev.idle_timer);\n        pm_runtime_disable(&pm_dev.pdev->dev);\n        platform_device_unregister(pm_dev.pdev);\n        platform_driver_unregister(&pm_platform_driver);\n        kfree(pm_dev.buffer);\n        return PTR_ERR(pm_dev.class);\n    }\n    \n    pm_dev.device = device_create(pm_dev.class, NULL, pm_dev.dev_num,\n                                 NULL, DEVICE_NAME);\n    if (IS_ERR(pm_dev.device)) {\n        class_destroy(pm_dev.class);\n        cdev_del(&pm_dev.cdev);\n        unregister_chrdev_region(pm_dev.dev_num, 1);\n        del_timer_sync(&pm_dev.idle_timer);\n        pm_runtime_disable(&pm_dev.pdev->dev);\n        platform_device_unregister(pm_dev.pdev);\n        platform_driver_unregister(&pm_platform_driver);\n        kfree(pm_dev.buffer);\n        return PTR_ERR(pm_dev.device);\n    }\n    \n    printk(KERN_INFO \"Power management device loaded successfully\\n\");\n    printk(KERN_INFO \"Device: /dev/%s with runtime PM support\\n\", DEVICE_NAME);\n    printk(KERN_INFO \"Auto-suspend delay: %d ms\\n\", pm_dev.auto_suspend_delay_ms);\n    \n    return 0;\n}\n\nstatic void __exit pm_dev_exit(void)\n{\n    printk(KERN_INFO \"Power management device unloading...\\n\");\n    \n    // TODO: Stop timers and work\n    del_timer_sync(&pm_dev.idle_timer);\n    cancel_work_sync(&pm_dev.suspend_work);\n    \n    // TODO: Disable runtime PM\n    pm_runtime_disable(&pm_dev.pdev->dev);\n    \n    // TODO: Clean up device\n    device_destroy(pm_dev.class, pm_dev.dev_num);\n    class_destroy(pm_dev.class);\n    cdev_del(&pm_dev.cdev);\n    unregister_chrdev_region(pm_dev.dev_num, 1);\n    \n    // TODO: Clean up platform device and driver\n    platform_device_unregister(pm_dev.pdev);\n    platform_driver_unregister(&pm_platform_driver);\n    \n    kfree(pm_dev.buffer);\n    \n    printk(KERN_INFO \"Power management device unloaded\\n\");\n    printk(KERN_INFO \"PM stats - Suspend: %lu, Resume: %lu, Runtime Suspend: %lu, Runtime Resume: %lu\\n\",\n           pm_dev.stats.suspend_count, pm_dev.stats.resume_count,\n           pm_dev.stats.runtime_suspend_count, pm_dev.stats.runtime_resume_count);\n    printk(KERN_INFO \"Active time: %lu ms, Suspended time: %lu ms\\n\",\n           pm_dev.stats.active_time_ms, pm_dev.stats.suspended_time_ms);\n}\n\nmodule_init(pm_dev_init);\nmodule_exit(pm_dev_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Character device with power management support\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "power_management",
      "runtime_pm",
      "suspend_resume",
      "power_states",
      "pm_ops",
      "device_pm"
    ],
    "skills": [
      "power_management_programming",
      "runtime_pm_usage",
      "power_optimization",
      "embedded_systems"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Power management device loaded successfully",
        "Device: /dev/pmdev with runtime PM support",
        "Auto-suspend delay:",
        "Power management device unloaded",
        "PM stats - Suspend:"
      ],
      "requirements": [
        "Use required function names: pm_dev_init, pm_dev_exit, pm_runtime_suspend, pm_runtime_resume, pm_suspend, pm_resume, pm_change_state, pm_update_activity, idle_timer_callback, suspend_work_handler",
        "Use required variable names: pm_dev, pm_dev_pm_ops, pm_platform_driver",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/pm.h, linux/pm_runtime.h, linux/platform_device.h",
        "Code must contain: pm_runtime_enable, pm_runtime_disable, pm_runtime_get_sync, pm_runtime_put, pm_runtime_mark_last_busy, pm_runtime_set_autosuspend_delay, pm_runtime_use_autosuspend, dev_pm_ops, platform_driver_register, platform_device_register_simple"
      ]
    }
  },
  {
    "id": 51,
    "title": "Device Tree Integration and Platform Drivers",
    "difficulty": 8,
    "xp": 80,
    "phase": "kernel_core",
    "description": "Implement a platform driver with device tree integration, including property parsing and resource management. This teaches embedded system development techniques used in ARM-based systems and IoT devices.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_platform.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/clk.h>\n#include <linux/reset.h>\n\n#define DEVICE_NAME \"dtdev\"\n#define CLASS_NAME \"dtclass\"\n#define BUFFER_SIZE 1024\n\n// TODO: Device configuration from device tree\nstruct dt_device_config {\n    const char *device_name;\n    u32 reg_base;\n    u32 reg_size;\n    u32 clock_frequency;\n    u32 buffer_size;\n    int irq_number;\n    bool enable_debug;\n    const char *compatible;\n};\n\n// TODO: Device structure\nstruct dt_device {\n    struct platform_device *pdev;\n    struct device *char_device;\n    struct class *class;\n    struct cdev cdev;\n    dev_t dev_num;\n    \n    // Device tree configuration\n    struct dt_device_config config;\n    \n    // Resources\n    struct resource *mem_resource;\n    void __iomem *reg_base;\n    struct clk *device_clock;\n    struct reset_control *reset_control;\n    \n    // Device data\n    char *buffer;\n    size_t buffer_used;\n    struct mutex device_mutex;\n    \n    // Statistics\n    unsigned long read_count;\n    unsigned long write_count;\n    unsigned long probe_time_jiffies;\n};\n\nstatic struct dt_device *dt_dev_instance = NULL;\nstatic struct class *dt_dev_class = NULL;\n\n// TODO: Parse device tree properties\nstatic int parse_dt_properties(struct platform_device *pdev, struct dt_device_config *config)\n{\n    struct device_node *np = pdev->dev.of_node;\n    int ret;\n    \n    if (!np) {\n        dev_err(&pdev->dev, \"No device tree node found\\n\");\n        return -ENODEV;\n    }\n    \n    // TODO: Parse compatible string\n    ret = of_property_read_string(np, \"compatible\", &config->compatible);\n    if (ret) {\n        dev_err(&pdev->dev, \"Failed to read compatible property\\n\");\n        return ret;\n    }\n    \n    // TODO: Parse device name\n    ret = of_property_read_string(np, \"device-name\", &config->device_name);\n    if (ret) {\n        config->device_name = \"default-dt-device\";\n        dev_info(&pdev->dev, \"Using default device name\\n\");\n    }\n    \n    // TODO: Parse register base and size\n    ret = of_property_read_u32_index(np, \"reg\", 0, &config->reg_base);\n    if (ret) {\n        dev_err(&pdev->dev, \"Failed to read reg base\\n\");\n        return ret;\n    }\n    \n    ret = of_property_read_u32_index(np, \"reg\", 1, &config->reg_size);\n    if (ret) {\n        dev_err(&pdev->dev, \"Failed to read reg size\\n\");\n        return ret;\n    }\n    \n    // TODO: Parse optional clock frequency\n    ret = of_property_read_u32(np, \"clock-frequency\", &config->clock_frequency);\n    if (ret) {\n        config->clock_frequency = 100000000; // Default 100MHz\n        dev_info(&pdev->dev, \"Using default clock frequency: %u Hz\\n\", config->clock_frequency);\n    }\n    \n    // TODO: Parse optional buffer size\n    ret = of_property_read_u32(np, \"buffer-size\", &config->buffer_size);\n    if (ret) {\n        config->buffer_size = BUFFER_SIZE;\n        dev_info(&pdev->dev, \"Using default buffer size: %u bytes\\n\", config->buffer_size);\n    }\n    \n    // TODO: Parse debug enable flag\n    config->enable_debug = of_property_read_bool(np, \"enable-debug\");\n    \n    dev_info(&pdev->dev, \"Device tree properties parsed successfully\\n\");\n    dev_info(&pdev->dev, \"  Compatible: %s\\n\", config->compatible);\n    dev_info(&pdev->dev, \"  Device name: %s\\n\", config->device_name);\n    dev_info(&pdev->dev, \"  Register: 0x%x (size: 0x%x)\\n\", config->reg_base, config->reg_size);\n    dev_info(&pdev->dev, \"  Clock frequency: %u Hz\\n\", config->clock_frequency);\n    dev_info(&pdev->dev, \"  Buffer size: %u bytes\\n\", config->buffer_size);\n    dev_info(&pdev->dev, \"  Debug enabled: %s\\n\", config->enable_debug ? \"yes\" : \"no\");\n    \n    return 0;\n}\n\n// TODO: Setup device resources\nstatic int setup_device_resources(struct dt_device *dev)\n{\n    struct platform_device *pdev = dev->pdev;\n    int ret;\n    \n    // TODO: Get memory resource\n    dev->mem_resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n    if (!dev->mem_resource) {\n        dev_err(&pdev->dev, \"Failed to get memory resource\\n\");\n        return -ENODEV;\n    }\n    \n    // TODO: Request and map memory region\n    if (!request_mem_region(dev->mem_resource->start,\n                           resource_size(dev->mem_resource),\n                           dev_name(&pdev->dev))) {\n        dev_err(&pdev->dev, \"Failed to request memory region\\n\");\n        return -EBUSY;\n    }\n    \n    dev->reg_base = ioremap(dev->mem_resource->start, resource_size(dev->mem_resource));\n    if (!dev->reg_base) {\n        dev_err(&pdev->dev, \"Failed to map memory region\\n\");\n        release_mem_region(dev->mem_resource->start, resource_size(dev->mem_resource));\n        return -ENOMEM;\n    }\n    \n    // TODO: Get optional clock\n    dev->device_clock = devm_clk_get(&pdev->dev, \"device-clock\");\n    if (IS_ERR(dev->device_clock)) {\n        if (PTR_ERR(dev->device_clock) == -EPROBE_DEFER) {\n            dev_info(&pdev->dev, \"Clock not ready, deferring probe\\n\");\n            ret = -EPROBE_DEFER;\n            goto err_unmap;\n        }\n        dev_info(&pdev->dev, \"No clock specified in device tree\\n\");\n        dev->device_clock = NULL;\n    } else {\n        ret = clk_prepare_enable(dev->device_clock);\n        if (ret) {\n            dev_err(&pdev->dev, \"Failed to enable clock: %d\\n\", ret);\n            goto err_unmap;\n        }\n        dev_info(&pdev->dev, \"Clock enabled successfully\\n\");\n    }\n    \n    // TODO: Get optional reset control\n    dev->reset_control = devm_reset_control_get_optional(&pdev->dev, \"device-reset\");\n    if (IS_ERR(dev->reset_control)) {\n        ret = PTR_ERR(dev->reset_control);\n        dev_err(&pdev->dev, \"Failed to get reset control: %d\\n\", ret);\n        goto err_disable_clock;\n    }\n    \n    if (dev->reset_control) {\n        ret = reset_control_deassert(dev->reset_control);\n        if (ret) {\n            dev_err(&pdev->dev, \"Failed to deassert reset: %d\\n\", ret);\n            goto err_disable_clock;\n        }\n        dev_info(&pdev->dev, \"Reset deasserted successfully\\n\");\n    }\n    \n    // TODO: Get optional interrupt\n    dev->config.irq_number = platform_get_irq(pdev, 0);\n    if (dev->config.irq_number < 0) {\n        dev_info(&pdev->dev, \"No interrupt specified in device tree\\n\");\n        dev->config.irq_number = -1;\n    } else {\n        dev_info(&pdev->dev, \"IRQ: %d\\n\", dev->config.irq_number);\n    }\n    \n    dev_info(&pdev->dev, \"Device resources setup successfully\\n\");\n    return 0;\n    \nerr_disable_clock:\n    if (dev->device_clock) {\n        clk_disable_unprepare(dev->device_clock);\n    }\nerr_unmap:\n    iounmap(dev->reg_base);\n    release_mem_region(dev->mem_resource->start, resource_size(dev->mem_resource));\n    return ret;\n}\n\n// TODO: Cleanup device resources\nstatic void cleanup_device_resources(struct dt_device *dev)\n{\n    if (dev->reset_control) {\n        reset_control_assert(dev->reset_control);\n    }\n    \n    if (dev->device_clock) {\n        clk_disable_unprepare(dev->device_clock);\n    }\n    \n    if (dev->reg_base) {\n        iounmap(dev->reg_base);\n    }\n    \n    if (dev->mem_resource) {\n        release_mem_region(dev->mem_resource->start, resource_size(dev->mem_resource));\n    }\n}\n\n// TODO: File operations\nstatic int device_open(struct inode *inode, struct file *file)\n{\n    struct dt_device *dev = dt_dev_instance;\n    \n    if (!dev) {\n        return -ENODEV;\n    }\n    \n    file->private_data = dev;\n    \n    if (dev->config.enable_debug) {\n        dev_info(&dev->pdev->dev, \"Device opened\\n\");\n    }\n    \n    return 0;\n}\n\nstatic int device_release(struct inode *inode, struct file *file)\n{\n    struct dt_device *dev = file->private_data;\n    \n    if (dev && dev->config.enable_debug) {\n        dev_info(&dev->pdev->dev, \"Device closed\\n\");\n    }\n    \n    return 0;\n}\n\nstatic ssize_t device_read(struct file *file, char __user *user_buffer,\n                          size_t count, loff_t *offset)\n{\n    struct dt_device *dev = file->private_data;\n    ssize_t bytes_read = 0;\n    char info_buffer[512];\n    size_t info_len;\n    \n    if (!dev) {\n        return -ENODEV;\n    }\n    \n    mutex_lock(&dev->device_mutex);\n    \n    // Create device information string\n    info_len = snprintf(info_buffer, sizeof(info_buffer),\n                       \"Device Tree Device Information\\n\"\n                       \"==============================\\n\"\n                       \"Compatible: %s\\n\"\n                       \"Device Name: %s\\n\"\n                       \"Register Base: 0x%x\\n\"\n                       \"Register Size: 0x%x\\n\"\n                       \"Clock Frequency: %u Hz\\n\"\n                       \"Buffer Size: %u bytes\\n\"\n                       \"IRQ: %d\\n\"\n                       \"Debug: %s\\n\"\n                       \"Read Count: %lu\\n\"\n                       \"Write Count: %lu\\n\"\n                       \"Probe Time: %lu jiffies\\n\",\n                       dev->config.compatible,\n                       dev->config.device_name,\n                       dev->config.reg_base,\n                       dev->config.reg_size,\n                       dev->config.clock_frequency,\n                       dev->config.buffer_size,\n                       dev->config.irq_number,\n                       dev->config.enable_debug ? \"enabled\" : \"disabled\",\n                       dev->read_count,\n                       dev->write_count,\n                       dev->probe_time_jiffies);\n    \n    if (*offset >= info_len) {\n        mutex_unlock(&dev->device_mutex);\n        return 0; // EOF\n    }\n    \n    bytes_read = min(count, info_len - *offset);\n    \n    if (copy_to_user(user_buffer, info_buffer + *offset, bytes_read)) {\n        mutex_unlock(&dev->device_mutex);\n        return -EFAULT;\n    }\n    \n    *offset += bytes_read;\n    dev->read_count++;\n    \n    mutex_unlock(&dev->device_mutex);\n    \n    if (dev->config.enable_debug) {\n        dev_info(&dev->pdev->dev, \"Read %zu bytes\\n\", bytes_read);\n    }\n    \n    return bytes_read;\n}\n\nstatic ssize_t device_write(struct file *file, const char __user *user_buffer,\n                           size_t count, loff_t *offset)\n{\n    struct dt_device *dev = file->private_data;\n    ssize_t bytes_written = 0;\n    \n    if (!dev) {\n        return -ENODEV;\n    }\n    \n    mutex_lock(&dev->device_mutex);\n    \n    if (*offset >= dev->config.buffer_size) {\n        mutex_unlock(&dev->device_mutex);\n        return -ENOSPC;\n    }\n    \n    bytes_written = min(count, dev->config.buffer_size - *offset);\n    \n    if (copy_from_user(dev->buffer + *offset, user_buffer, bytes_written)) {\n        mutex_unlock(&dev->device_mutex);\n        return -EFAULT;\n    }\n    \n    *offset += bytes_written;\n    if (*offset > dev->buffer_used) {\n        dev->buffer_used = *offset;\n    }\n    \n    dev->write_count++;\n    \n    mutex_unlock(&dev->device_mutex);\n    \n    if (dev->config.enable_debug) {\n        dev_info(&dev->pdev->dev, \"Wrote %zu bytes\\n\", bytes_written);\n    }\n    \n    return bytes_written;\n}\n\nstatic const struct file_operations dt_dev_fops = {\n    .owner = THIS_MODULE,\n    .open = device_open,\n    .release = device_release,\n    .read = device_read,\n    .write = device_write,\n};\n\n// TODO: Platform driver probe function\nstatic int dt_device_probe(struct platform_device *pdev)\n{\n    struct dt_device *dev;\n    int ret;\n    \n    dev_info(&pdev->dev, \"Probing device tree device\\n\");\n    \n    // TODO: Allocate device structure\n    dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n    if (!dev) {\n        return -ENOMEM;\n    }\n    \n    dev->pdev = pdev;\n    dev->probe_time_jiffies = jiffies;\n    mutex_init(&dev->device_mutex);\n    \n    // TODO: Parse device tree properties\n    ret = parse_dt_properties(pdev, &dev->config);\n    if (ret) {\n        return ret;\n    }\n    \n    // TODO: Setup device resources\n    ret = setup_device_resources(dev);\n    if (ret) {\n        return ret;\n    }\n    \n    // TODO: Allocate buffer\n    dev->buffer = devm_kzalloc(&pdev->dev, dev->config.buffer_size, GFP_KERNEL);\n    if (!dev->buffer) {\n        cleanup_device_resources(dev);\n        return -ENOMEM;\n    }\n    \n    // TODO: Register character device\n    ret = alloc_chrdev_region(&dev->dev_num, 0, 1, DEVICE_NAME);\n    if (ret < 0) {\n        dev_err(&pdev->dev, \"Failed to allocate character device region\\n\");\n        cleanup_device_resources(dev);\n        return ret;\n    }\n    \n    cdev_init(&dev->cdev, &dt_dev_fops);\n    dev->cdev.owner = THIS_MODULE;\n    \n    ret = cdev_add(&dev->cdev, dev->dev_num, 1);\n    if (ret < 0) {\n        dev_err(&pdev->dev, \"Failed to add character device\\n\");\n        unregister_chrdev_region(dev->dev_num, 1);\n        cleanup_device_resources(dev);\n        return ret;\n    }\n    \n    // TODO: Create device file\n    dev->char_device = device_create(dt_dev_class, &pdev->dev, dev->dev_num,\n                                    dev, \"%s\", dev->config.device_name);\n    if (IS_ERR(dev->char_device)) {\n        dev_err(&pdev->dev, \"Failed to create device file\\n\");\n        cdev_del(&dev->cdev);\n        unregister_chrdev_region(dev->dev_num, 1);\n        cleanup_device_resources(dev);\n        return PTR_ERR(dev->char_device);\n    }\n    \n    // TODO: Set platform driver data\n    platform_set_drvdata(pdev, dev);\n    dt_dev_instance = dev;\n    \n    dev_info(&pdev->dev, \"Device tree device probed successfully\\n\");\n    dev_info(&pdev->dev, \"Character device: /dev/%s\\n\", dev->config.device_name);\n    \n    return 0;\n}\n\n// TODO: Platform driver remove function\nstatic int dt_device_remove(struct platform_device *pdev)\n{\n    struct dt_device *dev = platform_get_drvdata(pdev);\n    \n    dev_info(&pdev->dev, \"Removing device tree device\\n\");\n    \n    if (dev) {\n        // TODO: Clean up character device\n        device_destroy(dt_dev_class, dev->dev_num);\n        cdev_del(&dev->cdev);\n        unregister_chrdev_region(dev->dev_num, 1);\n        \n        // TODO: Clean up resources\n        cleanup_device_resources(dev);\n        \n        dt_dev_instance = NULL;\n    }\n    \n    dev_info(&pdev->dev, \"Device tree device removed\\n\");\n    return 0;\n}\n\n// TODO: Device tree match table\nstatic const struct of_device_id dt_device_of_match[] = {\n    { .compatible = \"kernel-academy,dt-demo-device\" },\n    { .compatible = \"example,dt-device\" },\n    { /* sentinel */ }\n};\nMODULE_DEVICE_TABLE(of, dt_device_of_match);\n\n// TODO: Platform driver structure\nstatic struct platform_driver dt_device_driver = {\n    .probe = dt_device_probe,\n    .remove = dt_device_remove,\n    .driver = {\n        .name = \"dt-demo-device\",\n        .of_match_table = dt_device_of_match,\n    },\n};\n\nstatic int __init dt_dev_init(void)\n{\n    int ret;\n    \n    printk(KERN_INFO \"Device tree device driver initializing...\\n\");\n    \n    // TODO: Create device class\n    dt_dev_class = class_create(THIS_MODULE, CLASS_NAME);\n    if (IS_ERR(dt_dev_class)) {\n        printk(KERN_ERR \"Failed to create device class\\n\");\n        return PTR_ERR(dt_dev_class);\n    }\n    \n    // TODO: Register platform driver\n    ret = platform_driver_register(&dt_device_driver);\n    if (ret) {\n        printk(KERN_ERR \"Failed to register platform driver\\n\");\n        class_destroy(dt_dev_class);\n        return ret;\n    }\n    \n    printk(KERN_INFO \"Device tree device driver loaded successfully\\n\");\n    printk(KERN_INFO \"Waiting for device tree match...\\n\");\n    \n    return 0;\n}\n\nstatic void __exit dt_dev_exit(void)\n{\n    printk(KERN_INFO \"Device tree device driver unloading...\\n\");\n    \n    // TODO: Unregister platform driver\n    platform_driver_unregister(&dt_device_driver);\n    \n    // TODO: Destroy device class\n    class_destroy(dt_dev_class);\n    \n    printk(KERN_INFO \"Device tree device driver unloaded\\n\");\n}\n\nmodule_init(dt_dev_init);\nmodule_exit(dt_dev_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Device tree platform driver demonstration\");\nMODULE_VERSION(\"1.0\");\nMODULE_DEVICE_TABLE(of, dt_device_of_match);",
    "concepts": [
      "device_tree",
      "platform_driver",
      "of_device",
      "resource_management",
      "devicetree_properties",
      "embedded_systems"
    ],
    "skills": [
      "embedded_programming",
      "devicetree_usage",
      "platform_driver_development",
      "resource_parsing"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Device tree device driver loaded successfully",
        "Waiting for device tree match...",
        "Device tree device driver unloaded"
      ],
      "requirements": [
        "Use required function names: dt_dev_init, dt_dev_exit, dt_device_probe, dt_device_remove, parse_dt_properties, setup_device_resources, cleanup_device_resources",
        "Use required variable names: dt_device_driver, dt_device_of_match, dt_dev_fops",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/platform_device.h, linux/of.h, linux/of_device.h, linux/of_platform.h",
        "Code must contain: of_property_read_string, of_property_read_u32, of_property_read_bool, platform_get_resource, platform_get_irq, devm_clk_get, devm_reset_control_get_optional, ioremap, iounmap, request_mem_region, release_mem_region"
      ]
    }
  },
  {
    "id": 52,
    "title": "Kernel Timer Implementation",
    "difficulty": 5,
    "xp": 25,
    "phase": "kernel_core",
    "description": "Implement a kernel module that uses a timer to periodically print messages. The timer should fire every 2 seconds and print a counter value. This teaches you kernel timer management and periodic task scheduling.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/timer.h>\n#include <linux/jiffies.h>\n\n// TODO: Declare global timer structure\n// TODO: Declare counter variable\n\n// TODO: Implement timer callback function\n// Function signature: void timer_callback(struct timer_list *t)\n\nstatic int __init timer_demo_init(void)\n{\n    printk(KERN_INFO \"Timer demo module loaded\\n\");\n    \n    // TODO: Initialize timer with timer_setup()\n    // TODO: Set timer to fire in 2 seconds using mod_timer()\n    \n    return 0;\n}\n\nstatic void __exit timer_demo_exit(void)\n{\n    // TODO: Delete timer with del_timer()\n    printk(KERN_INFO \"Timer demo module unloaded\\n\");\n}\n\nmodule_init(timer_demo_init);\nmodule_exit(timer_demo_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Kernel Timer Implementation Demo\");\nMODULE_AUTHOR(\"Kernel Academy\");",
    "concepts": [
      "timers",
      "periodic_tasks",
      "jiffies",
      "callbacks",
      "cleanup"
    ],
    "skills": [
      "timer_setup",
      "mod_timer",
      "del_timer",
      "timer_callbacks",
      "resource_management"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Timer demo module loaded",
        "Timer fired: count = 1",
        "Timer demo module unloaded"
      ],
      "requirements": [
        "Use required function names: timer_demo_init, timer_demo_exit, timer_callback",
        "Use required variable names: my_timer, counter",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/timer.h, linux/jiffies.h",
        "Code must contain: timer_setup, mod_timer, del_timer, jiffies, msecs_to_jiffies"
      ]
    }
  },
  {
    "id": 53,
    "title": "Device Attributes and Sysfs Integration",
    "difficulty": 7,
    "xp": 70,
    "phase": "kernel_core",
    "description": "Extend the character device driver with sysfs attributes for configuration and status monitoring. This teaches device attribute management used extensively in production drivers at enterprise companies for device configuration and debugging.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n\n#define DEVICE_NAME \"attrdev\"\n#define CLASS_NAME \"attrclass\"\n#define BUFFER_SIZE 4096\n\n// TODO: Device configuration structure\nstruct device_config {\n    int debug_level;\n    bool read_only;\n    size_t max_buffer_size;\n    char device_name[32];\n    unsigned long access_count;\n    unsigned long last_access_jiffies;\n};\n\n// TODO: Main device structure\nstruct attr_device {\n    struct cdev cdev;\n    struct device *device;\n    struct class *class;\n    dev_t dev_num;\n    char *buffer;\n    size_t buffer_used;\n    struct mutex device_mutex;\n    struct device_config config;\n};\n\nstatic struct attr_device attr_dev;\n\n// TODO: Device attribute show functions\nstatic ssize_t debug_level_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n    struct attr_device *attr_dev_ptr = dev_get_drvdata(dev);\n    return sprintf(buf, \"%d\\n\", attr_dev_ptr->config.debug_level);\n}\n\n// TODO: Device attribute store functions\nstatic ssize_t debug_level_store(struct device *dev, struct device_attribute *attr,\n                                const char *buf, size_t count)\n{\n    struct attr_device *attr_dev_ptr = dev_get_drvdata(dev);\n    int value;\n    int ret;\n    \n    ret = kstrtoint(buf, 10, &value);\n    if (ret) {\n        return ret;\n    }\n    \n    if (value < 0 || value > 3) {\n        return -EINVAL;\n    }\n    \n    mutex_lock(&attr_dev_ptr->device_mutex);\n    attr_dev_ptr->config.debug_level = value;\n    mutex_unlock(&attr_dev_ptr->device_mutex);\n    \n    if (value >= 2) {\n        dev_info(dev, \"Debug level changed to %d\\n\", value);\n    }\n    \n    return count;\n}\n\n// TODO: Read-only attribute show function\nstatic ssize_t read_only_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n    struct attr_device *attr_dev_ptr = dev_get_drvdata(dev);\n    return sprintf(buf, \"%d\\n\", attr_dev_ptr->config.read_only ? 1 : 0);\n}\n\n// TODO: Read-only attribute store function\nstatic ssize_t read_only_store(struct device *dev, struct device_attribute *attr,\n                              const char *buf, size_t count)\n{\n    struct attr_device *attr_dev_ptr = dev_get_drvdata(dev);\n    bool value;\n    int ret;\n    \n    ret = kstrtobool(buf, &value);\n    if (ret) {\n        return ret;\n    }\n    \n    mutex_lock(&attr_dev_ptr->device_mutex);\n    attr_dev_ptr->config.read_only = value;\n    mutex_unlock(&attr_dev_ptr->device_mutex);\n    \n    dev_info(dev, \"Read-only mode %s\\n\", value ? \"enabled\" : \"disabled\");\n    \n    return count;\n}\n\n// TODO: Statistics attribute show function\nstatic ssize_t stats_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n    struct attr_device *attr_dev_ptr = dev_get_drvdata(dev);\n    return sprintf(buf, \"Access count: %lu\\nLast access: %lu jiffies ago\\nBuffer used: %zu/%zu\\n\",\n                   attr_dev_ptr->config.access_count,\n                   jiffies - attr_dev_ptr->config.last_access_jiffies,\n                   attr_dev_ptr->buffer_used,\n                   BUFFER_SIZE);\n}\n\n// TODO: Device name attribute functions\nstatic ssize_t device_name_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n    struct attr_device *attr_dev_ptr = dev_get_drvdata(dev);\n    return sprintf(buf, \"%s\\n\", attr_dev_ptr->config.device_name);\n}\n\nstatic ssize_t device_name_store(struct device *dev, struct device_attribute *attr,\n                                const char *buf, size_t count)\n{\n    struct attr_device *attr_dev_ptr = dev_get_drvdata(dev);\n    \n    if (count >= sizeof(attr_dev_ptr->config.device_name)) {\n        return -EINVAL;\n    }\n    \n    mutex_lock(&attr_dev_ptr->device_mutex);\n    strncpy(attr_dev_ptr->config.device_name, buf, sizeof(attr_dev_ptr->config.device_name) - 1);\n    attr_dev_ptr->config.device_name[sizeof(attr_dev_ptr->config.device_name) - 1] = '\\0';\n    \n    // Remove trailing newline if present\n    if (attr_dev_ptr->config.device_name[strlen(attr_dev_ptr->config.device_name) - 1] == '\\n') {\n        attr_dev_ptr->config.device_name[strlen(attr_dev_ptr->config.device_name) - 1] = '\\0';\n    }\n    \n    mutex_unlock(&attr_dev_ptr->device_mutex);\n    \n    dev_info(dev, \"Device name changed to: %s\\n\", attr_dev_ptr->config.device_name);\n    \n    return count;\n}\n\n// TODO: Define device attributes\nstatic DEVICE_ATTR_RW(debug_level);\nstatic DEVICE_ATTR_RW(read_only);\nstatic DEVICE_ATTR_RO(stats);\nstatic DEVICE_ATTR_RW(device_name);\n\n// TODO: Create attribute group\nstatic struct attribute *attr_dev_attrs[] = {\n    &dev_attr_debug_level.attr,\n    &dev_attr_read_only.attr,\n    &dev_attr_stats.attr,\n    &dev_attr_device_name.attr,\n    NULL,\n};\n\nstatic const struct attribute_group attr_dev_group = {\n    .attrs = attr_dev_attrs,\n};\n\n// TODO: File operations\nstatic int device_open(struct inode *inode, struct file *file)\n{\n    struct attr_device *dev_data = &attr_dev;\n    \n    file->private_data = dev_data;\n    \n    mutex_lock(&dev_data->device_mutex);\n    dev_data->config.access_count++;\n    dev_data->config.last_access_jiffies = jiffies;\n    mutex_unlock(&dev_data->device_mutex);\n    \n    if (dev_data->config.debug_level >= 2) {\n        printk(KERN_INFO \"Device opened (access count: %lu)\\n\", dev_data->config.access_count);\n    }\n    \n    return 0;\n}\n\nstatic int device_release(struct inode *inode, struct file *file)\n{\n    struct attr_device *dev_data = file->private_data;\n    \n    if (dev_data->config.debug_level >= 2) {\n        printk(KERN_INFO \"Device closed\\n\");\n    }\n    \n    return 0;\n}\n\nstatic ssize_t device_read(struct file *file, char __user *user_buffer,\n                          size_t count, loff_t *offset)\n{\n    struct attr_device *dev_data = file->private_data;\n    ssize_t bytes_read = 0;\n    \n    if (mutex_lock_interruptible(&dev_data->device_mutex)) {\n        return -ERESTARTSYS;\n    }\n    \n    dev_data->config.last_access_jiffies = jiffies;\n    \n    if (*offset >= dev_data->buffer_used) {\n        mutex_unlock(&dev_data->device_mutex);\n        return 0; // EOF\n    }\n    \n    bytes_read = min(count, dev_data->buffer_used - *offset);\n    \n    if (copy_to_user(user_buffer, dev_data->buffer + *offset, bytes_read)) {\n        mutex_unlock(&dev_data->device_mutex);\n        return -EFAULT;\n    }\n    \n    *offset += bytes_read;\n    \n    if (dev_data->config.debug_level >= 3) {\n        printk(KERN_INFO \"Device read: %zu bytes\\n\", bytes_read);\n    }\n    \n    mutex_unlock(&dev_data->device_mutex);\n    return bytes_read;\n}\n\nstatic ssize_t device_write(struct file *file, const char __user *user_buffer,\n                           size_t count, loff_t *offset)\n{\n    struct attr_device *dev_data = file->private_data;\n    ssize_t bytes_written = 0;\n    \n    // Check if device is in read-only mode\n    if (dev_data->config.read_only) {\n        return -EPERM;\n    }\n    \n    if (mutex_lock_interruptible(&dev_data->device_mutex)) {\n        return -ERESTARTSYS;\n    }\n    \n    dev_data->config.last_access_jiffies = jiffies;\n    \n    if (*offset >= BUFFER_SIZE) {\n        mutex_unlock(&dev_data->device_mutex);\n        return -ENOSPC;\n    }\n    \n    bytes_written = min(count, BUFFER_SIZE - *offset);\n    \n    if (copy_from_user(dev_data->buffer + *offset, user_buffer, bytes_written)) {\n        mutex_unlock(&dev_data->device_mutex);\n        return -EFAULT;\n    }\n    \n    *offset += bytes_written;\n    if (*offset > dev_data->buffer_used) {\n        dev_data->buffer_used = *offset;\n    }\n    \n    if (dev_data->config.debug_level >= 3) {\n        printk(KERN_INFO \"Device write: %zu bytes\\n\", bytes_written);\n    }\n    \n    mutex_unlock(&dev_data->device_mutex);\n    return bytes_written;\n}\n\nstatic const struct file_operations attr_dev_fops = {\n    .owner = THIS_MODULE,\n    .open = device_open,\n    .release = device_release,\n    .read = device_read,\n    .write = device_write,\n};\n\nstatic int __init attr_dev_init(void)\n{\n    int ret;\n    \n    printk(KERN_INFO \"Attribute device driver initializing...\\n\");\n    \n    // TODO: Initialize device structure\n    memset(&attr_dev, 0, sizeof(attr_dev));\n    mutex_init(&attr_dev.device_mutex);\n    \n    // TODO: Initialize configuration\n    attr_dev.config.debug_level = 1;\n    attr_dev.config.read_only = false;\n    attr_dev.config.max_buffer_size = BUFFER_SIZE;\n    strcpy(attr_dev.config.device_name, \"default_name\");\n    attr_dev.config.access_count = 0;\n    attr_dev.config.last_access_jiffies = jiffies;\n    \n    // TODO: Allocate buffer\n    attr_dev.buffer = kzalloc(BUFFER_SIZE, GFP_KERNEL);\n    if (!attr_dev.buffer) {\n        return -ENOMEM;\n    }\n    \n    // TODO: Register character device\n    ret = alloc_chrdev_region(&attr_dev.dev_num, 0, 1, DEVICE_NAME);\n    if (ret < 0) {\n        kfree(attr_dev.buffer);\n        return ret;\n    }\n    \n    cdev_init(&attr_dev.cdev, &attr_dev_fops);\n    attr_dev.cdev.owner = THIS_MODULE;\n    \n    ret = cdev_add(&attr_dev.cdev, attr_dev.dev_num, 1);\n    if (ret < 0) {\n        unregister_chrdev_region(attr_dev.dev_num, 1);\n        kfree(attr_dev.buffer);\n        return ret;\n    }\n    \n    // TODO: Create device class\n    attr_dev.class = class_create(THIS_MODULE, CLASS_NAME);\n    if (IS_ERR(attr_dev.class)) {\n        cdev_del(&attr_dev.cdev);\n        unregister_chrdev_region(attr_dev.dev_num, 1);\n        kfree(attr_dev.buffer);\n        return PTR_ERR(attr_dev.class);\n    }\n    \n    // TODO: Create device\n    attr_dev.device = device_create(attr_dev.class, NULL, attr_dev.dev_num,\n                                   &attr_dev, DEVICE_NAME);\n    if (IS_ERR(attr_dev.device)) {\n        class_destroy(attr_dev.class);\n        cdev_del(&attr_dev.cdev);\n        unregister_chrdev_region(attr_dev.dev_num, 1);\n        kfree(attr_dev.buffer);\n        return PTR_ERR(attr_dev.device);\n    }\n    \n    // TODO: Set device driver data\n    dev_set_drvdata(attr_dev.device, &attr_dev);\n    \n    // TODO: Create sysfs attribute group\n    ret = sysfs_create_group(&attr_dev.device->kobj, &attr_dev_group);\n    if (ret) {\n        device_destroy(attr_dev.class, attr_dev.dev_num);\n        class_destroy(attr_dev.class);\n        cdev_del(&attr_dev.cdev);\n        unregister_chrdev_region(attr_dev.dev_num, 1);\n        kfree(attr_dev.buffer);\n        return ret;\n    }\n    \n    printk(KERN_INFO \"Attribute device driver loaded successfully\\n\");\n    printk(KERN_INFO \"Device: /dev/%s\\n\", DEVICE_NAME);\n    printk(KERN_INFO \"Sysfs attributes: /sys/class/%s/%s/\\n\", CLASS_NAME, DEVICE_NAME);\n    \n    return 0;\n}\n\nstatic void __exit attr_dev_exit(void)\n{\n    // TODO: Remove sysfs attributes\n    sysfs_remove_group(&attr_dev.device->kobj, &attr_dev_group);\n    \n    // TODO: Clean up device\n    device_destroy(attr_dev.class, attr_dev.dev_num);\n    class_destroy(attr_dev.class);\n    cdev_del(&attr_dev.cdev);\n    unregister_chrdev_region(attr_dev.dev_num, 1);\n    kfree(attr_dev.buffer);\n    \n    printk(KERN_INFO \"Attribute device driver unloaded\\n\");\n}\n\nmodule_init(attr_dev_init);\nmodule_exit(attr_dev_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Character device with sysfs attributes\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "device_attributes",
      "sysfs_integration",
      "show_store_functions",
      "device_configuration",
      "runtime_control"
    ],
    "skills": [
      "device_attribute_management",
      "sysfs_programming",
      "device_configuration",
      "runtime_parameter_control"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Attribute device driver loaded successfully",
        "Device: /dev/attrdev",
        "Sysfs attributes: /sys/class/attrclass/attrdev/",
        "Attribute device driver unloaded"
      ],
      "requirements": [
        "Use required function names: attr_dev_init, attr_dev_exit, debug_level_show, debug_level_store, read_only_show, read_only_store, stats_show, device_name_show, device_name_store",
        "Use required variable names: attr_dev, attr_dev_group",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/fs.h, linux/device.h, linux/cdev.h",
        "Code must contain: DEVICE_ATTR_RW, DEVICE_ATTR_RO, sysfs_create_group, sysfs_remove_group, dev_set_drvdata, dev_get_drvdata"
      ]
    }
  },
  {
    "id": 54,
    "title": "Poll/Select Support and Asynchronous I/O",
    "difficulty": 8,
    "xp": 80,
    "phase": "kernel_core",
    "description": "Implement poll/select support for the character device to enable asynchronous I/O operations. This teaches advanced I/O patterns used in high-performance drivers and networking code at enterprise companies.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/sched.h>\n#include <linux/timer.h>\n#include <linux/workqueue.h>\n\n#define DEVICE_NAME \"polldev\"\n#define CLASS_NAME \"pollclass\"\n#define BUFFER_SIZE 1024\n#define DATA_READY_THRESHOLD 64\n\n// TODO: Device state structure\nstruct poll_device {\n    struct cdev cdev;\n    struct device *device;\n    struct class *class;\n    dev_t dev_num;\n    \n    // Buffers for read and write\n    char *read_buffer;\n    char *write_buffer;\n    size_t read_data_available;\n    size_t write_space_available;\n    \n    // Wait queues for blocking operations\n    wait_queue_head_t read_wait;\n    wait_queue_head_t write_wait;\n    \n    // Synchronization\n    struct mutex device_mutex;\n    spinlock_t buffer_lock;\n    \n    // Asynchronous notification\n    struct fasync_struct *async_queue;\n    \n    // Statistics\n    unsigned long read_count;\n    unsigned long write_count;\n    unsigned long poll_count;\n    \n    // Simulated data generation\n    struct timer_list data_timer;\n    struct work_struct data_work;\n    bool data_generation_active;\n};\n\nstatic struct poll_device poll_dev;\n\n// TODO: Data generation work function (simulates hardware interrupts)\nstatic void data_generation_work(struct work_struct *work)\n{\n    struct poll_device *dev = container_of(work, struct poll_device, data_work);\n    unsigned long flags;\n    char new_data[32];\n    size_t data_len;\n    \n    // Generate some simulated data\n    data_len = snprintf(new_data, sizeof(new_data), \"Data_%lu\\n\", jiffies);\n    \n    spin_lock_irqsave(&dev->buffer_lock, flags);\n    \n    // Add data to read buffer if there's space\n    if (dev->read_data_available + data_len <= BUFFER_SIZE) {\n        memcpy(dev->read_buffer + dev->read_data_available, new_data, data_len);\n        dev->read_data_available += data_len;\n        \n        // Wake up any processes waiting for read data\n        wake_up_interruptible(&dev->read_wait);\n        \n        // Send async notification\n        if (dev->async_queue) {\n            kill_fasync(&dev->async_queue, SIGIO, POLL_IN);\n        }\n        \n        if (dev->read_data_available >= DATA_READY_THRESHOLD) {\n            printk(KERN_INFO \"Data ready for reading (%zu bytes)\\n\", dev->read_data_available);\n        }\n    }\n    \n    spin_unlock_irqrestore(&dev->buffer_lock, flags);\n}\n\n// TODO: Timer callback for simulated data generation\nstatic void data_timer_callback(struct timer_list *timer)\n{\n    struct poll_device *dev = container_of(timer, struct poll_device, data_timer);\n    \n    // Schedule work to generate data\n    if (dev->data_generation_active) {\n        schedule_work(&dev->data_work);\n        \n        // Restart timer for next data generation\n        mod_timer(&dev->data_timer, jiffies + msecs_to_jiffies(2000));\n    }\n}\n\n// TODO: Implement poll function\nstatic __poll_t device_poll(struct file *file, poll_table *wait)\n{\n    struct poll_device *dev = file->private_data;\n    __poll_t mask = 0;\n    unsigned long flags;\n    \n    // Add our wait queues to the poll table\n    poll_wait(file, &dev->read_wait, wait);\n    poll_wait(file, &dev->write_wait, wait);\n    \n    spin_lock_irqsave(&dev->buffer_lock, flags);\n    \n    dev->poll_count++;\n    \n    // Check if data is available for reading\n    if (dev->read_data_available > 0) {\n        mask |= EPOLLIN | EPOLLRDNORM; // Readable\n    }\n    \n    // Check if space is available for writing\n    if (dev->write_space_available > 0) {\n        mask |= EPOLLOUT | EPOLLWRNORM; // Writable\n    }\n    \n    spin_unlock_irqrestore(&dev->buffer_lock, flags);\n    \n    if (mask) {\n        printk(KERN_INFO \"Poll returning mask: 0x%x\\n\", mask);\n    }\n    \n    return mask;\n}\n\n// TODO: Implement fasync function for asynchronous notification\nstatic int device_fasync(int fd, struct file *file, int mode)\n{\n    struct poll_device *dev = file->private_data;\n    return fasync_helper(fd, file, mode, &dev->async_queue);\n}\n\nstatic int device_open(struct inode *inode, struct file *file)\n{\n    struct poll_device *dev = &poll_dev;\n    \n    file->private_data = dev;\n    \n    mutex_lock(&dev->device_mutex);\n    \n    // Start data generation when first opened\n    if (!dev->data_generation_active) {\n        dev->data_generation_active = true;\n        mod_timer(&dev->data_timer, jiffies + msecs_to_jiffies(1000));\n        printk(KERN_INFO \"Data generation started\\n\");\n    }\n    \n    mutex_unlock(&dev->device_mutex);\n    \n    printk(KERN_INFO \"Poll device opened\\n\");\n    return 0;\n}\n\nstatic int device_release(struct inode *inode, struct file *file)\n{\n    struct poll_device *dev = file->private_data;\n    \n    // Remove from async notification list\n    device_fasync(-1, file, 0);\n    \n    printk(KERN_INFO \"Poll device closed\\n\");\n    return 0;\n}\n\n// TODO: Implement non-blocking read\nstatic ssize_t device_read(struct file *file, char __user *user_buffer,\n                          size_t count, loff_t *offset)\n{\n    struct poll_device *dev = file->private_data;\n    ssize_t bytes_read = 0;\n    unsigned long flags;\n    \n    if (count == 0) {\n        return 0;\n    }\n    \n    // For non-blocking I/O, don't wait\n    if (file->f_flags & O_NONBLOCK) {\n        spin_lock_irqsave(&dev->buffer_lock, flags);\n        if (dev->read_data_available == 0) {\n            spin_unlock_irqrestore(&dev->buffer_lock, flags);\n            return -EAGAIN;\n        }\n        spin_unlock_irqrestore(&dev->buffer_lock, flags);\n    } else {\n        // For blocking I/O, wait for data\n        if (wait_event_interruptible(dev->read_wait, dev->read_data_available > 0)) {\n            return -ERESTARTSYS;\n        }\n    }\n    \n    spin_lock_irqsave(&dev->buffer_lock, flags);\n    \n    if (dev->read_data_available > 0) {\n        bytes_read = min(count, dev->read_data_available);\n        \n        if (copy_to_user(user_buffer, dev->read_buffer, bytes_read)) {\n            spin_unlock_irqrestore(&dev->buffer_lock, flags);\n            return -EFAULT;\n        }\n        \n        // Move remaining data to beginning of buffer\n        if (bytes_read < dev->read_data_available) {\n            memmove(dev->read_buffer, dev->read_buffer + bytes_read,\n                   dev->read_data_available - bytes_read);\n        }\n        \n        dev->read_data_available -= bytes_read;\n        dev->read_count++;\n    }\n    \n    spin_unlock_irqrestore(&dev->buffer_lock, flags);\n    \n    if (bytes_read > 0) {\n        printk(KERN_INFO \"Read %zu bytes\\n\", bytes_read);\n    }\n    \n    return bytes_read;\n}\n\n// TODO: Implement non-blocking write\nstatic ssize_t device_write(struct file *file, const char __user *user_buffer,\n                           size_t count, loff_t *offset)\n{\n    struct poll_device *dev = file->private_data;\n    ssize_t bytes_written = 0;\n    unsigned long flags;\n    \n    if (count == 0) {\n        return 0;\n    }\n    \n    // For non-blocking I/O, don't wait\n    if (file->f_flags & O_NONBLOCK) {\n        spin_lock_irqsave(&dev->buffer_lock, flags);\n        if (dev->write_space_available == 0) {\n            spin_unlock_irqrestore(&dev->buffer_lock, flags);\n            return -EAGAIN;\n        }\n        spin_unlock_irqrestore(&dev->buffer_lock, flags);\n    } else {\n        // For blocking I/O, wait for space\n        if (wait_event_interruptible(dev->write_wait, dev->write_space_available > 0)) {\n            return -ERESTARTSYS;\n        }\n    }\n    \n    spin_lock_irqsave(&dev->buffer_lock, flags);\n    \n    if (dev->write_space_available > 0) {\n        bytes_written = min(count, dev->write_space_available);\n        \n        if (copy_from_user(dev->write_buffer, user_buffer, bytes_written)) {\n            spin_unlock_irqrestore(&dev->buffer_lock, flags);\n            return -EFAULT;\n        }\n        \n        dev->write_space_available -= bytes_written;\n        dev->write_count++;\n        \n        // Wake up any processes waiting for write space\n        wake_up_interruptible(&dev->write_wait);\n    }\n    \n    spin_unlock_irqrestore(&dev->buffer_lock, flags);\n    \n    if (bytes_written > 0) {\n        printk(KERN_INFO \"Wrote %zu bytes\\n\", bytes_written);\n    }\n    \n    return bytes_written;\n}\n\nstatic const struct file_operations poll_dev_fops = {\n    .owner = THIS_MODULE,\n    .open = device_open,\n    .release = device_release,\n    .read = device_read,\n    .write = device_write,\n    .poll = device_poll,\n    .fasync = device_fasync,\n};\n\nstatic int __init poll_dev_init(void)\n{\n    int ret;\n    \n    printk(KERN_INFO \"Poll device driver initializing...\\n\");\n    \n    // TODO: Initialize device structure\n    memset(&poll_dev, 0, sizeof(poll_dev));\n    mutex_init(&poll_dev.device_mutex);\n    spin_lock_init(&poll_dev.buffer_lock);\n    \n    // TODO: Initialize wait queues\n    init_waitqueue_head(&poll_dev.read_wait);\n    init_waitqueue_head(&poll_dev.write_wait);\n    \n    // TODO: Allocate buffers\n    poll_dev.read_buffer = kzalloc(BUFFER_SIZE, GFP_KERNEL);\n    if (!poll_dev.read_buffer) {\n        return -ENOMEM;\n    }\n    \n    poll_dev.write_buffer = kzalloc(BUFFER_SIZE, GFP_KERNEL);\n    if (!poll_dev.write_buffer) {\n        kfree(poll_dev.read_buffer);\n        return -ENOMEM;\n    }\n    \n    // TODO: Initialize buffer state\n    poll_dev.read_data_available = 0;\n    poll_dev.write_space_available = BUFFER_SIZE;\n    \n    // TODO: Initialize timer and work\n    timer_setup(&poll_dev.data_timer, data_timer_callback, 0);\n    INIT_WORK(&poll_dev.data_work, data_generation_work);\n    \n    // TODO: Register character device\n    ret = alloc_chrdev_region(&poll_dev.dev_num, 0, 1, DEVICE_NAME);\n    if (ret < 0) {\n        kfree(poll_dev.write_buffer);\n        kfree(poll_dev.read_buffer);\n        return ret;\n    }\n    \n    cdev_init(&poll_dev.cdev, &poll_dev_fops);\n    poll_dev.cdev.owner = THIS_MODULE;\n    \n    ret = cdev_add(&poll_dev.cdev, poll_dev.dev_num, 1);\n    if (ret < 0) {\n        unregister_chrdev_region(poll_dev.dev_num, 1);\n        kfree(poll_dev.write_buffer);\n        kfree(poll_dev.read_buffer);\n        return ret;\n    }\n    \n    // TODO: Create device class and device\n    poll_dev.class = class_create(THIS_MODULE, CLASS_NAME);\n    if (IS_ERR(poll_dev.class)) {\n        cdev_del(&poll_dev.cdev);\n        unregister_chrdev_region(poll_dev.dev_num, 1);\n        kfree(poll_dev.write_buffer);\n        kfree(poll_dev.read_buffer);\n        return PTR_ERR(poll_dev.class);\n    }\n    \n    poll_dev.device = device_create(poll_dev.class, NULL, poll_dev.dev_num,\n                                   NULL, DEVICE_NAME);\n    if (IS_ERR(poll_dev.device)) {\n        class_destroy(poll_dev.class);\n        cdev_del(&poll_dev.cdev);\n        unregister_chrdev_region(poll_dev.dev_num, 1);\n        kfree(poll_dev.write_buffer);\n        kfree(poll_dev.read_buffer);\n        return PTR_ERR(poll_dev.device);\n    }\n    \n    printk(KERN_INFO \"Poll device driver loaded successfully\\n\");\n    printk(KERN_INFO \"Device: /dev/%s supports poll/select operations\\n\", DEVICE_NAME);\n    \n    return 0;\n}\n\nstatic void __exit poll_dev_exit(void)\n{\n    // TODO: Stop data generation\n    poll_dev.data_generation_active = false;\n    del_timer_sync(&poll_dev.data_timer);\n    flush_work(&poll_dev.data_work);\n    \n    // TODO: Wake up any waiting processes\n    wake_up_interruptible_all(&poll_dev.read_wait);\n    wake_up_interruptible_all(&poll_dev.write_wait);\n    \n    // TODO: Clean up device\n    device_destroy(poll_dev.class, poll_dev.dev_num);\n    class_destroy(poll_dev.class);\n    cdev_del(&poll_dev.cdev);\n    unregister_chrdev_region(poll_dev.dev_num, 1);\n    kfree(poll_dev.write_buffer);\n    kfree(poll_dev.read_buffer);\n    \n    printk(KERN_INFO \"Poll device driver unloaded\\n\");\n    printk(KERN_INFO \"Final stats - Reads: %lu, Writes: %lu, Polls: %lu\\n\",\n           poll_dev.read_count, poll_dev.write_count, poll_dev.poll_count);\n}\n\nmodule_init(poll_dev_init);\nmodule_exit(poll_dev_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Character device with poll/select support\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "poll_select",
      "wait_queues",
      "async_io",
      "event_notification",
      "file_operations_poll"
    ],
    "skills": [
      "async_io_programming",
      "wait_queue_management",
      "event_driven_programming",
      "performance_optimization"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Poll device driver loaded successfully",
        "Device: /dev/polldev supports poll/select operations",
        "Poll device driver unloaded",
        "Final stats - Reads:"
      ],
      "requirements": [
        "Use required function names: poll_dev_init, poll_dev_exit, device_poll, device_fasync, data_generation_work, data_timer_callback",
        "Use required variable names: poll_dev, poll_dev_fops",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/fs.h, linux/wait.h, linux/poll.h",
        "Code must contain: poll_wait, wake_up_interruptible, wait_event_interruptible, init_waitqueue_head, fasync_helper, kill_fasync, EPOLLIN, EPOLLOUT"
      ]
    }
  },
  {
    "id": 55,
    "title": "Memory Mapping (mmap) Implementation",
    "difficulty": 9,
    "xp": 90,
    "phase": "kernel_core",
    "description": "Implement memory mapping support for the character device, allowing userspace applications to directly map device memory. This teaches advanced memory management techniques critical for high-performance drivers and shared memory systems.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/vmalloc.h>\n#include <linux/page-flags.h>\n#include <linux/highmem.h>\n\n#define DEVICE_NAME \"mmapdev\"\n#define CLASS_NAME \"mmapclass\"\n#define MMAP_SIZE (PAGE_SIZE * 4)  // 4 pages\n#define MAX_MAPPINGS 16\n\n// TODO: Memory mapping information structure\nstruct mmap_info {\n    struct list_head list;\n    struct vm_area_struct *vma;\n    unsigned long virt_addr;\n    unsigned long phys_addr;\n    size_t size;\n    pid_t pid;\n    char comm[TASK_COMM_LEN];\n    unsigned long created_jiffies;\n};\n\n// TODO: Device structure\nstruct mmap_device {\n    struct cdev cdev;\n    struct device *device;\n    struct class *class;\n    dev_t dev_num;\n    \n    // Memory management\n    void *kernel_buffer;\n    unsigned long buffer_size;\n    struct page **pages;\n    int num_pages;\n    \n    // Mapping tracking\n    struct list_head mappings;\n    struct mutex mappings_mutex;\n    atomic_t mapping_count;\n    \n    // Statistics\n    unsigned long total_mappings;\n    unsigned long active_mappings;\n    unsigned long fault_count;\n    unsigned long map_requests;\n};\n\nstatic struct mmap_device mmap_dev;\n\n// TODO: VM operations structure forward declaration\nstatic const struct vm_operations_struct mmap_vm_ops;\n\n// TODO: VMA open callback\nstatic void mmap_vma_open(struct vm_area_struct *vma)\n{\n    struct mmap_info *info = vma->vm_private_data;\n    \n    if (info) {\n        atomic_inc(&mmap_dev.mapping_count);\n        printk(KERN_INFO \"VMA opened: pid=%d, addr=0x%lx, size=%lu\\n\",\n               current->pid, vma->vm_start, vma->vm_end - vma->vm_start);\n    }\n}\n\n// TODO: VMA close callback\nstatic void mmap_vma_close(struct vm_area_struct *vma)\n{\n    struct mmap_info *info = vma->vm_private_data;\n    \n    if (info) {\n        mutex_lock(&mmap_dev.mappings_mutex);\n        list_del(&info->list);\n        mutex_unlock(&mmap_dev.mappings_mutex);\n        \n        atomic_dec(&mmap_dev.mapping_count);\n        \n        printk(KERN_INFO \"VMA closed: pid=%d, addr=0x%lx, mapping duration=%lu jiffies\\n\",\n               info->pid, info->virt_addr, jiffies - info->created_jiffies);\n        \n        kfree(info);\n    }\n}\n\n// TODO: Page fault handler\nstatic vm_fault_t mmap_vma_fault(struct vm_fault *vmf)\n{\n    struct vm_area_struct *vma = vmf->vma;\n    struct mmap_info *info = vma->vm_private_data;\n    unsigned long offset;\n    struct page *page;\n    \n    if (!info) {\n        return VM_FAULT_SIGBUS;\n    }\n    \n    // Calculate offset into our buffer\n    offset = vmf->pgoff << PAGE_SHIFT;\n    \n    if (offset >= mmap_dev.buffer_size) {\n        printk(KERN_ERR \"Fault beyond buffer: offset=0x%lx, size=0x%lx\\n\",\n               offset, mmap_dev.buffer_size);\n        return VM_FAULT_SIGBUS;\n    }\n    \n    // Get the page corresponding to this offset\n    page = mmap_dev.pages[vmf->pgoff];\n    if (!page) {\n        printk(KERN_ERR \"No page for offset 0x%lx\\n\", offset);\n        return VM_FAULT_SIGBUS;\n    }\n    \n    // Increment page reference count\n    get_page(page);\n    vmf->page = page;\n    \n    mmap_dev.fault_count++;\n    \n    printk(KERN_INFO \"Page fault handled: pid=%d, offset=0x%lx, page=%p\\n\",\n           current->pid, offset, page);\n    \n    return 0;\n}\n\n// TODO: Define VM operations\nstatic const struct vm_operations_struct mmap_vm_ops = {\n    .open = mmap_vma_open,\n    .close = mmap_vma_close,\n    .fault = mmap_vma_fault,\n};\n\n// TODO: Implement mmap file operation\nstatic int device_mmap(struct file *file, struct vm_area_struct *vma)\n{\n    struct mmap_info *info;\n    unsigned long size = vma->vm_end - vma->vm_start;\n    unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\n    \n    mmap_dev.map_requests++;\n    \n    // Validate mapping request\n    if (offset + size > mmap_dev.buffer_size) {\n        printk(KERN_ERR \"mmap request beyond buffer: offset=0x%lx, size=0x%lx, buffer_size=0x%lx\\n\",\n               offset, size, mmap_dev.buffer_size);\n        return -EINVAL;\n    }\n    \n    if (size == 0 || size > mmap_dev.buffer_size) {\n        printk(KERN_ERR \"Invalid mmap size: %lu\\n\", size);\n        return -EINVAL;\n    }\n    \n    // Check if we exceed maximum mappings\n    if (atomic_read(&mmap_dev.mapping_count) >= MAX_MAPPINGS) {\n        printk(KERN_ERR \"Maximum mappings exceeded\\n\");\n        return -ENOMEM;\n    }\n    \n    // Create mapping info\n    info = kzalloc(sizeof(*info), GFP_KERNEL);\n    if (!info) {\n        return -ENOMEM;\n    }\n    \n    info->vma = vma;\n    info->virt_addr = vma->vm_start;\n    info->size = size;\n    info->pid = current->pid;\n    get_task_comm(info->comm, current);\n    info->created_jiffies = jiffies;\n    \n    // Set VM area flags\n    vma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\n    vma->vm_private_data = info;\n    vma->vm_ops = &mmap_vm_ops;\n    \n    // Add to mappings list\n    mutex_lock(&mmap_dev.mappings_mutex);\n    list_add(&info->list, &mmap_dev.mappings);\n    mutex_unlock(&mmap_dev.mappings_mutex);\n    \n    atomic_inc(&mmap_dev.mapping_count);\n    mmap_dev.total_mappings++;\n    \n    // Call open to initialize reference counting\n    mmap_vma_open(vma);\n    \n    printk(KERN_INFO \"Memory mapped: pid=%d (%s), addr=0x%lx-0x%lx, size=%lu, offset=0x%lx\\n\",\n           current->pid, current->comm, vma->vm_start, vma->vm_end, size, offset);\n    \n    return 0;\n}\n\nstatic int device_open(struct inode *inode, struct file *file)\n{\n    printk(KERN_INFO \"Mmap device opened by pid=%d (%s)\\n\", current->pid, current->comm);\n    return 0;\n}\n\nstatic int device_release(struct inode *inode, struct file *file)\n{\n    printk(KERN_INFO \"Mmap device closed by pid=%d (%s)\\n\", current->pid, current->comm);\n    return 0;\n}\n\n// TODO: Read function to show buffer content\nstatic ssize_t device_read(struct file *file, char __user *user_buffer,\n                          size_t count, loff_t *offset)\n{\n    ssize_t bytes_read = 0;\n    \n    if (*offset >= mmap_dev.buffer_size) {\n        return 0; // EOF\n    }\n    \n    bytes_read = min(count, mmap_dev.buffer_size - *offset);\n    \n    if (copy_to_user(user_buffer, mmap_dev.kernel_buffer + *offset, bytes_read)) {\n        return -EFAULT;\n    }\n    \n    *offset += bytes_read;\n    \n    printk(KERN_INFO \"Read %zu bytes from offset %lld\\n\", bytes_read, *offset - bytes_read);\n    return bytes_read;\n}\n\n// TODO: Write function to modify buffer content\nstatic ssize_t device_write(struct file *file, const char __user *user_buffer,\n                           size_t count, loff_t *offset)\n{\n    ssize_t bytes_written = 0;\n    \n    if (*offset >= mmap_dev.buffer_size) {\n        return -ENOSPC;\n    }\n    \n    bytes_written = min(count, mmap_dev.buffer_size - *offset);\n    \n    if (copy_from_user(mmap_dev.kernel_buffer + *offset, user_buffer, bytes_written)) {\n        return -EFAULT;\n    }\n    \n    *offset += bytes_written;\n    \n    printk(KERN_INFO \"Wrote %zu bytes to offset %lld\\n\", bytes_written, *offset - bytes_written);\n    return bytes_written;\n}\n\nstatic const struct file_operations mmap_dev_fops = {\n    .owner = THIS_MODULE,\n    .open = device_open,\n    .release = device_release,\n    .read = device_read,\n    .write = device_write,\n    .mmap = device_mmap,\n};\n\n// TODO: Allocate and setup pages for mapping\nstatic int allocate_buffer_pages(void)\n{\n    int i;\n    struct page *page;\n    \n    mmap_dev.num_pages = mmap_dev.buffer_size / PAGE_SIZE;\n    \n    // Allocate array to hold page pointers\n    mmap_dev.pages = kcalloc(mmap_dev.num_pages, sizeof(struct page *), GFP_KERNEL);\n    if (!mmap_dev.pages) {\n        return -ENOMEM;\n    }\n    \n    // Allocate individual pages\n    for (i = 0; i < mmap_dev.num_pages; i++) {\n        page = alloc_page(GFP_KERNEL | __GFP_ZERO);\n        if (!page) {\n            // Free previously allocated pages\n            while (--i >= 0) {\n                __free_page(mmap_dev.pages[i]);\n            }\n            kfree(mmap_dev.pages);\n            return -ENOMEM;\n        }\n        mmap_dev.pages[i] = page;\n    }\n    \n    // Map pages into kernel virtual memory\n    mmap_dev.kernel_buffer = vmap(mmap_dev.pages, mmap_dev.num_pages, VM_MAP, PAGE_KERNEL);\n    if (!mmap_dev.kernel_buffer) {\n        for (i = 0; i < mmap_dev.num_pages; i++) {\n            __free_page(mmap_dev.pages[i]);\n        }\n        kfree(mmap_dev.pages);\n        return -ENOMEM;\n    }\n    \n    // Initialize buffer with pattern\n    for (i = 0; i < mmap_dev.buffer_size / sizeof(int); i++) {\n        ((int *)mmap_dev.kernel_buffer)[i] = i;\n    }\n    \n    printk(KERN_INFO \"Allocated %d pages (%lu bytes) for mmap buffer\\n\",\n           mmap_dev.num_pages, mmap_dev.buffer_size);\n    \n    return 0;\n}\n\n// TODO: Free allocated pages\nstatic void free_buffer_pages(void)\n{\n    int i;\n    \n    if (mmap_dev.kernel_buffer) {\n        vunmap(mmap_dev.kernel_buffer);\n    }\n    \n    if (mmap_dev.pages) {\n        for (i = 0; i < mmap_dev.num_pages; i++) {\n            if (mmap_dev.pages[i]) {\n                __free_page(mmap_dev.pages[i]);\n            }\n        }\n        kfree(mmap_dev.pages);\n    }\n}\n\nstatic int __init mmap_dev_init(void)\n{\n    int ret;\n    \n    printk(KERN_INFO \"Mmap device driver initializing...\\n\");\n    \n    // TODO: Initialize device structure\n    memset(&mmap_dev, 0, sizeof(mmap_dev));\n    mutex_init(&mmap_dev.mappings_mutex);\n    INIT_LIST_HEAD(&mmap_dev.mappings);\n    atomic_set(&mmap_dev.mapping_count, 0);\n    \n    // TODO: Set buffer size (must be page-aligned)\n    mmap_dev.buffer_size = MMAP_SIZE;\n    \n    // TODO: Allocate buffer pages\n    ret = allocate_buffer_pages();\n    if (ret) {\n        printk(KERN_ERR \"Failed to allocate buffer pages\\n\");\n        return ret;\n    }\n    \n    // TODO: Register character device\n    ret = alloc_chrdev_region(&mmap_dev.dev_num, 0, 1, DEVICE_NAME);\n    if (ret < 0) {\n        free_buffer_pages();\n        return ret;\n    }\n    \n    cdev_init(&mmap_dev.cdev, &mmap_dev_fops);\n    mmap_dev.cdev.owner = THIS_MODULE;\n    \n    ret = cdev_add(&mmap_dev.cdev, mmap_dev.dev_num, 1);\n    if (ret < 0) {\n        unregister_chrdev_region(mmap_dev.dev_num, 1);\n        free_buffer_pages();\n        return ret;\n    }\n    \n    // TODO: Create device class and device\n    mmap_dev.class = class_create(THIS_MODULE, CLASS_NAME);\n    if (IS_ERR(mmap_dev.class)) {\n        cdev_del(&mmap_dev.cdev);\n        unregister_chrdev_region(mmap_dev.dev_num, 1);\n        free_buffer_pages();\n        return PTR_ERR(mmap_dev.class);\n    }\n    \n    mmap_dev.device = device_create(mmap_dev.class, NULL, mmap_dev.dev_num,\n                                   NULL, DEVICE_NAME);\n    if (IS_ERR(mmap_dev.device)) {\n        class_destroy(mmap_dev.class);\n        cdev_del(&mmap_dev.cdev);\n        unregister_chrdev_region(mmap_dev.dev_num, 1);\n        free_buffer_pages();\n        return PTR_ERR(mmap_dev.device);\n    }\n    \n    printk(KERN_INFO \"Mmap device driver loaded successfully\\n\");\n    printk(KERN_INFO \"Device: /dev/%s with %lu bytes mappable memory\\n\",\n           DEVICE_NAME, mmap_dev.buffer_size);\n    \n    return 0;\n}\n\nstatic void __exit mmap_dev_exit(void)\n{\n    struct mmap_info *info, *tmp;\n    \n    printk(KERN_INFO \"Mmap device driver unloading...\\n\");\n    \n    // TODO: Force unmap any remaining mappings\n    mutex_lock(&mmap_dev.mappings_mutex);\n    list_for_each_entry_safe(info, tmp, &mmap_dev.mappings, list) {\n        list_del(&info->list);\n        printk(KERN_WARNING \"Force unmapping: pid=%d, addr=0x%lx\\n\",\n               info->pid, info->virt_addr);\n        kfree(info);\n    }\n    mutex_unlock(&mmap_dev.mappings_mutex);\n    \n    // TODO: Clean up device\n    device_destroy(mmap_dev.class, mmap_dev.dev_num);\n    class_destroy(mmap_dev.class);\n    cdev_del(&mmap_dev.cdev);\n    unregister_chrdev_region(mmap_dev.dev_num, 1);\n    \n    // TODO: Free buffer pages\n    free_buffer_pages();\n    \n    printk(KERN_INFO \"Mmap device driver unloaded\\n\");\n    printk(KERN_INFO \"Final stats - Total mappings: %lu, Faults: %lu, Requests: %lu\\n\",\n           mmap_dev.total_mappings, mmap_dev.fault_count, mmap_dev.map_requests);\n}\n\nmodule_init(mmap_dev_init);\nmodule_exit(mmap_dev_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Character device with mmap support\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "mmap",
      "vm_operations",
      "memory_mapping",
      "page_allocation",
      "vm_area_struct",
      "fault_handling"
    ],
    "skills": [
      "memory_management",
      "virtual_memory",
      "page_fault_handling",
      "shared_memory",
      "zero_copy_operations"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Mmap device driver loaded successfully",
        "Device: /dev/mmapdev with",
        "bytes mappable memory",
        "Mmap device driver unloaded",
        "Final stats - Total mappings:"
      ],
      "requirements": [
        "Use required function names: mmap_dev_init, mmap_dev_exit, device_mmap, mmap_vma_open, mmap_vma_close, mmap_vma_fault, allocate_buffer_pages, free_buffer_pages",
        "Use required variable names: mmap_dev, mmap_vm_ops",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/fs.h, linux/mm.h, linux/mman.h, linux/vmalloc.h",
        "Code must contain: alloc_page, __free_page, vmap, vunmap, get_page, vm_operations_struct, VM_FAULT_SIGBUS, vm_fault"
      ]
    }
  }
];

export default problemBank;
