// Auto-generated from problems/ directory
// DO NOT EDIT THIS FILE DIRECTLY - Edit problems/*.json instead
// Generated at: 2025-07-04T06:00:38.972Z

const problemBank = [
  {
    "id": 1,
    "title": "Hello Kernel World",
    "difficulty": 1,
    "xp": 10,
    "phase": "foundations",
    "description": "Create your first kernel module that prints a greeting message when loaded and a goodbye message when unloaded. This is the traditional 'Hello World' for kernel programming.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// TODO: Implement hello_init function\n// TODO: Implement hello_exit function\n\n// TODO: Set module init and exit functions\n// TODO: Add module information\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"A simple Hello World kernel module\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "module_init",
      "module_exit",
      "printk",
      "MODULE_LICENSE",
      "kernel modules"
    ],
    "skills": [
      "Basic kernel programming",
      "Module lifecycle",
      "Kernel logging"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Hello from the kernel!",
        "Goodbye from the kernel!"
      ],
      "requirements": [
        "Use required function names: hello_init, hello_exit",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h",
        "Must include MODULE_LICENSE(\"GPL\")"
      ]
    }
  },
  {
    "id": 2,
    "title": "Variables and Data Types",
    "difficulty": 2,
    "xp": 15,
    "phase": "foundations",
    "description": "Learn to work with different data types in kernel space. Create variables of different types and print their values using printk. This introduces you to kernel-space variable declaration and printing.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// TODO: Declare variables with exact names and values:\n// int my_int = 42;\n// char my_char = 'K';\n// bool my_bool = true;\n\nstatic int __init datatypes_init(void) {\n    // TODO: Print the variables in exact format:\n    // printk(KERN_INFO \"Integer: %d\\n\", my_int);\n    // printk(KERN_INFO \"Character: %c\\n\", my_char);\n    // printk(KERN_INFO \"Boolean: %d\\n\", my_bool);\n    return 0;\n}\n\nstatic void __exit datatypes_exit(void) {\n    printk(KERN_INFO \"Datatypes module unloaded\\n\");\n}\n\nmodule_init(datatypes_init);\nmodule_exit(datatypes_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Data types demonstration module\");",
    "concepts": [
      "kernel data types",
      "variable declaration",
      "printk formatting",
      "static variables"
    ],
    "skills": [
      "Variable management",
      "Data type understanding",
      "Kernel logging with formatting"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Integer: 42",
        "Character: K",
        "Boolean: 1"
      ],
      "requirements": [
        "Use required function names: datatypes_init, datatypes_exit",
        "Use required variable names: my_int, my_char, my_bool",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h",
        "Code must contain: printk, KERN_INFO",
        "Must include MODULE_LICENSE(\"GPL\")"
      ]
    }
  },
  {
    "id": 3,
    "title": "Variable Declaration and Usage",
    "difficulty": 1,
    "xp": 30,
    "phase": "foundations",
    "description": "Declare integer and character variables, then print their values using proper format specifiers. The system will test both compilation and runtime output with hidden test cases.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int __init variables_init(void) {\n    // TODO: Declare an integer variable with any value\n    // TODO: Declare a character variable with any value\n    // TODO: Print both using printk with correct format specifiers\n    // Format: \"Integer value: %d\" and \"Character value: %c\"\n    \n    return 0;\n}\n\n// TODO: Add exit function\n// TODO: Register init/exit functions\n// TODO: Add module metadata\n\nMODULE_LICENSE(\"GPL\");",
    "concepts": [
      "C data types",
      "Format specifiers",
      "Variable declaration"
    ],
    "skills": [
      "Variable usage",
      "printk formatting",
      "Type safety"
    ],
    "problemId": "variable_usage_module",
    "inputOutput": {
      "expectedOutput": [
        "Integer value: 42",
        "Character value: K"
      ],
      "requirements": [
        "Use required function names: variables_init, variables_exit",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h",
        "Code must contain: printk, module_init, module_exit",
        "Must include MODULE_LICENSE(\"GPL\")"
      ]
    },
    "leetCodeStyle": true
  },
  {
    "id": 4,
    "title": "Arrays and Loops in Kernel Space",
    "difficulty": 2,
    "xp": 20,
    "phase": "foundations",
    "description": "Learn to work with arrays and loops in kernel space. Create an array of integers and use a for loop to print each element. This introduces fundamental C programming concepts in kernel context.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// TODO: Declare an array of integers called 'numbers' with values [10, 20, 30, 40, 50]\n// TODO: Use a for loop to print each element\n// Format: \"Element 0: 10\", \"Element 1: 20\", etc.\n\nstatic int __init arrays_init(void) {\n    // TODO: Implement array declaration and loop\n    return 0;\n}\n\nstatic void __exit arrays_exit(void) {\n    printk(KERN_INFO \"Arrays module unloaded\\n\");\n}\n\nmodule_init(arrays_init);\nmodule_exit(arrays_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Arrays and loops demonstration module\");",
    "concepts": [
      "arrays",
      "for loops",
      "array indexing",
      "iteration"
    ],
    "skills": [
      "Array manipulation",
      "Loop control",
      "Index-based access"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Element 0: 10",
        "Element 1: 20",
        "Element 2: 30",
        "Element 3: 40",
        "Element 4: 50"
      ],
      "requirements": [
        "Use required function names: arrays_init, arrays_exit",
        "Declare array with exact name 'numbers' and values [10, 20, 30, 40, 50]",
        "Use for loop to iterate through array",
        "Print in exact format: \"Element X: Y\"",
        "Must include proper kernel headers"
      ]
    }
  },
  {
    "id": 5,
    "title": "Arithmetic and Comparison Operations",
    "difficulty": 2,
    "xp": 25,
    "phase": "foundations",
    "description": "Master arithmetic operations (+, -, *, /, %) and comparison operators in kernel programming. Learn to perform calculations and make logical comparisons essential for kernel logic.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int __init arithmetic_init(void) {\n    int a = 25, b = 7;\n    int sum, diff, product, quotient, remainder;\n    bool greater, equal, not_equal;\n    \n    // TODO: Perform arithmetic operations\n    // sum = a + b\n    // diff = a - b  \n    // product = a * b\n    // quotient = a / b\n    // remainder = a % b\n    \n    // TODO: Perform comparison operations\n    // greater = (a > b)\n    // equal = (a == b)\n    // not_equal = (a != b)\n    \n    // TODO: Print results in exact format:\n    // \"Arithmetic Results:\"\n    // \"25 + 7 = 32\"\n    // \"25 - 7 = 18\"\n    // \"25 * 7 = 175\"\n    // \"25 / 7 = 3\"\n    // \"25 % 7 = 4\"\n    // \"Comparison Results:\"\n    // \"25 > 7: true (1)\"\n    // \"25 == 7: false (0)\"\n    // \"25 != 7: true (1)\"\n    \n    return 0;\n}\n\nstatic void __exit arithmetic_exit(void) {\n    printk(KERN_INFO \"Arithmetic operations module unloaded\\n\");\n}\n\nmodule_init(arithmetic_init);\nmodule_exit(arithmetic_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Arithmetic and comparison operations module\");",
    "concepts": [
      "arithmetic operators",
      "comparison operators",
      "integer division",
      "modulo operation",
      "boolean results"
    ],
    "skills": [
      "Mathematical calculations",
      "Logical comparisons",
      "Operator precedence",
      "Type understanding"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Arithmetic Results:",
        "25 + 7 = 32",
        "25 - 7 = 18",
        "25 * 7 = 175",
        "25 / 7 = 3",
        "25 % 7 = 4",
        "Comparison Results:",
        "25 > 7: true (1)",
        "25 == 7: false (0)",
        "25 != 7: true (1)"
      ],
      "requirements": [
        "Use required function names: arithmetic_init, arithmetic_exit",
        "Use exact variable names: a=25, b=7, sum, diff, product, quotient, remainder",
        "Use exact variable names for comparisons: greater, equal, not_equal",
        "Perform all arithmetic operations: +, -, *, /, %",
        "Perform all comparison operations: >, ==, !=",
        "Print results in exact format shown above",
        "Must show correct mathematical results"
      ]
    }
  },
  {
    "id": 6,
    "title": "Functions and Return Values",
    "difficulty": 3,
    "xp": 25,
    "phase": "foundations",
    "description": "Create custom functions that perform calculations and return values. Learn function declaration, parameter passing, and return values in kernel programming context.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// TODO: Create a function called 'calculate_sum' that takes two integers and returns their sum\n// TODO: Create a function called 'find_max' that takes two integers and returns the larger one\n\nstatic int __init functions_init(void) {\n    int a = 15, b = 25;\n    int sum, max;\n    \n    // TODO: Call calculate_sum and find_max functions\n    // TODO: Print results in exact format:\n    // \"Sum of 15 and 25 is: 40\"\n    // \"Maximum of 15 and 25 is: 25\"\n    \n    return 0;\n}\n\nstatic void __exit functions_exit(void) {\n    printk(KERN_INFO \"Functions module unloaded\\n\");\n}\n\nmodule_init(functions_init);\nmodule_exit(functions_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Functions and return values demonstration module\");",
    "concepts": [
      "function declaration",
      "function parameters",
      "return values",
      "function calls"
    ],
    "skills": [
      "Function design",
      "Parameter passing",
      "Return value handling",
      "Code organization"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Sum of 15 and 25 is: 40",
        "Maximum of 15 and 25 is: 25"
      ],
      "requirements": [
        "Use required function names: functions_init, functions_exit",
        "Create function 'calculate_sum' that takes two int parameters and returns int",
        "Create function 'find_max' that takes two int parameters and returns int",
        "Use exact variables: a=15, b=25",
        "Print in exact format shown above",
        "Functions must return correct values"
      ]
    }
  },
  {
    "id": 7,
    "title": "Conditional Statements and Control Flow",
    "difficulty": 3,
    "xp": 30,
    "phase": "foundations",
    "description": "Master if/else statements and logical operators for control flow in kernel programming. Learn to make decisions and control program execution based on conditions.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int __init conditional_init(void) {\n    int temperature = 75;\n    int humidity = 60;\n    bool is_summer = true;\n    int age = 25;\n    \n    // TODO: Use if/else to check temperature ranges\n    // if temperature >= 80: print \"Hot weather\"\n    // else if temperature >= 60: print \"Moderate weather\" \n    // else: print \"Cold weather\"\n    \n    // TODO: Use logical operators (&&, ||, !)\n    // if (temperature > 70 && humidity > 50): print \"Warm and humid\"\n    // if (is_summer || temperature > 85): print \"Summer conditions\"\n    // if (!is_summer): print \"Not summer\"\n    \n    // TODO: Use nested if statements\n    // if (age >= 18) {\n    //     if (age >= 65) print \"Senior citizen\"\n    //     else print \"Adult\"\n    // } else {\n    //     print \"Minor\"\n    // }\n    \n    // Expected output:\n    // \"Temperature Check: Moderate weather\"\n    // \"Condition Check: Warm and humid\" \n    // \"Season Check: Summer conditions\"\n    // \"Age Check: Adult\"\n    \n    return 0;\n}\n\nstatic void __exit conditional_exit(void) {\n    printk(KERN_INFO \"Conditional statements module unloaded\\n\");\n}\n\nmodule_init(conditional_init);\nmodule_exit(conditional_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Conditional statements and control flow module\");",
    "concepts": [
      "if/else statements",
      "logical operators",
      "nested conditions",
      "boolean logic",
      "control flow"
    ],
    "skills": [
      "Decision making",
      "Conditional logic",
      "Program flow control",
      "Boolean operations"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Temperature Check: Moderate weather",
        "Condition Check: Warm and humid",
        "Season Check: Summer conditions",
        "Age Check: Adult"
      ],
      "requirements": [
        "Use required function names: conditional_init, conditional_exit",
        "Use exact variable values: temperature=75, humidity=60, is_summer=true, age=25",
        "Implement if/else if/else for temperature check",
        "Use logical operators: && (AND), || (OR), ! (NOT)",
        "Implement nested if statements for age check",
        "Print results with exact prefixes: 'Temperature Check:', 'Condition Check:', etc.",
        "Must use actual conditional logic, not hardcoded prints"
      ]
    }
  },
  {
    "id": 8,
    "title": "Loop Structures and Iteration Control",
    "difficulty": 3,
    "xp": 30,
    "phase": "foundations",
    "description": "Master different loop types (while, do-while, for) and loop control statements (break, continue) in kernel programming. Essential for iterative operations and data processing.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int __init loops_init(void) {\n    int i, sum;\n    int numbers[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    int count = 0;\n    \n    // TODO: Use for loop to calculate sum of array elements\n    // for (i = 0; i < 10; i++) { sum += numbers[i]; }\n    // Print: \"For loop sum: 55\"\n    \n    // TODO: Use while loop to count even numbers\n    // i = 0; while (i < 10) { if even, increment count; i++; }\n    // Print: \"While loop even count: 5\"\n    \n    // TODO: Use do-while loop to find first number > 5\n    // i = 0; do { check numbers[i]; i++; } while (numbers[i-1] <= 5);\n    // Print: \"Do-while found number > 5 at index: 5\" (number 6)\n    \n    // TODO: Use for loop with break and continue\n    // Skip odd numbers (continue), break at 8\n    // Print even numbers: \"Loop control: 2 4 6 8\"\n    \n    return 0;\n}\n\nstatic void __exit loops_exit(void) {\n    printk(KERN_INFO \"Loops module unloaded\\n\");\n}\n\nmodule_init(loops_init);\nmodule_exit(loops_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Loop structures and iteration control module\");",
    "concepts": [
      "for loops",
      "while loops",
      "do-while loops",
      "break statement",
      "continue statement",
      "loop control"
    ],
    "skills": [
      "Iterative programming",
      "Loop design",
      "Flow control",
      "Array processing"
    ],
    "inputOutput": {
      "expectedOutput": [
        "For loop sum: 55",
        "While loop even count: 5",
        "Do-while found number > 5 at index: 5",
        "Loop control: 2 4 6 8"
      ],
      "requirements": [
        "Use required function names: loops_init, loops_exit",
        "Use provided array: numbers[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}",
        "Implement for loop to calculate sum of all array elements",
        "Implement while loop to count even numbers in array",
        "Implement do-while loop to find first number > 5",
        "Use break and continue statements in loop control example",
        "Print results in exact format shown above",
        "Must use actual loop logic, not hardcoded results"
      ]
    }
  },
  {
    "id": 9,
    "title": "Switch-Case Statements and Multi-way Branching",
    "difficulty": 3,
    "xp": 25,
    "phase": "foundations",
    "description": "Master switch-case statements for multi-way branching and understand when to use switch vs if-else. Learn proper use of break statements and default cases.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int __init switch_init(void) {\n    int operation = 2;\n    int a = 15, b = 5;\n    int result = 0;\n    char grade = 'B';\n    int day = 3;\n    \n    // TODO: Use switch statement for arithmetic operations\n    // case 1: addition (a + b)\n    // case 2: subtraction (a - b) \n    // case 3: multiplication (a * b)\n    // case 4: division (a / b)\n    // default: print \"Invalid operation\"\n    // Print: \"Operation 2 result: 10\"\n    \n    // TODO: Use switch statement for grade interpretation\n    // case 'A': print \"Excellent\"\n    // case 'B': print \"Good\"\n    // case 'C': print \"Average\" \n    // case 'D': print \"Below Average\"\n    // case 'F': print \"Fail\"\n    // default: print \"Invalid grade\"\n    // Print: \"Grade B: Good\"\n    \n    // TODO: Use switch with fall-through for day grouping\n    // case 1,2,3,4,5: print \"Weekday\"\n    // case 6,7: print \"Weekend\"\n    // default: print \"Invalid day\"\n    // Print: \"Day 3: Weekday\"\n    \n    return 0;\n}\n\nstatic void __exit switch_exit(void) {\n    printk(KERN_INFO \"Switch statements module unloaded\\n\");\n}\n\nmodule_init(switch_init);\nmodule_exit(switch_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Switch-case statements module\");",
    "concepts": [
      "switch statements",
      "case labels",
      "break statements",
      "default case",
      "fall-through behavior"
    ],
    "skills": [
      "Multi-way branching",
      "Switch vs if-else selection",
      "Control flow design",
      "Pattern matching"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Operation 2 result: 10",
        "Grade B: Good",
        "Day 3: Weekday"
      ],
      "requirements": [
        "Use required function names: switch_init, switch_exit",
        "Use exact variable values: operation=2, a=15, b=5, grade='B', day=3",
        "Implement switch statement for arithmetic operations (cases 1-4, default)",
        "Implement switch statement for grade interpretation (cases A-F, default)",
        "Implement switch statement with fall-through for weekday/weekend",
        "Use proper break statements to prevent fall-through where needed",
        "Include default cases in all switch statements",
        "Print results in exact format shown above"
      ]
    }
  },
  {
    "id": 10,
    "title": "Structures Basics - Part 1: Definition and Usage",
    "difficulty": 3,
    "xp": 30,
    "phase": "foundations",
    "description": "Learn to define and use structures in kernel programming. Understand structure declaration, member access, and initialization. This is fundamental for kernel data structures.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// TODO: Define a structure called 'student' with members:\n// - int id\n// - char name[20] \n// - int age\n// - float gpa\n\nstatic int __init structures_init(void) {\n    // TODO: Declare a variable 'stu' of type 'struct student'\n    // TODO: Initialize: id=101, name=\"Alice\", age=20, gpa=3.8\n    // TODO: Print all member values in exact format:\n    // \"Student ID: 101\"\n    // \"Student Name: Alice\"\n    // \"Student Age: 20\" \n    // \"Student GPA: 3\"\n    \n    return 0;\n}\n\nstatic void __exit structures_exit(void) {\n    printk(KERN_INFO \"Structures module unloaded\\n\");\n}\n\nmodule_init(structures_init);\nmodule_exit(structures_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Structures demonstration module\");",
    "concepts": [
      "structure definition",
      "structure members",
      "structure initialization",
      "member access operator"
    ],
    "skills": [
      "Data structure design",
      "Complex data types",
      "Structure manipulation",
      "Member access"
    ],
    "totalParts": 3,
    "inputOutput": {
      "expectedOutput": [
        "Student ID: 101",
        "Student Name: Alice",
        "Student Age: 20",
        "Student GPA: 3"
      ],
      "requirements": [
        "Use required function names: structures_init, structures_exit",
        "Define structure 'student' with exact members: id, name[20], age, gpa",
        "Declare variable 'stu' of type 'struct student'",
        "Initialize with exact values: id=101, name=\"Alice\", age=20, gpa=3.8",
        "Print using dot operator to access members",
        "Use exact format strings shown above"
      ]
    }
  },
  {
    "id": 11,
    "title": "Enums, Constants, and Symbolic Values",
    "difficulty": 3,
    "xp": 30,
    "phase": "foundations",
    "description": "Learn to use enums for named constants and symbolic values. Understand const keyword, #define macros, and proper constant management in kernel programming.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// TODO: Define preprocessor constants\n#define MAX_DEVICES 10\n#define DEVICE_NAME_LEN 32\n#define VERSION_MAJOR 2\n#define VERSION_MINOR 1\n\n// TODO: Define enum for device states\nenum device_state {\n    DEVICE_OFFLINE,\n    DEVICE_INITIALIZING,\n    DEVICE_READY, \n    DEVICE_BUSY,\n    DEVICE_ERROR\n};\n\n// TODO: Define enum for operation types\nenum operation_type {\n    OP_READ = 1,\n    OP_WRITE = 2,\n    OP_IOCTL = 4,\n    OP_MMAP = 8\n};\n\nstatic int __init enums_init(void) {\n    const int buffer_size = 1024;\n    const char *driver_name = \"test_driver\";\n    enum device_state current_state = DEVICE_READY;\n    enum operation_type allowed_ops = OP_READ | OP_WRITE;\n    int device_count = 5;\n    \n    // TODO: Print constant values\n    // \"Constants:\"\n    // \"MAX_DEVICES: 10\"\n    // \"DEVICE_NAME_LEN: 32\" \n    // \"Version: 2.1\"\n    // \"Buffer size: 1024\"\n    // \"Driver name: test_driver\"\n    \n    // TODO: Print enum values and their integer representations\n    // \"Device States:\"\n    // \"DEVICE_OFFLINE = 0\"\n    // \"DEVICE_READY = 2\" \n    // \"Current state: DEVICE_READY (2)\"\n    \n    // TODO: Use enums in conditional logic\n    // if (current_state == DEVICE_READY) print \"Device is ready\"\n    // if (device_count < MAX_DEVICES) print \"Can add more devices\"\n    // if (allowed_ops & OP_READ) print \"Read operation allowed\"\n    \n    return 0;\n}\n\nstatic void __exit enums_exit(void) {\n    printk(KERN_INFO \"Enums and constants module unloaded\\n\");\n}\n\nmodule_init(enums_init);\nmodule_exit(enums_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Enums and constants demonstration module\");",
    "concepts": [
      "enums",
      "#define macros",
      "const keyword",
      "symbolic constants",
      "enum values",
      "bitfield operations"
    ],
    "skills": [
      "Constant management",
      "Symbolic programming",
      "Type-safe constants",
      "Code maintainability"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Constants:",
        "MAX_DEVICES: 10",
        "DEVICE_NAME_LEN: 32",
        "Version: 2.1",
        "Buffer size: 1024",
        "Driver name: test_driver",
        "Device States:",
        "DEVICE_OFFLINE = 0",
        "DEVICE_READY = 2",
        "Current state: DEVICE_READY (2)",
        "Device is ready",
        "Can add more devices",
        "Read operation allowed"
      ],
      "requirements": [
        "Use required function names: enums_init, enums_exit",
        "Define preprocessor constants: MAX_DEVICES=10, DEVICE_NAME_LEN=32, VERSION_MAJOR=2, VERSION_MINOR=1",
        "Define enum device_state with exact values: DEVICE_OFFLINE, DEVICE_INITIALIZING, DEVICE_READY, DEVICE_BUSY, DEVICE_ERROR",
        "Define enum operation_type with exact values: OP_READ=1, OP_WRITE=2, OP_IOCTL=4, OP_MMAP=8",
        "Use const variables: buffer_size=1024, driver_name=\"test_driver\"",
        "Use enums in variables: current_state=DEVICE_READY, allowed_ops=OP_READ|OP_WRITE",
        "Print exact format shown above with enum values and their integer representations"
      ]
    }
  },
  {
    "id": 12,
    "title": "Kernel Logging with printk and Log Levels",
    "difficulty": 3,
    "xp": 30,
    "phase": "foundations",
    "description": "Master kernel logging using printk with different log levels. Understand when to use each log level and how kernel logging differs from userspace printf.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int __init printk_init(void) {\n    int error_code = -12;\n    int device_count = 3;\n    unsigned long memory_addr = 0xdeadbeef;\n    \n    // TODO: Use different printk log levels\n    // KERN_EMERG: System is unusable\n    // KERN_ALERT: Action must be taken immediately  \n    // KERN_CRIT: Critical conditions\n    // KERN_ERR: Error conditions\n    // KERN_WARNING: Warning conditions\n    // KERN_NOTICE: Normal but significant condition\n    // KERN_INFO: Informational\n    // KERN_DEBUG: Debug-level messages\n    \n    // TODO: Demonstrate each log level with appropriate messages\n    printk(KERN_INFO \"Module initialization started\\n\");\n    \n    // TODO: Simulate different scenarios with appropriate log levels\n    if (device_count > 0) {\n        printk(KERN_NOTICE \"Found %d devices during initialization\\n\", device_count);\n    }\n    \n    if (error_code < 0) {\n        printk(KERN_WARNING \"Non-critical error occurred: %d\\n\", error_code);\n    }\n    \n    // TODO: Show different format specifiers\n    printk(KERN_DEBUG \"Debug info: memory_addr=0x%lx, device_count=%d\\n\", \n           memory_addr, device_count);\n    \n    // TODO: Demonstrate pr_* macros (modern alternatives)\n    pr_info(\"Using pr_info macro for informational message\\n\");\n    pr_warn(\"Using pr_warn macro for warning message\\n\");\n    pr_err(\"Using pr_err macro for error message\\n\");\n    \n    // TODO: Rate-limited printing\n    printk_ratelimited(KERN_INFO \"This message is rate-limited\\n\");\n    \n    // Expected output (with appropriate log levels):\n    // \"Module initialization started\"\n    // \"Found 3 devices during initialization\" \n    // \"Non-critical error occurred: -12\"\n    // \"Debug info: memory_addr=0xdeadbeef, device_count=3\"\n    // \"Using pr_info macro for informational message\"\n    // \"Using pr_warn macro for warning message\"\n    // \"Using pr_err macro for error message\"\n    // \"This message is rate-limited\"\n    \n    return 0;\n}\n\nstatic void __exit printk_exit(void) {\n    printk(KERN_INFO \"Module cleanup completed\\n\");\n}\n\nmodule_init(printk_init);\nmodule_exit(printk_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Kernel logging with printk and log levels module\");",
    "concepts": [
      "printk function",
      "kernel log levels",
      "KERN_* constants",
      "pr_* macros",
      "format specifiers",
      "rate limiting",
      "kernel vs userspace logging"
    ],
    "skills": [
      "Kernel debugging",
      "Logging best practices",
      "Message categorization",
      "Format string usage"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Module initialization started",
        "Found 3 devices during initialization",
        "Non-critical error occurred: -12",
        "Debug info: memory_addr=0xdeadbeef, device_count=3",
        "Using pr_info macro for informational message",
        "Using pr_warn macro for warning message",
        "Using pr_err macro for error message",
        "This message is rate-limited"
      ],
      "requirements": [
        "Use required function names: printk_init, printk_exit",
        "Use exact variable values: error_code=-12, device_count=3, memory_addr=0xdeadbeef",
        "Use different printk log levels: KERN_INFO, KERN_NOTICE, KERN_WARNING, KERN_DEBUG",
        "Use pr_* macros: pr_info, pr_warn, pr_err",
        "Use printk_ratelimited for rate-limited message",
        "Use appropriate format specifiers: %d, %lx",
        "Match log levels to message content appropriately",
        "Print messages in exact format shown above"
      ]
    }
  },
  {
    "id": 13,
    "title": "Structures and Pointers - Part 2: Arrow Operator",
    "difficulty": 4,
    "xp": 35,
    "phase": "foundations",
    "description": "Learn to use pointers to structures and the arrow operator. Understand the difference between dot and arrow operators. This builds on Part 1 structure knowledge.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// From Part 1 - COMPLETED CODE (structure definition):\n// You learned structure definition, member access with dot operator\n\n// Define the same structure from Part 1:\nstruct student {\n    int id;\n    char name[20];\n    int age;\n    float gpa;\n};\n\n// Part 2 - NEW CONCEPTS:\n// TODO: Learn pointer to structure and arrow operator\n\nstatic int __init structures_pointers_init(void) {\n    struct student stu = {102, \"Bob\", 21, 3.5};\n    \n    // TODO: Declare a pointer 'stu_ptr' that points to 'stu'\n    // TODO: Print all member values using arrow operator:\n    // \"Student ID via pointer: 102\"\n    // \"Student Name via pointer: Bob\"\n    // \"Student Age via pointer: 21\"\n    // \"Student GPA via pointer: 3\"\n    \n    return 0;\n}\n\nstatic void __exit structures_pointers_exit(void) {\n    printk(KERN_INFO \"Structures and pointers module unloaded\\n\");\n}\n\nmodule_init(structures_pointers_init);\nmodule_exit(structures_pointers_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Structures and pointers demonstration module\");",
    "concepts": [
      "pointers to structures",
      "arrow operator",
      "structure pointer dereferencing",
      "dot vs arrow operator"
    ],
    "skills": [
      "Advanced structure usage",
      "Pointer-based structure access",
      "Operator selection",
      "Structure pointer manipulation"
    ],
    "totalParts": 3,
    "inputOutput": {
      "expectedOutput": [
        "Student ID via pointer: 102",
        "Student Name via pointer: Bob",
        "Student Age via pointer: 21",
        "Student GPA via pointer: 3"
      ],
      "requirements": [
        "Use required function names: structures_pointers_init, structures_pointers_exit",
        "Use provided structure definition and initialization",
        "Declare pointer 'stu_ptr' that points to 'stu'",
        "Access all members using arrow operator (stu_ptr->member)",
        "Print in exact format shown above",
        "Must use arrow operator, not dot operator with pointer"
      ]
    }
  },
  {
    "id": 14,
    "title": "Pointers Basics - Part 1: Declaration and Dereferencing",
    "difficulty": 4,
    "xp": 30,
    "phase": "foundations",
    "description": "Learn fundamental pointer concepts in kernel programming. Understand pointer declaration, assignment, and dereferencing. This is the first part of the pointer series.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// TODO: Declare an integer variable 'num' with value 42\n// TODO: Declare a pointer 'ptr' that points to 'num'\n// TODO: Print the value of 'num' directly\n// TODO: Print the value of 'num' through the pointer\n// TODO: Print the address stored in the pointer\n\nstatic int __init pointers_init(void) {\n    // TODO: Implement pointer basics\n    // Expected output format:\n    // \"Direct value: 42\"\n    // \"Value through pointer: 42\"\n    // \"Address in pointer: 0x[hex_address]\"\n    \n    return 0;\n}\n\nstatic void __exit pointers_exit(void) {\n    printk(KERN_INFO \"Pointers module unloaded\\n\");\n}\n\nmodule_init(pointers_init);\nmodule_exit(pointers_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Pointers basics demonstration module\");",
    "concepts": [
      "pointers",
      "pointer declaration",
      "dereferencing",
      "address-of operator",
      "memory addresses"
    ],
    "skills": [
      "Pointer manipulation",
      "Memory understanding",
      "Indirection concepts",
      "Address arithmetic"
    ],
    "totalParts": 3,
    "inputOutput": {
      "expectedOutput": [
        "Direct value: 42",
        "Value through pointer: 42",
        "Address in pointer: (0x[hex] or (____ptrval____))"
      ],
      "requirements": [
        "Use required function names: pointers_init, pointers_exit",
        "Declare integer variable 'num' with value 42",
        "Declare pointer 'ptr' that points to 'num'",
        "Print direct value, dereferenced value, and address",
        "Use exact format strings shown above",
        "Address output should show pointer value (may be obfuscated as (____ptrval____) for security)"
      ]
    }
  },
  {
    "id": 15,
    "title": "Pointers and Arrays - Part 2: Array Traversal with Pointers",
    "difficulty": 4,
    "xp": 35,
    "phase": "foundations",
    "description": "Learn the relationship between pointers and arrays in kernel programming. Use pointers to traverse arrays and understand pointer arithmetic. This builds on Part 1 pointer knowledge.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// From Part 1 - COMPLETED CODE (pointer basics):\n// You learned pointer declaration, dereferencing, and address access\n\n// Part 2 - NEW CONCEPTS:\n// TODO: Declare an array 'values' with elements [100, 200, 300, 400, 500]\n// TODO: Declare a pointer 'arr_ptr' that points to the first element of the array\n// TODO: Use pointer arithmetic to traverse the array\n// TODO: Print each element using pointer notation\n\nstatic int __init pointers_arrays_init(void) {\n    // TODO: Implement array traversal with pointers\n    // Expected output format:\n    // \"Element 0: 100\"\n    // \"Element 1: 200\"\n    // \"Element 2: 300\"\n    // \"Element 3: 400\"\n    // \"Element 4: 500\"\n    \n    return 0;\n}\n\nstatic void __exit pointers_arrays_exit(void) {\n    printk(KERN_INFO \"Pointers and arrays module unloaded\\n\");\n}\n\nmodule_init(pointers_arrays_init);\nmodule_exit(pointers_arrays_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Pointers and arrays demonstration module\");",
    "concepts": [
      "pointer arithmetic",
      "array-pointer relationship",
      "pointer traversal",
      "array indexing with pointers"
    ],
    "skills": [
      "Advanced pointer usage",
      "Array manipulation via pointers",
      "Pointer arithmetic",
      "Memory traversal"
    ],
    "totalParts": 3,
    "inputOutput": {
      "expectedOutput": [
        "Element 0: 100",
        "Element 1: 200",
        "Element 2: 300",
        "Element 3: 400",
        "Element 4: 500"
      ],
      "requirements": [
        "Use required function names: pointers_arrays_init, pointers_arrays_exit",
        "Declare array 'values' with exact elements [100, 200, 300, 400, 500]",
        "Declare pointer 'arr_ptr' that points to first array element",
        "Use pointer arithmetic (arr_ptr + i) to traverse array",
        "Print using pointer dereferencing *(arr_ptr + i)",
        "Use exact format strings shown above"
      ]
    }
  },
  {
    "id": 16,
    "title": "Pointers and Functions - Part 3: Pass by Reference",
    "difficulty": 5,
    "xp": 40,
    "phase": "foundations",
    "description": "Master passing pointers to functions to modify values by reference. Learn the difference between pass-by-value and pass-by-reference. This completes the pointer series foundation.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// From Parts 1-2 - COMPLETED CONCEPTS:\n// ✓ Pointer declaration and dereferencing\n// ✓ Array traversal with pointer arithmetic\n\n// Part 3 - NEW CONCEPTS:\n// TODO: Create function 'swap_values' that takes two int pointers and swaps their values\n// TODO: Create function 'double_value' that takes an int pointer and doubles the value\n\nstatic int __init pointers_functions_init(void) {\n    int x = 10, y = 20;\n    int z = 15;\n    \n    printk(KERN_INFO \"Before swap: x=%d, y=%d\\n\", x, y);\n    printk(KERN_INFO \"Before doubling: z=%d\\n\", z);\n    \n    // TODO: Call swap_values(&x, &y)\n    // TODO: Call double_value(&z)\n    \n    printk(KERN_INFO \"After swap: x=%d, y=%d\\n\", x, y);\n    printk(KERN_INFO \"After doubling: z=%d\\n\", z);\n    \n    return 0;\n}\n\nstatic void __exit pointers_functions_exit(void) {\n    printk(KERN_INFO \"Pointers and functions module unloaded\\n\");\n}\n\nmodule_init(pointers_functions_init);\nmodule_exit(pointers_functions_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Pointers and functions demonstration module\");",
    "concepts": [
      "pass by reference",
      "pointers as function parameters",
      "function pointer parameters",
      "value modification via pointers"
    ],
    "skills": [
      "Advanced function design",
      "Reference parameter handling",
      "Pointer-based value modification",
      "Function interface design"
    ],
    "totalParts": 3,
    "inputOutput": {
      "expectedOutput": [
        "Before swap: x=10, y=20",
        "Before doubling: z=15",
        "After swap: x=20, y=10",
        "After doubling: z=30"
      ],
      "requirements": [
        "Use required function names: pointers_functions_init, pointers_functions_exit",
        "Create function 'swap_values' with parameters (int *a, int *b)",
        "Create function 'double_value' with parameter (int *val)",
        "Functions must modify values through pointers",
        "Use exact variable names and values: x=10, y=20, z=15",
        "Print in exact format shown above"
      ]
    }
  },
  {
    "id": 17,
    "title": "Bitwise Operations and Bit Manipulation",
    "difficulty": 4,
    "xp": 35,
    "phase": "foundations",
    "description": "Master bitwise operations (&, |, ^, ~, <<, >>) essential for kernel programming, device drivers, and hardware interaction. Learn bit manipulation techniques for flags and registers.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int __init bitwise_init(void) {\n    unsigned int a = 0x5A;  // 01011010 binary\n    unsigned int b = 0x3C;  // 00111100 binary\n    unsigned int flags = 0x00;\n    unsigned int mask;\n    \n    // TODO: Perform basic bitwise operations\n    // AND: a & b\n    // OR: a | b  \n    // XOR: a ^ b\n    // NOT: ~a\n    // Left shift: a << 2\n    // Right shift: a >> 2\n    \n    // TODO: Bit manipulation for flags\n    // Set bit 3: flags |= (1 << 3)\n    // Clear bit 5: flags &= ~(1 << 5) \n    // Toggle bit 7: flags ^= (1 << 7)\n    // Check if bit 3 is set: (flags & (1 << 3)) != 0\n    \n    // TODO: Create mask for bits 2-5: mask = 0x3C (00111100)\n    // Extract bits 2-5 from a: (a & mask) >> 2\n    \n    // Print results in hex format:\n    // \"Bitwise Operations:\"\n    // \"0x5A & 0x3C = 0x18\"\n    // \"0x5A | 0x3C = 0x7E\" \n    // \"0x5A ^ 0x3C = 0x66\"\n    // \"~0x5A = 0xFFFFFFA5\"\n    // \"0x5A << 2 = 0x168\"\n    // \"0x5A >> 2 = 0x16\"\n    // \"Flag Operations:\"\n    // \"After setting bit 3: 0x8\"\n    // \"Bit 3 is set: 1\"\n    // \"Extracted bits 2-5: 0x6\"\n    \n    return 0;\n}\n\nstatic void __exit bitwise_exit(void) {\n    printk(KERN_INFO \"Bitwise operations module unloaded\\n\");\n}\n\nmodule_init(bitwise_init);\nmodule_exit(bitwise_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Bitwise operations and bit manipulation module\");",
    "concepts": [
      "bitwise AND (&)",
      "bitwise OR (|)",
      "bitwise XOR (^)",
      "bitwise NOT (~)",
      "left shift (<<)",
      "right shift (>>)",
      "bit manipulation",
      "flag operations"
    ],
    "skills": [
      "Bit manipulation",
      "Hardware register access",
      "Flag operations",
      "Low-level programming"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Bitwise Operations:",
        "0x5A & 0x3C = 0x18",
        "0x5A | 0x3C = 0x7E",
        "0x5A ^ 0x3C = 0x66",
        "~0x5A = 0xFFFFFFA5",
        "0x5A << 2 = 0x168",
        "0x5A >> 2 = 0x16",
        "Flag Operations:",
        "After setting bit 3: 0x8",
        "Bit 3 is set: 1",
        "Extracted bits 2-5: 0x6"
      ],
      "requirements": [
        "Use required function names: bitwise_init, bitwise_exit",
        "Use exact values: a=0x5A, b=0x3C, flags=0x00",
        "Perform all bitwise operations: &, |, ^, ~, <<, >>",
        "Implement bit manipulation: set bit, clear bit, toggle bit, check bit",
        "Create and use bit mask for extraction",
        "Print results in hexadecimal format (0x prefix)",
        "Must use actual bitwise calculations, not hardcoded results"
      ]
    }
  },
  {
    "id": 18,
    "title": "String Manipulation and Character Arrays",
    "difficulty": 4,
    "xp": 35,
    "phase": "foundations",
    "description": "Master string handling in kernel space using character arrays and kernel string functions. Learn the difference between string literals, character arrays, and pointers to strings.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n\nstatic int __init strings_init(void) {\n    char str1[50] = \"Hello\";\n    char str2[50] = \"World\";\n    char result[100];\n    char *dynamic_str;\n    const char *literal = \"Kernel Programming\";\n    int len1, len2, total_len;\n    int cmp_result;\n    \n    // TODO: Get string lengths using strlen\n    // len1 = strlen(str1)\n    // len2 = strlen(str2)\n    // total_len = strlen(literal)\n    \n    // TODO: String concatenation using strcat\n    // strcpy(result, str1)  // Copy \"Hello\" to result\n    // strcat(result, \" \")   // Append space\n    // strcat(result, str2)  // Append \"World\"\n    \n    // TODO: String comparison using strcmp\n    // cmp_result = strcmp(str1, str2)\n    \n    // TODO: Dynamic string allocation and copy\n    // dynamic_str = kstrdup(literal, GFP_KERNEL)\n    \n    // TODO: Character manipulation\n    // Convert first character of str1 to lowercase if uppercase\n    // if (str1[0] >= 'A' && str1[0] <= 'Z') str1[0] += 32\n    \n    // Print results:\n    // \"String Operations:\"\n    // \"str1 length: 5\"\n    // \"str2 length: 5\"\n    // \"literal length: 18\"\n    // \"Concatenated: Hello World\"\n    // \"strcmp(\\\"Hello\\\", \\\"World\\\"): -15\" (or negative value)\n    // \"Dynamic string: Kernel Programming\"\n    // \"First char converted: hello\"\n    \n    // TODO: Clean up dynamic allocation\n    if (dynamic_str)\n        kfree(dynamic_str);\n    \n    return 0;\n}\n\nstatic void __exit strings_exit(void) {\n    printk(KERN_INFO \"String manipulation module unloaded\\n\");\n}\n\nmodule_init(strings_init);\nmodule_exit(strings_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"String manipulation and character arrays module\");",
    "concepts": [
      "character arrays",
      "string literals",
      "strlen function",
      "strcpy function",
      "strcat function",
      "strcmp function",
      "dynamic strings",
      "character manipulation"
    ],
    "skills": [
      "String processing",
      "Memory-safe string operations",
      "Character array handling",
      "Dynamic string management"
    ],
    "inputOutput": {
      "expectedOutput": [
        "String Operations:",
        "str1 length: 5",
        "str2 length: 5",
        "literal length: 18",
        "Concatenated: Hello World",
        "strcmp(\"Hello\", \"World\"): -15",
        "Dynamic string: Kernel Programming",
        "First char converted: hello"
      ],
      "requirements": [
        "Use required function names: strings_init, strings_exit",
        "Include linux/string.h for string functions",
        "Use exact string values: str1=\"Hello\", str2=\"World\", literal=\"Kernel Programming\"",
        "Use kernel string functions: strlen, strcpy, strcat, strcmp",
        "Use kstrdup for dynamic string allocation with GFP_KERNEL",
        "Perform character manipulation using array indexing",
        "Use proper memory cleanup with kfree",
        "Print results in exact format shown above"
      ]
    }
  },
  {
    "id": 19,
    "title": "Macros and Preprocessor Directives",
    "difficulty": 4,
    "xp": 35,
    "phase": "foundations",
    "description": "Master preprocessor macros, conditional compilation, and function-like macros essential for kernel programming. Learn proper macro design and common kernel macro patterns.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// TODO: Define simple object-like macros\n#define BUFFER_SIZE 1024\n#define MAX_USERS 100\n#define DRIVER_VERSION \"1.2.3\"\n\n// TODO: Define function-like macros\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define SQUARE(x) ((x) * (x))\n#define IS_POWER_OF_2(x) (((x) != 0) && (((x) & ((x) - 1)) == 0))\n\n// TODO: Define conditional compilation macros\n#define DEBUG_ENABLED 1\n\n#if DEBUG_ENABLED\n#define DEBUG_PRINT(fmt, args...) printk(KERN_DEBUG fmt, ##args)\n#else\n#define DEBUG_PRINT(fmt, args...) do { } while (0)\n#endif\n\n// TODO: Define multi-line macro with do-while(0)\n#define INIT_DEVICE(dev, id, name) do { \\\n    (dev)->device_id = (id); \\\n    strncpy((dev)->device_name, (name), sizeof((dev)->device_name) - 1); \\\n    (dev)->device_name[sizeof((dev)->device_name) - 1] = '\\0'; \\\n    (dev)->status = 0; \\\n} while (0)\n\nstruct device {\n    int device_id;\n    char device_name[32];\n    int status;\n};\n\nstatic int __init macros_init(void) {\n    int a = 15, b = 25;\n    int num = 8;\n    struct device my_device;\n    \n    // TODO: Use simple macros\n    // Print buffer size, max users, and version\n    \n    // TODO: Use function-like macros\n    // Calculate and print MIN(a, b), MAX(a, b), SQUARE(num)\n    // Check if num is power of 2\n    \n    // TODO: Use conditional compilation\n    // Use DEBUG_PRINT to print debug message\n    \n    // TODO: Use multi-line macro\n    // Initialize device with id=1, name=\"test_device\"\n    \n    // Expected output:\n    // \"Macro Constants:\"\n    // \"Buffer size: 1024\"\n    // \"Max users: 100\"\n    // \"Driver version: 1.2.3\"\n    // \"Function Macros:\"\n    // \"MIN(15, 25) = 15\"\n    // \"MAX(15, 25) = 25\"\n    // \"SQUARE(8) = 64\"\n    // \"8 is power of 2: 1\"\n    // \"Debug message: Module initialized\"\n    // \"Device initialized: ID=1, Name=test_device\"\n    \n    return 0;\n}\n\nstatic void __exit macros_exit(void) {\n    printk(KERN_INFO \"Macros module unloaded\\n\");\n}\n\nmodule_init(macros_init);\nmodule_exit(macros_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Macros and preprocessor directives module\");",
    "concepts": [
      "object-like macros",
      "function-like macros",
      "conditional compilation",
      "#if/#else/#endif",
      "variadic macros",
      "do-while(0) idiom",
      "macro safety"
    ],
    "skills": [
      "Preprocessor programming",
      "Macro design",
      "Conditional compilation",
      "Code generation"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Macro Constants:",
        "Buffer size: 1024",
        "Max users: 100",
        "Driver version: 1.2.3",
        "Function Macros:",
        "MIN(15, 25) = 15",
        "MAX(15, 25) = 25",
        "SQUARE(8) = 64",
        "8 is power of 2: 1",
        "Debug message: Module initialized",
        "Device initialized: ID=1, Name=test_device"
      ],
      "requirements": [
        "Use required function names: macros_init, macros_exit",
        "Define object-like macros: BUFFER_SIZE=1024, MAX_USERS=100, DRIVER_VERSION=\"1.2.3\"",
        "Define function-like macros: MIN, MAX, SQUARE, IS_POWER_OF_2",
        "Implement conditional compilation with DEBUG_ENABLED and DEBUG_PRINT",
        "Define multi-line macro INIT_DEVICE using do-while(0) idiom",
        "Use exact variable values: a=15, b=25, num=8",
        "Use all defined macros in the code",
        "Print results in exact format shown above"
      ]
    }
  },
  {
    "id": 20,
    "title": "Unions, Type Casting, and Memory Layout",
    "difficulty": 4,
    "xp": 35,
    "phase": "foundations",
    "description": "Learn unions for overlapping memory layouts and type casting for data conversion. Essential for hardware registers, protocol headers, and low-level kernel programming.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// TODO: Define union for different data interpretations\nunion data_converter {\n    unsigned int full_value;      // 32-bit integer\n    unsigned short half_values[2]; // Two 16-bit values  \n    unsigned char bytes[4];        // Four 8-bit values\n    struct {\n        unsigned char b0:4;  // Lower 4 bits\n        unsigned char b1:4;  // Upper 4 bits of first byte\n        unsigned char b2:4;\n        unsigned char b3:4;\n        unsigned char b4:4;\n        unsigned char b5:4;\n        unsigned char b6:4;\n        unsigned char b7:4;\n    } nibbles;  // Bit fields\n};\n\n// TODO: Define union for network packet header\nunion packet_header {\n    struct {\n        unsigned char version:4;\n        unsigned char header_len:4;\n        unsigned char type_of_service;\n        unsigned short total_length;\n    } ip_header;\n    unsigned char raw_bytes[4];\n    unsigned int raw_value;\n};\n\nstatic int __init unions_init(void) {\n    union data_converter converter;\n    union packet_header packet;\n    void *generic_ptr;\n    int int_value = 0x12345678;\n    float float_value = 3.14;\n    \n    // TODO: Use union to interpret data differently\n    converter.full_value = 0x12345678;\n    \n    // TODO: Type casting examples\n    // Cast int to float and back\n    float_value = (float)int_value;\n    int_value = (int)float_value;\n    \n    // TODO: Pointer type casting\n    generic_ptr = &converter;\n    int *int_ptr = (int *)generic_ptr;\n    char *char_ptr = (char *)generic_ptr;\n    \n    // TODO: Initialize packet header\n    packet.ip_header.version = 4;\n    packet.ip_header.header_len = 5; \n    packet.ip_header.type_of_service = 0;\n    packet.ip_header.total_length = 1500;\n    \n    // Print results:\n    // \"Union Data Converter:\"\n    // \"Full value: 0x12345678\"\n    // \"Half values: 0x1234, 0x5678\" (or 0x5678, 0x1234 on little-endian)\n    // \"Bytes: 0x12, 0x34, 0x56, 0x78\" (or reversed on little-endian)\n    // \"Type Casting:\"\n    // \"int to float: 305419896.000000\"\n    // \"Pointer casting works\"\n    // \"Packet Header:\"\n    // \"Version: 4, Header Length: 5\"\n    // \"Total Length: 1500\"\n    // \"Raw header bytes: 0x45, 0x0, 0xDC, 0x5\" (endian-dependent)\n    \n    return 0;\n}\n\nstatic void __exit unions_exit(void) {\n    printk(KERN_INFO \"Unions and type casting module unloaded\\n\");\n}\n\nmodule_init(unions_init);\nmodule_exit(unions_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Unions and type casting demonstration module\");",
    "concepts": [
      "unions",
      "overlapping memory",
      "type casting",
      "bit fields",
      "endianness",
      "pointer casting",
      "memory layout"
    ],
    "skills": [
      "Low-level memory manipulation",
      "Data structure optimization",
      "Hardware interface programming",
      "Type system understanding"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Union Data Converter:",
        "Full value: 0x12345678",
        "Half values: 0x1234, 0x5678",
        "Bytes: 0x12, 0x34, 0x56, 0x78",
        "Type Casting:",
        "int to float: 305419896.000000",
        "Pointer casting works",
        "Packet Header:",
        "Version: 4, Header Length: 5",
        "Total Length: 1500",
        "Raw header bytes: 0x45, 0x0, 0xDC, 0x5"
      ],
      "requirements": [
        "Use required function names: unions_init, unions_exit",
        "Define union data_converter with overlapping int, short array, byte array, and bit fields",
        "Define union packet_header with IP header struct and raw data views",
        "Use exact values: converter.full_value=0x12345678, int_value=0x12345678, float_value=3.14",
        "Demonstrate type casting: int to float, pointer casting",
        "Initialize packet header: version=4, header_len=5, total_length=1500",
        "Print all union members to show overlapping memory",
        "Handle endianness correctly in output"
      ]
    }
  },
  {
    "id": 21,
    "title": "Variable Scope, Storage Classes, and Lifetime",
    "difficulty": 4,
    "xp": 35,
    "phase": "foundations",
    "description": "Master variable scope (global, local, static) and storage classes in kernel programming. Understand variable lifetime, initialization, and proper usage patterns for kernel modules.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// TODO: Global variables (module scope)\nstatic int global_counter = 0;\nstatic char global_buffer[100];\nconst char *global_name = \"test_module\";\n\n// TODO: Function with static local variable\nstatic int increment_static_counter(void) {\n    static int static_counter = 0;  // Retains value between calls\n    int local_temp = 10;            // Reset each call\n    \n    static_counter++;\n    local_temp++;\n    \n    printk(KERN_INFO \"Static counter: %d, Local temp: %d\\n\", static_counter, local_temp);\n    return static_counter;\n}\n\n// TODO: Function with automatic variables\nstatic void demonstrate_scope(int param) {\n    int local_var = param * 2;      // Automatic storage\n    \n    if (param > 5) {\n        int block_var = local_var + 1;  // Block scope\n        printk(KERN_INFO \"Block scope: param=%d, local_var=%d, block_var=%d\\n\", \n               param, local_var, block_var);\n    }\n    // block_var is not accessible here\n    \n    printk(KERN_INFO \"Function scope: param=%d, local_var=%d\\n\", param, local_var);\n}\n\n// TODO: Function demonstrating variable shadowing\nstatic void demonstrate_shadowing(void) {\n    int value = 100;  // Outer scope\n    \n    printk(KERN_INFO \"Outer scope value: %d\\n\", value);\n    \n    {\n        int value = 200;  // Inner scope - shadows outer\n        printk(KERN_INFO \"Inner scope value: %d\\n\", value);\n    }\n    \n    printk(KERN_INFO \"Back to outer scope value: %d\\n\", value);\n}\n\nstatic int __init scope_init(void) {\n    int local_init = 42;\n    \n    // TODO: Demonstrate global variable access\n    global_counter = 5;\n    strcpy(global_buffer, \"Hello from global\");\n    \n    printk(KERN_INFO \"Variable Scope Demonstration:\\n\");\n    printk(KERN_INFO \"Global counter: %d\\n\", global_counter);\n    printk(KERN_INFO \"Global buffer: %s\\n\", global_buffer);\n    printk(KERN_INFO \"Global name: %s\\n\", global_name);\n    printk(KERN_INFO \"Local init: %d\\n\", local_init);\n    \n    // TODO: Call functions to demonstrate static vs local\n    printk(KERN_INFO \"\\nStatic vs Local Variables:\\n\");\n    increment_static_counter();  // Should print: Static counter: 1, Local temp: 11\n    increment_static_counter();  // Should print: Static counter: 2, Local temp: 11\n    increment_static_counter();  // Should print: Static counter: 3, Local temp: 11\n    \n    // TODO: Demonstrate function scope\n    printk(KERN_INFO \"\\nFunction Scope:\\n\");\n    demonstrate_scope(3);  // param <= 5, no block scope\n    demonstrate_scope(8);  // param > 5, shows block scope\n    \n    // TODO: Demonstrate variable shadowing\n    printk(KERN_INFO \"\\nVariable Shadowing:\\n\");\n    demonstrate_shadowing();\n    \n    return 0;\n}\n\nstatic void __exit scope_exit(void) {\n    printk(KERN_INFO \"Final global counter: %d\\n\", global_counter);\n    printk(KERN_INFO \"Variable scope module unloaded\\n\");\n}\n\nmodule_init(scope_init);\nmodule_exit(scope_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Variable scope and storage classes module\");",
    "concepts": [
      "global variables",
      "local variables",
      "static variables",
      "automatic storage",
      "variable lifetime",
      "scope rules",
      "variable shadowing"
    ],
    "skills": [
      "Scope management",
      "Memory lifetime understanding",
      "Variable design patterns",
      "Code organization"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Variable Scope Demonstration:",
        "Global counter: 5",
        "Global buffer: Hello from global",
        "Global name: test_module",
        "Local init: 42",
        "Static vs Local Variables:",
        "Static counter: 1, Local temp: 11",
        "Static counter: 2, Local temp: 11",
        "Static counter: 3, Local temp: 11",
        "Function Scope:",
        "Function scope: param=3, local_var=6",
        "Block scope: param=8, local_var=16, block_var=17",
        "Function scope: param=8, local_var=16",
        "Variable Shadowing:",
        "Outer scope value: 100",
        "Inner scope value: 200",
        "Back to outer scope value: 100"
      ],
      "requirements": [
        "Use required function names: scope_init, scope_exit",
        "Define static global variables: global_counter, global_buffer, global_name",
        "Implement increment_static_counter with static local variable",
        "Implement demonstrate_scope showing local and block scope",
        "Implement demonstrate_shadowing showing variable shadowing",
        "Use exact values and demonstrate all scope types",
        "Show difference between static and automatic storage",
        "Print results in exact format shown above"
      ]
    }
  },
  {
    "id": 22,
    "title": "Structures and Functions - Part 3: Passing Structures",
    "difficulty": 5,
    "xp": 40,
    "phase": "foundations",
    "description": "Master passing structures to functions by value and by reference. Learn when to use each approach and understand the performance implications. This completes the structure series.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n// From Parts 1-2 - COMPLETED CONCEPTS:\n// ✓ Structure definition and member access with dot operator\n// ✓ Pointers to structures and arrow operator\n\n// Define the same structure from previous parts:\nstruct student {\n    int id;\n    char name[20];\n    int age;\n    float gpa;\n};\n\n// Part 3 - NEW CONCEPTS:\n// TODO: Create function 'print_student_byval' that takes struct student by value\n// TODO: Create function 'update_gpa' that takes struct student* and new GPA value\n// TODO: update_gpa should modify the GPA through the pointer\n\nstatic int __init structures_functions_init(void) {\n    struct student stu = {103, \"Charlie\", 22, 3.2};\n    \n    printk(KERN_INFO \"Original student:\\n\");\n    // TODO: Call print_student_byval(stu)\n    \n    // TODO: Call update_gpa(&stu, 3.9)\n    \n    printk(KERN_INFO \"After GPA update:\\n\");\n    // TODO: Call print_student_byval(stu) again\n    \n    return 0;\n}\n\nstatic void __exit structures_functions_exit(void) {\n    printk(KERN_INFO \"Structures and functions module unloaded\\n\");\n}\n\nmodule_init(structures_functions_init);\nmodule_exit(structures_functions_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Structures and functions demonstration module\");",
    "concepts": [
      "structures as function parameters",
      "pass by value vs pass by reference",
      "structure modification via pointers",
      "function parameter design"
    ],
    "skills": [
      "Advanced function design with structures",
      "Parameter passing strategies",
      "Structure modification patterns",
      "Performance-aware programming"
    ],
    "totalParts": 3,
    "inputOutput": {
      "expectedOutput": [
        "Original student:",
        "ID: 103, Name: Charlie, Age: 22, GPA: 3",
        "After GPA update:",
        "ID: 103, Name: Charlie, Age: 22, GPA: 3"
      ],
      "requirements": [
        "Use required function names: structures_functions_init, structures_functions_exit",
        "Create function 'print_student_byval' with parameter (struct student s)",
        "Create function 'update_gpa' with parameters (struct student *s, float new_gpa)",
        "print_student_byval must print: \"ID: X, Name: Y, Age: Z, GPA: W\"",
        "update_gpa must modify GPA through pointer",
        "Use exact variable values: id=103, name=\"Charlie\", age=22, initial gpa=3.2, new gpa=3.9"
      ]
    }
  },
  {
    "id": 23,
    "title": "Kernel Memory Management - Part 1: kmalloc and kfree",
    "difficulty": 5,
    "xp": 45,
    "phase": "foundations",
    "description": "Learn kernel memory allocation using kmalloc and kfree. Understand the difference between kernel and userspace memory management. This is the first part of kernel memory series.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n\n// TODO: Allocate memory for an array of 5 integers using kmalloc\n// TODO: Initialize the array with values [10, 20, 30, 40, 50]\n// TODO: Print each value\n// TODO: Free the memory using kfree\n\nstatic int __init kmalloc_init(void) {\n    // TODO: Declare a pointer to int called 'arr'\n    // TODO: Allocate memory: arr = kmalloc(5 * sizeof(int), GFP_KERNEL)\n    // TODO: Check if allocation succeeded (arr != NULL)\n    // TODO: Initialize and print values\n    // TODO: Free memory before returning\n    \n    return 0;\n}\n\nstatic void __exit kmalloc_exit(void) {\n    printk(KERN_INFO \"Kernel memory module unloaded\\n\");\n}\n\nmodule_init(kmalloc_init);\nmodule_exit(kmalloc_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Kernel memory management demonstration module\");",
    "concepts": [
      "kmalloc",
      "kfree",
      "GFP_KERNEL",
      "kernel memory allocation",
      "memory leak prevention"
    ],
    "skills": [
      "Kernel memory management",
      "Dynamic allocation",
      "Memory safety",
      "Resource cleanup"
    ],
    "totalParts": 3,
    "inputOutput": {
      "expectedOutput": [
        "Memory allocated successfully",
        "arr[0] = 10",
        "arr[1] = 20",
        "arr[2] = 30",
        "arr[3] = 40",
        "arr[4] = 50",
        "Memory freed successfully"
      ],
      "requirements": [
        "Use required function names: kmalloc_init, kmalloc_exit",
        "Include linux/slab.h for memory allocation functions",
        "Declare pointer 'arr' of type int*",
        "Use kmalloc(5 * sizeof(int), GFP_KERNEL) for allocation",
        "Check for allocation failure (NULL pointer)",
        "Initialize array with exact values [10, 20, 30, 40, 50]",
        "Print each element in format 'arr[i] = value'",
        "Use kfree(arr) to free memory",
        "Print allocation and free success messages"
      ]
    }
  },
  {
    "id": 24,
    "title": "Kernel Memory Management - Part 2: Dynamic Strings with kstrdup",
    "difficulty": 5,
    "xp": 45,
    "phase": "foundations",
    "description": "Learn kernel string management using kstrdup, strlen, and proper string handling. Understand kernel string functions vs userspace equivalents. This builds on Part 1 memory knowledge.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n// From Part 1 - COMPLETED CONCEPTS:\n// ✓ kmalloc and kfree for basic memory allocation\n// ✓ NULL pointer checking and memory safety\n\n// Part 2 - NEW CONCEPTS:\n// TODO: Learn kernel string functions and dynamic string allocation\n\nstatic int __init kstrings_init(void) {\n    const char *original = \"Hello Kernel World\";\n    char *copy1, *copy2;\n    \n    // TODO: Use kstrdup to create a copy of 'original'\n    // TODO: Use kmalloc + strcpy to create another copy\n    // TODO: Print both copies and their lengths\n    // TODO: Free both allocated strings\n    \n    // Expected output:\n    // \"Original: Hello Kernel World\"\n    // \"Copy1 (kstrdup): Hello Kernel World\"\n    // \"Copy2 (kmalloc+strcpy): Hello Kernel World\"\n    // \"String length: 18\"\n    // \"Strings freed successfully\"\n    \n    return 0;\n}\n\nstatic void __exit kstrings_exit(void) {\n    printk(KERN_INFO \"Kernel strings module unloaded\\n\");\n}\n\nmodule_init(kstrings_init);\nmodule_exit(kstrings_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Kernel string management demonstration module\");",
    "concepts": [
      "kstrdup",
      "kernel string functions",
      "strlen in kernel",
      "strcpy in kernel",
      "string memory management"
    ],
    "skills": [
      "Kernel string handling",
      "Dynamic string allocation",
      "String function usage",
      "Advanced memory management"
    ],
    "totalParts": 3,
    "inputOutput": {
      "expectedOutput": [
        "Original: Hello Kernel World",
        "Copy1 (kstrdup): Hello Kernel World",
        "Copy2 (kmalloc+strcpy): Hello Kernel World",
        "String length: 18",
        "Strings freed successfully"
      ],
      "requirements": [
        "Use required function names: kstrings_init, kstrings_exit",
        "Include linux/string.h for string functions",
        "Use exact string: \"Hello Kernel World\"",
        "Create copy1 using kstrdup(original, GFP_KERNEL)",
        "Create copy2 using kmalloc + strcpy combination",
        "Check for allocation failures",
        "Use strlen to get string length",
        "Print in exact format shown above",
        "Free both allocated strings with kfree"
      ]
    }
  },
  {
    "id": 25,
    "title": "Kernel Memory Management - Part 3: Dynamic Structures",
    "difficulty": 6,
    "xp": 50,
    "phase": "foundations",
    "description": "Master dynamic allocation of structures in kernel space. Combine structure knowledge with kernel memory management. This completes the kernel memory series and prepares for advanced concepts.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n// From Parts 1-2 - COMPLETED CONCEPTS:\n// ✓ kmalloc/kfree for basic memory allocation\n// ✓ kstrdup and kernel string functions\n// ✓ Structure definition and usage\n\n// Define a kernel data structure:\nstruct device_info {\n    int device_id;\n    char *device_name;\n    int status;  // 0=inactive, 1=active\n    unsigned long timestamp;\n};\n\n// Part 3 - NEW CONCEPTS:\n// TODO: Dynamic allocation of structures with embedded pointers\n\nstatic int __init kmem_structures_init(void) {\n    struct device_info *dev;\n    \n    // TODO: Allocate memory for struct device_info using kmalloc\n    // TODO: Initialize: device_id=100, device_name=\"eth0\", status=1, timestamp=123456789\n    // TODO: Use kstrdup for device_name allocation\n    // TODO: Print all structure members\n    // TODO: Free device_name first, then the structure\n    \n    // Expected output:\n    // \"Device allocated successfully\"\n    // \"Device ID: 100\"\n    // \"Device Name: eth0\"\n    // \"Device Status: 1 (active)\"\n    // \"Device Timestamp: 123456789\"\n    // \"Device memory freed successfully\"\n    \n    return 0;\n}\n\nstatic void __exit kmem_structures_exit(void) {\n    printk(KERN_INFO \"Kernel memory structures module unloaded\\n\");\n}\n\nmodule_init(kmem_structures_init);\nmodule_exit(kmem_structures_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Kernel memory structures demonstration module\");",
    "concepts": [
      "dynamic structure allocation",
      "embedded pointers in structures",
      "complex memory cleanup",
      "kernel data structures",
      "memory management patterns"
    ],
    "skills": [
      "Advanced memory management",
      "Complex data structure handling",
      "Resource cleanup patterns",
      "Kernel programming best practices"
    ],
    "totalParts": 3,
    "inputOutput": {
      "expectedOutput": [
        "Device allocated successfully",
        "Device ID: 100",
        "Device Name: eth0",
        "Device Status: 1 (active)",
        "Device Timestamp: 123456789",
        "Device memory freed successfully"
      ],
      "requirements": [
        "Use required function names: kmem_structures_init, kmem_structures_exit",
        "Use provided struct device_info definition",
        "Allocate structure using kmalloc(sizeof(struct device_info), GFP_KERNEL)",
        "Initialize with exact values: device_id=100, device_name=\"eth0\", status=1, timestamp=123456789",
        "Use kstrdup for device_name allocation",
        "Check for allocation failures",
        "Access members using arrow operator",
        "Free device_name first, then structure",
        "Print in exact format shown above"
      ]
    }
  },
  {
    "id": 26,
    "title": "Module Parameters and Configuration",
    "difficulty": 4,
    "xp": 40,
    "phase": "foundations",
    "description": "Learn to create configurable kernel modules using module parameters. Understand how to accept configuration from userspace during module loading. This is essential for production kernel modules.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/moduleparam.h>\n\n// TODO: Declare module parameters:\n// - int parameter 'debug_level' with default value 1\n// - string parameter 'device_name' with default value \"default_device\"\n// - bool parameter 'enable_logging' with default value true\n\n// TODO: Use module_param() to make parameters configurable\n// TODO: Use MODULE_PARM_DESC() to add parameter descriptions\n\nstatic int __init modparam_init(void) {\n    // TODO: Print current parameter values\n    // Expected format:\n    // \"Module loaded with parameters:\"\n    // \"Debug Level: X\"\n    // \"Device Name: Y\"\n    // \"Logging Enabled: Z\"\n    \n    return 0;\n}\n\nstatic void __exit modparam_exit(void) {\n    printk(KERN_INFO \"Module parameters module unloaded\\n\");\n}\n\nmodule_init(modparam_init);\nmodule_exit(modparam_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Module parameters demonstration\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "module parameters",
      "moduleparam.h",
      "module_param macro",
      "MODULE_PARM_DESC",
      "runtime configuration"
    ],
    "skills": [
      "Module configuration",
      "Parameter handling",
      "User-kernel interface",
      "Production module design"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Module loaded with parameters:",
        "Debug Level: 1",
        "Device Name: default_device",
        "Logging Enabled: 1"
      ],
      "requirements": [
        "Use required function names: modparam_init, modparam_exit",
        "Include linux/moduleparam.h",
        "Declare parameters: debug_level (int, default 1), device_name (string, default \"default_device\"), enable_logging (bool, default true)",
        "Use module_param() for each parameter",
        "Use MODULE_PARM_DESC() for parameter descriptions",
        "Print parameters in exact format shown above",
        "Use S_IRUGO permissions for parameters"
      ]
    }
  },
  {
    "id": 27,
    "title": "Kernel Error Handling and Return Codes",
    "difficulty": 5,
    "xp": 45,
    "phase": "foundations",
    "description": "Learn proper error handling in kernel space using standard Linux error codes. Understand error propagation and cleanup patterns essential for reliable kernel code.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\n// TODO: Create function 'allocate_buffer' that:\n// - Takes size parameter\n// - Returns pointer on success, NULL on failure\n// - Handles allocation errors properly\n\n// TODO: Create function 'process_data' that:\n// - Takes buffer pointer and size\n// - Returns 0 on success, negative error code on failure\n// - Validates parameters (returns -EINVAL for NULL pointer or zero size)\n\nstatic int __init error_handling_init(void) {\n    char *buffer;\n    int result;\n    int size = 1024;\n    \n    // TODO: Call allocate_buffer and handle errors\n    // TODO: Call process_data and handle errors\n    // TODO: Implement proper cleanup on errors\n    \n    // Expected output:\n    // \"Buffer allocated successfully (1024 bytes)\"\n    // \"Data processed successfully\"\n    // \"Cleanup completed\"\n    \n    return 0;\n}\n\nstatic void __exit error_handling_exit(void) {\n    printk(KERN_INFO \"Error handling module unloaded\\n\");\n}\n\nmodule_init(error_handling_init);\nmodule_exit(error_handling_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Error handling demonstration module\");",
    "concepts": [
      "kernel error codes",
      "error propagation",
      "cleanup patterns",
      "EINVAL, ENOMEM",
      "defensive programming"
    ],
    "skills": [
      "Error handling",
      "Defensive programming",
      "Resource cleanup",
      "Code reliability"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Buffer allocated successfully (1024 bytes)",
        "Data processed successfully",
        "Cleanup completed"
      ],
      "requirements": [
        "Use required function names: error_handling_init, error_handling_exit",
        "Include linux/errno.h for error codes",
        "Create function 'allocate_buffer' that returns char* (NULL on failure)",
        "Create function 'process_data' that returns int (0 success, negative error)",
        "Use standard error codes: -ENOMEM for allocation failure, -EINVAL for invalid parameters",
        "Handle all error conditions with proper cleanup",
        "Print success messages in exact format shown above",
        "Free allocated memory in all code paths"
      ]
    }
  },
  {
    "id": 28,
    "title": "Foundation Capstone: Complete Kernel Module",
    "difficulty": 6,
    "xp": 60,
    "phase": "foundations",
    "description": "Create a comprehensive kernel module that demonstrates all foundation concepts. This capstone project combines everything learned to build a production-ready kernel module with proper error handling, memory management, and configuration.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/moduleparam.h>\n#include <linux/errno.h>\n\n// TODO: Define a structure 'kernel_device' with:\n// - int device_id\n// - char *name\n// - int status (0=inactive, 1=active)\n// - void *data_buffer\n// - size_t buffer_size\n\n// TODO: Module parameters:\n// - int max_devices (default 5)\n// - int buffer_size (default 1024)\n// - bool debug_mode (default false)\n\n// TODO: Global variables:\n// - Array of pointers to kernel_device structures\n// - Counter for active devices\n\n// TODO: Functions to implement:\n// - create_device(int id, const char *name) -> returns pointer or NULL\n// - destroy_device(struct kernel_device *dev) -> cleanup function\n// - list_devices(void) -> print all active devices\n\nstatic int __init capstone_init(void) {\n    // TODO: Initialize module\n    // TODO: Create 3 test devices with IDs 1, 2, 3 and names \"dev1\", \"dev2\", \"dev3\"\n    // TODO: List all devices\n    // TODO: Handle all error conditions\n    \n    return 0;\n}\n\nstatic void __exit capstone_exit(void) {\n    // TODO: Cleanup all allocated resources\n    // TODO: Destroy all devices\n    printk(KERN_INFO \"Foundation capstone module unloaded\\n\");\n}\n\nmodule_init(capstone_init);\nmodule_exit(capstone_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Foundation capstone demonstration module\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "comprehensive module design",
      "integrated memory management",
      "error handling patterns",
      "module parameters",
      "resource cleanup",
      "production practices"
    ],
    "skills": [
      "Complete module development",
      "Integration of all foundation concepts",
      "Production-ready code",
      "Professional kernel programming"
    ],
    "inputOutput": {
      "expectedOutput": [
        "Foundation Capstone Module loaded",
        "Module parameters: max_devices=5, buffer_size=1024, debug_mode=0",
        "Device 1 (dev1) created successfully",
        "Device 2 (dev2) created successfully",
        "Device 3 (dev3) created successfully",
        "Active devices:",
        "  Device 1: dev1 (status: 1, buffer: 1024 bytes)",
        "  Device 2: dev2 (status: 1, buffer: 1024 bytes)",
        "  Device 3: dev3 (status: 1, buffer: 1024 bytes)",
        "Total active devices: 3"
      ],
      "requirements": [
        "Use required function names: capstone_init, capstone_exit",
        "Define struct kernel_device with exact members specified",
        "Implement module parameters: max_devices, buffer_size, debug_mode with defaults",
        "Implement functions: create_device, destroy_device, list_devices",
        "Create exactly 3 devices with IDs 1,2,3 and names dev1,dev2,dev3",
        "Allocate buffer for each device using module parameter buffer_size",
        "Implement complete error handling with proper cleanup",
        "Print output in exact format shown above",
        "Free all resources in exit function"
      ]
    }
  },
  {
    "id": 29,
    "title": "Comprehensive Foundations Assessment",
    "difficulty": 7,
    "xp": 75,
    "phase": "foundations",
    "description": "Final comprehensive assessment integrating all foundation concepts: variables, functions, pointers, structures, memory management, control flow, and kernel-specific features. This validates complete mastery of kernel C foundations.",
    "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/moduleparam.h>\n#include <linux/errno.h>\n\n// TODO: Define preprocessor constants\n#define MAX_STUDENTS 50\n#define NAME_LENGTH 32\n#define GRADE_LEVELS 5\n\n// TODO: Define enum for student status\nenum student_status {\n    STATUS_ENROLLED,\n    STATUS_ACTIVE,\n    STATUS_GRADUATED,\n    STATUS_DROPPED\n};\n\n// TODO: Define student structure\nstruct student {\n    int student_id;\n    char *name;\n    enum student_status status;\n    float gpa;\n    int courses[4];\n    int course_count;\n};\n\n// TODO: Define union for grade data\nunion grade_data {\n    float numeric_grade;\n    char letter_grade;\n    struct {\n        unsigned int passed:1;\n        unsigned int honors:1;\n        unsigned int credits:6;\n    } flags;\n};\n\n// TODO: Module parameters\nstatic int max_capacity = 30;\nstatic bool debug_enabled = false;\nmodule_param(max_capacity, int, S_IRUGO);\nmodule_param(debug_enabled, bool, S_IRUGO);\n\n// TODO: Global variables\nstatic struct student **student_list = NULL;\nstatic int student_count = 0;\nstatic unsigned long statistics = 0;\n\n// TODO: Function prototypes and implementations\n\n// Function to create a new student\nstatic struct student *create_student(int id, const char *name, float gpa) {\n    struct student *new_student;\n    \n    // TODO: Allocate memory for student\n    // TODO: Allocate memory for name and copy\n    // TODO: Initialize all fields\n    // TODO: Return pointer or NULL on failure\n    \n    return NULL; // Placeholder\n}\n\n// Function to destroy a student and free memory\nstatic void destroy_student(struct student *student) {\n    // TODO: Free name memory\n    // TODO: Free student structure\n}\n\n// Function to calculate class statistics using pointers\nstatic void calculate_statistics(struct student **students, int count, \n                               float *avg_gpa, int *active_count) {\n    // TODO: Calculate average GPA of active students\n    // TODO: Count active students\n    // TODO: Use pointer arithmetic and dereferencing\n}\n\n// Function to process grades using unions and bitwise operations\nstatic void process_grades(union grade_data *grades, int count) {\n    // TODO: Process array of grade data\n    // TODO: Use bitwise operations on flags\n    // TODO: Print grade information\n}\n\n// Function demonstrating control flow\nstatic int enrollment_manager(void) {\n    int result = 0;\n    \n    // TODO: Use loops to create test students\n    // TODO: Use conditionals for validation\n    // TODO: Use switch for status processing\n    // TODO: Demonstrate break/continue\n    \n    return result;\n}\n\nstatic int __init assessment_init(void) {\n    float average_gpa = 0.0;\n    int active_students = 0;\n    union grade_data test_grades[3];\n    int i;\n    \n    pr_info(\"=== Comprehensive Foundations Assessment ===\\n\");\n    pr_info(\"Module parameters: max_capacity=%d, debug_enabled=%d\\n\", \n            max_capacity, debug_enabled);\n    \n    // TODO: Allocate memory for student list\n    student_list = kmalloc(sizeof(struct student *) * MAX_STUDENTS, GFP_KERNEL);\n    if (!student_list) {\n        pr_err(\"Failed to allocate student list\\n\");\n        return -ENOMEM;\n    }\n    \n    // TODO: Initialize student list to NULL\n    for (i = 0; i < MAX_STUDENTS; i++) {\n        student_list[i] = NULL;\n    }\n    \n    // TODO: Run enrollment manager\n    if (enrollment_manager() < 0) {\n        pr_err(\"Enrollment manager failed\\n\");\n        kfree(student_list);\n        return -EIO;\n    }\n    \n    // TODO: Calculate statistics\n    calculate_statistics(student_list, student_count, &average_gpa, &active_students);\n    \n    // TODO: Process test grades\n    test_grades[0].numeric_grade = 95.5;\n    test_grades[1].letter_grade = 'A';\n    test_grades[2].flags.passed = 1;\n    test_grades[2].flags.honors = 1;\n    test_grades[2].flags.credits = 3;\n    \n    process_grades(test_grades, 3);\n    \n    // TODO: Print final statistics\n    pr_info(\"Final Statistics: %d students, average GPA: %.2f\\n\", \n            active_students, average_gpa);\n    \n    return 0;\n}\n\nstatic void __exit assessment_exit(void) {\n    int i;\n    \n    // TODO: Clean up all allocated memory\n    if (student_list) {\n        for (i = 0; i < student_count; i++) {\n            if (student_list[i]) {\n                destroy_student(student_list[i]);\n            }\n        }\n        kfree(student_list);\n    }\n    \n    pr_info(\"Assessment module cleanup completed\\n\");\n}\n\nmodule_init(assessment_init);\nmodule_exit(assessment_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"Comprehensive foundations assessment module\");\nMODULE_VERSION(\"1.0\");",
    "concepts": [
      "comprehensive integration",
      "memory management",
      "data structures",
      "pointers and references",
      "control flow",
      "error handling",
      "module parameters",
      "unions and bitfields",
      "preprocessor directives",
      "function design"
    ],
    "skills": [
      "Complete foundation mastery",
      "Integration of all concepts",
      "Production-ready code",
      "Complex problem solving",
      "Memory safety",
      "Error handling patterns"
    ],
    "inputOutput": {
      "expectedOutput": [
        "=== Comprehensive Foundations Assessment ===",
        "Module parameters: max_capacity=30, debug_enabled=0",
        "Created student: ID=1, Name=Alice, GPA=3.8",
        "Created student: ID=2, Name=Bob, GPA=3.5",
        "Created student: ID=3, Name=Charlie, GPA=3.9",
        "Processing grades:",
        "Grade 0: Numeric 95.5",
        "Grade 1: Letter A",
        "Grade 2: Passed=1, Honors=1, Credits=3",
        "Final Statistics: 3 students, average GPA: 3.73"
      ],
      "requirements": [
        "Use required function names: assessment_init, assessment_exit",
        "Implement all required functions: create_student, destroy_student, calculate_statistics, process_grades, enrollment_manager",
        "Use all foundation concepts: structs, unions, enums, pointers, arrays, loops, conditionals",
        "Implement proper memory management with kmalloc/kfree",
        "Use module parameters with proper declarations",
        "Implement comprehensive error handling",
        "Use bitwise operations and unions correctly",
        "Create at least 3 test students with proper data",
        "Calculate and display statistics correctly"
      ]
    }
  }
];

export default problemBank;
