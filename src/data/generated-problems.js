// Auto-generated from problems/ directory
// DO NOT EDIT THIS FILE DIRECTLY - Edit problems/*.json instead
// Generated at: 2025-08-31T08:03:08.540Z

const problemBank = [
  {
    "id": 1,
    "title": "Hello World - Your First Kernel Module",
    "difficulty": 1,
    "xp": 10,
    "phase": "foundations",
    "description": "Welcome to kernel programming! Create your very first kernel module - a simple \"Hello World\" program that runs inside the Linux kernel. This introduction uses just one file to keep things simple and help you understand the basics before moving to more advanced topics.",
    "concepts": [
      "kernel modules",
      "printk function",
      "module_init and module_exit",
      "basic kernel programming",
      "module lifecycle"
    ],
    "skills": [
      "Understanding kernel vs userspace",
      "Using printk for kernel output",
      "Creating init and exit functions",
      "Basic module structure",
      "Kernel module compilation"
    ],
    "files": [
      {
        "name": "hello.c",
        "content": "/* WELCOME TO KERNEL PROGRAMMING!\n *\n * What is this program?\n * - This is a \"kernel module\" - code that runs inside the Linux operating system\n * - Think of it like adding a small program to your computer's core brain\n * - When you load this module, it will print a message you can see with 'dmesg'\n * \n * Don't worry if you don't understand everything - just follow the TODOs!\n * Programming is learned by doing, step by step.\n */\n\n#include <linux/module.h>    /* For all kernel modules */\n#include <linux/kernel.h>    /* For printk() function */\n#include <linux/init.h>      /* For __init and __exit macros */\n\n/* TODO: Create the init function */\n/* This function runs when the module is loaded into memory */\n/* 'static' means only this file can use this function */\n/* 'int' means this function returns a number (0 = success) */\nstatic int __init hello_init(void)\n{\n    /* TODO: Print \"Hello World from kernel!\" using printk */\n    /* printk is like printf, but for kernel messages */\n    /* KERN_INFO means \"information level\" message */\n    /* \\n means \"new line\" (like pressing Enter) */\n    /* Use: printk(KERN_INFO \"Your message here\\n\"); */\n    \n    return 0;  /* Return 0 means \"success, everything worked!\" */\n}\n\n/* TODO: Create the exit function */\n/* This function runs when the module is unloaded from memory */\n/* 'void' means this function doesn't return anything */\nstatic void __exit hello_exit(void)\n{\n    /* TODO: Print \"Goodbye from kernel!\" using printk */\n    /* This lets us know the module was unloaded successfully */\n    /* Use: printk(KERN_INFO \"Your message here\\n\"); */\n}\n\n/* These lines tell the kernel which functions to call */\n/* They register your functions with the kernel */\nmodule_init(hello_init);   /* This registers the init function */\nmodule_exit(hello_exit);   /* This registers the exit function */\n\n/* Module information - these are required by the kernel */\n/* Think of these like a \"name tag\" for your module */\nMODULE_LICENSE(\"GPL\");     /* GPL is a common open source license */\nMODULE_AUTHOR(\"Student\");   /* That's you! */\nMODULE_DESCRIPTION(\"My first kernel module - Hello World\");\nMODULE_VERSION(\"1.0\");     /* Version 1.0 - your first try! */",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Simple Makefile for hello world kernel module\nobj-m += hello.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "hello.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "hello_init",
          "hello_exit"
        ],
        "outputMessages": [
          "Hello World from kernel!",
          "Goodbye from kernel!"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h"
        ],
        "mustContain": [
          "printk",
          "KERN_INFO"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "static int __init hello_init(void)",
            "static void __exit hello_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "kernel_functionality_test",
          "name": "Kernel Module Functionality Test",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "hello_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\\\"=== Hello World Module Test ===\\\\n\\\");\\n    \\n    printf(\\\"Test: Loading hello module...\\\\n\\\");\\n    system(\\\"insmod /lib/modules/hello.ko\\\");\\n    \\n    printf(\\\"Test: Unloading hello module...\\\\n\\\");\\n    system(\\\"rmmod hello\\\");\\n    \\n    printf(\\\"SUCCESS: Module load/unload completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "testCommands": [
              "echo 'Testing kernel module compilation and basic functionality...'",
              "/bin/hello_tester",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Checking for kernel logging functionality...'",
              "dmesg | grep 'Hello World from kernel' && echo 'PASS: init function logging working' || echo 'FAIL: init function logging missing'",
              "dmesg | grep 'Goodbye from kernel' && echo 'PASS: exit function logging working' || echo 'FAIL: exit function logging missing'",
              "echo 'PASS: All kernel functionality tests completed'"
            ],
            "expected": {
              "dmesg": [
                "Hello World from kernel!",
                "Goodbye from kernel!"
              ],
              "stdout": [
                "Hello World Module Test",
                "SUCCESS: Module load/unload completed",
                "PASS: All kernel functionality tests completed"
              ]
            },
            "timeout": 10
          }
        },
        {
          "id": "exact_output",
          "name": "Function-Linked Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Hello World from kernel!",
              "exact": true,
              "linkedFunction": "static int __init hello_init(void)"
            },
            {
              "pattern": "Goodbye from kernel!",
              "exact": true,
              "linkedFunction": "static void __exit hello_exit(void)"
            }
          ]
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Hello World from kernel!",
        "Goodbye from kernel!"
      ],
      "requirements": [
        "Use required function names: hello_init, hello_exit",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h",
        "Code must contain: printk, KERN_INFO",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Hello World from kernel!",
          "linkedFunction": "static int __init hello_init(void)",
          "exact": true
        },
        {
          "pattern": "Goodbye from kernel!",
          "linkedFunction": "static void __exit hello_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 2,
    "title": "Hello World - Multi-File Kernel Module",
    "difficulty": 1,
    "xp": 15,
    "phase": "foundations",
    "description": "Create your first multi-file kernel module with a separate header file. This introduces you to kernel module structure with proper file organization. Note: Module init/exit functions are static and don't need header declarations.",
    "concepts": [
      "multi-file modules",
      "header files",
      "module_init",
      "module_exit",
      "printk",
      "Makefile"
    ],
    "skills": [
      "Header file creation",
      "File organization",
      "Module lifecycle",
      "Kernel logging",
      "Build system understanding"
    ],
    "files": [
      {
        "name": "hello.h",
        "content": "#ifndef HELLO_H\n#define HELLO_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n/* TODO: Add any shared constants or structures here */\n/* Note: Module init/exit functions are static and don't need declarations */\n\n#endif /* HELLO_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "hello.c",
        "content": "#include \"hello.h\"\n\n/* TODO: Implement your init function */\nstatic int __init hello_init(void)\n{\n    /* TODO: Print \"Hello from multi-file kernel module!\" */\n    return 0;\n}\n\n/* TODO: Implement your exit function */\nstatic void __exit hello_exit(void)\n{\n    /* TODO: Print \"Goodbye from multi-file kernel module!\" */\n}\n\n/* TODO: Set module init and exit functions */\nmodule_init(hello_init);\nmodule_exit(hello_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Multi-file Hello World kernel module\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Multi-file kernel module Makefile\nobj-m += hello.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "hello.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "hello_init",
          "hello_exit"
        ],
        "outputMessages": [
          "Hello from multi-file kernel module!",
          "Goodbye from multi-file kernel module!"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h"
        ],
        "mustContain": [
          "printk",
          "KERN_INFO"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "header_structure",
          "name": "Header File Structure",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "#ifndef HELLO_H",
            "#define HELLO_H",
            "#endif"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [],
          "prohibitedSymbols": [
            "static.*hello_init",
            "static.*hello_exit"
          ]
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "static int __init hello_init(void)",
            "static void __exit hello_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "multifile_functionality_test",
          "name": "Multi-File Module Functionality Test",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "multifile_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\\\"=== Multi-File Module Test ===\\\\n\\\");\\n    \\n    printf(\\\"Test: Loading multi-file hello module...\\\\n\\\");\\n    system(\\\"insmod /lib/modules/hello.ko\\\");\\n    \\n    printf(\\\"Test: Unloading multi-file hello module...\\\\n\\\");\\n    system(\\\"rmmod hello\\\");\\n    \\n    printf(\\\"SUCCESS: Multi-file module load/unload completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "testCommands": [
              "echo 'Testing multi-file kernel module functionality...'",
              "/bin/multifile_tester",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Checking for module information and functionality...'",
              "dmesg | grep 'Hello from multi-file kernel module' && echo 'PASS: init function with proper message' || echo 'FAIL: init function message missing'",
              "dmesg | grep 'Goodbye from multi-file kernel module' && echo 'PASS: exit function with proper message' || echo 'FAIL: exit function message missing'",
              "echo 'PASS: All multi-file functionality tests completed'"
            ],
            "expected": {
              "dmesg": [
                "Hello from multi-file kernel module!",
                "Goodbye from multi-file kernel module!"
              ],
              "stdout": [
                "Multi-File Module Test",
                "SUCCESS: Multi-file module load/unload completed",
                "PASS: All multi-file functionality tests completed"
              ]
            },
            "timeout": 10
          }
        },
        {
          "id": "exact_output",
          "name": "Function-Linked Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Hello from multi-file kernel module!",
              "exact": true,
              "linkedFunction": "static int __init hello_init(void)"
            },
            {
              "pattern": "Goodbye from multi-file kernel module!",
              "exact": true,
              "linkedFunction": "static void __exit hello_exit(void)"
            }
          ]
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Hello from multi-file kernel module!",
        "Goodbye from multi-file kernel module!"
      ],
      "requirements": [
        "Use required function names: hello_init, hello_exit",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h",
        "Code must contain: printk, KERN_INFO",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Hello from multi-file kernel module!",
          "linkedFunction": "static int __init hello_init(void)",
          "exact": true
        },
        {
          "pattern": "Goodbye from multi-file kernel module!",
          "linkedFunction": "static void __exit hello_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 3,
    "title": "Create Your First Variable",
    "difficulty": 1,
    "xp": 15,
    "phase": "foundations",
    "description": "Learn to create variables in kernel modules using proper file structure. You'll work with separate header and C files - a fundamental practice in professional kernel development that builds good coding habits from day one.",
    "concepts": [
      "variable declaration",
      "variable definition",
      "header files",
      "extern keyword",
      "file structure"
    ],
    "skills": [
      "Proper file organization",
      "Header/C file separation",
      "Variable management",
      "Professional coding habits"
    ],
    "files": [
      {
        "name": "variables.h",
        "content": "#ifndef VARIABLES_H\n#define VARIABLES_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n/* TODO: Declare your variable here */\n/* extern int my_number; */\n\n#endif /* VARIABLES_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "variables.c",
        "content": "#include \"variables.h\"\n\n/* TODO: Define your variable here with value 42 */\n/* int my_number = 42; */\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your variable is declared correctly.\n * Removing them will cause test failures.\n */\nmodule_param(my_number, int, 0644);\nMODULE_PARM_DESC(my_number, \"Variable for testing proper declaration\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\nstatic int __init variables_init(void)\n{\n    printk(KERN_INFO \"Variables module loaded\\n\");\n    /* TODO: Print the variable value to show it exists */\n    /* printk(KERN_INFO \"Variable value: %d\\n\", my_number); */\n    return 0;\n}\n\nstatic void __exit variables_exit(void)\n{\n    printk(KERN_INFO \"Variables module unloaded\\n\");\n}\n\nmodule_init(variables_init);\nmodule_exit(variables_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning variables with proper file structure\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Variables module Makefile\nobj-m += variables.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "variables.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "variables_init",
          "variables_exit"
        ],
        "variables_declarations": [
          {
            "name": "my_number",
            "type": "int",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "my_number",
            "type": "int",
            "value": 42,
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Variables module loaded"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h"
        ],
        "mustContain": [
          "#ifndef VARIABLES_H",
          "#define VARIABLES_H",
          "extern int my_number",
          "int my_number = 42",
          "#include \"variables.h\""
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "header_guards",
          "name": "Proper Header Guards",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "#ifndef VARIABLES_H",
            "#define VARIABLES_H",
            "#endif"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "variable_declaration",
          "name": "Variable Declaration in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "extern int my_number"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "variable_definition",
          "name": "Variable Definition in C File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int my_number = 42"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "static int __init variables_init(void)",
            "static void __exit variables_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "variable_functionality_test",
          "name": "Variable Declaration and Definition Test",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "variable_param_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Variable Parameter Validation Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random test values\\n    int test_val1 = (rand() % 50) + 10;  // 10-59\\n    int test_val2 = (rand() % 50) + 60;  // 60-109\\n    \\n    printf(\\\"Test 1: Loading with my_number=%d\\\\n\\\", test_val1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/variables.ko my_number=%d\\\", test_val1);\\n    system(\\\"rmmod variables 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Loading with my_number=%d\\\\n\\\", test_val2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/variables.ko my_number=%d\\\", test_val2);\\n    system(\\\"rmmod variables\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Variable parameter test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo 'Creating test file that validates extern variable declaration...'",
              "echo '#include \"/lib/modules/variables.h\"' > /tmp/test.c",
              "echo 'int main() { my_number = 42; return my_number; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: extern int my_number not properly declared in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: extern int my_number found in header file'",
              "echo 'Phase 2: Dynamic Parameter Testing'",
              "/bin/variable_param_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Phase 2.1: Variable parameter extraction...'",
              "TEST_VAL1=$(grep -o 'Test 1: Loading with my_number=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
              "TEST_VAL2=$(grep -o 'Test 2: Loading with my_number=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
              "echo 'Test value 1: '$TEST_VAL1",
              "echo 'Test value 2: '$TEST_VAL2",
              "echo 'Phase 2.2: Module parameter validation...'",
              "dmesg | grep 'Variables module loaded' && echo 'PASS: Module loads with parameter' || echo 'FAIL: Module loading failed'",
              "echo 'Phase 3: Default value validation (must be 42)...'",
              "rmmod variables 2>/dev/null",
              "insmod /lib/modules/variables.ko",
              "sleep 1",
              "DEFAULT_VALUE=$(cat /sys/module/variables/parameters/my_number 2>/dev/null || echo 'ERROR')",
              "echo 'Default value from parameter: '$DEFAULT_VALUE",
              "if [ \"$DEFAULT_VALUE\" = \"42\" ]; then",
              "    echo 'PASS: Variable initialized to 42 correctly'",
              "else",
              "    echo 'FAIL: Variable not initialized to 42 (got: '$DEFAULT_VALUE')'",
              "fi",
              "echo 'Phase 4: Value reassignment test (ensuring variable is mutable)...'",
              "echo 99 > /sys/module/variables/parameters/my_number 2>/dev/null",
              "NEW_VALUE=$(cat /sys/module/variables/parameters/my_number 2>/dev/null || echo 'ERROR')",
              "echo 'Value after reassignment: '$NEW_VALUE",
              "if [ \"$NEW_VALUE\" = \"99\" ]; then",
              "    echo 'PASS: Variable is mutable and reassignable'",
              "else",
              "    echo 'FAIL: Variable is not properly mutable (expected 99, got: '$NEW_VALUE')'",
              "fi",
              "echo 'Phase 5: Parameter accessibility validation...'",
              "ls /sys/module/variables/parameters/my_number >/dev/null 2>&1 && echo 'PASS: Variable exposed as module parameter' || echo 'FAIL: Variable not declared as module parameter'",
              "echo 'PASS: All variable validation tests completed'"
            ],
            "expected": {
              "dmesg": [
                "Variables module loaded",
                "Variables module unloaded"
              ],
              "stdout": [
                "PASS: extern int my_number found in header file",
                "Variable Parameter Validation Test",
                "SUCCESS: Variable parameter test completed",
                "PASS: Variable initialized to 42 correctly",
                "PASS: Variable is mutable and reassignable",
                "PASS: All variable validation tests completed"
              ]
            },
            "timeout": 10
          }
        },
        {
          "id": "exact_output",
          "name": "Exact Output Message",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Variables module loaded",
              "exact": true,
              "linkedFunction": "static int __init variables_init(void)"
            }
          ]
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Variables module loaded"
      ],
      "requirements": [
        "Use required function names: variables_init, variables_exit",
        "Use required variable names: my_number",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h",
        "Code must contain: #ifndef VARIABLES_H, #define VARIABLES_H, extern int my_number, int my_number = 42, #include \"variables.h\"",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Variables module loaded",
          "linkedFunction": "static int __init variables_init(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 4,
    "title": "Use Your Variable",
    "difficulty": 2,
    "xp": 20,
    "phase": "foundations",
    "description": "Learn to use variables by printing them with proper format specifiers. Build on your knowledge of header/C file structure while introducing printk formatting - a crucial skill for kernel debugging.",
    "concepts": [
      "variable usage",
      "printk formatting",
      "format specifiers",
      "integer printing",
      "debugging output"
    ],
    "skills": [
      "Using variables in printk",
      "printk with format specifiers",
      "Variable access in kernel modules",
      "Debugging output"
    ],
    "files": [
      {
        "name": "use_vars.h",
        "content": "#ifndef USE_VARS_H\n#define USE_VARS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nextern int my_number;\n\n#endif /* USE_VARS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "use_vars.c",
        "content": "#include \"use_vars.h\"\n\nint my_number = 42;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your variable usage works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(my_number, int, 0644);\nMODULE_PARM_DESC(my_number, \"Number to print for testing variable usage\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\nstatic int __init use_vars_init(void)\n{\n    printk(KERN_INFO \"Variable usage module loaded\\n\");\n    /* TODO: Print the variable using printk */\n    /* printk(KERN_INFO \"My number is: %d\\n\", my_number); */\n    return 0;\n}\n\nstatic void __exit use_vars_exit(void)\n{\n    printk(KERN_INFO \"Variable usage module unloaded\\n\");\n}\n\nmodule_init(use_vars_init);\nmodule_exit(use_vars_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning to use variables with printk formatting\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Variable usage module Makefile\nobj-m += use_vars.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "use_vars.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "use_vars_init",
          "use_vars_exit"
        ],
        "variables_declarations": [
          {
            "name": "my_number",
            "type": "int",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "my_number",
            "type": "int",
            "value": 42,
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Variable usage module loaded",
          "My number is: 42"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h"
        ],
        "mustContain": [
          "printk(KERN_INFO \"My number is: %d\\n\", my_number)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "static int __init use_vars_init(void)",
            "static void __exit use_vars_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "variable_usage_test",
          "name": "Variable Usage and Formatting Test",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "variable_usage_dynamic_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Variable Usage Dynamic Validation Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random test values\\n    int test_val1 = (rand() % 50) + 10;  // 10-59\\n    int test_val2 = (rand() % 50) + 60;  // 60-109\\n    int test_val3 = (rand() % 20) + 1;   // 1-20\\n    \\n    printf(\\\"Test 1: Testing with my_number=%d\\\\n\\\", test_val1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/use_vars.ko my_number=%d\\\", test_val1);\\n    system(\\\"rmmod use_vars 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Testing with my_number=%d\\\\n\\\", test_val2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/use_vars.ko my_number=%d\\\", test_val2);\\n    system(\\\"rmmod use_vars\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"Test 3: Testing with my_number=%d\\\\n\\\", test_val3);\\n    char cmd3[256];\\n    snprintf(cmd3, sizeof(cmd3), \\\"insmod /lib/modules/use_vars.ko my_number=%d\\\", test_val3);\\n    system(\\\"rmmod use_vars\\\");\\n    system(cmd3);\\n    \\n    printf(\\\"SUCCESS: Variable usage dynamic test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo 'Creating test file that validates extern variable declaration...'",
              "echo '#include \"/lib/modules/use_vars.h\"' > /tmp/test.c",
              "echo 'int main() { my_number = 99; return my_number; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: extern int my_number not properly declared in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: extern int my_number found in header file'",
              "echo 'Phase 2: Dynamic Variable Usage Testing'",
              "/bin/variable_usage_dynamic_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Phase 2.1: Dynamic test value extraction...'",
              "TEST_VAL1=$(grep -o 'Test 1: Testing with my_number=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
              "TEST_VAL2=$(grep -o 'Test 2: Testing with my_number=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
              "TEST_VAL3=$(grep -o 'Test 3: Testing with my_number=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
              "echo 'Test values: '$TEST_VAL1', '$TEST_VAL2', '$TEST_VAL3",
              "echo 'Phase 2.2: Basic module functionality check...'",
              "dmesg | grep 'Variable usage module loaded' && echo 'PASS: use_vars_init function working' || echo 'FAIL: use_vars_init function missing'",
              "echo 'Phase 3: Dynamic variable usage validation...'",
              "dmesg | grep \"My number is: $TEST_VAL1\" && echo \"PASS: Variable correctly prints value $TEST_VAL1\" || echo \"FAIL: Variable not used or wrong value (expected $TEST_VAL1)\"",
              "dmesg | grep \"My number is: $TEST_VAL2\" && echo \"PASS: Variable correctly prints value $TEST_VAL2\" || echo \"FAIL: Variable not used or wrong value (expected $TEST_VAL2)\"",
              "dmesg | grep \"My number is: $TEST_VAL3\" && echo \"PASS: Variable correctly prints value $TEST_VAL3\" || echo \"FAIL: Variable not used or wrong value (expected $TEST_VAL3)\"",
              "echo 'Phase 4: Default value validation (must be 42)...'",
              "rmmod use_vars 2>/dev/null",
              "insmod /lib/modules/use_vars.ko",
              "sleep 1",
              "dmesg | grep 'My number is: 42' && echo 'PASS: Default value 42 correctly displayed' || echo 'FAIL: Default value not 42 or not printed'",
              "echo 'Phase 5: Module unload check...'",
              "dmesg | grep 'Variable usage module unloaded' && echo 'PASS: use_vars_exit function working' || echo 'FAIL: use_vars_exit function missing'",
              "echo 'PASS: All variable usage dynamic validation tests completed'"
            ],
            "expected": {
              "dmesg": [
                "Variable usage module loaded",
                "My number is: .*",
                "Variable usage module unloaded"
              ],
              "stdout": [
                "PASS: extern int my_number found in header file",
                "Variable Usage Dynamic Validation Test",
                "SUCCESS: Variable usage dynamic test completed",
                "PASS: Default value 42 correctly displayed",
                "PASS: All variable usage dynamic validation tests completed"
              ]
            },
            "timeout": 10
          }
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Variable usage module loaded",
              "exact": true,
              "linkedFunction": "static int __init use_vars_init(void)"
            },
            {
              "pattern": "My number is: 42",
              "exact": true,
              "linkedFunction": "static int __init use_vars_init(void)"
            }
          ]
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Variable usage module loaded",
        "My number is: 42"
      ],
      "requirements": [
        "Use required function names: use_vars_init, use_vars_exit",
        "Use required variable names: my_number",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h",
        "Code must contain: printk(KERN_INFO \"My number is: %d\\n\", my_number)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Variable usage module loaded",
          "linkedFunction": "static int __init use_vars_init(void)",
          "exact": true
        },
        {
          "pattern": "My number is: 42",
          "linkedFunction": "static int __init use_vars_init(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 5,
    "title": "Multiple Variables - Study Complete Example",
    "difficulty": 2,
    "xp": 25,
    "phase": "foundations",
    "description": "Study a complete working example with multiple data types. See how int, char, and bool variables work together with proper format specifiers. This example includes advanced module parameter support that will be used in later problems.",
    "concepts": [
      "multiple data types",
      "integer variables",
      "character variables",
      "boolean variables",
      "format specifiers for different types"
    ],
    "skills": [
      "Managing multiple variables",
      "Understanding data type differences",
      "Using appropriate format specifiers",
      "Code organization with multiple variables"
    ],
    "files": [
      {
        "name": "multi_vars.h",
        "content": "#ifndef MULTI_VARS_H\n#define MULTI_VARS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* Function to print student information */\nvoid print_student_info(void);\n\n#endif /* MULTI_VARS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "multi_vars.c",
        "content": "#include \"multi_vars.h\"\n\n/* Complete working example\n * Study how these three different data types work together\n * Notice the different format specifiers for each type\n */\n\n/* Variable definitions with different data types */\nint student_id = 12345;      // Integer variable\nchar student_grade = 'A';    // Character variable  \nbool student_passed = true;  // Boolean variable\n\n/* Module parameters for advanced testing */\nmodule_param(student_id, int, 0644);\nMODULE_PARM_DESC(student_id, \"Student ID number\");\n/* Note: char and bool parameters need special handling */\n\n/* Complete function implementation - study the pattern */\nvoid print_student_info(void)\n{\n    printk(KERN_INFO \"=== Student Information ===\\n\");\n    printk(KERN_INFO \"Student ID: %d\\n\", student_id);        // %d for int\n    printk(KERN_INFO \"Student Grade: %c\\n\", student_grade);   // %c for char\n    printk(KERN_INFO \"Student Passed: %d\\n\", student_passed); // %d for bool (shows 0/1)\n}\n\nstatic int __init multi_vars_init(void)\n{\n    printk(KERN_INFO \"Multi-variable module loaded\\n\");\n    print_student_info();\n    return 0;\n}\n\nstatic void __exit multi_vars_exit(void)\n{\n    printk(KERN_INFO \"Multi-variable module unloaded\\n\");\n}\n\nmodule_init(multi_vars_init);\nmodule_exit(multi_vars_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Complete example: multiple variables and data types\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Multi-variable module Makefile\nobj-m += multi_vars.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "multi_vars.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "multi_vars_init",
          "multi_vars_exit",
          "print_student_info"
        ],
        "variables": [
          {
            "name": "student_id",
            "type": "int",
            "value": 12345
          },
          {
            "name": "student_grade",
            "type": "char",
            "value": "'A'"
          },
          {
            "name": "student_passed",
            "type": "bool",
            "value": true
          }
        ],
        "outputMessages": [
          "Multi-variable module loaded",
          "Student ID: 12345",
          "Student Grade: A",
          "Student Passed: 1"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "int student_id = 12345",
          "char student_grade = 'A'",
          "bool student_passed = true",
          "void print_student_info(void)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "multiple_definitions",
          "name": "Multiple Variable Definitions",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int student_id = 12345",
            "char student_grade = 'A'",
            "bool student_passed = true"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_structure",
          "name": "Print Function Implementation",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_student_info(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_student_info(void)",
            "static int __init multi_vars_init(void)",
            "static void __exit multi_vars_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_student_info(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Basic Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Multi-variable module loaded",
              "exact": true,
              "linkedFunction": "static int __init multi_vars_init(void)"
            },
            {
              "pattern": "Student Information",
              "exact": true,
              "linkedFunction": "void print_student_info(void)"
            },
            {
              "pattern": "Student ID: 12345",
              "exact": true,
              "linkedFunction": "void print_student_info(void)"
            },
            {
              "pattern": "Student Grade: A",
              "exact": true,
              "linkedFunction": "void print_student_info(void)"
            },
            {
              "pattern": "Student Passed: 1",
              "exact": true,
              "linkedFunction": "void print_student_info(void)"
            }
          ]
        },
        {
          "id": "demonstration_test",
          "name": "Study Example with Dynamic Testing",
          "type": "kernel_project_test",
          "critical": false,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "demo_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\"=== Part A Demo Test ===\\\\n\");\\n    printf(\"Demonstrating dynamic module parameters\\\\n\");\\n    \\n    printf(\"Test: Loading with student_id=99999\\\\n\");\\n    system(\"rmmod multi_vars 2>/dev/null\");\\n    system(\"insmod /lib/modules/multi_vars.ko student_id=99999\");\\n    \\n    printf(\"SUCCESS: Demo completed\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Demonstrating module parameter functionality'"
            ],
            "testCommands": [
              "/bin/demo_tester",
              "echo 'Check: Module parameter works'",
              "dmesg | grep 'Student ID: 99999' && echo 'DEMO: Parameter worked!' || echo 'INFO: Using default value'"
            ],
            "expected": {
              "dmesg": [
                "Multi-variable module loaded"
              ],
              "stdout": [
                "Part A Demo Test",
                "SUCCESS: Demo completed"
              ]
            },
            "timeout": 30
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Multi-variable module loaded",
        "Student ID: 12345",
        "Student Grade: A",
        "Student Passed: 1"
      ],
      "requirements": [
        "Use required function names: multi_vars_init, multi_vars_exit, print_student_info",
        "Use required variable names: student_id, student_grade, student_passed",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: int student_id = 12345, char student_grade = 'A', bool student_passed = true, void print_student_info(void)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Multi-variable module loaded",
          "linkedFunction": "static int __init multi_vars_init(void)",
          "exact": true
        },
        {
          "pattern": "Student Information",
          "linkedFunction": "void print_student_info(void)",
          "exact": true
        },
        {
          "pattern": "Student ID: 12345",
          "linkedFunction": "void print_student_info(void)",
          "exact": true
        },
        {
          "pattern": "Student Grade: A",
          "linkedFunction": "void print_student_info(void)",
          "exact": true
        },
        {
          "pattern": "Student Passed: 1",
          "linkedFunction": "void print_student_info(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 6,
    "title": "Multiple Variables - Guided Practice",
    "difficulty": 3,
    "xp": 35,
    "phase": "foundations",
    "description": "Build on Problem 4 by completing a partially implemented solution. Fill in strategic gaps while working with module parameters for dynamic testing. This bridges complete examples to independent creation.",
    "concepts": [
      "guided practice",
      "multiple data types",
      "format specifier completion",
      "variable initialization",
      "pattern application"
    ],
    "skills": [
      "Completing partial implementations",
      "Applying learned patterns",
      "Working with three data types",
      "Format specifier selection",
      "Code completion skills"
    ],
    "files": [
      {
        "name": "practice_vars.h",
        "content": "#ifndef PRACTICE_VARS_H\n#define PRACTICE_VARS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* Function to complete */\nvoid print_employee_info(void);\n\n#endif /* PRACTICE_VARS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "practice_vars.c",
        "content": "#include \"practice_vars.h\"\n\n/* Complete the strategic gaps below\n * Build on what you learned from Problem 4's complete example\n * This time YOU fill in the missing pieces!\n */\n\n/* TODO: Complete the variable definitions with these values:\n * employee_id = 67890\n * performance_grade = 'A'\n * is_promoted = true\n */\nint employee_id = _____;\nchar performance_grade = _____;\nbool is_promoted = _____;\n\n/* Module parameters for dynamic testing - DO NOT REMOVE! */\nmodule_param(employee_id, int, 0644);\nMODULE_PARM_DESC(employee_id, \"Employee ID for testing\");\n/* char and bool parameters handled separately */\n\nvoid print_employee_info(void)\n{\n    printk(KERN_INFO \"=== Employee Information ===\\n\");\n    \n    /* TODO: Complete these printk statements with correct format specifiers */\n    /* Hint: Use %d for int, %c for char, %d for bool */\n    printk(KERN_INFO \"Employee ID: %___, _____);    // Fill in format and variable\n    printk(KERN_INFO \"Grade: %___, _____);          // Fill in format and variable  \n    printk(KERN_INFO \"Promoted: %___, _____);       // Fill in format and variable\n}\n\nstatic int __init practice_vars_init(void)\n{\n    printk(KERN_INFO \"Practice variables module loaded\\n\");\n    print_employee_info();\n    return 0;\n}\n\nstatic void __exit practice_vars_exit(void)\n{\n    printk(KERN_INFO \"Practice variables module unloaded\\n\");\n}\n\nmodule_init(practice_vars_init);\nmodule_exit(practice_vars_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Guided practice with multiple variables and dynamic testing\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Practice variables module Makefile\nobj-m += practice_vars.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "practice_vars.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "practice_vars_init",
          "practice_vars_exit",
          "print_employee_info"
        ],
        "variables": [
          {
            "name": "employee_id",
            "type": "int",
            "value": 67890
          },
          {
            "name": "performance_grade",
            "type": "char",
            "value": "'A'"
          },
          {
            "name": "is_promoted",
            "type": "bool",
            "value": true
          }
        ],
        "outputMessages": [
          "Practice variables module loaded",
          "Employee Information",
          "Employee ID: 67890",
          "Grade: A",
          "Promoted: 1"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "int employee_id = 67890",
          "char performance_grade = 'A'",
          "bool is_promoted = true",
          "void print_employee_info(void)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "variable_completion",
          "name": "Variable Value Completion",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int employee_id = 67890",
            "char performance_grade = 'A'",
            "bool is_promoted = true"
          ],
          "prohibitedSymbols": [
            "_____"
          ]
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_employee_info(void)",
            "static int __init practice_vars_init(void)",
            "static void __exit practice_vars_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_employee_info(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Function-Linked Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Practice variables module loaded",
              "exact": true,
              "linkedFunction": "static int __init practice_vars_init(void)"
            },
            {
              "pattern": "Employee Information",
              "exact": true,
              "linkedFunction": "void print_employee_info(void)"
            },
            {
              "pattern": "Employee ID: 67890",
              "exact": true,
              "linkedFunction": "void print_employee_info(void)"
            },
            {
              "pattern": "Grade: A",
              "exact": true,
              "linkedFunction": "void print_employee_info(void)"
            },
            {
              "pattern": "Promoted: 1",
              "exact": true,
              "linkedFunction": "void print_employee_info(void)"
            }
          ]
        },
        {
          "id": "guided_dynamic_testing",
          "name": "Guided Dynamic Testing",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "practice_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\"=== Part B Practice Test ===\\\\n\");\\n    printf(\"Testing guided completion with dynamic values\\\\n\");\\n    \\n    printf(\"Test: Loading with employee_id=88888\\\\n\");\\n    system(\"rmmod practice_vars 2>/dev/null\");\\n    system(\"insmod /lib/modules/practice_vars.ko employee_id=88888\");\\n    \\n    printf(\"SUCCESS: Practice test completed\\\\n\");\\n    printf(\"PASS: Variable completion works\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting guided practice testing'"
            ],
            "testCommands": [
              "/bin/practice_tester",
              "echo 'Checking dynamic value'",
              "dmesg | grep 'Employee ID: 88888' && echo 'PASS: Dynamic employee_id worked' || echo 'FAIL: Must use variables, not hardcoded values'"
            ],
            "expected": {
              "dmesg": [
                "Practice variables module loaded",
                "Employee ID: 88888"
              ],
              "stdout": [
                "Part B Practice Test",
                "SUCCESS: Practice test completed",
                "PASS: Variable completion works"
              ]
            },
            "timeout": 30
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Practice variables module loaded",
        "Employee Information",
        "Employee ID: 67890",
        "Grade: A",
        "Promoted: 1"
      ],
      "requirements": [
        "Use required function names: practice_vars_init, practice_vars_exit, print_employee_info",
        "Use required variable names: employee_id, performance_grade, is_promoted",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: int employee_id = 67890, char performance_grade = 'A', bool is_promoted = true, void print_employee_info(void)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Practice variables module loaded",
          "linkedFunction": "static int __init practice_vars_init(void)",
          "exact": true
        },
        {
          "pattern": "Employee Information",
          "linkedFunction": "void print_employee_info(void)",
          "exact": true
        },
        {
          "pattern": "Employee ID: 67890",
          "linkedFunction": "void print_employee_info(void)",
          "exact": true
        },
        {
          "pattern": "Grade: A",
          "linkedFunction": "void print_employee_info(void)",
          "exact": true
        },
        {
          "pattern": "Promoted: 1",
          "linkedFunction": "void print_employee_info(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 7,
    "title": "Multiple Variables - Advanced Dynamic Testing",
    "difficulty": 4,
    "xp": 45,
    "phase": "foundations",
    "description": "Master advanced variable usage with dynamic testing! Create a complete solution that works with changing values - the system will test your code with different inputs to ensure you're using variables correctly, not hardcoding values.",
    "concepts": [
      "independent creation",
      "four data types",
      "complete implementation",
      "format specifier mastery",
      "creative problem solving"
    ],
    "skills": [
      "Writing code from requirements",
      "Managing four different data types",
      "Creating complete solutions",
      "Independent problem solving",
      "Applying learned patterns creatively"
    ],
    "files": [
      {
        "name": "create_vars.h",
        "content": "#ifndef CREATE_VARS_H\n#define CREATE_VARS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* TODO: Declare your function */\n/* void print_server_status(void); */\n\n#endif /* CREATE_VARS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "create_vars.c",
        "content": "#include \"create_vars.h\"\n\n/* CHALLENGE: Advanced Variable Creation with Dynamic Testing!\n * \n * REQUIREMENTS:\n * Create 4 variables with these default values:\n * - server_id = 1001 (int)\n * - status_code = 'R' for Ready (char)  \n * - temperature = 68 (int)\n * - online = true (bool)\n * \n * Print them in this exact format:\n * \"Server %d: Status %c, Temp %d, Online: %d\"\n * \n * CRITICAL WARNING: The testing system will change values dynamically!\n * You MUST use actual variables, not hardcoded values, or you will fail!\n */\n\n/* TODO: Define all 4 variables with the specified default values */\n\n\n\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your variables work with different values.\n * Removing them will cause test failures.\n */\nmodule_param(server_id, int, 0644);\nMODULE_PARM_DESC(server_id, \"Server ID for testing\");\nmodule_param(temperature, int, 0644);\nMODULE_PARM_DESC(temperature, \"Temperature value for testing\");\n/* Note: char and bool module params need special handling, so we only test int params */\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* TODO: Implement print_server_status function */\n/* Use appropriate format specifiers: %d for int, %c for char, %d for bool */\n/* WARNING: Use actual variables! The system tests with different values! */\nvoid print_server_status(void)\n{\n    /* TODO: Print the server information using the variables above */\n    \n    \n}\n\nstatic int __init create_vars_init(void)\n{\n    printk(KERN_INFO \"Variable creation module loaded\\n\");\n    print_server_status();\n    return 0;\n}\n\nstatic void __exit create_vars_exit(void)\n{\n    printk(KERN_INFO \"Variable creation module unloaded\\n\");\n}\n\nmodule_init(create_vars_init);\nmodule_exit(create_vars_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Advanced variable creation with dynamic testing\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Variable creation module Makefile\nobj-m += create_vars.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "create_vars.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "create_vars_init",
          "create_vars_exit",
          "print_server_status"
        ],
        "variables": [
          {
            "name": "server_id",
            "type": "int",
            "value": 1001
          },
          {
            "name": "status_code",
            "type": "char",
            "value": "'R'"
          },
          {
            "name": "temperature",
            "type": "int",
            "value": 68
          },
          {
            "name": "online",
            "type": "bool",
            "value": true
          }
        ],
        "outputMessages": [
          "Variable creation module loaded",
          "Server 1001: Status R, Temp 68, Online: 1"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "int server_id = 1001",
          "char status_code = 'R'",
          "int temperature = 68",
          "bool online = true",
          "void print_server_status(void)",
          "module_param(server_id, int, 0644)",
          "module_param(temperature, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "variable_definitions",
          "name": "Variable Definitions in Source",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int server_id = 1001",
            "char status_code = 'R'",
            "int temperature = 68",
            "bool online = true"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "module_parameters",
          "name": "Module Parameter Infrastructure",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "module_param(server_id, int, 0644)",
            "module_param(temperature, int, 0644)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_server_status(void)",
            "static int __init create_vars_init(void)",
            "static void __exit create_vars_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_server_status(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Basic Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Variable creation module loaded",
              "exact": true,
              "linkedFunction": "static int __init create_vars_init(void)"
            },
            {
              "pattern": "Server 1001: Status R, Temp 68, Online: 1",
              "exact": true,
              "linkedFunction": "void print_server_status(void)"
            }
          ]
        },
        {
          "id": "dynamic_variable_testing",
          "name": "Dynamic Variable Testing",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "variable_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\"=== Dynamic Variable Test ===\\\\n\");\\n    \\n    printf(\"Test 1: Testing server_id=2001, temperature=85\\\\n\");\\n    system(\"rmmod create_vars 2>/dev/null\");\\n    system(\"insmod /lib/modules/create_vars.ko server_id=2001 temperature=85\");\\n    \\n    printf(\"Test 2: Testing server_id=3001, temperature=92\\\\n\");\\n    system(\"rmmod create_vars\");\\n    system(\"insmod /lib/modules/create_vars.ko server_id=3001 temperature=92\");\\n    \\n    printf(\"SUCCESS: Dynamic test completed\\\\n\");\\n    printf(\"PASS: Variable usage detected\\\\n\");\\n    printf(\"PASS: Module parameters work\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting dynamic variable testing'"
            ],
            "testCommands": [
              "/bin/variable_tester",
              "echo 'Checking kernel output for dynamic values'",
              "dmesg | grep 'Server 2001' && echo 'PASS: 2001 test worked' || echo 'FAIL: 2001 test failed'",
              "dmesg | grep 'Temp 85' && echo 'PASS: 85 test worked' || echo 'FAIL: 85 test failed'",
              "dmesg | grep 'Server 3001' && echo 'PASS: 3001 test worked' || echo 'FAIL: 3001 test failed'",
              "dmesg | grep 'Temp 92' && echo 'PASS: 92 test worked' || echo 'FAIL: 92 test failed'"
            ],
            "expected": {
              "dmesg": [
                "Variable creation module loaded",
                "Server 2001: Status R, Temp 85, Online: 1",
                "Server 3001: Status R, Temp 92, Online: 1"
              ],
              "stdout": [
                "Dynamic Variable Test",
                "SUCCESS: Dynamic test completed",
                "PASS: Variable usage detected",
                "PASS: Module parameters work"
              ]
            },
            "timeout": 45
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Variable creation module loaded",
        "Server 1001: Status R, Temp 68, Online: 1"
      ],
      "requirements": [
        "Use required function names: create_vars_init, create_vars_exit, print_server_status",
        "Use required variable names: server_id, status_code, temperature, online",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: int server_id = 1001, char status_code = 'R', int temperature = 68, bool online = true, void print_server_status(void), module_param(server_id, int, 0644), module_param(temperature, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Variable creation module loaded",
          "linkedFunction": "static int __init create_vars_init(void)",
          "exact": true
        },
        {
          "pattern": "Server 1001: Status R, Temp 68, Online: 1",
          "linkedFunction": "void print_server_status(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 8,
    "title": "Function Parameters - Advanced Dynamic Testing",
    "difficulty": 4,
    "xp": 40,
    "phase": "foundations",
    "description": "Master function parameters and return values with dynamic testing! Create functions that work with changing input values - the system will test your functions with different parameters to ensure they work correctly, not just with hardcoded values.",
    "concepts": [
      "function parameters",
      "return values",
      "function calls with arguments",
      "local variables",
      "modulo operator",
      "boolean logic"
    ],
    "skills": [
      "Writing functions with parameters",
      "Understanding return values",
      "Function composition",
      "Mathematical operations in kernel space",
      "Boolean operations and logic"
    ],
    "files": [
      {
        "name": "functions.h",
        "content": "#ifndef FUNCTIONS_H\n#define FUNCTIONS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* TODO: Declare functions with parameters */\n/* int add_numbers(int a, int b); */\n/* void print_calculation(int num1, int num2, int result); */\n/* bool is_even(int number); */\n\n/* Variables for dynamic testing */\nextern int first;\nextern int second;\n\n#endif /* FUNCTIONS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "functions.c",
        "content": "#include \"functions.h\"\n\n/* CHALLENGE: Advanced Function Parameters with Dynamic Testing!\n *\n * REQUIREMENTS:\n * Create these functions:\n * - add_numbers(int a, int b) -> returns a + b\n * - print_calculation(int num1, int num2, int result) -> prints \"num1 + num2 = result\"\n * - is_even(int number) -> returns true if number is even, false if odd\n *\n * CRITICAL WARNING: The testing system will use different input values!\n * Your functions must work with ANY inputs, not just the defaults below.\n */\n\n/* Variables for dynamic testing */\nint first = 15;\nint second = 25;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your functions work with different inputs.\n * Removing them will cause test failures.\n */\nmodule_param(first, int, 0644);\nMODULE_PARM_DESC(first, \"First number for testing\");\nmodule_param(second, int, 0644);\nMODULE_PARM_DESC(second, \"Second number for testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* TODO: Implement add_numbers function */\n/* Return the sum of a and b */\n\n\n/* TODO: Implement print_calculation function */  \n/* Print in format: \"num1 + num2 = result\" */\n\n\n/* TODO: Implement is_even function */\n/* Return true if number is even, false if odd */\n/* Hint: Use modulo operator (%) */\n\n\nstatic int __init functions_init(void)\n{\n    int sum;\n    bool even_check;\n    \n    printk(KERN_INFO \"Function parameters module loaded\\n\");\n    \n    /* TODO: Call add_numbers and store result */\n    /* sum = add_numbers(first, second); */\n    \n    /* TODO: Call print_calculation to display result */\n    /* print_calculation(first, second, sum); */\n    \n    /* TODO: Check if sum is even and print result */\n    /* even_check = is_even(sum); */\n    /* printk(KERN_INFO \"Sum is even: %d\\n\", even_check); */\n    \n    return 0;\n}\n\nstatic void __exit functions_exit(void)\n{\n    printk(KERN_INFO \"Function parameters module unloaded\\n\");\n}\n\nmodule_init(functions_init);\nmodule_exit(functions_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Advanced function parameters with dynamic testing\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Functions module Makefile\nobj-m += functions.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "functions.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "functions_init",
          "functions_exit",
          "add_numbers",
          "print_calculation",
          "is_even"
        ],
        "variables": [
          {
            "name": "first",
            "type": "int",
            "value": 15
          },
          {
            "name": "second",
            "type": "int",
            "value": 25
          }
        ],
        "outputMessages": [
          "Function parameters module loaded",
          "15 + 25 = 40",
          "Sum is even: 1"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "int add_numbers(int a, int b)",
          "void print_calculation(int num1, int num2, int result)",
          "bool is_even(int number)",
          "return a + b",
          "number % 2 == 0",
          "add_numbers(first, second)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int add_numbers(int a, int b)",
            "void print_calculation(int num1, int num2, int result)",
            "bool is_even(int number)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_implementations",
          "name": "Function Implementations",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "return a + b",
            "return (number % 2 == 0)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_calls",
          "name": "Proper Function Calls",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "add_numbers(first, second)",
            "print_calculation(first, second, sum)",
            "is_even(sum)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "modulo_operator",
          "name": "Modulo Operator Usage",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "number % 2"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "return_values",
          "name": "Proper Return Value Usage",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "sum = add_numbers",
            "even_check = is_even"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int add_numbers(int a, int b)",
            "void print_calculation(int num1, int num2, int result)",
            "bool is_even(int number)",
            "static int __init functions_init(void)",
            "static void __exit functions_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Basic Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Function parameters module loaded",
              "exact": true,
              "linkedFunction": "static int __init functions_init(void)"
            },
            {
              "pattern": "15 + 25 = 40",
              "exact": true,
              "linkedFunction": "void print_calculation(int num1, int num2, int result)"
            },
            {
              "pattern": "Sum is even: 1",
              "exact": true,
              "linkedFunction": "static int __init functions_init(void)"
            }
          ]
        },
        {
          "id": "advanced_function_testing",
          "name": "Advanced Function Parameter Testing",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "function_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\"=== Dynamic Function Test ===\\\\n\");\\n    printf(\"Test 1: Testing first=10, second=30 (sum=40, even)\\\\n\");\\n    system(\"rmmod functions 2>/dev/null\");\\n    system(\"insmod /lib/modules/functions.ko first=10 second=30\");\\n    printf(\"Test 2: Testing first=7, second=8 (sum=15, odd)\\\\n\");\\n    system(\"rmmod functions\");\\n    system(\"insmod /lib/modules/functions.ko first=7 second=8\");\\n    printf(\"SUCCESS: Dynamic test completed\\\\n\");\\n    printf(\"PASS: Function parameters detected\\\\n\");\\n    printf(\"PASS: Module parameters work\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting comprehensive validation'",
              "cp /lib/modules/functions.h /lib/modules/ 2>/dev/null"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo 'Creating test file that includes student header...'",
              "echo '#include \"/lib/modules/functions.h\"' > /tmp/test.c",
              "echo 'int main() { add_numbers(1,2); print_calculation(1,2,3); is_even(4); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declarations missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: All function declarations found in header file'",
              "echo 'Phase 2: Dynamic Parameter Testing'",
              "echo 'Marking start of dynamic tests for validation...'",
              "echo 'DYNAMIC_TEST_START' > /tmp/test_marker",
              "/bin/function_tester",
              "echo 'Phase 3: Context-Aware Logic Validation'",
              "echo 'Validating Test 1: first=10, second=30 (sum=40, should be even)'",
              "dmesg | grep '10 + 30 = 40' && echo 'PASS: add_numbers(10,30) calculation correct' || { echo 'FAIL: add_numbers(10,30) calculation wrong or missing'; exit 1; }",
              "dmesg | grep -A1 '10 + 30 = 40' | grep 'Sum is even: 1' && echo 'PASS: is_even(40) correctly identifies even number' || { echo 'FAIL: is_even(40) wrong - should return 1 for even number 40'; exit 1; }",
              "echo 'Validating Test 2: first=7, second=8 (sum=15, should be odd)'",
              "dmesg | grep '7 + 8 = 15' && echo 'PASS: add_numbers(7,8) calculation correct' || { echo 'FAIL: add_numbers(7,8) calculation wrong or missing'; exit 1; }",
              "dmesg | grep -A1 '7 + 8 = 15' | grep 'Sum is even: 0' && echo 'PASS: is_even(15) correctly identifies odd number' || { echo 'FAIL: is_even(15) wrong - should return 0 for odd number 15'; exit 1; }",
              "echo 'Phase 4: Cross-Validation (ensuring test-specific results are correct)'",
              "echo 'Checking that 40 (even) produces Sum is even: 1'",
              "TEST1_CORRECT=$(dmesg | grep -A1 '10 + 30 = 40' | grep -c 'Sum is even: 1')",
              "echo 'Checking that 15 (odd) produces Sum is even: 0'",
              "TEST2_CORRECT=$(dmesg | grep -A1 '7 + 8 = 15' | grep -c 'Sum is even: 0')",
              "echo 'Test 1 correct results: '$TEST1_CORRECT' (expected: 1)'",
              "echo 'Test 2 correct results: '$TEST2_CORRECT' (expected: 1)'",
              "if [ $TEST1_CORRECT -eq 1 ] && [ $TEST2_CORRECT -eq 1 ]; then echo 'PASS: Both tests show correct even/odd logic'; else echo 'FAIL: Logic validation failed - Test 1: '$TEST1_CORRECT', Test 2: '$TEST2_CORRECT' (expected 1 each)'; exit 1; fi"
            ],
            "expected": {
              "dmesg": [
                "Function parameters module loaded",
                "10 \\+ 30 = 40",
                "Sum is even: 1",
                "7 \\+ 8 = 15",
                "Sum is even: 0"
              ],
              "stdout": [
                "PASS: All function declarations found in header file",
                "SUCCESS: Dynamic test completed",
                "PASS: Both tests show correct even/odd logic"
              ]
            },
            "timeout": 25
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Function parameters module loaded",
        "15 + 25 = 40",
        "Sum is even: 1"
      ],
      "requirements": [
        "Use required function names: functions_init, functions_exit, add_numbers, print_calculation, is_even",
        "Use required variable names: first, second",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: int add_numbers(int a, int b), void print_calculation(int num1, int num2, int result), bool is_even(int number), return a + b, number % 2 == 0, add_numbers(first, second)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Function parameters module loaded",
          "linkedFunction": "static int __init functions_init(void)",
          "exact": true
        },
        {
          "pattern": "15 + 25 = 40",
          "linkedFunction": "void print_calculation(int num1, int num2, int result)",
          "exact": true
        },
        {
          "pattern": "Sum is even: 1",
          "linkedFunction": "static int __init functions_init(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 9,
    "title": "Conditional Logic - Making Decisions",
    "difficulty": 3,
    "xp": 35,
    "phase": "foundations",
    "description": "Learn to make decisions in your code using if/else statements and comparison operators. This introduces logical thinking and decision-making patterns essential for kernel development where conditions determine code flow.",
    "concepts": [
      "if statements",
      "else if statements",
      "comparison operators",
      "logical decision making",
      "conditional execution"
    ],
    "skills": [
      "Writing conditional statements",
      "Using comparison operators",
      "Logical thinking and flow control",
      "Decision-based programming",
      "Testing multiple conditions"
    ],
    "files": [
      {
        "name": "conditions.h",
        "content": "#ifndef CONDITIONS_H\n#define CONDITIONS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n\n\n#endif /* CONDITIONS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "conditions.c",
        "content": "#include \"conditions.h\"\n\nint test_number = 42;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your conditional logic works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(test_number, int, 0644);\nMODULE_PARM_DESC(test_number, \"Number to test with conditional logic\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n\n\nstatic int __init conditions_init(void)\n{\n    printk(KERN_INFO \"Conditional logic module loaded\\n\");\n    \n    \n    \n    return 0;\n}\n\nstatic void __exit conditions_exit(void)\n{\n    printk(KERN_INFO \"Conditional logic module unloaded\\n\");\n}\n\nmodule_init(conditions_init);\nmodule_exit(conditions_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning conditional logic and decision making\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Conditional logic module Makefile\nobj-m += conditions.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "conditions.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "conditions_init",
          "conditions_exit",
          "check_number_status"
        ],
        "variables": [
          {
            "name": "test_number",
            "type": "int",
            "value": 42
          }
        ],
        "outputMessages": [
          "Conditional logic module loaded",
          "Number 42 is positive",
          "Number -15 is negative",
          "Number 0 is zero"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "int test_number = 42",
          "void check_number_status(int number)",
          "if (number > 0)",
          "else if (number < 0)",
          "else"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void check_number_status(int number)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void check_number_status(int number)",
            "static int __init conditions_init(void)",
            "static void __exit conditions_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Basic Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Conditional logic module loaded",
              "exact": true,
              "linkedFunction": "static int __init conditions_init(void)"
            },
            {
              "pattern": "Number 42 is positive",
              "exact": true,
              "linkedFunction": "void check_number_status(int number)"
            },
            {
              "pattern": "Number -15 is negative",
              "exact": true,
              "linkedFunction": "void check_number_status(int number)"
            },
            {
              "pattern": "Number 0 is zero",
              "exact": true,
              "linkedFunction": "void check_number_status(int number)"
            }
          ]
        },
        {
          "id": "advanced_conditional_testing",
          "name": "Advanced Conditional Logic with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "conditional_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\"=== Dynamic Conditional Test ===\\\\n\");\\n    \\n    // Seed random number generator with current time\\n    srand(time(NULL));\\n    \\n    // Generate random test values within -100 to 100\\n    int positive_val = (rand() % 90) + 10;  // 10 to 99\\n    int negative_val = -((rand() % 90) + 10); // -99 to -10\\n    int zero_val = 0;  // Always test zero\\n    \\n    printf(\"Test 1: Testing positive number (%d)\\\\n\", positive_val);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \"insmod /lib/modules/conditions.ko test_number=%d\", positive_val);\\n    system(\"rmmod conditions 2>/dev/null\");\\n    system(cmd1);\\n    \\n    printf(\"Test 2: Testing negative number (%d)\\\\n\", negative_val);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \"insmod /lib/modules/conditions.ko test_number=%d\", negative_val);\\n    system(\"rmmod conditions\");\\n    system(cmd2);\\n    \\n    printf(\"Test 3: Testing zero (%d)\\\\n\", zero_val);\\n    system(\"rmmod conditions\");\\n    system(\"insmod /lib/modules/conditions.ko test_number=0\");\\n    \\n    printf(\"SUCCESS: Dynamic test completed\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting comprehensive conditional logic validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo 'Creating test file that includes student header...'",
              "echo '#include \"/lib/modules/conditions.h\"' > /tmp/test.c",
              "echo 'int main() { check_number_status(42); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: Function declaration found in header file'",
              "echo 'Phase 2: Dynamic Parameter Testing'",
              "/bin/conditional_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Dynamic Randomized Conditional Logic Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "POSITIVE_VAL=$(grep -o 'Testing positive number ([0-9]*)' /tmp/test_output.log | cut -d'(' -f2 | cut -d')' -f1)",
              "NEGATIVE_VAL=$(grep -o 'Testing negative number (-[0-9]*)' /tmp/test_output.log | cut -d'(' -f2 | cut -d')' -f1)",
              "echo 'Extracted positive value: '$POSITIVE_VAL",
              "echo 'Extracted negative value: '$NEGATIVE_VAL",
              "echo 'Random positive value: '$POSITIVE_VAL",
              "echo 'Random negative value: '$NEGATIVE_VAL",
              "echo 'Validating positive number logic with random value '$POSITIVE_VAL",
              "dmesg | grep \"Number $POSITIVE_VAL is positive\" && echo 'PASS: Positive number logic correct' || echo 'FAIL: Positive number logic wrong'",
              "echo 'Validating negative number logic with random value '$NEGATIVE_VAL",
              "dmesg | grep \"Number $NEGATIVE_VAL is negative\" && echo 'PASS: Negative number logic correct' || echo 'FAIL: Negative number logic wrong'",
              "echo 'Validating zero logic (0 should be zero)'",
              "dmesg | grep 'Number 0 is zero' && echo 'PASS: Zero logic correct' || echo 'FAIL: Zero logic wrong'",
              "echo 'All individual validations completed'",
              "echo 'Phase 4: Dynamic Cross-Validation Consistency Check'",
              "echo 'Checking that random test values produced correct results'",
              "TEST_POSITIVE=$(dmesg | grep -c \"Number $POSITIVE_VAL is positive\")",
              "TEST_NEGATIVE=$(dmesg | grep -c \"Number $NEGATIVE_VAL is negative\")",
              "TEST_ZERO=$(dmesg | grep -c 'Number 0 is zero')",
              "echo 'Test positive '$POSITIVE_VAL' results: '$TEST_POSITIVE' (expected: 1)'",
              "echo 'Test negative '$NEGATIVE_VAL' results: '$TEST_NEGATIVE' (expected: 1)'",
              "echo 'Test 0 zero results: '$TEST_ZERO' (expected: at least 1)'",
              "if [ $TEST_POSITIVE -eq 1 ] && [ $TEST_NEGATIVE -eq 1 ] && [ $TEST_ZERO -ge 1 ]; then echo 'PASS: All conditional logic working correctly'; else echo 'FAIL: Conditional logic validation failed - Positive: '$TEST_POSITIVE', Negative: '$TEST_NEGATIVE', Zero: '$TEST_ZERO; fi"
            ],
            "expected": {
              "dmesg": [
                "Conditional logic module loaded",
                "Number .* is positive",
                "Number .* is negative",
                "Number 0 is zero"
              ],
              "stdout": [
                "PASS: Function declaration found in header file",
                "SUCCESS: Dynamic test completed",
                "PASS: All conditional logic working correctly"
              ]
            },
            "timeout": 25
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Conditional logic module loaded",
        "Number 42 is positive",
        "Number -15 is negative",
        "Number 0 is zero"
      ],
      "requirements": [
        "Use required function names: conditions_init, conditions_exit, check_number_status",
        "Use required variable names: test_number",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: int test_number = 42, void check_number_status(int number), if (number > 0), else if (number < 0), else",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Conditional logic module loaded",
          "linkedFunction": "static int __init conditions_init(void)",
          "exact": true
        },
        {
          "pattern": "Number 42 is positive",
          "linkedFunction": "void check_number_status(int number)",
          "exact": true
        },
        {
          "pattern": "Number -15 is negative",
          "linkedFunction": "void check_number_status(int number)",
          "exact": true
        },
        {
          "pattern": "Number 0 is zero",
          "linkedFunction": "void check_number_status(int number)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 10,
    "title": "Basic Loops - Study Loop Patterns",
    "difficulty": 2,
    "xp": 25,
    "phase": "foundations",
    "description": "Study complete working examples of for loops and iteration patterns. This demonstrates how loops are used in kernel development for processing data and implementing basic algorithms.",
    "concepts": [
      "for loops",
      "loop variables",
      "iteration patterns",
      "accumulation",
      "loop-based calculations"
    ],
    "skills": [
      "Writing for loops",
      "Managing loop counters",
      "Iterative algorithms",
      "Accumulation patterns",
      "Loop-based problem solving"
    ],
    "files": [
      {
        "name": "loops.h",
        "content": "#ifndef LOOPS_H\n#define LOOPS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\nextern int max_count;\nextern int sum_result;\n\n/* Function to print numbers from 1 to count */\nvoid print_numbers(int count);\n\n/* Function to calculate sum of numbers from 1 to n */\nint calculate_sum(int n);\n\n#endif /* LOOPS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "loops.c",
        "content": "#include \"loops.h\"\n\nint max_count = 5;\nint sum_result = 0;\n\n/* \n * Function to print numbers from 1 to count\n * Demonstrates basic for loop pattern for iteration\n */\nvoid print_numbers(int count) {\n    int i;\n    for (i = 1; i <= count; i++) {\n        printk(KERN_INFO \"Count: %d\\n\", i);\n    }\n}\n\n/* \n * Function to calculate sum of numbers from 1 to n\n * Demonstrates accumulation pattern using loops\n * Formula: sum = 1 + 2 + 3 + ... + n\n */\nint calculate_sum(int n) {\n    int i, sum = 0;\n    for (i = 1; i <= n; i++) {\n        sum += i;  // Accumulate each number into sum\n    }\n    return sum;\n}\n\nstatic int __init loops_init(void)\n{\n    printk(KERN_INFO \"Basic loops module loaded\\n\");\n    \n    // Demonstrate loop for printing sequential numbers\n    print_numbers(max_count);\n    \n    // Demonstrate loop for mathematical calculation\n    sum_result = calculate_sum(max_count);\n    printk(KERN_INFO \"Sum of 1 to %d is: %d\\n\", max_count, sum_result);\n    \n    return 0;\n}\n\nstatic void __exit loops_exit(void)\n{\n    printk(KERN_INFO \"Basic loops module unloaded\\n\");\n}\n\nmodule_init(loops_init);\nmodule_exit(loops_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning basic loops and iteration\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Basic loops module Makefile\nobj-m += loops.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "loops.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "loops_init",
          "loops_exit",
          "print_numbers",
          "calculate_sum"
        ],
        "variables": [
          {
            "name": "max_count",
            "type": "int",
            "value": 5
          },
          {
            "name": "sum_result",
            "type": "int",
            "value": 0
          }
        ],
        "outputMessages": [
          "Basic loops module loaded",
          "Count: 1",
          "Count: 2",
          "Count: 3",
          "Count: 4",
          "Count: 5",
          "Sum of 1 to 5 is: 15"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "extern int max_count",
          "extern int sum_result",
          "int max_count = 5",
          "int sum_result = 0",
          "for (i = 1; i <= count; i++)",
          "for (i = 1; i <= n; i++)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_numbers(int count)",
            "int calculate_sum(int n)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_numbers(int count)",
            "int calculate_sum(int n)",
            "static int __init loops_init(void)",
            "static void __exit loops_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Basic Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Basic loops module loaded",
              "exact": true,
              "linkedFunction": "static int __init loops_init(void)"
            },
            {
              "pattern": "Count: 1",
              "exact": true,
              "linkedFunction": "void print_numbers(int count)"
            },
            {
              "pattern": "Count: 2",
              "exact": true,
              "linkedFunction": "void print_numbers(int count)"
            },
            {
              "pattern": "Count: 3",
              "exact": true,
              "linkedFunction": "void print_numbers(int count)"
            },
            {
              "pattern": "Count: 4",
              "exact": true,
              "linkedFunction": "void print_numbers(int count)"
            },
            {
              "pattern": "Count: 5",
              "exact": true,
              "linkedFunction": "void print_numbers(int count)"
            },
            {
              "pattern": "Sum of 1 to 5 is: 15",
              "exact": true,
              "linkedFunction": "static int __init loops_init(void)"
            }
          ]
        },
        {
          "id": "advanced_loop_validation",
          "name": "Advanced Loop Pattern Validation with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "loop_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\"=== Loop Pattern Test ===\\\\n\");\\n    printf(\"SUCCESS: Loop test completed\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting loop pattern validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo 'Creating test file that includes student header...'",
              "echo '#include \"/lib/modules/loops.h\"' > /tmp/test.c",
              "echo 'int main() { print_numbers(5); calculate_sum(5); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: All function declarations found in header file'",
              "echo 'Phase 2: Module Testing'",
              "/bin/loop_tester"
            ],
            "expected": {
              "dmesg": [
                "Basic loops module loaded",
                "Count: 1",
                "Count: 2",
                "Count: 3",
                "Count: 4",
                "Count: 5",
                "Sum of 1 to 5 is: 15"
              ],
              "stdout": [
                "PASS: All function declarations found in header file",
                "SUCCESS: Loop test completed"
              ]
            },
            "timeout": 20
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Basic loops module loaded",
        "Count: 1",
        "Count: 2",
        "Count: 3",
        "Count: 4",
        "Count: 5",
        "Sum of 1 to 5 is: 15"
      ],
      "requirements": [
        "Use required function names: loops_init, loops_exit, print_numbers, calculate_sum",
        "Use required variable names: max_count, sum_result",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: extern int max_count, extern int sum_result, int max_count = 5, int sum_result = 0, for (i = 1; i <= count; i++), for (i = 1; i <= n; i++)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Basic loops module loaded",
          "linkedFunction": "static int __init loops_init(void)",
          "exact": true
        },
        {
          "pattern": "Count: 1",
          "linkedFunction": "void print_numbers(int count)",
          "exact": true
        },
        {
          "pattern": "Count: 2",
          "linkedFunction": "void print_numbers(int count)",
          "exact": true
        },
        {
          "pattern": "Count: 3",
          "linkedFunction": "void print_numbers(int count)",
          "exact": true
        },
        {
          "pattern": "Count: 4",
          "linkedFunction": "void print_numbers(int count)",
          "exact": true
        },
        {
          "pattern": "Count: 5",
          "linkedFunction": "void print_numbers(int count)",
          "exact": true
        },
        {
          "pattern": "Sum of 1 to 5 is: 15",
          "linkedFunction": "static int __init loops_init(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 11,
    "title": "Basic Loops - Implement Loop Solutions",
    "difficulty": 4,
    "xp": 40,
    "phase": "foundations",
    "description": "Implement your own loop-based solutions for iterative calculations and array processing. Apply the patterns you studied in Problem 9 to create functions that perform calculations and process data using loops.",
    "concepts": [
      "reverse iteration",
      "factorial calculation",
      "array multiplication",
      "accumulation patterns",
      "loop control variables"
    ],
    "skills": [
      "Implementing reverse loops",
      "Mathematical calculations with loops",
      "Array processing algorithms",
      "Accumulation and multiplication patterns",
      "Loop-based problem solving"
    ],
    "files": [
      {
        "name": "loops_impl.h",
        "content": "#ifndef LOOPS_IMPL_H\n#define LOOPS_IMPL_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n#define ARRAY_SIZE 6\n\nextern int numbers[ARRAY_SIZE];\nextern int factorial_result;\nextern int product_result;\n\n/* TODO: Declare your functions */\n/* void print_reverse(int arr[], int size); */\n/* int calculate_factorial(int n); */\n/* int multiply_array(int arr[], int size); */\n\n#endif /* LOOPS_IMPL_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "loops_impl.c",
        "content": "#include \"loops_impl.h\"\n\nint numbers[ARRAY_SIZE] = {2, 4, 6, 8, 10, 12};\nint factorial_result = 5;  // Default: calculate factorial of 5\nint product_result = 6;    // Default: multiply first 6 elements\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your loop implementations work\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(factorial_result, int, 0644);\nMODULE_PARM_DESC(factorial_result, \"Number for factorial calculation testing\");\nmodule_param(product_result, int, 0644);\nMODULE_PARM_DESC(product_result, \"Array size for processing testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* TODO: Implement function to print array in reverse order */\n/* Use a for loop starting from size-1 down to 0 */\n/* Print: \"Position X: Y\" for each element */\n\n/* TODO: Implement function to calculate factorial of n */\n/* factorial(n) = n * (n-1) * (n-2) * ... * 1 */\n/* Use a for loop from 1 to n, multiply result by each number */\n\n/* TODO: Implement function to multiply all array elements */\n/* Use accumulation pattern: start with result = 1 */\n/* Multiply result by each array element using for loop */\n\nstatic int __init loops_impl_init(void)\n{\n    int calculated_factorial, calculated_product;\n    \n    printk(KERN_INFO \"Loop implementation module loaded\\n\");\n    \n    /* TODO: Print array in reverse order */\n    /* printk(KERN_INFO \"Array in reverse order:\\n\"); */\n    /* print_reverse(numbers, ARRAY_SIZE); */\n    \n    /* TODO: Calculate factorial using factorial_result as input */\n    /* calculated_factorial = calculate_factorial(factorial_result); */\n    /* printk(KERN_INFO \"Factorial of %d: %d\\n\", factorial_result, calculated_factorial); */\n    \n    /* TODO: Calculate product of array elements using product_result as array size */\n    /* calculated_product = multiply_array(numbers, product_result); */\n    /* printk(KERN_INFO \"Product of first %d elements: %d\\n\", product_result, calculated_product); */\n    \n    return 0;\n}\n\nstatic void __exit loops_impl_exit(void)\n{\n    printk(KERN_INFO \"Loop implementation module unloaded\\n\");\n}\n\nmodule_init(loops_impl_init);\nmodule_exit(loops_impl_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Implementing loop-based algorithms\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Loop implementation module Makefile\nobj-m += loops_impl.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "loops_impl.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "loops_impl_init",
          "loops_impl_exit",
          "print_reverse",
          "calculate_factorial",
          "multiply_array"
        ],
        "variables": [
          {
            "name": "numbers",
            "type": "int[]",
            "value": "{2, 4, 6, 8, 10, 12}"
          },
          {
            "name": "factorial_result",
            "type": "int",
            "value": 5
          },
          {
            "name": "product_result",
            "type": "int",
            "value": 6
          }
        ],
        "outputMessages": [
          "Loop implementation module loaded",
          "Array in reverse order:",
          "Position 5: 12",
          "Position 4: 10",
          "Position 3: 8",
          "Position 2: 6",
          "Position 1: 4",
          "Position 0: 2",
          "Factorial of 5: 120",
          "Product of array: 46080"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "#define ARRAY_SIZE 6",
          "int numbers[ARRAY_SIZE]",
          "for.*i.*=.*size.*-.*1.*i.*>=.*0.*i--",
          "for.*i.*=.*1.*i.*<=.*n.*i\\+\\+"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_reverse(int arr[], int size)",
            "int calculate_factorial(int n)",
            "int multiply_array(int arr[], int size)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_reverse(int arr[], int size)",
            "int calculate_factorial(int n)",
            "int multiply_array(int arr[], int size)",
            "static int __init loops_impl_init(void)",
            "static void __exit loops_impl_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Basic Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Loop implementation module loaded",
              "exact": true,
              "linkedFunction": "static int __init loops_impl_init(void)"
            },
            {
              "pattern": "Array in reverse order:",
              "exact": true,
              "linkedFunction": "static int __init loops_impl_init(void)"
            },
            {
              "pattern": "Position 5: 12",
              "exact": true,
              "linkedFunction": "void print_reverse(int arr[], int size)"
            },
            {
              "pattern": "Position 4: 10",
              "exact": true,
              "linkedFunction": "void print_reverse(int arr[], int size)"
            },
            {
              "pattern": "Position 3: 8",
              "exact": true,
              "linkedFunction": "void print_reverse(int arr[], int size)"
            },
            {
              "pattern": "Position 2: 6",
              "exact": true,
              "linkedFunction": "void print_reverse(int arr[], int size)"
            },
            {
              "pattern": "Position 1: 4",
              "exact": true,
              "linkedFunction": "void print_reverse(int arr[], int size)"
            },
            {
              "pattern": "Position 0: 2",
              "exact": true,
              "linkedFunction": "void print_reverse(int arr[], int size)"
            },
            {
              "pattern": "Factorial of 5: 120",
              "exact": true,
              "linkedFunction": "static int __init loops_impl_init(void)"
            },
            {
              "pattern": "Product of array: 46080",
              "exact": true,
              "linkedFunction": "static int __init loops_impl_init(void)"
            }
          ]
        },
        {
          "id": "advanced_loop_implementation_validation",
          "name": "Advanced Loop Implementation with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "loop_impl_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\"=== Dynamic Loop Implementation Test ===\\\\n\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random test values\\n    int factorial_n = (rand() % 6) + 3;  // 3 to 8 for reasonable factorial\\n    int array_size = (rand() % 3) + 4;   // 4 to 6 elements\\n    \\n    printf(\"Test 1: Factorial calculation for n=%d\\\\n\", factorial_n);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \"insmod /lib/modules/loops_impl.ko factorial_result=%d\", factorial_n);\\n    system(\"rmmod loops_impl 2>/dev/null\");\\n    system(cmd1);\\n    \\n    printf(\"Test 2: Array processing with %d elements\\\\n\", array_size);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \"insmod /lib/modules/loops_impl.ko product_result=%d\", array_size);\\n    system(\"rmmod loops_impl\");\\n    system(cmd2);\\n    \\n    printf(\"SUCCESS: Dynamic loop test completed\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced loop implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo 'Creating test file that includes student header...'",
              "echo '#include \"/lib/modules/loops_impl.h\"' > /tmp/test.c",
              "echo 'int main() { print_reverse((int[]){1,2,3}, 3); calculate_factorial(5); multiply_array((int[]){1,2}, 2); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: All function declarations found in header file'",
              "echo 'Phase 2: Dynamic Implementation Testing'",
              "/bin/loop_impl_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Dynamic Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "FACTORIAL_N=$(grep -o 'Factorial calculation for n=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
              "ARRAY_SIZE_TEST=$(grep -o 'Array processing with [0-9]* elements' /tmp/test_output.log | cut -d' ' -f4)",
              "echo 'Random factorial value: '$FACTORIAL_N",
              "echo 'Random array size: '$ARRAY_SIZE_TEST",
              "echo 'Validating factorial calculation for n='$FACTORIAL_N",
              "dmesg | grep \"Factorial of $FACTORIAL_N:\" && echo 'PASS: Factorial calculation correct' || echo 'FAIL: Factorial calculation wrong'",
              "echo 'Validating array processing for size='$ARRAY_SIZE_TEST",
              "dmesg | grep \"Product of first $ARRAY_SIZE_TEST elements:\" && echo 'PASS: Array processing correct' || echo 'FAIL: Array processing wrong'",
              "echo 'Validating reverse array output'",
              "dmesg | grep 'Array in reverse order:' && echo 'PASS: Reverse array output found' || echo 'FAIL: Reverse array output missing'",
              "echo 'All dynamic validations completed'"
            ],
            "expected": {
              "dmesg": [
                "Loop implementation module loaded",
                "Array in reverse order:",
                "Position .* .*",
                "Factorial of .* .*",
                "Product of first .* elements: .*"
              ],
              "stdout": [
                "PASS: All function declarations found in header file",
                "SUCCESS: Dynamic loop test completed",
                "PASS: Factorial calculation correct",
                "PASS: Array processing correct",
                "PASS: Reverse array output found"
              ]
            },
            "timeout": 25
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Loop implementation module loaded",
        "Array in reverse order:",
        "Position 5: 12",
        "Position 4: 10",
        "Position 3: 8",
        "Position 2: 6",
        "Position 1: 4",
        "Position 0: 2",
        "Factorial of 5: 120",
        "Product of array: 46080"
      ],
      "requirements": [
        "Use required function names: loops_impl_init, loops_impl_exit, print_reverse, calculate_factorial, multiply_array",
        "Use required variable names: numbers, factorial_result, product_result",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: #define ARRAY_SIZE 6, int numbers[ARRAY_SIZE], for.*i.*=.*size.*-.*1.*i.*>=.*0.*i--, for.*i.*=.*1.*i.*<=.*n.*i\\+\\+",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Loop implementation module loaded",
          "linkedFunction": "static int __init loops_impl_init(void)",
          "exact": true
        },
        {
          "pattern": "Array in reverse order:",
          "linkedFunction": "static int __init loops_impl_init(void)",
          "exact": true
        },
        {
          "pattern": "Position 5: 12",
          "linkedFunction": "void print_reverse(int arr[], int size)",
          "exact": true
        },
        {
          "pattern": "Position 4: 10",
          "linkedFunction": "void print_reverse(int arr[], int size)",
          "exact": true
        },
        {
          "pattern": "Position 3: 8",
          "linkedFunction": "void print_reverse(int arr[], int size)",
          "exact": true
        },
        {
          "pattern": "Position 2: 6",
          "linkedFunction": "void print_reverse(int arr[], int size)",
          "exact": true
        },
        {
          "pattern": "Position 1: 4",
          "linkedFunction": "void print_reverse(int arr[], int size)",
          "exact": true
        },
        {
          "pattern": "Position 0: 2",
          "linkedFunction": "void print_reverse(int arr[], int size)",
          "exact": true
        },
        {
          "pattern": "Factorial of 5: 120",
          "linkedFunction": "static int __init loops_impl_init(void)",
          "exact": true
        },
        {
          "pattern": "Product of array: 46080",
          "linkedFunction": "static int __init loops_impl_init(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 12,
    "title": "Arrays and Collections - Study Complete Examples",
    "difficulty": 2,
    "xp": 25,
    "phase": "foundations",
    "description": "Study complete array implementations to understand how to store and manage multiple values. This introduces data collection patterns essential for kernel development where you often need to manage lists of devices, buffers, or other resources. Observe the patterns before implementing them yourself.",
    "concepts": [
      "array declaration with #define",
      "array initialization with literal values",
      "array indexing with []",
      "array traversal with for loops",
      "maximum finding algorithms",
      "accumulation patterns",
      "linear search algorithms"
    ],
    "skills": [
      "Understanding array syntax",
      "Recognizing traversal patterns",
      "Learning search algorithms",
      "Understanding index-based access",
      "Observing accumulation patterns"
    ],
    "files": [
      {
        "name": "arrays_study.h",
        "content": "#ifndef ARRAYS_STUDY_H\n#define ARRAYS_STUDY_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* Array size definition */\n#define MAX_DEVICES 6\n\n/* Array declarations */\nextern int device_ids[MAX_DEVICES];\nextern int device_count;\n\n/* Function declarations - study these patterns */\nvoid print_all_devices(void);\nint find_max_device_id(void);\nint calculate_id_sum(void);\nbool check_device_exists(int);\n\n#endif /* ARRAYS_STUDY_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "arrays_study.c",
        "content": "#include \"arrays_study.h\"\n\n/* Array initialization with device IDs */\nint device_ids[MAX_DEVICES] = {101, 205, 150, 320, 180, 275};\nint device_count = MAX_DEVICES;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify array operations work\n * with different input values. Removing them will cause test failures.\n */\nmodule_param_array(device_ids, int, &device_count, 0644);\nMODULE_PARM_DESC(device_ids, \"Array of device IDs for testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/**\n * print_all_devices - Print all device IDs in the array\n * \n * This function demonstrates basic array traversal using a for loop.\n * Notice how we use the loop counter 'i' as an index to access\n * each array element with device_ids[i].\n */\nvoid print_all_devices(void)\n{\n    int i;\n    \n    printk(KERN_INFO \"Device listing:\\n\");\n    for (i = 0; i < device_count; i++) {\n        printk(KERN_INFO \"Device %d: ID %d\\n\", i + 1, device_ids[i]);\n    }\n}\n\n/**\n * find_max_device_id - Find the highest device ID in the array\n * Returns: The maximum device ID found\n * \n * This function shows the standard algorithm for finding maximum values:\n * 1. Start with first element as current maximum\n * 2. Compare each remaining element with current maximum\n * 3. Update maximum when a larger value is found\n */\nint find_max_device_id(void)\n{\n    int i, max_id;\n    \n    /* Initialize with first element */\n    max_id = device_ids[0];\n    \n    /* Compare with remaining elements */\n    for (i = 1; i < device_count; i++) {\n        if (device_ids[i] > max_id) {\n            max_id = device_ids[i];\n        }\n    }\n    \n    return max_id;\n}\n\n/**\n * calculate_id_sum - Calculate sum of all device IDs\n * Returns: Total sum of all device IDs\n * \n * This demonstrates the accumulation pattern:\n * 1. Initialize accumulator to 0\n * 2. Loop through array adding each element to accumulator\n * 3. Return final accumulated value\n */\nint calculate_id_sum(void)\n{\n    int i, sum = 0;\n    \n    for (i = 0; i < device_count; i++) {\n        sum += device_ids[i];\n    }\n    \n    return sum;\n}\n\n/**\n * check_device_exists - Check if a specific device ID exists in array\n * @target_id: The device ID to search for\n * Returns: true if found, false if not found\n * \n * This shows the search pattern:\n * 1. Loop through array comparing each element with target\n * 2. Return true immediately when match is found\n * 3. Return false if loop completes without finding match\n */\nbool check_device_exists(int target_id)\n{\n    int i;\n    \n    for (i = 0; i < device_count; i++) {\n        if (device_ids[i] == target_id) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nstatic int __init arrays_study_init(void)\n{\n    int max_id, total_sum;\n    bool device_found;\n    \n    printk(KERN_INFO \"Arrays study module loaded\\n\");\n    printk(KERN_INFO \"Studying array operations with %d devices\\n\", device_count);\n    \n    /* Demonstrate array traversal */\n    print_all_devices();\n    \n    /* Demonstrate maximum finding */\n    max_id = find_max_device_id();\n    printk(KERN_INFO \"Highest device ID: %d\\n\", max_id);\n    \n    /* Demonstrate accumulation */\n    total_sum = calculate_id_sum();\n    printk(KERN_INFO \"Total sum of device IDs: %d\\n\", total_sum);\n    \n    /* Demonstrate search */\n    device_found = check_device_exists(205);\n    printk(KERN_INFO \"Device 205 found: %s\\n\", device_found ? \"Yes\" : \"No\");\n    \n    device_found = check_device_exists(999);\n    printk(KERN_INFO \"Device 999 found: %s\\n\", device_found ? \"Yes\" : \"No\");\n    \n    return 0;\n}\n\nstatic void __exit arrays_study_exit(void)\n{\n    printk(KERN_INFO \"Arrays study module unloaded\\n\");\n}\n\nmodule_init(arrays_study_init);\nmodule_exit(arrays_study_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"KernelOne Educational System\");\nMODULE_DESCRIPTION(\"Study complete array implementations and patterns\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Arrays study module Makefile\nobj-m += arrays_study.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "arrays_study.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "arrays_study_init",
          "arrays_study_exit",
          "print_all_devices",
          "find_max_device_id",
          "calculate_id_sum",
          "check_device_exists"
        ],
        "variables": [
          {
            "name": "device_ids[]",
            "type": "int",
            "value": "{101, 205, 150, 320, 180, 275}"
          },
          {
            "name": "device_count",
            "type": "int",
            "value": 6
          }
        ],
        "outputMessages": [
          "Arrays study module loaded",
          "Studying array operations with 6 devices",
          "Device listing:",
          "Device 1: ID 101",
          "Device 2: ID 205",
          "Device 3: ID 150",
          "Device 4: ID 320",
          "Device 5: ID 180",
          "Device 6: ID 275",
          "Highest device ID: 320",
          "Total sum of device IDs: 1231",
          "Device 205 found: Yes",
          "Device 999 found: No"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "#define MAX_DEVICES 6",
          "int device_ids[MAX_DEVICES]",
          "module_param_array(device_ids, int, &device_count, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_all_devices(void)",
            "int find_max_device_id(void)",
            "int calculate_id_sum(void)",
            "bool check_device_exists(int)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_all_devices(void)",
            "int find_max_device_id(void)",
            "int calculate_id_sum(void)",
            "bool check_device_exists(int target_id)",
            "static int __init arrays_study_init(void)",
            "static void __exit arrays_study_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Expected Study Output",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Arrays study module loaded",
              "exact": true,
              "linkedFunction": "static int __init arrays_study_init(void)"
            },
            {
              "pattern": "Studying array operations with 6 devices",
              "exact": true,
              "linkedFunction": "static int __init arrays_study_init(void)"
            },
            {
              "pattern": "Device listing:",
              "exact": true,
              "linkedFunction": "void print_all_devices(void)"
            },
            {
              "pattern": "Device 1: ID 101",
              "exact": true,
              "linkedFunction": "void print_all_devices(void)"
            },
            {
              "pattern": "Device 6: ID 275",
              "exact": true,
              "linkedFunction": "void print_all_devices(void)"
            },
            {
              "pattern": "Highest device ID: 320",
              "exact": true,
              "linkedFunction": "static int __init arrays_study_init(void)"
            },
            {
              "pattern": "Total sum of device IDs: 1231",
              "exact": true,
              "linkedFunction": "static int __init arrays_study_init(void)"
            },
            {
              "pattern": "Device 205 found: Yes",
              "exact": true,
              "linkedFunction": "static int __init arrays_study_init(void)"
            },
            {
              "pattern": "Device 999 found: No",
              "exact": true,
              "linkedFunction": "static int __init arrays_study_init(void)"
            }
          ]
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Arrays study module loaded",
        "Studying array operations with 6 devices",
        "Device listing:",
        "Device 1: ID 101",
        "Device 2: ID 205",
        "Device 3: ID 150",
        "Device 4: ID 320",
        "Device 5: ID 180",
        "Device 6: ID 275",
        "Highest device ID: 320",
        "Total sum of device IDs: 1231",
        "Device 205 found: Yes",
        "Device 999 found: No"
      ],
      "requirements": [
        "Use required function names: arrays_study_init, arrays_study_exit, print_all_devices, find_max_device_id, calculate_id_sum, check_device_exists",
        "Use required variable names: device_ids[], device_count",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: #define MAX_DEVICES 6, int device_ids[MAX_DEVICES], module_param_array(device_ids, int, &device_count, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Arrays study module loaded",
          "linkedFunction": "static int __init arrays_study_init(void)",
          "exact": true
        },
        {
          "pattern": "Studying array operations with 6 devices",
          "linkedFunction": "static int __init arrays_study_init(void)",
          "exact": true
        },
        {
          "pattern": "Device listing:",
          "linkedFunction": "void print_all_devices(void)",
          "exact": true
        },
        {
          "pattern": "Device 1: ID 101",
          "linkedFunction": "void print_all_devices(void)",
          "exact": true
        },
        {
          "pattern": "Device 6: ID 275",
          "linkedFunction": "void print_all_devices(void)",
          "exact": true
        },
        {
          "pattern": "Highest device ID: 320",
          "linkedFunction": "static int __init arrays_study_init(void)",
          "exact": true
        },
        {
          "pattern": "Total sum of device IDs: 1231",
          "linkedFunction": "static int __init arrays_study_init(void)",
          "exact": true
        },
        {
          "pattern": "Device 205 found: Yes",
          "linkedFunction": "static int __init arrays_study_init(void)",
          "exact": true
        },
        {
          "pattern": "Device 999 found: No",
          "linkedFunction": "static int __init arrays_study_init(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 13,
    "title": "Arrays and Collections - Implement Solutions",
    "difficulty": 4,
    "xp": 40,
    "phase": "foundations",
    "description": "Implement your own array-based solutions for managing multiple values. Apply the patterns you studied in Problem 11 to create functions that process arrays, find maximum values, and calculate statistics. This builds on the complete examples you observed.",
    "concepts": [
      "array declaration",
      "array initialization",
      "array indexing",
      "array iteration",
      "data collection algorithms"
    ],
    "skills": [
      "Working with arrays",
      "Array traversal with loops",
      "Finding maximum values",
      "Calculating averages",
      "Index-based data access"
    ],
    "files": [
      {
        "name": "arrays.h",
        "content": "#ifndef ARRAYS_H\n#define ARRAYS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n#define MAX_GRADES 5\n\nextern int student_grades[MAX_GRADES];\nextern int grade_count;\n\n/* TODO: Declare your functions */\n/* void print_all_grades(void); */\n/* int find_highest_grade(void); */\n/* int calculate_average(void); */\n\n#endif /* ARRAYS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "arrays.c",
        "content": "#include \"arrays.h\"\n\n/* TODO: Initialize array with grades: {85, 92, 78, 96, 88} */\n/* int student_grades[MAX_GRADES] = {85, 92, 78, 96, 88}; */\nint grade_count = MAX_GRADES;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your array operations work\n * with different input values. Removing them will cause test failures.\n */\nmodule_param_array(student_grades, int, &grade_count, 0644);\nMODULE_PARM_DESC(student_grades, \"Array of student grades for testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* TODO: Implement function to print all grades */\n/* Use a for loop to iterate through the array */\n/* Print each grade with format: \"Grade X: Y\" */\n\n/* TODO: Implement function to find highest grade */\n/* Initialize with first element, then compare with rest */\n/* Return the maximum value found */\n\n/* TODO: Implement function to calculate average */\n/* Sum all grades using a loop, then divide by count */\n/* Return the calculated average */\n\nstatic int __init arrays_init(void)\n{\n    int highest, average;\n    \n    printk(KERN_INFO \"Arrays module loaded\\n\");\n    \n    /* TODO: Print all grades */\n    /* print_all_grades(); */\n    \n    /* TODO: Find and print highest grade */\n    /* highest = find_highest_grade(); */\n    /* printk(KERN_INFO \"Highest grade: %d\\n\", highest); */\n    \n    /* TODO: Calculate and print average */\n    /* average = calculate_average(); */\n    /* printk(KERN_INFO \"Average grade: %d\\n\", average); */\n    \n    return 0;\n}\n\nstatic void __exit arrays_exit(void)\n{\n    printk(KERN_INFO \"Arrays module unloaded\\n\");\n}\n\nmodule_init(arrays_init);\nmodule_exit(arrays_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning arrays and data collections\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Arrays module Makefile\nobj-m += arrays.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "arrays.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "arrays_init",
          "arrays_exit",
          "print_all_grades",
          "find_highest_grade",
          "calculate_average"
        ],
        "variables": [
          {
            "name": "student_grades[]",
            "type": "int",
            "value": "{85, 92, 78, 96, 88}"
          },
          {
            "name": "grade_count",
            "type": "int",
            "value": 5
          }
        ],
        "outputMessages": [
          "Arrays module loaded",
          "Student grades:",
          "Grade 1: 85",
          "Grade 2: 92",
          "Grade 3: 78",
          "Grade 4: 96",
          "Grade 5: 88",
          "Highest grade: 96",
          "Average grade: 87"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "#define MAX_GRADES 5",
          "extern int student_grades[MAX_GRADES]",
          "extern int grade_count",
          "int student_grades[MAX_GRADES] = {85, 92, 78, 96, 88}",
          "int grade_count = MAX_GRADES"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_all_grades(void)",
            "int find_highest_grade(void)",
            "int calculate_average(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_all_grades(void)",
            "int find_highest_grade(void)",
            "int calculate_average(void)",
            "static int __init arrays_init(void)",
            "static void __exit arrays_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Basic Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Arrays module loaded",
              "exact": true,
              "linkedFunction": "static int __init arrays_init(void)"
            },
            {
              "pattern": "Student grades:",
              "exact": true,
              "linkedFunction": "void print_all_grades(void)"
            },
            {
              "pattern": "Grade 1: 85",
              "exact": true,
              "linkedFunction": "void print_all_grades(void)"
            },
            {
              "pattern": "Grade 2: 92",
              "exact": true,
              "linkedFunction": "void print_all_grades(void)"
            },
            {
              "pattern": "Grade 3: 78",
              "exact": true,
              "linkedFunction": "void print_all_grades(void)"
            },
            {
              "pattern": "Grade 4: 96",
              "exact": true,
              "linkedFunction": "void print_all_grades(void)"
            },
            {
              "pattern": "Grade 5: 88",
              "exact": true,
              "linkedFunction": "void print_all_grades(void)"
            },
            {
              "pattern": "Highest grade: 96",
              "exact": true,
              "linkedFunction": "static int __init arrays_init(void)"
            },
            {
              "pattern": "Average grade: 87",
              "exact": true,
              "linkedFunction": "static int __init arrays_init(void)"
            }
          ]
        },
        {
          "id": "advanced_array_implementation_validation",
          "name": "Advanced Array Implementation with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "array_impl_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\"=== Dynamic Array Implementation Test ===\\\\n\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random test arrays\\n    int grades1[3] = {(rand() % 40) + 60, (rand() % 40) + 60, (rand() % 40) + 60};  // 60-99 range\\n    int grades2[4] = {(rand() % 30) + 70, (rand() % 30) + 70, (rand() % 30) + 70, (rand() % 30) + 70};  // 70-99 range\\n    \\n    printf(\"Test 1: Array with %d,%d,%d\\\\n\", grades1[0], grades1[1], grades1[2]);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \"insmod /lib/modules/arrays.ko student_grades=%d,%d,%d\", grades1[0], grades1[1], grades1[2]);\\n    system(\"rmmod arrays 2>/dev/null\");\\n    system(cmd1);\\n    \\n    printf(\"Test 2: Array with %d,%d,%d,%d\\\\n\", grades2[0], grades2[1], grades2[2], grades2[3]);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \"insmod /lib/modules/arrays.ko student_grades=%d,%d,%d,%d\", grades2[0], grades2[1], grades2[2], grades2[3]);\\n    system(\"rmmod arrays\");\\n    system(cmd2);\\n    \\n    printf(\"SUCCESS: Dynamic array test completed\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced array implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param_array(name, type, nump, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo '#define true 1' >> /tmp/linux/types.h",
              "echo '#define false 0' >> /tmp/linux/types.h",
              "echo 'Creating test file that includes student header...'",
              "echo '#include \"/lib/modules/arrays.h\"' > /tmp/test.c",
              "echo 'int main() { print_all_grades(); find_highest_grade(); calculate_average(); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: All function declarations found in header file'",
              "echo 'Phase 2: Dynamic Array Implementation Testing'",
              "/bin/array_impl_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Dynamic Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "TEST1_LINE=$(grep 'Test 1: Array with' /tmp/test_output.log)",
              "TEST2_LINE=$(grep 'Test 2: Array with' /tmp/test_output.log)",
              "echo 'Test 1 values: '$TEST1_LINE",
              "echo 'Test 2 values: '$TEST2_LINE",
              "echo 'Validating array processing output'",
              "dmesg | grep 'Student grades:' && echo 'PASS: Array output found' || echo 'FAIL: Array output missing'",
              "dmesg | grep 'Grade.*:.*[0-9]' && echo 'PASS: Grade enumeration working' || echo 'FAIL: Grade enumeration broken'",
              "dmesg | grep 'Highest grade:.*[0-9]' && echo 'PASS: Maximum finding working' || echo 'FAIL: Maximum finding broken'",
              "dmesg | grep 'Average grade:.*[0-9]' && echo 'PASS: Average calculation working' || echo 'FAIL: Average calculation broken'",
              "echo 'All dynamic validations completed'"
            ],
            "expected": {
              "dmesg": [
                "Arrays module loaded",
                "Student grades:",
                "Grade .* .*",
                "Highest grade: .*",
                "Average grade: .*"
              ],
              "stdout": [
                "PASS: All function declarations found in header file",
                "SUCCESS: Dynamic array test completed",
                "PASS: Array output found",
                "PASS: Grade enumeration working",
                "PASS: Maximum finding working",
                "PASS: Average calculation working"
              ]
            },
            "timeout": 30
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Arrays module loaded",
        "Student grades:",
        "Grade 1: 85",
        "Grade 2: 92",
        "Grade 3: 78",
        "Grade 4: 96",
        "Grade 5: 88",
        "Highest grade: 96",
        "Average grade: 87"
      ],
      "requirements": [
        "Use required function names: arrays_init, arrays_exit, print_all_grades, find_highest_grade, calculate_average",
        "Use required variable names: student_grades[], grade_count",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: #define MAX_GRADES 5, extern int student_grades[MAX_GRADES], extern int grade_count, int student_grades[MAX_GRADES] = {85, 92, 78, 96, 88}, int grade_count = MAX_GRADES",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Arrays module loaded",
          "linkedFunction": "static int __init arrays_init(void)",
          "exact": true
        },
        {
          "pattern": "Student grades:",
          "linkedFunction": "void print_all_grades(void)",
          "exact": true
        },
        {
          "pattern": "Grade 1: 85",
          "linkedFunction": "void print_all_grades(void)",
          "exact": true
        },
        {
          "pattern": "Grade 2: 92",
          "linkedFunction": "void print_all_grades(void)",
          "exact": true
        },
        {
          "pattern": "Grade 3: 78",
          "linkedFunction": "void print_all_grades(void)",
          "exact": true
        },
        {
          "pattern": "Grade 4: 96",
          "linkedFunction": "void print_all_grades(void)",
          "exact": true
        },
        {
          "pattern": "Grade 5: 88",
          "linkedFunction": "void print_all_grades(void)",
          "exact": true
        },
        {
          "pattern": "Highest grade: 96",
          "linkedFunction": "static int __init arrays_init(void)",
          "exact": true
        },
        {
          "pattern": "Average grade: 87",
          "linkedFunction": "static int __init arrays_init(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 14,
    "title": "String Basics - Arrays of Characters",
    "difficulty": 2,
    "xp": 25,
    "phase": "foundations",
    "description": "Learn that strings are just arrays of characters! This builds directly on the arrays problem - instead of int arrays, we use char arrays. No pointers, no parameters, just simple array indexing like device_name[0], device_name[1], etc.",
    "concepts": [
      "char arrays (strings) vs int arrays",
      "string initialization with literals",
      "null terminator concept (\\0)",
      "array indexing for characters",
      "manual character counting",
      "character-by-character assignment"
    ],
    "skills": [
      "Treating strings like arrays",
      "Using array indexing for characters",
      "Understanding null termination",
      "Manual character operations",
      "No-pointer string manipulation"
    ],
    "files": [
      {
        "name": "strings.h",
        "content": "#ifndef STRINGS_H\n#define STRINGS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/string.h>\n\n#define MAX_NAME_SIZE 32\n#define MAX_MESSAGE_SIZE 64\n\nextern char device_name[MAX_NAME_SIZE];\nextern char welcome_msg[MAX_MESSAGE_SIZE];\nextern int name_len;\n\n/* TODO: Declare your functions (no pointers!) */\n/* void show_device_info(void); */\n/* void count_device_name_length(void); */\n/* void update_to_new_device(void); */\n\n#endif /* STRINGS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "strings.c",
        "content": "#include \"strings.h\"\n\n/* TODO: Initialize your string arrays (just like int arrays!) */\n/* char device_name[MAX_NAME_SIZE] = \"my_device\"; */\n/* char welcome_msg[MAX_MESSAGE_SIZE] = \"Hello from kernel!\"; */\nint name_len = 0;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your string operations work\n * with different input values. Removing them will cause test failures.\n */\nmodule_param_string(device_name, device_name, MAX_NAME_SIZE, 0644);\nMODULE_PARM_DESC(device_name, \"Device name for testing string operations\");\nmodule_param_string(welcome_msg, welcome_msg, MAX_MESSAGE_SIZE, 0644);\nMODULE_PARM_DESC(welcome_msg, \"Welcome message for string operations\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* TODO: Implement function to show device information */\n/* Print device name and its length using printk */\n/* Format: \"Device: [name], Length: [X]\" */\n\n/* TODO: Implement function to count device_name length manually */\n/* Count characters in device_name until you find '\\0' */\n/* Use a for loop like: for (i = 0; i < MAX_NAME_SIZE; i++) */\n/* Update the global name_len variable */\n\n/* TODO: Implement function to manually copy \"new_device\" */\n/* Copy each character one by one: device_name[0] = 'n', device_name[1] = 'e', etc. */\n/* Don't forget to add null terminator at the end: device_name[10] = '\\0' */\n/* Call count_device_name_length() to update name_len */\n\nstatic int __init strings_init(void)\n{\n    printk(KERN_INFO \"String basics module loaded\\n\");\n    \n    /* TODO: Calculate length of device name */\n    /* count_device_name_length(); */\n    \n    /* TODO: Show initial device info */\n    /* show_device_info(); */\n    \n    /* TODO: Print the welcome message */\n/* printk(KERN_INFO \"Message: %s\\n\", welcome_msg); */\n    \n    /* TODO: Update to new device name and show info */\n    /* update_to_new_device(); */\n    /* printk(KERN_INFO \"After name change:\\n\"); */\n    /* show_device_info(); */\n    \n    return 0;\n}\n\nstatic void __exit strings_exit(void)\n{\n    printk(KERN_INFO \"String basics module unloaded\\n\");\n}\n\nmodule_init(strings_init);\nmodule_exit(strings_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning strings as character arrays\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# String basics module Makefile\nobj-m += strings.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "strings.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "strings_init",
          "strings_exit",
          "show_device_info",
          "count_device_name_length",
          "update_to_new_device"
        ],
        "variables": [
          {
            "name": "device_name[]",
            "type": "char",
            "value": "\"my_device\""
          },
          {
            "name": "welcome_msg[]",
            "type": "char",
            "value": "\"Hello from kernel!\""
          },
          {
            "name": "name_len",
            "type": "int",
            "value": " 0"
          }
        ],
        "outputMessages": [
          "String basics module loaded",
          "Device: my_device, Length: 9",
          "Message: Hello from kernel!",
          "After name change:",
          "Device: new_device, Length: 10"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/string.h"
        ],
        "mustContain": [
          "#define MAX_NAME_SIZE 32",
          "#define MAX_MESSAGE_SIZE 64",
          "char device_name[MAX_NAME_SIZE]",
          "char welcome_msg[MAX_MESSAGE_SIZE]"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header (No Pointers)",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void show_device_info(void)",
            "void count_device_name_length(void)",
            "void update_to_new_device(void)"
          ],
          "prohibitedSymbols": [
            "const char \\*",
            "char \\*"
          ]
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File (No Pointers)",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void show_device_info(void)",
            "void count_device_name_length(void)",
            "void update_to_new_device(void)",
            "static int __init strings_init(void)",
            "static void __exit strings_exit(void)"
          ],
          "prohibitedSymbols": [
            "const char \\*",
            "char \\*"
          ]
        },
        {
          "id": "exact_output",
          "name": "Expected Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "String basics module loaded",
              "exact": true,
              "linkedFunction": "static int __init strings_init(void)"
            },
            {
              "pattern": "Device: my_device, Length: 9",
              "exact": true,
              "linkedFunction": "void show_device_info(void)"
            },
            {
              "pattern": "Message: Hello from kernel!",
              "exact": true,
              "linkedFunction": "static int __init strings_init(void)"
            },
            {
              "pattern": "After name change:",
              "exact": true,
              "linkedFunction": "static int __init strings_init(void)"
            },
            {
              "pattern": "Device: new_device, Length: 10",
              "exact": true,
              "linkedFunction": "void show_device_info(void)"
            }
          ]
        },
        {
          "id": "basic_string_implementation_validation",
          "name": "Basic String Implementation with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "string_dynamic_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\"=== Dynamic String Implementation Test ===\\\\n\");\\n    \\n    // Generate randomized test cases\\n    const char* device_names[] = {\\\"sensor\\\", \\\"device\\\", \\\"module\\\", \\\"driver\\\", \\\"kernel\\\", \\\"system\\\"};\\n    const char* messages[] = {\\\"Hello\\\", \\\"Greetings\\\", \\\"Welcome\\\", \\\"Status\\\", \\\"Testing\\\", \\\"Active\\\"};\\n    \\n    srand(time(NULL));\\n    int name_idx = rand() % 6;\\n    int msg_idx = rand() % 6;\\n    \\n    printf(\\\"Test 1: Testing with device_name='%s' and welcome_msg='%s'\\\\n\\\", device_names[name_idx], messages[msg_idx]);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/strings.ko device_name=%s welcome_msg=%s\\\", device_names[name_idx], messages[msg_idx]);\\n    system(\\\"rmmod strings 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    // Generate second test with different values\\n    int name_idx2 = (name_idx + 2) % 6;\\n    int msg_idx2 = (msg_idx + 3) % 6;\\n    \\n    printf(\\\"Test 2: Testing with device_name='%s' and welcome_msg='%s'\\\\n\\\", device_names[name_idx2], messages[msg_idx2]);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/strings.ko device_name=%s welcome_msg=%s\\\", device_names[name_idx2], messages[msg_idx2]);\\n    system(\\\"rmmod strings\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Dynamic string test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting basic string implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param_string(name, string, len, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef unsigned long size_t;' > /tmp/linux/string.h",
              "echo 'size_t strlen(const char *s);' >> /tmp/linux/string.h",
              "echo 'Creating test file that includes student header...'",
              "echo '#include \"/lib/modules/strings.h\"' > /tmp/test.c",
              "echo 'int main() { show_device_info(); count_device_name_length(); update_to_new_device(); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: All function declarations found in header file'",
              "echo 'Phase 2: Dynamic String Implementation Testing'",
              "/bin/string_dynamic_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Dynamic Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "TEST1_DEVICE=$(grep -o \"Test 1: Testing with device_name='[^']*'\" /tmp/test_output.log | cut -d\"'\" -f2)",
              "TEST1_MESSAGE=$(grep -o \"Test 1: Testing with device_name='[^']*' and welcome_msg='[^']*'\" /tmp/test_output.log | cut -d\"'\" -f4)",
              "TEST2_DEVICE=$(grep -o \"Test 2: Testing with device_name='[^']*'\" /tmp/test_output.log | cut -d\"'\" -f2)",
              "TEST2_MESSAGE=$(grep -o \"Test 2: Testing with device_name='[^']*' and welcome_msg='[^']*'\" /tmp/test_output.log | cut -d\"'\" -f4)",
              "echo \"Test 1 device: '$TEST1_DEVICE', message: '$TEST1_MESSAGE'\"",
              "echo \"Test 2 device: '$TEST2_DEVICE', message: '$TEST2_MESSAGE'\"",
              "echo 'Calculating expected string lengths...'",
              "TEST1_EXPECTED_LEN=$(echo -n \"$TEST1_DEVICE\" | awk '{print length}')",
              "TEST2_EXPECTED_LEN=$(echo -n \"$TEST2_DEVICE\" | awk '{print length}')",
              "echo \"Expected: $TEST1_DEVICE = $TEST1_EXPECTED_LEN chars, $TEST2_DEVICE = $TEST2_EXPECTED_LEN chars\"",
              "echo 'Validating Test 1 string operations'",
              "dmesg | grep \"Device: $TEST1_DEVICE, Length: $TEST1_EXPECTED_LEN\" && echo 'PASS: Test 1 device name and length correct' || echo \"FAIL: Test 1 length wrong - expected $TEST1_EXPECTED_LEN for '$TEST1_DEVICE'\"",
              "dmesg | grep \"Message: $TEST1_MESSAGE\" && echo 'PASS: Test 1 message correct' || echo 'FAIL: Test 1 message wrong'",
              "echo 'Validating Test 2 string operations'",
              "dmesg | grep \"Device: $TEST2_DEVICE, Length: $TEST2_EXPECTED_LEN\" && echo 'PASS: Test 2 device name and length correct' || echo \"FAIL: Test 2 length wrong - expected $TEST2_EXPECTED_LEN for '$TEST2_DEVICE'\"",
              "dmesg | grep \"Message: $TEST2_MESSAGE\" && echo 'PASS: Test 2 message correct' || echo 'FAIL: Test 2 message wrong'",
              "echo 'Validating function behavior (new_device length should be 10)'",
              "dmesg | grep 'Device: new_device, Length: 10' && echo 'PASS: new_device length calculation correct' || echo 'FAIL: new_device length wrong - expected 10'",
              "dmesg | grep 'After name change:' && echo 'PASS: Name change function working' || echo 'FAIL: Name change function broken'",
              "echo 'All dynamic string validations completed'"
            ],
            "expected": {
              "dmesg": [
                "String basics module loaded",
                "Device: .* Length: .*",
                "Message: .*",
                "After name change:",
                "Device: .* Length: .*"
              ],
              "stdout": [
                "PASS: All function declarations found in header file",
                "SUCCESS: Dynamic string test completed",
                "PASS: Test 1 device name and length correct",
                "PASS: Test 1 message correct",
                "PASS: Test 2 device name and length correct",
                "PASS: Test 2 message correct",
                "PASS: new_device length calculation correct",
                "PASS: Name change function working"
              ]
            },
            "timeout": 30
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "String basics module loaded",
        "Device: my_device, Length: 9",
        "Message: Hello from kernel!",
        "After name change:",
        "Device: new_device, Length: 10"
      ],
      "requirements": [
        "Use required function names: strings_init, strings_exit, show_device_info, count_device_name_length, update_to_new_device",
        "Use required variable names: device_name[], welcome_msg[], name_len",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/string.h",
        "Code must contain: #define MAX_NAME_SIZE 32, #define MAX_MESSAGE_SIZE 64, char device_name[MAX_NAME_SIZE], char welcome_msg[MAX_MESSAGE_SIZE]",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "String basics module loaded",
          "linkedFunction": "static int __init strings_init(void)",
          "exact": true
        },
        {
          "pattern": "Device: my_device, Length: 9",
          "linkedFunction": "void show_device_info(void)",
          "exact": true
        },
        {
          "pattern": "Message: Hello from kernel!",
          "linkedFunction": "static int __init strings_init(void)",
          "exact": true
        },
        {
          "pattern": "After name change:",
          "linkedFunction": "static int __init strings_init(void)",
          "exact": true
        },
        {
          "pattern": "Device: new_device, Length: 10",
          "linkedFunction": "void show_device_info(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 15,
    "title": "Basic Structures - Organizing Related Data",
    "difficulty": 4,
    "xp": 40,
    "phase": "foundations",
    "description": "Learn to create and use basic structures to organize related data together. This introduces simple data modeling patterns essential for kernel development where structures represent system information.",
    "concepts": [
      "structure definition",
      "structure initialization",
      "structure member access",
      "designated initializers",
      "dot notation"
    ],
    "skills": [
      "Defining custom data types",
      "Organizing related data",
      "Direct structure access",
      "Structure member usage",
      "Basic data modeling"
    ],
    "files": [
      {
        "name": "structures.h",
        "content": "#ifndef STRUCTURES_H\n#define STRUCTURES_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n#define MAX_NAME_LEN 32\n\n/* TODO: Define student structure */\n/* struct student {\n *     int id;\n *     char name[MAX_NAME_LEN];\n *     int grade;\n *     bool passed;\n * }; */\n\nextern struct student my_student;\n\n/* TODO: Declare your functions */\n/* void print_student_info(void); */\n/* void check_student_status(void); */\n\n#endif /* STRUCTURES_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "structures.c",
        "content": "#include \"structures.h\"\n\n/* TODO: Initialize student structure */\n/* struct student my_student = {\n *     .id = 12345,\n *     .name = \"Alice Smith\",\n *     .grade = 85,\n *     .passed = true\n * }; */\n\n/* TODO: Implement function to print student information */\n/* void print_student_info(void) {\n *     printk(KERN_INFO \"Student ID: %d\\n\", my_student.id);\n *     printk(KERN_INFO \"Student Name: %s\\n\", my_student.name);\n *     printk(KERN_INFO \"Student Grade: %d\\n\", my_student.grade);\n * } */\n\n/* TODO: Implement function to check student status */\n/* void check_student_status(void) {\n *     if (my_student.passed) {\n *         printk(KERN_INFO \"Student Status: Passed\\n\");\n *     } else {\n *         printk(KERN_INFO \"Student Status: Failed\\n\");\n *     }\n * } */\n\nstatic int __init structures_init(void)\n{\n    printk(KERN_INFO \"Basic structures module loaded\\n\");\n    \n    /* TODO: Print student information */\n    /* print_student_info(); */\n    \n    /* TODO: Check student status */\n    /* check_student_status(); */\n    \n    return 0;\n}\n\nstatic void __exit structures_exit(void)\n{\n    printk(KERN_INFO \"Basic structures module unloaded\\n\");\n}\n\nmodule_init(structures_init);\nmodule_exit(structures_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning basic structures and data organization\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Basic structures module Makefile\nobj-m += structures.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "structures.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "structures_init",
          "structures_exit",
          "print_student_info",
          "check_student_status"
        ],
        "variables": [
          {
            "name": "my_student",
            "type": "struct student",
            "value": "{.id = 12345, .name = \"Alice Smith\", .grade = 85, .passed = true}"
          }
        ],
        "outputMessages": [
          "Basic structures module loaded",
          "Student ID: 12345",
          "Student Name: Alice Smith",
          "Student Grade: 85",
          "Student Status: Passed"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "struct student {",
          "extern struct student my_student",
          "struct student my_student = {",
          ".id = 12345",
          ".name = \"Alice Smith\"",
          ".grade = 85",
          ".passed = true"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "structure_definition",
          "name": "Structure Type Definition",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "struct student.*\\{",
            "int id;",
            "char name\\[MAX_NAME_LEN\\];",
            "int grade;",
            "bool passed;"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "structure_initialization",
          "name": "Structure Initialization with Designated Initializers",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "struct student my_student.*=.*\\{",
            "\\.id.*=.*12345",
            "\\.name.*=.*\"Alice Smith\"",
            "\\.grade.*=.*85",
            "\\.passed.*=.*true"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "structure_member_access",
          "name": "Direct Structure Member Access",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "my_student\\.id",
            "my_student\\.name",
            "my_student\\.grade",
            "my_student\\.passed"
          ],
          "prohibitedSymbols": [
            "my_student->",
            "pointer_access"
          ]
        },
        {
          "id": "conditional_with_struct",
          "name": "Using Structure Members in Conditionals",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "if.*my_student\\.passed"
          ],
          "prohibitedSymbols": [
            "true",
            "false",
            "hardcoded"
          ]
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_student_info(void)",
            "void check_student_status(void)",
            "static int __init structures_init(void)",
            "static void __exit structures_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Basic structures module loaded",
              "exact": true
            },
            {
              "pattern": "Student ID: 12345",
              "exact": true
            },
            {
              "pattern": "Student Name: Alice Smith",
              "exact": true
            },
            {
              "pattern": "Student Grade: 85",
              "exact": true
            },
            {
              "pattern": "Student Status: Passed",
              "exact": true
            }
          ]
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Basic structures module loaded",
        "Student ID: 12345",
        "Student Name: Alice Smith",
        "Student Grade: 85",
        "Student Status: Passed"
      ],
      "requirements": [
        "Use required function names: structures_init, structures_exit, print_student_info, check_student_status",
        "Use required variable names: my_student",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: struct student {, extern struct student my_student, struct student my_student = {, .id = 12345, .name = \"Alice Smith\", .grade = 85, .passed = true",
        "Must include MODULE_LICENSE(\"GPL\")"
      ]
    }
  },
  {
    "id": 16,
    "title": "Structure Pointers - Advanced Data Manipulation",
    "difficulty": 5,
    "xp": 45,
    "phase": "foundations",
    "description": "Learn to work with pointers to structures and modify structure data through functions. This builds on basic structures and introduces essential pointer concepts needed for advanced kernel programming.",
    "concepts": [
      "structure pointers",
      "pointer dereferencing",
      "arrow operator (->)",
      "address-of operator (&)",
      "structure modification via pointers"
    ],
    "skills": [
      "Working with structure pointers",
      "Using arrow operator for member access",
      "Passing structures to functions by reference",
      "Modifying structures through pointers",
      "Understanding pointer-based data manipulation"
    ],
    "files": [
      {
        "name": "struct_pointers.h",
        "content": "#ifndef STRUCT_POINTERS_H\n#define STRUCT_POINTERS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n#define MAX_NAME_LEN 32\n\n/* Structure from previous problem - now we work with pointers */\nstruct student {\n    int id;\n    char name[MAX_NAME_LEN];\n    int grade;\n    bool passed;\n};\n\n/* TODO: Define device_info structure */\n/* struct device_info {\n *     char device_name[MAX_NAME_LEN];\n *     int device_id;\n *     bool is_active;\n *     int data_count;\n * }; */\n\nextern struct student test_student;\nextern struct device_info my_device;\n\n/* TODO: Declare your functions that work with pointers */\n/* void print_student_info(struct student *s); */\n/* void print_device_info(struct device_info *dev); */\n/* void update_student_grade(struct student *s, int new_grade); */\n/* void activate_device(struct device_info *dev); */\n\n#endif /* STRUCT_POINTERS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "struct_pointers.c",
        "content": "#include \"struct_pointers.h\"\n\n/* Initialize structures - same data as problem 10 */\nstruct student test_student = {\n    .id = 12345,\n    .name = \"Alice Smith\",\n    .grade = 85,\n    .passed = true\n};\n\n/* TODO: Initialize device structure */\n/* struct device_info my_device = {\n *     .device_name = \"sensor01\",\n *     .device_id = 1001,\n *     .is_active = false,\n *     .data_count = 0\n * }; */\n\n/* TODO: Implement function to print student info using pointer */\n/* void print_student_info(struct student *s) {\n *     printk(KERN_INFO \"Student ID: %d\\n\", s->id);\n *     printk(KERN_INFO \"Student Name: %s\\n\", s->name);\n *     printk(KERN_INFO \"Student Grade: %d\\n\", s->grade);\n *     printk(KERN_INFO \"Student Status: %s\\n\", s->passed ? \"Passed\" : \"Failed\");\n * } */\n\n/* TODO: Implement function to print device info using pointer */\n/* void print_device_info(struct device_info *dev) {\n *     printk(KERN_INFO \"Device Name: %s\\n\", dev->device_name);\n *     printk(KERN_INFO \"Device ID: %d\\n\", dev->device_id);\n *     printk(KERN_INFO \"Device Active: %s\\n\", dev->is_active ? \"Yes\" : \"No\");\n *     printk(KERN_INFO \"Data Count: %d\\n\", dev->data_count);\n * } */\n\n/* TODO: Implement function to update student grade via pointer */\n/* void update_student_grade(struct student *s, int new_grade) {\n *     s->grade = new_grade;\n *     s->passed = (new_grade >= 60) ? true : false;\n *     printk(KERN_INFO \"Updated %s grade to: %d\\n\", s->name, new_grade);\n * } */\n\n/* TODO: Implement function to activate device via pointer */\n/* void activate_device(struct device_info *dev) {\n *     dev->is_active = true;\n *     dev->data_count = 1;\n *     printk(KERN_INFO \"Device %s activated\\n\", dev->device_name);\n * } */\n\nstatic int __init struct_pointers_init(void)\n{\n    printk(KERN_INFO \"Structure pointers module loaded\\n\");\n    \n    /* TODO: Print initial student info using pointer */\n    /* printk(KERN_INFO \"Initial Student Information:\\n\"); */\n    /* print_student_info(&test_student); */\n    \n    /* TODO: Print initial device info using pointer */\n    /* printk(KERN_INFO \"Initial Device Information:\\n\"); */\n    /* print_device_info(&my_device); */\n    \n    /* TODO: Update student grade through pointer */\n    /* update_student_grade(&test_student, 95); */\n    \n    /* TODO: Activate device through pointer */\n    /* activate_device(&my_device); */\n    \n    /* TODO: Print updated information */\n    /* printk(KERN_INFO \"Updated Information:\\n\"); */\n    /* print_student_info(&test_student); */\n    /* print_device_info(&my_device); */\n    \n    return 0;\n}\n\nstatic void __exit struct_pointers_exit(void)\n{\n    printk(KERN_INFO \"Structure pointers module unloaded\\n\");\n}\n\nmodule_init(struct_pointers_init);\nmodule_exit(struct_pointers_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning structure pointers and data manipulation\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Structure pointers module Makefile\nobj-m += struct_pointers.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "struct_pointers.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "struct_pointers_init",
          "struct_pointers_exit",
          "print_student_info",
          "print_device_info",
          "update_student_grade",
          "activate_device"
        ],
        "variables": [
          {
            "name": "test_student",
            "type": "struct student",
            "value": "{.id = 12345, .name = \"Alice Smith\", .grade = 85, .passed = true}"
          },
          {
            "name": "my_device",
            "type": "struct device_info",
            "value": "{.device_name = \"sensor01\", .device_id = 1001, .is_active = false, .data_count = 0}"
          }
        ],
        "outputMessages": [
          "Structure pointers module loaded",
          "Initial Student Information:",
          "Student ID: 12345",
          "Student Name: Alice Smith",
          "Student Grade: 85",
          "Student Status: Passed",
          "Initial Device Information:",
          "Device Name: sensor01",
          "Device ID: 1001",
          "Device Active: No",
          "Data Count: 0",
          "Updated Alice Smith grade to: 95",
          "Device sensor01 activated",
          "Updated Information:",
          "Student Grade: 95",
          "Device Active: Yes",
          "Data Count: 1"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "struct device_info {",
          "extern struct student test_student",
          "extern struct device_info my_device",
          "struct device_info my_device = {",
          "&test_student",
          "&my_device"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "structure_definitions",
          "name": "Structure Type Definitions",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "struct device_info.*\\{",
            "char device_name\\[MAX_NAME_LEN\\];",
            "int device_id;",
            "bool is_active;",
            "int data_count;"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "pointer_function_parameters",
          "name": "Function Parameters with Structure Pointers",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "struct student \\*s",
            "struct device_info \\*dev",
            "int new_grade"
          ],
          "prohibitedSymbols": [
            "struct student s",
            "struct device_info dev"
          ]
        },
        {
          "id": "arrow_operator_usage",
          "name": "Arrow Operator for Pointer Member Access",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "s->id",
            "s->name",
            "s->grade",
            "s->passed",
            "dev->device_name",
            "dev->device_id",
            "dev->is_active",
            "dev->data_count"
          ],
          "prohibitedSymbols": [
            "s.id",
            "dev.device_name",
            "dot_access"
          ]
        },
        {
          "id": "address_of_operator",
          "name": "Address-of Operator for Passing Structure Pointers",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "&test_student",
            "&my_device"
          ],
          "prohibitedSymbols": [
            "test_student",
            "my_device"
          ]
        },
        {
          "id": "structure_modification",
          "name": "Structure Modification via Pointers",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "s->grade.*=.*new_grade",
            "s->passed.*=.*new_grade.*>=.*60",
            "dev->is_active.*=.*true",
            "dev->data_count.*=.*1"
          ],
          "prohibitedSymbols": [
            "95",
            "true",
            "1",
            "hardcoded"
          ]
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_student_info(struct student \\*s)",
            "void print_device_info(struct device_info \\*dev)",
            "void update_student_grade(struct student \\*s, int new_grade)",
            "void activate_device(struct device_info \\*dev)",
            "static int __init struct_pointers_init(void)",
            "static void __exit struct_pointers_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Structure pointers module loaded",
              "exact": true
            },
            {
              "pattern": "Initial Student Information:",
              "exact": true
            },
            {
              "pattern": "Student ID: 12345",
              "exact": true
            },
            {
              "pattern": "Student Name: Alice Smith",
              "exact": true
            },
            {
              "pattern": "Student Grade: 85",
              "exact": true
            },
            {
              "pattern": "Student Status: Passed",
              "exact": true
            },
            {
              "pattern": "Initial Device Information:",
              "exact": true
            },
            {
              "pattern": "Device Name: sensor01",
              "exact": true
            },
            {
              "pattern": "Device ID: 1001",
              "exact": true
            },
            {
              "pattern": "Device Active: No",
              "exact": true
            },
            {
              "pattern": "Data Count: 0",
              "exact": true
            },
            {
              "pattern": "Updated Alice Smith grade to: 95",
              "exact": true
            },
            {
              "pattern": "Device sensor01 activated",
              "exact": true
            },
            {
              "pattern": "Updated Information:",
              "exact": true
            },
            {
              "pattern": "Student Grade: 95",
              "exact": true
            },
            {
              "pattern": "Device Active: Yes",
              "exact": true
            },
            {
              "pattern": "Data Count: 1",
              "exact": true
            }
          ]
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Structure pointers module loaded",
        "Initial Student Information:",
        "Student ID: 12345",
        "Student Name: Alice Smith",
        "Student Grade: 85",
        "Student Status: Passed",
        "Initial Device Information:",
        "Device Name: sensor01",
        "Device ID: 1001",
        "Device Active: No",
        "Data Count: 0",
        "Updated Alice Smith grade to: 95",
        "Device sensor01 activated",
        "Updated Information:",
        "Student Grade: 95",
        "Device Active: Yes",
        "Data Count: 1"
      ],
      "requirements": [
        "Use required function names: struct_pointers_init, struct_pointers_exit, print_student_info, print_device_info, update_student_grade, activate_device",
        "Use required variable names: test_student, my_device",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: struct device_info {, extern struct student test_student, extern struct device_info my_device, struct device_info my_device = {, &test_student, &my_device",
        "Must include MODULE_LICENSE(\"GPL\")"
      ]
    }
  },
  {
    "id": 79,
    "title": "Secure String Handling - Modern Kernel Text Operations",
    "difficulty": 4,
    "xp": 40,
    "phase": "foundations",
    "description": "Learn modern, secure string handling in kernel space using current best practices. Master strscpy(), snprintf(), and safe string operations essential for handling device names, user messages, and configuration data in kernel modules.",
    "concepts": [
      "secure string copying with strscpy()",
      "safe string formatting with snprintf()",
      "string validation and error handling",
      "module parameter strings",
      "kernel logging best practices",
      "buffer overflow prevention"
    ],
    "skills": [
      "Using modern kernel string functions",
      "Implementing secure string operations",
      "Error handling in string operations",
      "Input validation and sanitization",
      "Safe buffer management in kernel space",
      "Professional kernel logging patterns"
    ],
    "files": [
      {
        "name": "strings.h",
        "content": "#ifndef STRINGS_H\n#define STRINGS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n\n#define MAX_DEVICE_NAME 32\n#define MAX_STATUS_MSG 64\n#define MAX_BUFFER_SIZE 128\n\nextern char device_name[MAX_DEVICE_NAME];\nextern char status_message[MAX_STATUS_MSG];\nextern int name_length;\n\n/* TODO: Declare your functions */\n/* void display_device_info(void); */\n/* ssize_t update_device_name(const char *new_name); */\n/* int format_status_message(const char *status); */\n/* int validate_string_input(const char *input); */\n\n#endif /* STRINGS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "strings.c",
        "content": "#include \"strings.h\"\n\n/* TODO: Initialize device name and status message */\n/* char device_name[MAX_DEVICE_NAME] = \"sensor_001\"; */\n/* char status_message[MAX_STATUS_MSG] = \"initializing\"; */\nint name_length = 0;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your string operations work\n * with different input values. Removing them will cause test failures.\n */\nmodule_param_string(device_name, device_name, MAX_DEVICE_NAME, 0644);\nMODULE_PARM_DESC(device_name, \"Device name for testing string operations\");\nmodule_param_string(status_message, status_message, MAX_STATUS_MSG, 0644);\nMODULE_PARM_DESC(status_message, \"Status message for string formatting tests\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* TODO: Implement function to display device information */\n/* Use printk with KERN_INFO to display device name, length, and status */\n/* Format: \"Device: [name] (Length: [X])\" and \"Status: [status]\" */\n\n/* TODO: Implement function to safely update device name using strscpy() */\n/* Use strscpy() instead of manual copying for security */\n/* Return the number of characters copied, or negative on error */\n/* Update name_length after successful copy */\n\n/* TODO: Implement function to format status message using snprintf() */\n/* Use snprintf() to safely format: \"Device [name] is [status]\" */\n/* Return 0 on success, negative on error */\n/* Check for truncation and log warning if needed */\n\n/* TODO: Implement function to validate string input */\n/* Check if input is not NULL and length is reasonable */\n/* Use strlen() to get length, return length or -EINVAL on error */\n/* Reject empty strings and strings that are too long */\n\nstatic int __init strings_init(void)\n{\n    printk(KERN_INFO \"Secure string handling module loaded\\n\");\n    \n    /* TODO: Validate and calculate initial name length */\n    /* name_length = validate_string_input(device_name); */\n    /* if (name_length < 0) { */\n    /*     printk(KERN_ERR \"Invalid device name\\n\"); */\n    /*     return name_length; */\n    /* } */\n    \n    /* TODO: Display initial device information */\n    /* display_device_info(); */\n    \n    /* TODO: Update device name and display results */\n    /* ssize_t result = update_device_name(\"updated_sensor\"); */\n    /* if (result < 0) { */\n    /*     printk(KERN_WARNING \"Device name update failed: %zd\\n\", result); */\n    /* } else { */\n    /*     printk(KERN_INFO \"Device name updated successfully\\n\"); */\n    /*     display_device_info(); */\n    /* } */\n    \n    /* TODO: Format and display status message */\n    /* int fmt_result = format_status_message(\"active\"); */\n    /* if (fmt_result < 0) { */\n    /*     printk(KERN_WARNING \"Status formatting failed: %d\\n\", fmt_result); */\n    /* } */\n    \n    return 0;\n}\n\nstatic void __exit strings_exit(void)\n{\n    printk(KERN_INFO \"Secure string handling module unloaded\\n\");\n}\n\nmodule_init(strings_init);\nmodule_exit(strings_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning secure string handling in kernel space\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# String handling module Makefile\nobj-m += strings.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "strings.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "strings_init",
          "strings_exit",
          "display_device_info",
          "update_device_name",
          "format_status_message",
          "validate_string_input"
        ],
        "variables": [
          {
            "name": "device_name",
            "type": "char[]",
            "value": "\"sensor_001\""
          },
          {
            "name": "status_message",
            "type": "char[]",
            "value": "\"initializing\""
          },
          {
            "name": "name_length",
            "type": "int",
            "value": 0
          }
        ],
        "outputMessages": [
          "Secure string handling module loaded",
          "Device: sensor_001 (Length: 10)",
          "Status: initializing",
          "Device name updated successfully",
          "Device: updated_sensor (Length: 14)",
          "Status: Device updated_sensor is active"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h",
          "linux/string.h"
        ],
        "mustContain": [
          "#define MAX_DEVICE_NAME 32",
          "#define MAX_STATUS_MSG 64",
          "extern char device_name[MAX_DEVICE_NAME]",
          "extern char status_message[MAX_STATUS_MSG]",
          "module_param_string(device_name, device_name, MAX_DEVICE_NAME, 0644)",
          "module_param_string(status_message, status_message, MAX_STATUS_MSG, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void display_device_info(void)",
            "ssize_t update_device_name(const char *new_name)",
            "int format_status_message(const char *status)",
            "int validate_string_input(const char *input)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void display_device_info(void)",
            "ssize_t update_device_name(const char *new_name)",
            "int format_status_message(const char *status)",
            "int validate_string_input(const char *input)",
            "static int __init strings_init(void)",
            "static void __exit strings_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "advanced_string_implementation_validation",
          "name": "Advanced String Implementation with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "string_impl_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\"=== Dynamic String Implementation Test ===\\\\n\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random device names and statuses\\n    const char* device_prefixes[] = {\"sensor\", \"actuator\", \"controller\", \"monitor\"};\\n    const char* statuses[] = {\"active\", \"idle\", \"error\", \"maintenance\", \"ready\"};\\n    \\n    int device_idx = rand() % 4;\\n    int device_num = (rand() % 100) + 1;\\n    int status_idx = rand() % 5;\\n    \\n    char device_name[32];\\n    snprintf(device_name, sizeof(device_name), \"%s_%03d\", device_prefixes[device_idx], device_num);\\n    \\n    printf(\"Test 1: Device name '%s' with status '%s'\\\\n\", device_name, statuses[status_idx]);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \"insmod /lib/modules/strings.ko device_name=%s status_message=%s\", device_name, statuses[status_idx]);\\n    system(\"rmmod strings 2>/dev/null\");\\n    system(cmd1);\\n    \\n    // Second test with different values\\n    device_idx = rand() % 4;\\n    device_num = (rand() % 100) + 1;\\n    status_idx = rand() % 5;\\n    snprintf(device_name, sizeof(device_name), \"%s_%03d\", device_prefixes[device_idx], device_num);\\n    \\n    printf(\"Test 2: Device name '%s' with status '%s'\\\\n\", device_name, statuses[status_idx]);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \"insmod /lib/modules/strings.ko device_name=%s status_message=%s\", device_name, statuses[status_idx]);\\n    system(\"rmmod strings\");\\n    system(cmd2);\\n    \\n    printf(\"SUCCESS: Dynamic string test completed\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced string implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo '#define KERN_WARNING' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param_string(name, string, len, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef long ssize_t;' > /tmp/linux/types.h",
              "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
              "echo 'ssize_t strscpy(char *dest, const char *src, size_t count);' > /tmp/linux/string.h",
              "echo 'int snprintf(char *buf, size_t size, const char *fmt, ...);' >> /tmp/linux/string.h",
              "echo 'size_t strlen(const char *s);' >> /tmp/linux/string.h",
              "echo '#define EINVAL 22' > /tmp/linux/errno.h",
              "echo '#define E2BIG 7' >> /tmp/linux/errno.h",
              "echo 'Creating test file that includes student header...'",
              "echo '#include \"/lib/modules/strings.h\"' > /tmp/test.c",
              "echo 'int main() { display_device_info(); update_device_name(\"test\"); format_status_message(\"active\"); validate_string_input(\"input\"); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: All function declarations found in header file'",
              "echo 'Phase 2: Dynamic String Implementation Testing'",
              "/bin/string_impl_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Dynamic Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "TEST1_LINE=$(grep 'Test 1: Device name' /tmp/test_output.log)",
              "TEST2_LINE=$(grep 'Test 2: Device name' /tmp/test_output.log)",
              "echo 'Test 1 values: '$TEST1_LINE",
              "echo 'Test 2 values: '$TEST2_LINE",
              "echo 'Validating string operation output'",
              "dmesg | grep 'Secure string handling module loaded' && echo 'PASS: Module loaded correctly' || echo 'FAIL: Module loading issue'",
              "dmesg | grep 'Device:.*Length:' && echo 'PASS: Device info display working' || echo 'FAIL: Device info display broken'",
              "dmesg | grep 'Status:' && echo 'PASS: Status message working' || echo 'FAIL: Status message broken'",
              "dmesg | grep 'Device name updated successfully' && echo 'PASS: String update working' || echo 'FAIL: String update broken'",
              "echo 'All dynamic string validations completed'"
            ],
            "expected": {
              "dmesg": [
                "Secure string handling module loaded",
                "Device: .* \\(Length: .*\\)",
                "Status: .*",
                "Device name updated successfully"
              ],
              "stdout": [
                "PASS: All function declarations found in header file",
                "SUCCESS: Dynamic string test completed",
                "PASS: Module loaded correctly",
                "PASS: Device info display working",
                "PASS: Status message working",
                "PASS: String update working"
              ]
            },
            "timeout": 35
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Secure string handling module loaded",
        "Device: sensor_001 (Length: 10)",
        "Status: initializing",
        "Device name updated successfully",
        "Device: updated_sensor (Length: 14)",
        "Status: Device updated_sensor is active"
      ],
      "requirements": [
        "Use required function names: strings_init, strings_exit, display_device_info, update_device_name, format_status_message, validate_string_input",
        "Use required variable names: device_name, status_message, name_length",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h, linux/string.h",
        "Code must contain: #define MAX_DEVICE_NAME 32, #define MAX_STATUS_MSG 64, extern char device_name[MAX_DEVICE_NAME], extern char status_message[MAX_STATUS_MSG], module_param_string(device_name, device_name, MAX_DEVICE_NAME, 0644), module_param_string(status_message, status_message, MAX_STATUS_MSG, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ]
    }
  },
  {
    "id": 80,
    "title": "Simple Driver - File Creation Challenge",
    "difficulty": 5,
    "xp": 60,
    "phase": "drivers",
    "description": "Create a simple kernel driver by implementing missing files. You are given a partial driver structure and need to create the missing source and header files to complete the driver implementation.",
    "concepts": [
      "file creation",
      "multi-file architecture",
      "character devices",
      "device operations",
      "kernel module structure"
    ],
    "skills": [
      "Creating header files",
      "Implementing device operations",
      "Character device management",
      "Resource management",
      "Multi-file project organization"
    ],
    "files": [
      {
        "name": "driver_main.c",
        "content": "#include \"driver_main.h\"\n#include \"device_ops.h\"\n\n/* Main driver structure */\nstruct simple_driver_data *driver_data = NULL;\n\nstatic int __init simple_driver_init(void)\n{\n    int result;\n    \n    pr_info(\"simple_driver: initializing\\n\");\n    \n    /* TODO: Allocate driver data structure */\n    driver_data = kzalloc(sizeof(struct simple_driver_data), GFP_KERNEL);\n    if (!driver_data) {\n        pr_err(\"simple_driver: failed to allocate driver data\\n\");\n        return -ENOMEM;\n    }\n    \n    /* TODO: Initialize the device */\n    result = device_init(driver_data);\n    if (result < 0) {\n        pr_err(\"simple_driver: device initialization failed\\n\");\n        kfree(driver_data);\n        return result;\n    }\n    \n    pr_info(\"simple_driver: loaded successfully\\n\");\n    return 0;\n}\n\nstatic void __exit simple_driver_exit(void)\n{\n    pr_info(\"simple_driver: unloading\\n\");\n    \n    if (driver_data) {\n        /* TODO: Clean up the device */\n        device_cleanup(driver_data);\n        kfree(driver_data);\n    }\n    \n    pr_info(\"simple_driver: unloaded\\n\");\n}\n\nmodule_init(simple_driver_init);\nmodule_exit(simple_driver_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Simple Driver Creation Challenge\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "driver_main.h",
        "content": "#ifndef DRIVER_MAIN_H\n#define DRIVER_MAIN_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n#define DRIVER_NAME \"simple_driver\"\n#define DEVICE_NAME \"simpledev\"\n#define CLASS_NAME \"simple_class\"\n\n/* Driver data structure */\nstruct simple_driver_data {\n    dev_t device_number;\n    struct cdev cdev;\n    struct class *device_class;\n    struct device *device_struct;\n    char *buffer;\n    size_t buffer_size;\n};\n\n/* Global driver data */\nextern struct simple_driver_data *driver_data;\n\n#endif /* DRIVER_MAIN_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "Makefile",
        "content": "# Simple driver Makefile\nobj-m += simple_driver.o\n\n# Object files that make up this module\nsimple_driver-objs := driver_main.o device_ops.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "driver_main.c",
    "requiredFiles": [
      {
        "name": "device_ops.h",
        "description": "Header file containing device operation declarations",
        "hints": [
          "Should include function declarations for device_init() and device_cleanup()",
          "Should include any necessary includes for device operations",
          "Should define any constants needed for device operations"
        ]
      },
      {
        "name": "device_ops.c",
        "description": "Implementation file containing device operations",
        "hints": [
          "Should implement device_init() function that sets up character device",
          "Should implement device_cleanup() function that cleans up resources",
          "Should include file operations structure with basic read/write functions"
        ]
      }
    ],
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "device_init",
          "device_cleanup",
          "simple_driver_init",
          "simple_driver_exit"
        ],
        "variables": [],
        "outputMessages": [
          "simple_driver: loaded successfully",
          "simple_driver: unloaded"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/fs.h",
          "linux/cdev.h"
        ],
        "mustContain": [
          "alloc_chrdev_region",
          "cdev_init",
          "cdev_add",
          "class_create",
          "device_create"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int device_init(struct simple_driver_data *driver_data)",
            "void device_cleanup(struct simple_driver_data *driver_data)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int device_init(struct simple_driver_data *driver_data)",
            "void device_cleanup(struct simple_driver_data *driver_data)",
            "static int __init simple_driver_init(void)",
            "static void __exit simple_driver_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "driver_functionality",
          "name": "Driver Functionality Test",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "device_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <fcntl.h>\\n#include <unistd.h>\\n#include <string.h>\\n\\n#define DEVICE_PATH \"/dev/simpledev\"\\n\\nint main() {\\n    int fd;\\n    char buffer[256];\\n    ssize_t bytes;\\n    \\n    printf(\"=== Simple Driver Test ===\\\\n\");\\n    \\n    fd = open(DEVICE_PATH, O_RDWR);\\n    if (fd < 0) {\\n        printf(\"INFO: Device not found (this is expected in basic test)\\\\n\");\\n        return 0;\\n    }\\n    \\n    printf(\"SUCCESS: Device opened\\\\n\");\\n    \\n    bytes = write(fd, \"test\", 4);\\n    if (bytes > 0) {\\n        printf(\"SUCCESS: Written %zd bytes\\\\n\", bytes);\\n    }\\n    \\n    close(fd);\\n    printf(\"SUCCESS: Driver test completed\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Setting up simple driver test'",
              "mkdir -p /dev"
            ],
            "testCommands": [
              "echo 'Creating device node...'",
              "major=$(grep simpledev /proc/devices | cut -d' ' -f1)",
              "if [ -z \"$major\" ]; then echo 'ERROR: simpledev not found'; exit 1; fi",
              "mknod /dev/simpledev c $major 0",
              "chmod 666 /dev/simpledev",
              "echo 'Running driver test'",
              "/bin/device_tester",
              "echo 'Checking driver registration'",
              "grep simple_driver /proc/modules 2>/dev/null || echo 'Driver loaded successfully'"
            ],
            "expected": {
              "dmesg": [
                "simple_driver.*loaded successfully",
                "simple_driver.*unloaded"
              ],
              "stdout": [
                "Simple Driver Test",
                "SUCCESS: Driver test completed"
              ]
            },
            "timeout": 30
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "simple_driver: loaded successfully",
        "simple_driver: unloaded"
      ],
      "requirements": [
        "Use required function names: device_init, device_cleanup, simple_driver_init, simple_driver_exit",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/fs.h, linux/cdev.h",
        "Code must contain: alloc_chrdev_region, cdev_init, cdev_add, class_create, device_create",
        "Must include MODULE_LICENSE(\"GPL\")",
        "Test Environment: Create missing device operation files to complete the driver",
        "Userspace Test: Basic device testing will be performed automatically",
        "Test Setup: Create device_ops.h with function declarations",
        "Test Setup: Create device_ops.c with complete implementation",
        "Test Setup: Ensure all required kernel APIs are used"
      ]
    }
  }
];

export default problemBank;
