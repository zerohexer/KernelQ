// Auto-generated from problems/ directory
// DO NOT EDIT THIS FILE DIRECTLY - Edit problems/*.json instead
// Generated at: 2025-09-27T04:29:07.634Z

const problemBank = [
  {
    "id": 1,
    "title": "Hello World - Your First Kernel Module",
    "difficulty": 1,
    "xp": 10,
    "phase": "foundations",
    "description": "Welcome to kernel programming! Create your very first kernel module - a simple \"Hello World\" program that runs inside the Linux kernel. This introduction uses just one file to keep things simple and help you understand the basics before moving to more advanced topics.",
    "concepts": [
      "kernel modules",
      "printk function",
      "module_init and module_exit",
      "basic kernel programming",
      "module lifecycle"
    ],
    "skills": [
      "Understanding kernel vs userspace",
      "Using printk for kernel output",
      "Creating init and exit functions",
      "Basic module structure",
      "Kernel module compilation"
    ],
    "files": [
      {
        "name": "hello.c",
        "content": "/* WELCOME TO KERNEL PROGRAMMING!\n *\n * What is this program?\n * - This is a \"kernel module\" - code that runs inside the Linux operating system\n * - Think of it like adding a small program to your computer's core brain\n * - When you load this module, it will print a message you can see with 'dmesg'\n * \n * Don't worry if you don't understand everything - just follow the TODOs!\n * Programming is learned by doing, step by step.\n */\n\n#include <linux/module.h>    /* For all kernel modules */\n#include <linux/kernel.h>    /* For printk() function */\n#include <linux/init.h>      /* For __init and __exit macros */\n\n/* TODO: Create the init function */\n/* This function runs when the module is loaded into memory */\n/* 'static' means only this file can use this function */\n/* 'int' means this function returns a number (0 = success) */\nstatic int __init hello_init(void)\n{\n    /* TODO: Print \"Hello World from kernel!\" using printk */\n    /* printk is like printf, but for kernel messages */\n    /* KERN_INFO means \"information level\" message */\n    /* \\n means \"new line\" (like pressing Enter) */\n    /* Use: printk(KERN_INFO \"Your message here\\n\"); */\n    \n    return 0;  /* Return 0 means \"success, everything worked!\" */\n}\n\n/* TODO: Create the exit function */\n/* This function runs when the module is unloaded from memory */\n/* 'void' means this function doesn't return anything */\nstatic void __exit hello_exit(void)\n{\n    /* TODO: Print \"Goodbye from kernel!\" using printk */\n    /* This lets us know the module was unloaded successfully */\n    /* Use: printk(KERN_INFO \"Your message here\\n\"); */\n}\n\n/* These lines tell the kernel which functions to call */\n/* They register your functions with the kernel */\nmodule_init(hello_init);   /* This registers the init function */\nmodule_exit(hello_exit);   /* This registers the exit function */\n\n/* Module information - these are required by the kernel */\n/* Think of these like a \"name tag\" for your module */\nMODULE_LICENSE(\"GPL\");     /* GPL is a common open source license */\nMODULE_AUTHOR(\"Student\");   /* That's you! */\nMODULE_DESCRIPTION(\"My first kernel module - Hello World\");\nMODULE_VERSION(\"1.0\");     /* Version 1.0 - your first try! */",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Simple Makefile for hello world kernel module\nobj-m += hello.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "hello.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "hello_init",
          "hello_exit"
        ],
        "outputMessages": [
          "Hello World from kernel!",
          "Goodbye from kernel!"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h"
        ],
        "mustContain": [
          "printk",
          "KERN_INFO"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "static int __init hello_init(void)",
            "static void __exit hello_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "kernel_functionality_test",
          "name": "Kernel Module Functionality Test",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "hello_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\\\"=== Hello World Module Test ===\\\\n\\\");\\n    \\n    printf(\\\"Test: Loading hello module...\\\\n\\\");\\n    system(\\\"insmod /lib/modules/hello.ko\\\");\\n    \\n    printf(\\\"Test: Unloading hello module...\\\\n\\\");\\n    system(\\\"rmmod hello\\\");\\n    \\n    printf(\\\"SUCCESS: Module load/unload completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "testCommands": [
              "echo 'Testing kernel module compilation and basic functionality...'",
              "/bin/hello_tester",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Checking for kernel logging functionality...'",
              "dmesg | grep 'Hello World from kernel' && echo 'PASS: init function logging working' || echo 'FAIL: init function logging missing'",
              "dmesg | grep 'Goodbye from kernel' && echo 'PASS: exit function logging working' || echo 'FAIL: exit function logging missing'",
              "echo 'PASS: All kernel functionality tests completed'"
            ],
            "expected": {
              "dmesg": [
                "Hello World from kernel!",
                "Goodbye from kernel!"
              ],
              "stdout": [
                "Hello World Module Test",
                "SUCCESS: Module load/unload completed",
                "PASS: All kernel functionality tests completed"
              ]
            },
            "timeout": 10
          }
        },
        {
          "id": "exact_output",
          "name": "Function-Linked Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Hello World from kernel!",
              "exact": true,
              "linkedFunction": "static int __init hello_init(void)"
            },
            {
              "pattern": "Goodbye from kernel!",
              "exact": true,
              "linkedFunction": "static void __exit hello_exit(void)"
            }
          ]
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Hello World from kernel!",
        "Goodbye from kernel!"
      ],
      "requirements": [
        "Use required function names: hello_init, hello_exit",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h",
        "Code must contain: printk, KERN_INFO",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Hello World from kernel!",
          "linkedFunction": "static int __init hello_init(void)",
          "exact": true
        },
        {
          "pattern": "Goodbye from kernel!",
          "linkedFunction": "static void __exit hello_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 2,
    "title": "Hello World - Multi-File Kernel Module",
    "difficulty": 1,
    "xp": 15,
    "phase": "foundations",
    "description": "Create your first multi-file kernel module with a separate header file. This introduces you to kernel module structure with proper file organization. Note: Module init/exit functions are static and don't need header declarations.",
    "concepts": [
      "multi-file modules",
      "header files",
      "module_init",
      "module_exit",
      "printk",
      "Makefile"
    ],
    "skills": [
      "Header file creation",
      "File organization",
      "Module lifecycle",
      "Kernel logging",
      "Build system understanding"
    ],
    "files": [
      {
        "name": "hello.h",
        "content": "#ifndef HELLO_H\n#define HELLO_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n/* TODO: Add any shared constants or structures here */\n/* Note: Module init/exit functions are static and don't need declarations */\n\n#endif /* HELLO_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "hello.c",
        "content": "#include \"hello.h\"\n\n/* TODO: Implement your init function */\nstatic int __init hello_init(void)\n{\n    /* TODO: Print \"Hello from multi-file kernel module!\" */\n    return 0;\n}\n\n/* TODO: Implement your exit function */\nstatic void __exit hello_exit(void)\n{\n    /* TODO: Print \"Goodbye from multi-file kernel module!\" */\n}\n\n/* TODO: Set module init and exit functions */\nmodule_init(hello_init);\nmodule_exit(hello_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Multi-file Hello World kernel module\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Multi-file kernel module Makefile\nobj-m += hello.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "hello.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "hello_init",
          "hello_exit"
        ],
        "outputMessages": [
          "Hello from multi-file kernel module!",
          "Goodbye from multi-file kernel module!"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h"
        ],
        "mustContain": [
          "printk",
          "KERN_INFO"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "header_structure",
          "name": "Header File Structure",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "#ifndef HELLO_H",
            "#define HELLO_H",
            "#endif"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [],
          "prohibitedSymbols": [
            "static.*hello_init",
            "static.*hello_exit"
          ]
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "static int __init hello_init(void)",
            "static void __exit hello_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "multifile_functionality_test",
          "name": "Multi-File Module Functionality Test",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "multifile_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\\\"=== Multi-File Module Test ===\\\\n\\\");\\n    \\n    printf(\\\"Test: Loading multi-file hello module...\\\\n\\\");\\n    system(\\\"insmod /lib/modules/hello.ko\\\");\\n    \\n    printf(\\\"Test: Unloading multi-file hello module...\\\\n\\\");\\n    system(\\\"rmmod hello\\\");\\n    \\n    printf(\\\"SUCCESS: Multi-file module load/unload completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "testCommands": [
              "echo 'Testing multi-file kernel module functionality...'",
              "/bin/multifile_tester",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Checking for module information and functionality...'",
              "dmesg | grep 'Hello from multi-file kernel module' && echo 'PASS: init function with proper message' || echo 'FAIL: init function message missing'",
              "dmesg | grep 'Goodbye from multi-file kernel module' && echo 'PASS: exit function with proper message' || echo 'FAIL: exit function message missing'",
              "echo 'PASS: All multi-file functionality tests completed'"
            ],
            "expected": {
              "dmesg": [
                "Hello from multi-file kernel module!",
                "Goodbye from multi-file kernel module!"
              ],
              "stdout": [
                "Multi-File Module Test",
                "SUCCESS: Multi-file module load/unload completed",
                "PASS: All multi-file functionality tests completed"
              ]
            },
            "timeout": 10
          }
        },
        {
          "id": "exact_output",
          "name": "Function-Linked Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Hello from multi-file kernel module!",
              "exact": true,
              "linkedFunction": "static int __init hello_init(void)"
            },
            {
              "pattern": "Goodbye from multi-file kernel module!",
              "exact": true,
              "linkedFunction": "static void __exit hello_exit(void)"
            }
          ]
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Hello from multi-file kernel module!",
        "Goodbye from multi-file kernel module!"
      ],
      "requirements": [
        "Use required function names: hello_init, hello_exit",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h",
        "Code must contain: printk, KERN_INFO",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Hello from multi-file kernel module!",
          "linkedFunction": "static int __init hello_init(void)",
          "exact": true
        },
        {
          "pattern": "Goodbye from multi-file kernel module!",
          "linkedFunction": "static void __exit hello_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 3,
    "title": "Create Your First Variable",
    "difficulty": 1,
    "xp": 15,
    "phase": "foundations",
    "description": "Learn to create variables in kernel modules using proper file structure. You'll work with separate header and C files - a fundamental practice in professional kernel development that builds good coding habits from day one.",
    "concepts": [
      "variable declaration",
      "variable definition",
      "header files",
      "extern keyword",
      "file structure"
    ],
    "skills": [
      "Proper file organization",
      "Header/C file separation",
      "Variable management",
      "Professional coding habits"
    ],
    "files": [
      {
        "name": "variables.h",
        "content": "#ifndef VARIABLES_H\n#define VARIABLES_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n/* TODO: Declare your variable here */\n/* extern int my_number; */\n\n#endif /* VARIABLES_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "variables.c",
        "content": "#include \"variables.h\"\n\n/* TODO: Define your variable here with value 42 */\n/* int my_number = 42; */\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your variable is declared correctly.\n * Removing them will cause test failures.\n */\nmodule_param(my_number, int, 0644);\nMODULE_PARM_DESC(my_number, \"Variable for testing proper declaration\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\nstatic int __init variables_init(void)\n{\n    printk(KERN_INFO \"Variables module loaded\\n\");\n    /* TODO: Print the variable value to show it exists */\n    /* printk(KERN_INFO \"Variable value: %d\\n\", my_number); */\n    return 0;\n}\n\nstatic void __exit variables_exit(void)\n{\n    printk(KERN_INFO \"Variables module unloaded\\n\");\n}\n\nmodule_init(variables_init);\nmodule_exit(variables_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning variables with proper file structure\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Variables module Makefile\nobj-m += variables.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "variables.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "variables_init",
          "variables_exit"
        ],
        "variables_declarations": [
          {
            "name": "my_number",
            "type": "int",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "my_number",
            "type": "int",
            "value": 42,
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Variables module loaded"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h"
        ],
        "mustContain": [
          "#ifndef VARIABLES_H",
          "#define VARIABLES_H",
          "extern int my_number",
          "int my_number = 42",
          "#include \"variables.h\""
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "header_guards",
          "name": "Proper Header Guards",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "#ifndef VARIABLES_H",
            "#define VARIABLES_H",
            "#endif"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "variable_declaration",
          "name": "Variable Declaration in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "extern int my_number"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "variable_definition",
          "name": "Variable Definition in C File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int my_number = 42"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "static int __init variables_init(void)",
            "static void __exit variables_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "variable_functionality_test",
          "name": "Variable Declaration and Definition Test",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "variable_param_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Variable Parameter Validation Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random test values\\n    int test_val1 = (rand() % 50) + 10;  // 10-59\\n    int test_val2 = (rand() % 50) + 60;  // 60-109\\n    \\n    printf(\\\"Test 1: Loading with my_number=%d\\\\n\\\", test_val1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/variables.ko my_number=%d\\\", test_val1);\\n    system(\\\"rmmod variables 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Loading with my_number=%d\\\\n\\\", test_val2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/variables.ko my_number=%d\\\", test_val2);\\n    system(\\\"rmmod variables\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Variable parameter test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo 'Creating test file that validates extern variable declaration...'",
              "echo '#include \"/lib/modules/variables.h\"' > /tmp/test.c",
              "echo 'int main() { my_number = 42; return my_number; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: extern int my_number not properly declared in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: extern int my_number found in header file'",
              "echo 'Phase 2: Dynamic Parameter Testing'",
              "/bin/variable_param_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Phase 2.1: Variable parameter extraction...'",
              "TEST_VAL1=$(grep -o 'Test 1: Loading with my_number=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
              "TEST_VAL2=$(grep -o 'Test 2: Loading with my_number=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
              "echo 'Test value 1: '$TEST_VAL1",
              "echo 'Test value 2: '$TEST_VAL2",
              "echo 'Phase 2.2: Module parameter validation...'",
              "dmesg | grep 'Variables module loaded' && echo 'PASS: Module loads with parameter' || echo 'FAIL: Module loading failed'",
              "echo 'Phase 3: Default value validation (must be 42)...'",
              "rmmod variables 2>/dev/null",
              "insmod /lib/modules/variables.ko",
              "sleep 1",
              "DEFAULT_VALUE=$(cat /sys/module/variables/parameters/my_number 2>/dev/null || echo 'ERROR')",
              "echo 'Default value from parameter: '$DEFAULT_VALUE",
              "if [ \"$DEFAULT_VALUE\" = \"42\" ]; then",
              "    echo 'PASS: Variable initialized to 42 correctly'",
              "else",
              "    echo 'FAIL: Variable not initialized to 42 (got: '$DEFAULT_VALUE')'",
              "fi",
              "echo 'Phase 4: Value reassignment test (ensuring variable is mutable)...'",
              "echo 99 > /sys/module/variables/parameters/my_number 2>/dev/null",
              "NEW_VALUE=$(cat /sys/module/variables/parameters/my_number 2>/dev/null || echo 'ERROR')",
              "echo 'Value after reassignment: '$NEW_VALUE",
              "if [ \"$NEW_VALUE\" = \"99\" ]; then",
              "    echo 'PASS: Variable is mutable and reassignable'",
              "else",
              "    echo 'FAIL: Variable is not properly mutable (expected 99, got: '$NEW_VALUE')'",
              "fi",
              "echo 'Phase 5: Parameter accessibility validation...'",
              "ls /sys/module/variables/parameters/my_number >/dev/null 2>&1 && echo 'PASS: Variable exposed as module parameter' || echo 'FAIL: Variable not declared as module parameter'",
              "echo 'PASS: All variable validation tests completed'"
            ],
            "expected": {
              "dmesg": [
                "Variables module loaded",
                "Variables module unloaded"
              ],
              "stdout": [
                "PASS: extern int my_number found in header file",
                "Variable Parameter Validation Test",
                "SUCCESS: Variable parameter test completed",
                "PASS: Variable initialized to 42 correctly",
                "PASS: Variable is mutable and reassignable",
                "PASS: All variable validation tests completed"
              ]
            },
            "timeout": 10
          }
        },
        {
          "id": "exact_output",
          "name": "Exact Output Message",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Variables module loaded",
              "exact": true,
              "linkedFunction": "static int __init variables_init(void)"
            }
          ]
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Variables module loaded"
      ],
      "requirements": [
        "Use required function names: variables_init, variables_exit",
        "Use required variable names: my_number",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h",
        "Code must contain: #ifndef VARIABLES_H, #define VARIABLES_H, extern int my_number, int my_number = 42, #include \"variables.h\"",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Variables module loaded",
          "linkedFunction": "static int __init variables_init(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 4,
    "title": "Use Your Variable",
    "difficulty": 2,
    "xp": 20,
    "phase": "foundations",
    "description": "Learn to use variables by printing them with proper format specifiers. Build on your knowledge of header/C file structure while introducing printk formatting - a crucial skill for kernel debugging.",
    "concepts": [
      "variable usage",
      "printk formatting",
      "format specifiers",
      "integer printing",
      "debugging output"
    ],
    "skills": [
      "Using variables in printk",
      "printk with format specifiers",
      "Variable access in kernel modules",
      "Debugging output"
    ],
    "files": [
      {
        "name": "use_vars.h",
        "content": "#ifndef USE_VARS_H\n#define USE_VARS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nextern int my_number;\n\n#endif /* USE_VARS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "use_vars.c",
        "content": "#include \"use_vars.h\"\n\nint my_number = 42;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your variable usage works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(my_number, int, 0644);\nMODULE_PARM_DESC(my_number, \"Number to print for testing variable usage\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\nstatic int __init use_vars_init(void)\n{\n    printk(KERN_INFO \"Variable usage module loaded\\n\");\n    /* TODO: Print the variable using printk */\n    /* printk(KERN_INFO \"My number is: %d\\n\", my_number); */\n    return 0;\n}\n\nstatic void __exit use_vars_exit(void)\n{\n    printk(KERN_INFO \"Variable usage module unloaded\\n\");\n}\n\nmodule_init(use_vars_init);\nmodule_exit(use_vars_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning to use variables with printk formatting\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Variable usage module Makefile\nobj-m += use_vars.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "use_vars.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "use_vars_init",
          "use_vars_exit"
        ],
        "variables_declarations": [
          {
            "name": "my_number",
            "type": "int",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "my_number",
            "type": "int",
            "value": 42,
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Variable usage module loaded",
          "My number is: 42"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h"
        ],
        "mustContain": [
          "printk(KERN_INFO \"My number is: %d\\n\", my_number)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "static int __init use_vars_init(void)",
            "static void __exit use_vars_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "variable_usage_test",
          "name": "Variable Usage and Formatting Test",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "variable_usage_dynamic_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Variable Usage Dynamic Validation Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random test values\\n    int test_val1 = (rand() % 50) + 10;  // 10-59\\n    int test_val2 = (rand() % 50) + 60;  // 60-109\\n    int test_val3 = (rand() % 20) + 1;   // 1-20\\n    \\n    printf(\\\"Test 1: Testing with my_number=%d\\\\n\\\", test_val1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/use_vars.ko my_number=%d\\\", test_val1);\\n    system(\\\"rmmod use_vars 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Testing with my_number=%d\\\\n\\\", test_val2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/use_vars.ko my_number=%d\\\", test_val2);\\n    system(\\\"rmmod use_vars\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"Test 3: Testing with my_number=%d\\\\n\\\", test_val3);\\n    char cmd3[256];\\n    snprintf(cmd3, sizeof(cmd3), \\\"insmod /lib/modules/use_vars.ko my_number=%d\\\", test_val3);\\n    system(\\\"rmmod use_vars\\\");\\n    system(cmd3);\\n    \\n    printf(\\\"SUCCESS: Variable usage dynamic test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo 'Creating test file that validates extern variable declaration...'",
              "echo '#include \"/lib/modules/use_vars.h\"' > /tmp/test.c",
              "echo 'int main() { my_number = 99; return my_number; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: extern int my_number not properly declared in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: extern int my_number found in header file'",
              "echo 'Phase 2: Dynamic Variable Usage Testing'",
              "/bin/variable_usage_dynamic_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Phase 2.1: Dynamic test value extraction...'",
              "TEST_VAL1=$(grep -o 'Test 1: Testing with my_number=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
              "TEST_VAL2=$(grep -o 'Test 2: Testing with my_number=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
              "TEST_VAL3=$(grep -o 'Test 3: Testing with my_number=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
              "echo 'Test values: '$TEST_VAL1', '$TEST_VAL2', '$TEST_VAL3",
              "echo 'Phase 2.2: Basic module functionality check...'",
              "dmesg | grep 'Variable usage module loaded' && echo 'PASS: use_vars_init function working' || echo 'FAIL: use_vars_init function missing'",
              "echo 'Phase 3: Dynamic variable usage validation...'",
              "dmesg | grep \"My number is: $TEST_VAL1\" && echo \"PASS: Variable correctly prints value $TEST_VAL1\" || echo \"FAIL: Variable not used or wrong value (expected $TEST_VAL1)\"",
              "dmesg | grep \"My number is: $TEST_VAL2\" && echo \"PASS: Variable correctly prints value $TEST_VAL2\" || echo \"FAIL: Variable not used or wrong value (expected $TEST_VAL2)\"",
              "dmesg | grep \"My number is: $TEST_VAL3\" && echo \"PASS: Variable correctly prints value $TEST_VAL3\" || echo \"FAIL: Variable not used or wrong value (expected $TEST_VAL3)\"",
              "echo 'Phase 4: Default value validation (must be 42)...'",
              "rmmod use_vars 2>/dev/null",
              "insmod /lib/modules/use_vars.ko",
              "sleep 1",
              "dmesg | grep 'My number is: 42' && echo 'PASS: Default value 42 correctly displayed' || echo 'FAIL: Default value not 42 or not printed'",
              "echo 'Phase 5: Module unload check...'",
              "dmesg | grep 'Variable usage module unloaded' && echo 'PASS: use_vars_exit function working' || echo 'FAIL: use_vars_exit function missing'",
              "echo 'PASS: All variable usage dynamic validation tests completed'"
            ],
            "expected": {
              "dmesg": [
                "Variable usage module loaded",
                "My number is: .*",
                "Variable usage module unloaded"
              ],
              "stdout": [
                "PASS: extern int my_number found in header file",
                "Variable Usage Dynamic Validation Test",
                "SUCCESS: Variable usage dynamic test completed",
                "PASS: Default value 42 correctly displayed",
                "PASS: All variable usage dynamic validation tests completed"
              ]
            },
            "timeout": 10
          }
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Variable usage module loaded",
              "exact": true,
              "linkedFunction": "static int __init use_vars_init(void)"
            },
            {
              "pattern": "My number is: 42",
              "exact": true,
              "linkedFunction": "static int __init use_vars_init(void)"
            }
          ]
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Variable usage module loaded",
        "My number is: 42"
      ],
      "requirements": [
        "Use required function names: use_vars_init, use_vars_exit",
        "Use required variable names: my_number",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h",
        "Code must contain: printk(KERN_INFO \"My number is: %d\\n\", my_number)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Variable usage module loaded",
          "linkedFunction": "static int __init use_vars_init(void)",
          "exact": true
        },
        {
          "pattern": "My number is: 42",
          "linkedFunction": "static int __init use_vars_init(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 5,
    "title": "Multiple Variables - Study Complete Example",
    "difficulty": 2,
    "xp": 25,
    "phase": "foundations",
    "description": "Study a complete working example with multiple data types. See how int, char, and bool variables work together with proper format specifiers. This example includes advanced module parameter support that will be used in later problems.",
    "concepts": [
      "multiple data types",
      "integer variables",
      "character variables",
      "boolean variables",
      "format specifiers for different types"
    ],
    "skills": [
      "Managing multiple variables",
      "Understanding data type differences",
      "Using appropriate format specifiers",
      "Code organization with multiple variables"
    ],
    "files": [
      {
        "name": "multi_vars.h",
        "content": "#ifndef MULTI_VARS_H\n#define MULTI_VARS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* Function to print student information */\nvoid print_student_info(void);\n\n#endif /* MULTI_VARS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "multi_vars.c",
        "content": "#include \"multi_vars.h\"\n\n/* Complete working example\n * Study how these three different data types work together\n * Notice the different format specifiers for each type\n */\n\n/* Variable definitions with different data types */\nint student_id = 12345;      // Integer variable\nchar student_grade = 'A';    // Character variable  \nbool student_passed = true;  // Boolean variable\n\n/* Module parameters for advanced testing */\nmodule_param(student_id, int, 0644);\nMODULE_PARM_DESC(student_id, \"Student ID number\");\n/* Note: char and bool parameters need special handling */\n\n/* Complete function implementation - study the pattern */\nvoid print_student_info(void)\n{\n    printk(KERN_INFO \"=== Student Information ===\\n\");\n    printk(KERN_INFO \"Student ID: %d\\n\", student_id);        // %d for int\n    printk(KERN_INFO \"Student Grade: %c\\n\", student_grade);   // %c for char\n    printk(KERN_INFO \"Student Passed: %d\\n\", student_passed); // %d for bool (shows 0/1)\n}\n\nstatic int __init multi_vars_init(void)\n{\n    printk(KERN_INFO \"Multi-variable module loaded\\n\");\n    print_student_info();\n    return 0;\n}\n\nstatic void __exit multi_vars_exit(void)\n{\n    printk(KERN_INFO \"Multi-variable module unloaded\\n\");\n}\n\nmodule_init(multi_vars_init);\nmodule_exit(multi_vars_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Complete example: multiple variables and data types\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Multi-variable module Makefile\nobj-m += multi_vars.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "multi_vars.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "multi_vars_init",
          "multi_vars_exit",
          "print_student_info"
        ],
        "variables": [
          {
            "name": "student_id",
            "type": "int",
            "value": 12345
          },
          {
            "name": "student_grade",
            "type": "char",
            "value": "'A'"
          },
          {
            "name": "student_passed",
            "type": "bool",
            "value": true
          }
        ],
        "outputMessages": [
          "Multi-variable module loaded",
          "Student ID: 12345",
          "Student Grade: A",
          "Student Passed: 1"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "int student_id = 12345",
          "char student_grade = 'A'",
          "bool student_passed = true",
          "void print_student_info(void)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "multiple_definitions",
          "name": "Multiple Variable Definitions",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int student_id = 12345",
            "char student_grade = 'A'",
            "bool student_passed = true"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_structure",
          "name": "Print Function Implementation",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_student_info(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_student_info(void)",
            "static int __init multi_vars_init(void)",
            "static void __exit multi_vars_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_student_info(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Basic Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Multi-variable module loaded",
              "exact": true,
              "linkedFunction": "static int __init multi_vars_init(void)"
            },
            {
              "pattern": "Student Information",
              "exact": true,
              "linkedFunction": "void print_student_info(void)"
            },
            {
              "pattern": "Student ID: 12345",
              "exact": true,
              "linkedFunction": "void print_student_info(void)"
            },
            {
              "pattern": "Student Grade: A",
              "exact": true,
              "linkedFunction": "void print_student_info(void)"
            },
            {
              "pattern": "Student Passed: 1",
              "exact": true,
              "linkedFunction": "void print_student_info(void)"
            }
          ]
        },
        {
          "id": "demonstration_test",
          "name": "Study Example with Dynamic Testing",
          "type": "kernel_project_test",
          "critical": false,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "demo_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\"=== Part A Demo Test ===\\\\n\");\\n    printf(\"Demonstrating dynamic module parameters\\\\n\");\\n    \\n    printf(\"Test: Loading with student_id=99999\\\\n\");\\n    system(\"rmmod multi_vars 2>/dev/null\");\\n    system(\"insmod /lib/modules/multi_vars.ko student_id=99999\");\\n    \\n    printf(\"SUCCESS: Demo completed\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Demonstrating module parameter functionality'"
            ],
            "testCommands": [
              "/bin/demo_tester",
              "echo 'Check: Module parameter works'",
              "dmesg | grep 'Student ID: 99999' && echo 'DEMO: Parameter worked!' || echo 'INFO: Using default value'"
            ],
            "expected": {
              "dmesg": [
                "Multi-variable module loaded"
              ],
              "stdout": [
                "Part A Demo Test",
                "SUCCESS: Demo completed"
              ]
            },
            "timeout": 30
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Multi-variable module loaded",
        "Student ID: 12345",
        "Student Grade: A",
        "Student Passed: 1"
      ],
      "requirements": [
        "Use required function names: multi_vars_init, multi_vars_exit, print_student_info",
        "Use required variable names: student_id, student_grade, student_passed",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: int student_id = 12345, char student_grade = 'A', bool student_passed = true, void print_student_info(void)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Multi-variable module loaded",
          "linkedFunction": "static int __init multi_vars_init(void)",
          "exact": true
        },
        {
          "pattern": "Student Information",
          "linkedFunction": "void print_student_info(void)",
          "exact": true
        },
        {
          "pattern": "Student ID: 12345",
          "linkedFunction": "void print_student_info(void)",
          "exact": true
        },
        {
          "pattern": "Student Grade: A",
          "linkedFunction": "void print_student_info(void)",
          "exact": true
        },
        {
          "pattern": "Student Passed: 1",
          "linkedFunction": "void print_student_info(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 6,
    "title": "Multiple Variables - Guided Practice",
    "difficulty": 3,
    "xp": 35,
    "phase": "foundations",
    "description": "Build on Problem 4 by completing a partially implemented solution. Fill in strategic gaps while working with module parameters for dynamic testing. This bridges complete examples to independent creation.",
    "concepts": [
      "guided practice",
      "multiple data types",
      "format specifier completion",
      "variable initialization",
      "pattern application"
    ],
    "skills": [
      "Completing partial implementations",
      "Applying learned patterns",
      "Working with three data types",
      "Format specifier selection",
      "Code completion skills"
    ],
    "files": [
      {
        "name": "practice_vars.h",
        "content": "#ifndef PRACTICE_VARS_H\n#define PRACTICE_VARS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* Function to complete */\nvoid print_employee_info(void);\n\n#endif /* PRACTICE_VARS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "practice_vars.c",
        "content": "#include \"practice_vars.h\"\n\n/* Complete the strategic gaps below\n * Build on what you learned from Problem 4's complete example\n * This time YOU fill in the missing pieces!\n */\n\n/* TODO: Complete the variable definitions with these values:\n * employee_id = 67890\n * performance_grade = 'A'\n * is_promoted = true\n */\nint employee_id = _____;\nchar performance_grade = _____;\nbool is_promoted = _____;\n\n/* Module parameters for dynamic testing - DO NOT REMOVE! */\nmodule_param(employee_id, int, 0644);\nMODULE_PARM_DESC(employee_id, \"Employee ID for testing\");\n/* char and bool parameters handled separately */\n\nvoid print_employee_info(void)\n{\n    printk(KERN_INFO \"=== Employee Information ===\\n\");\n    \n    /* TODO: Complete these printk statements with correct format specifiers */\n    /* Hint: Use %d for int, %c for char, %d for bool */\n    printk(KERN_INFO \"Employee ID: %___, _____);    // Fill in format and variable\n    printk(KERN_INFO \"Grade: %___, _____);          // Fill in format and variable  \n    printk(KERN_INFO \"Promoted: %___, _____);       // Fill in format and variable\n}\n\nstatic int __init practice_vars_init(void)\n{\n    printk(KERN_INFO \"Practice variables module loaded\\n\");\n    print_employee_info();\n    return 0;\n}\n\nstatic void __exit practice_vars_exit(void)\n{\n    printk(KERN_INFO \"Practice variables module unloaded\\n\");\n}\n\nmodule_init(practice_vars_init);\nmodule_exit(practice_vars_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Guided practice with multiple variables and dynamic testing\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Practice variables module Makefile\nobj-m += practice_vars.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "practice_vars.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "practice_vars_init",
          "practice_vars_exit",
          "print_employee_info"
        ],
        "variables": [
          {
            "name": "employee_id",
            "type": "int",
            "value": 67890
          },
          {
            "name": "performance_grade",
            "type": "char",
            "value": "'A'"
          },
          {
            "name": "is_promoted",
            "type": "bool",
            "value": true
          }
        ],
        "outputMessages": [
          "Practice variables module loaded",
          "Employee Information",
          "Employee ID: 67890",
          "Grade: A",
          "Promoted: 1"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "int employee_id = 67890",
          "char performance_grade = 'A'",
          "bool is_promoted = true",
          "void print_employee_info(void)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "variable_completion",
          "name": "Variable Value Completion",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int employee_id = 67890",
            "char performance_grade = 'A'",
            "bool is_promoted = true"
          ],
          "prohibitedSymbols": [
            "_____"
          ]
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_employee_info(void)",
            "static int __init practice_vars_init(void)",
            "static void __exit practice_vars_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_employee_info(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Function-Linked Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Practice variables module loaded",
              "exact": true,
              "linkedFunction": "static int __init practice_vars_init(void)"
            },
            {
              "pattern": "Employee Information",
              "exact": true,
              "linkedFunction": "void print_employee_info(void)"
            },
            {
              "pattern": "Employee ID: 67890",
              "exact": true,
              "linkedFunction": "void print_employee_info(void)"
            },
            {
              "pattern": "Grade: A",
              "exact": true,
              "linkedFunction": "void print_employee_info(void)"
            },
            {
              "pattern": "Promoted: 1",
              "exact": true,
              "linkedFunction": "void print_employee_info(void)"
            }
          ]
        },
        {
          "id": "guided_dynamic_testing",
          "name": "Guided Dynamic Testing",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "practice_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\"=== Part B Practice Test ===\\\\n\");\\n    printf(\"Testing guided completion with dynamic values\\\\n\");\\n    \\n    printf(\"Test: Loading with employee_id=88888\\\\n\");\\n    system(\"rmmod practice_vars 2>/dev/null\");\\n    system(\"insmod /lib/modules/practice_vars.ko employee_id=88888\");\\n    \\n    printf(\"SUCCESS: Practice test completed\\\\n\");\\n    printf(\"PASS: Variable completion works\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting guided practice testing'"
            ],
            "testCommands": [
              "/bin/practice_tester",
              "echo 'Checking dynamic value'",
              "dmesg | grep 'Employee ID: 88888' && echo 'PASS: Dynamic employee_id worked' || echo 'FAIL: Must use variables, not hardcoded values'"
            ],
            "expected": {
              "dmesg": [
                "Practice variables module loaded",
                "Employee ID: 88888"
              ],
              "stdout": [
                "Part B Practice Test",
                "SUCCESS: Practice test completed",
                "PASS: Variable completion works"
              ]
            },
            "timeout": 30
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Practice variables module loaded",
        "Employee Information",
        "Employee ID: 67890",
        "Grade: A",
        "Promoted: 1"
      ],
      "requirements": [
        "Use required function names: practice_vars_init, practice_vars_exit, print_employee_info",
        "Use required variable names: employee_id, performance_grade, is_promoted",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: int employee_id = 67890, char performance_grade = 'A', bool is_promoted = true, void print_employee_info(void)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Practice variables module loaded",
          "linkedFunction": "static int __init practice_vars_init(void)",
          "exact": true
        },
        {
          "pattern": "Employee Information",
          "linkedFunction": "void print_employee_info(void)",
          "exact": true
        },
        {
          "pattern": "Employee ID: 67890",
          "linkedFunction": "void print_employee_info(void)",
          "exact": true
        },
        {
          "pattern": "Grade: A",
          "linkedFunction": "void print_employee_info(void)",
          "exact": true
        },
        {
          "pattern": "Promoted: 1",
          "linkedFunction": "void print_employee_info(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 7,
    "title": "Multiple Variables - Advanced Dynamic Testing",
    "difficulty": 4,
    "xp": 45,
    "phase": "foundations",
    "description": "Master advanced variable usage with dynamic testing! Create a complete solution that works with changing values - the system will test your code with different inputs to ensure you're using variables correctly, not hardcoding values.",
    "concepts": [
      "independent creation",
      "four data types",
      "complete implementation",
      "format specifier mastery",
      "creative problem solving"
    ],
    "skills": [
      "Writing code from requirements",
      "Managing four different data types",
      "Creating complete solutions",
      "Independent problem solving",
      "Applying learned patterns creatively"
    ],
    "files": [
      {
        "name": "create_vars.h",
        "content": "#ifndef CREATE_VARS_H\n#define CREATE_VARS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* TODO: Declare your function */\n/* void print_server_status(void); */\n\n#endif /* CREATE_VARS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "create_vars.c",
        "content": "#include \"create_vars.h\"\n\n/* CHALLENGE: Advanced Variable Creation with Dynamic Testing!\n * \n * REQUIREMENTS:\n * Create 4 variables with these default values:\n * - server_id = 1001 (int)\n * - status_code = 'R' for Ready (char)  \n * - temperature = 68 (int)\n * - online = true (bool)\n * \n * Print them in this exact format:\n * \"Server %d: Status %c, Temp %d, Online: %d\"\n * \n * CRITICAL WARNING: The testing system will change values dynamically!\n * You MUST use actual variables, not hardcoded values, or you will fail!\n */\n\n/* TODO: Define all 4 variables with the specified default values */\n\n\n\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your variables work with different values.\n * Removing them will cause test failures.\n */\nmodule_param(server_id, int, 0644);\nMODULE_PARM_DESC(server_id, \"Server ID for testing\");\nmodule_param(temperature, int, 0644);\nMODULE_PARM_DESC(temperature, \"Temperature value for testing\");\n/* Note: char and bool module params need special handling, so we only test int params */\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* TODO: Implement print_server_status function */\n/* Use appropriate format specifiers: %d for int, %c for char, %d for bool */\n/* WARNING: Use actual variables! The system tests with different values! */\nvoid print_server_status(void)\n{\n    /* TODO: Print the server information using the variables above */\n    \n    \n}\n\nstatic int __init create_vars_init(void)\n{\n    printk(KERN_INFO \"Variable creation module loaded\\n\");\n    print_server_status();\n    return 0;\n}\n\nstatic void __exit create_vars_exit(void)\n{\n    printk(KERN_INFO \"Variable creation module unloaded\\n\");\n}\n\nmodule_init(create_vars_init);\nmodule_exit(create_vars_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Advanced variable creation with dynamic testing\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Variable creation module Makefile\nobj-m += create_vars.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "create_vars.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "create_vars_init",
          "create_vars_exit",
          "print_server_status"
        ],
        "variables": [
          {
            "name": "server_id",
            "type": "int",
            "value": 1001
          },
          {
            "name": "status_code",
            "type": "char",
            "value": "'R'"
          },
          {
            "name": "temperature",
            "type": "int",
            "value": 68
          },
          {
            "name": "online",
            "type": "bool",
            "value": true
          }
        ],
        "outputMessages": [
          "Variable creation module loaded",
          "Server 1001: Status R, Temp 68, Online: 1"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "int server_id = 1001",
          "char status_code = 'R'",
          "int temperature = 68",
          "bool online = true",
          "void print_server_status(void)",
          "module_param(server_id, int, 0644)",
          "module_param(temperature, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "variable_definitions",
          "name": "Variable Definitions in Source",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int server_id = 1001",
            "char status_code = 'R'",
            "int temperature = 68",
            "bool online = true"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "module_parameters",
          "name": "Module Parameter Infrastructure",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "module_param(server_id, int, 0644)",
            "module_param(temperature, int, 0644)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_server_status(void)",
            "static int __init create_vars_init(void)",
            "static void __exit create_vars_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_server_status(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Basic Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Variable creation module loaded",
              "exact": true,
              "linkedFunction": "static int __init create_vars_init(void)"
            },
            {
              "pattern": "Server 1001: Status R, Temp 68, Online: 1",
              "exact": true,
              "linkedFunction": "void print_server_status(void)"
            }
          ]
        },
        {
          "id": "dynamic_variable_testing",
          "name": "Dynamic Variable Testing",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "variable_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\"=== Dynamic Variable Test ===\\\\n\");\\n    \\n    printf(\"Test 1: Testing server_id=2001, temperature=85\\\\n\");\\n    system(\"rmmod create_vars 2>/dev/null\");\\n    system(\"insmod /lib/modules/create_vars.ko server_id=2001 temperature=85\");\\n    \\n    printf(\"Test 2: Testing server_id=3001, temperature=92\\\\n\");\\n    system(\"rmmod create_vars\");\\n    system(\"insmod /lib/modules/create_vars.ko server_id=3001 temperature=92\");\\n    \\n    printf(\"SUCCESS: Dynamic test completed\\\\n\");\\n    printf(\"PASS: Variable usage detected\\\\n\");\\n    printf(\"PASS: Module parameters work\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting dynamic variable testing'"
            ],
            "testCommands": [
              "/bin/variable_tester",
              "echo 'Checking kernel output for dynamic values'",
              "dmesg | grep 'Server 2001' && echo 'PASS: 2001 test worked' || echo 'FAIL: 2001 test failed'",
              "dmesg | grep 'Temp 85' && echo 'PASS: 85 test worked' || echo 'FAIL: 85 test failed'",
              "dmesg | grep 'Server 3001' && echo 'PASS: 3001 test worked' || echo 'FAIL: 3001 test failed'",
              "dmesg | grep 'Temp 92' && echo 'PASS: 92 test worked' || echo 'FAIL: 92 test failed'"
            ],
            "expected": {
              "dmesg": [
                "Variable creation module loaded",
                "Server 2001: Status R, Temp 85, Online: 1",
                "Server 3001: Status R, Temp 92, Online: 1"
              ],
              "stdout": [
                "Dynamic Variable Test",
                "SUCCESS: Dynamic test completed",
                "PASS: Variable usage detected",
                "PASS: Module parameters work"
              ]
            },
            "timeout": 45
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Variable creation module loaded",
        "Server 1001: Status R, Temp 68, Online: 1"
      ],
      "requirements": [
        "Use required function names: create_vars_init, create_vars_exit, print_server_status",
        "Use required variable names: server_id, status_code, temperature, online",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: int server_id = 1001, char status_code = 'R', int temperature = 68, bool online = true, void print_server_status(void), module_param(server_id, int, 0644), module_param(temperature, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Variable creation module loaded",
          "linkedFunction": "static int __init create_vars_init(void)",
          "exact": true
        },
        {
          "pattern": "Server 1001: Status R, Temp 68, Online: 1",
          "linkedFunction": "void print_server_status(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 8,
    "title": "Function Parameters - Advanced Dynamic Testing",
    "difficulty": 4,
    "xp": 40,
    "phase": "foundations",
    "description": "Master function parameters and return values with dynamic testing! Create functions that work with changing input values - the system will test your functions with different parameters to ensure they work correctly, not just with hardcoded values.",
    "concepts": [
      "function parameters",
      "return values",
      "function calls with arguments",
      "local variables",
      "modulo operator",
      "boolean logic"
    ],
    "skills": [
      "Writing functions with parameters",
      "Understanding return values",
      "Function composition",
      "Mathematical operations in kernel space",
      "Boolean operations and logic"
    ],
    "files": [
      {
        "name": "functions.h",
        "content": "#ifndef FUNCTIONS_H\n#define FUNCTIONS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* TODO: Declare functions with parameters */\n/* int add_numbers(int a, int b); */\n/* void print_calculation(int num1, int num2, int result); */\n/* bool is_even(int number); */\n\n/* Variables for dynamic testing */\nextern int first;\nextern int second;\n\n#endif /* FUNCTIONS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "functions.c",
        "content": "#include \"functions.h\"\n\n/* CHALLENGE: Advanced Function Parameters with Dynamic Testing!\n *\n * REQUIREMENTS:\n * Create these functions:\n * - add_numbers(int a, int b) -> returns a + b\n * - print_calculation(int num1, int num2, int result) -> prints \"num1 + num2 = result\"\n * - is_even(int number) -> returns true if number is even, false if odd\n *\n * CRITICAL WARNING: The testing system will use different input values!\n * Your functions must work with ANY inputs, not just the defaults below.\n */\n\n/* Variables for dynamic testing */\nint first = 15;\nint second = 25;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your functions work with different inputs.\n * Removing them will cause test failures.\n */\nmodule_param(first, int, 0644);\nMODULE_PARM_DESC(first, \"First number for testing\");\nmodule_param(second, int, 0644);\nMODULE_PARM_DESC(second, \"Second number for testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* TODO: Implement add_numbers function */\n/* Return the sum of a and b */\n\n\n/* TODO: Implement print_calculation function */  \n/* Print in format: \"num1 + num2 = result\" */\n\n\n/* TODO: Implement is_even function */\n/* Return true if number is even, false if odd */\n/* Hint: Use modulo operator (%) */\n\n\nstatic int __init functions_init(void)\n{\n    int sum;\n    bool even_check;\n    \n    printk(KERN_INFO \"Function parameters module loaded\\n\");\n    \n    /* TODO: Call add_numbers and store result */\n    /* sum = add_numbers(first, second); */\n    \n    /* TODO: Call print_calculation to display result */\n    /* print_calculation(first, second, sum); */\n    \n    /* TODO: Check if sum is even and print result */\n    /* even_check = is_even(sum); */\n    /* printk(KERN_INFO \"Sum is even: %d\\n\", even_check); */\n    \n    return 0;\n}\n\nstatic void __exit functions_exit(void)\n{\n    printk(KERN_INFO \"Function parameters module unloaded\\n\");\n}\n\nmodule_init(functions_init);\nmodule_exit(functions_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Advanced function parameters with dynamic testing\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Functions module Makefile\nobj-m += functions.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "functions.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "functions_init",
          "functions_exit",
          "add_numbers",
          "print_calculation",
          "is_even"
        ],
        "variables": [
          {
            "name": "first",
            "type": "int",
            "value": 15
          },
          {
            "name": "second",
            "type": "int",
            "value": 25
          }
        ],
        "outputMessages": [
          "Function parameters module loaded",
          "15 + 25 = 40",
          "Sum is even: 1"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "int add_numbers(int a, int b)",
          "void print_calculation(int num1, int num2, int result)",
          "bool is_even(int number)",
          "return a + b",
          "number % 2 == 0",
          "add_numbers(first, second)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int add_numbers(int a, int b)",
            "void print_calculation(int num1, int num2, int result)",
            "bool is_even(int number)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_implementations",
          "name": "Function Implementations",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "return a + b",
            "return (number % 2 == 0)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_calls",
          "name": "Proper Function Calls",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "add_numbers(first, second)",
            "print_calculation(first, second, sum)",
            "is_even(sum)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "modulo_operator",
          "name": "Modulo Operator Usage",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "number % 2"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "return_values",
          "name": "Proper Return Value Usage",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "sum = add_numbers",
            "even_check = is_even"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int add_numbers(int a, int b)",
            "void print_calculation(int num1, int num2, int result)",
            "bool is_even(int number)",
            "static int __init functions_init(void)",
            "static void __exit functions_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Basic Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Function parameters module loaded",
              "exact": true,
              "linkedFunction": "static int __init functions_init(void)"
            },
            {
              "pattern": "15 + 25 = 40",
              "exact": true,
              "linkedFunction": "void print_calculation(int num1, int num2, int result)"
            },
            {
              "pattern": "Sum is even: 1",
              "exact": true,
              "linkedFunction": "static int __init functions_init(void)"
            }
          ]
        },
        {
          "id": "advanced_function_testing",
          "name": "Advanced Function Parameter Testing",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "function_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\"=== Dynamic Function Test ===\\\\n\");\\n    printf(\"Test 1: Testing first=10, second=30 (sum=40, even)\\\\n\");\\n    system(\"rmmod functions 2>/dev/null\");\\n    system(\"insmod /lib/modules/functions.ko first=10 second=30\");\\n    printf(\"Test 2: Testing first=7, second=8 (sum=15, odd)\\\\n\");\\n    system(\"rmmod functions\");\\n    system(\"insmod /lib/modules/functions.ko first=7 second=8\");\\n    printf(\"SUCCESS: Dynamic test completed\\\\n\");\\n    printf(\"PASS: Function parameters detected\\\\n\");\\n    printf(\"PASS: Module parameters work\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting comprehensive validation'",
              "cp /lib/modules/functions.h /lib/modules/ 2>/dev/null"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo 'Creating test file that includes student header...'",
              "echo '#include \"/lib/modules/functions.h\"' > /tmp/test.c",
              "echo 'int main() { add_numbers(1,2); print_calculation(1,2,3); is_even(4); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declarations missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: All function declarations found in header file'",
              "echo 'Phase 2: Dynamic Parameter Testing'",
              "echo 'Marking start of dynamic tests for validation...'",
              "echo 'DYNAMIC_TEST_START' > /tmp/test_marker",
              "/bin/function_tester",
              "echo 'Phase 3: Context-Aware Logic Validation'",
              "echo 'Validating Test 1: first=10, second=30 (sum=40, should be even)'",
              "dmesg | grep '10 + 30 = 40' && echo 'PASS: add_numbers(10,30) calculation correct' || { echo 'FAIL: add_numbers(10,30) calculation wrong or missing'; exit 1; }",
              "dmesg | grep -A1 '10 + 30 = 40' | grep 'Sum is even: 1' && echo 'PASS: is_even(40) correctly identifies even number' || { echo 'FAIL: is_even(40) wrong - should return 1 for even number 40'; exit 1; }",
              "echo 'Validating Test 2: first=7, second=8 (sum=15, should be odd)'",
              "dmesg | grep '7 + 8 = 15' && echo 'PASS: add_numbers(7,8) calculation correct' || { echo 'FAIL: add_numbers(7,8) calculation wrong or missing'; exit 1; }",
              "dmesg | grep -A1 '7 + 8 = 15' | grep 'Sum is even: 0' && echo 'PASS: is_even(15) correctly identifies odd number' || { echo 'FAIL: is_even(15) wrong - should return 0 for odd number 15'; exit 1; }",
              "echo 'Phase 4: Cross-Validation (ensuring test-specific results are correct)'",
              "echo 'Checking that 40 (even) produces Sum is even: 1'",
              "TEST1_CORRECT=$(dmesg | grep -A1 '10 + 30 = 40' | grep -c 'Sum is even: 1')",
              "echo 'Checking that 15 (odd) produces Sum is even: 0'",
              "TEST2_CORRECT=$(dmesg | grep -A1 '7 + 8 = 15' | grep -c 'Sum is even: 0')",
              "echo 'Test 1 correct results: '$TEST1_CORRECT' (expected: 1)'",
              "echo 'Test 2 correct results: '$TEST2_CORRECT' (expected: 1)'",
              "if [ $TEST1_CORRECT -eq 1 ] && [ $TEST2_CORRECT -eq 1 ]; then echo 'PASS: Both tests show correct even/odd logic'; else echo 'FAIL: Logic validation failed - Test 1: '$TEST1_CORRECT', Test 2: '$TEST2_CORRECT' (expected 1 each)'; exit 1; fi"
            ],
            "expected": {
              "dmesg": [
                "Function parameters module loaded",
                "10 \\+ 30 = 40",
                "Sum is even: 1",
                "7 \\+ 8 = 15",
                "Sum is even: 0"
              ],
              "stdout": [
                "PASS: All function declarations found in header file",
                "SUCCESS: Dynamic test completed",
                "PASS: Both tests show correct even/odd logic"
              ]
            },
            "timeout": 25
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Function parameters module loaded",
        "15 + 25 = 40",
        "Sum is even: 1"
      ],
      "requirements": [
        "Use required function names: functions_init, functions_exit, add_numbers, print_calculation, is_even",
        "Use required variable names: first, second",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: int add_numbers(int a, int b), void print_calculation(int num1, int num2, int result), bool is_even(int number), return a + b, number % 2 == 0, add_numbers(first, second)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Function parameters module loaded",
          "linkedFunction": "static int __init functions_init(void)",
          "exact": true
        },
        {
          "pattern": "15 + 25 = 40",
          "linkedFunction": "void print_calculation(int num1, int num2, int result)",
          "exact": true
        },
        {
          "pattern": "Sum is even: 1",
          "linkedFunction": "static int __init functions_init(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 9,
    "title": "Conditional Logic - Making Decisions",
    "difficulty": 3,
    "xp": 35,
    "phase": "foundations",
    "description": "Learn to make decisions in your code using if/else statements and comparison operators. This introduces logical thinking and decision-making patterns essential for kernel development where conditions determine code flow.",
    "concepts": [
      "if statements",
      "else if statements",
      "comparison operators",
      "logical decision making",
      "conditional execution"
    ],
    "skills": [
      "Writing conditional statements",
      "Using comparison operators",
      "Logical thinking and flow control",
      "Decision-based programming",
      "Testing multiple conditions"
    ],
    "files": [
      {
        "name": "conditions.h",
        "content": "#ifndef CONDITIONS_H\n#define CONDITIONS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* TODO: Declare your function */\n/* void check_number_status(int number); */\n\n#endif /* CONDITIONS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "conditions.c",
        "content": "#include \"conditions.h\"\n\nint test_number = 42;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your conditional logic works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(test_number, int, 0644);\nMODULE_PARM_DESC(test_number, \"Number to test with conditional logic\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: How if/else works in C */\n/* Basic pattern for making decisions:\n *\n * if (condition1) {\n *     // do something when condition1 is true\n * } else if (condition2) {\n *     // do something when condition2 is true\n * } else {\n *     // do something when both conditions are false\n * }\n */\n\n/* COMPARISON OPERATORS: */\n/* > means \"greater than\"    (5 > 3 is true) */\n/* < means \"less than\"       (3 < 5 is true) */\n/* == means \"equal to\"       (5 == 5 is true) - NOTE: double equals! */\n\n/* TODO: Implement function to check if number is positive, negative, or zero */\n/* Use the pattern above with appropriate conditions */\n/* Print format: \"Number X is positive/negative/zero\" */\nvoid check_number_status(int number) {\n    // Your implementation here\n    // Follow the if/else pattern shown above\n}\n\nstatic int __init conditions_init(void)\n{\n    printk(KERN_INFO \"Conditional logic module loaded\\n\");\n    \n    // Call your function with the test parameter\n    check_number_status(test_number);\n    \n    // Test with fixed values for basic verification\n    check_number_status(42);\n    check_number_status(-15);\n    check_number_status(0);\n    \n    return 0;\n}\n\nstatic void __exit conditions_exit(void)\n{\n    printk(KERN_INFO \"Conditional logic module unloaded\\n\");\n}\n\nmodule_init(conditions_init);\nmodule_exit(conditions_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning conditional logic and decision making\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Conditional logic module Makefile\nobj-m += conditions.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "conditions.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "conditions_init",
          "conditions_exit",
          "check_number_status"
        ],
        "variables": [
          {
            "name": "test_number",
            "type": "int",
            "value": 42
          }
        ],
        "outputMessages": [
          "Conditional logic module loaded",
          "Number 42 is positive",
          "Number -15 is negative",
          "Number 0 is zero"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "int test_number = 42",
          "void check_number_status(int number)",
          "if (number > 0)",
          "else if (number < 0)",
          "else"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void check_number_status(int number)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void check_number_status(int number)",
            "static int __init conditions_init(void)",
            "static void __exit conditions_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Basic Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Conditional logic module loaded",
              "exact": true,
              "linkedFunction": "static int __init conditions_init(void)"
            },
            {
              "pattern": "Number 42 is positive",
              "exact": true,
              "linkedFunction": "void check_number_status(int number)"
            },
            {
              "pattern": "Number -15 is negative",
              "exact": true,
              "linkedFunction": "void check_number_status(int number)"
            },
            {
              "pattern": "Number 0 is zero",
              "exact": true,
              "linkedFunction": "void check_number_status(int number)"
            }
          ]
        },
        {
          "id": "advanced_conditional_testing",
          "name": "Advanced Conditional Logic with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "conditional_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\"=== Dynamic Conditional Test ===\\\\n\");\\n    \\n    // Seed random number generator with current time\\n    srand(time(NULL));\\n    \\n    // Generate random test values within -100 to 100\\n    int positive_val = (rand() % 90) + 10;  // 10 to 99\\n    int negative_val = -((rand() % 90) + 10); // -99 to -10\\n    int zero_val = 0;  // Always test zero\\n    \\n    printf(\"Test 1: Testing positive number (%d)\\\\n\", positive_val);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \"insmod /lib/modules/conditions.ko test_number=%d\", positive_val);\\n    system(\"rmmod conditions 2>/dev/null\");\\n    system(cmd1);\\n    \\n    printf(\"Test 2: Testing negative number (%d)\\\\n\", negative_val);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \"insmod /lib/modules/conditions.ko test_number=%d\", negative_val);\\n    system(\"rmmod conditions\");\\n    system(cmd2);\\n    \\n    printf(\"Test 3: Testing zero (%d)\\\\n\", zero_val);\\n    system(\"rmmod conditions\");\\n    system(\"insmod /lib/modules/conditions.ko test_number=0\");\\n    \\n    printf(\"SUCCESS: Dynamic test completed\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting comprehensive conditional logic validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo 'Creating test file that includes student header...'",
              "echo '#include \"/lib/modules/conditions.h\"' > /tmp/test.c",
              "echo 'int main() { check_number_status(42); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: Function declaration found in header file'",
              "echo 'Phase 2: Dynamic Parameter Testing'",
              "/bin/conditional_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Dynamic Randomized Conditional Logic Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "POSITIVE_VAL=$(grep -o 'Testing positive number ([0-9]*)' /tmp/test_output.log | cut -d'(' -f2 | cut -d')' -f1)",
              "NEGATIVE_VAL=$(grep -o 'Testing negative number (-[0-9]*)' /tmp/test_output.log | cut -d'(' -f2 | cut -d')' -f1)",
              "echo 'Extracted positive value: '$POSITIVE_VAL",
              "echo 'Extracted negative value: '$NEGATIVE_VAL",
              "echo 'Random positive value: '$POSITIVE_VAL",
              "echo 'Random negative value: '$NEGATIVE_VAL",
              "echo 'Validating positive number logic with random value '$POSITIVE_VAL",
              "dmesg | grep \"Number $POSITIVE_VAL is positive\" && echo 'PASS: Positive number logic correct' || echo 'FAIL: Positive number logic wrong'",
              "echo 'Validating negative number logic with random value '$NEGATIVE_VAL",
              "dmesg | grep \"Number $NEGATIVE_VAL is negative\" && echo 'PASS: Negative number logic correct' || echo 'FAIL: Negative number logic wrong'",
              "echo 'Validating zero logic (0 should be zero)'",
              "dmesg | grep 'Number 0 is zero' && echo 'PASS: Zero logic correct' || echo 'FAIL: Zero logic wrong'",
              "echo 'All individual validations completed'",
              "echo 'Phase 4: Dynamic Cross-Validation Consistency Check'",
              "echo 'Checking that random test values produced correct results'",
              "TEST_POSITIVE=$(dmesg | grep -c \"Number $POSITIVE_VAL is positive\")",
              "TEST_NEGATIVE=$(dmesg | grep -c \"Number $NEGATIVE_VAL is negative\")",
              "TEST_ZERO=$(dmesg | grep -c 'Number 0 is zero')",
              "echo 'Test positive '$POSITIVE_VAL' results: '$TEST_POSITIVE' (expected: 1)'",
              "echo 'Test negative '$NEGATIVE_VAL' results: '$TEST_NEGATIVE' (expected: 1)'",
              "echo 'Test 0 zero results: '$TEST_ZERO' (expected: at least 1)'",
              "if [ $TEST_POSITIVE -eq 1 ] && [ $TEST_NEGATIVE -eq 1 ] && [ $TEST_ZERO -ge 1 ]; then echo 'PASS: All conditional logic working correctly'; else echo 'FAIL: Conditional logic validation failed - Positive: '$TEST_POSITIVE', Negative: '$TEST_NEGATIVE', Zero: '$TEST_ZERO; fi"
            ],
            "expected": {
              "dmesg": [
                "Conditional logic module loaded",
                "Number .* is positive",
                "Number .* is negative",
                "Number 0 is zero"
              ],
              "stdout": [
                "PASS: Function declaration found in header file",
                "SUCCESS: Dynamic test completed",
                "PASS: All conditional logic working correctly"
              ]
            },
            "timeout": 25
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Conditional logic module loaded",
        "Number 42 is positive",
        "Number -15 is negative",
        "Number 0 is zero"
      ],
      "requirements": [
        "Use required function names: conditions_init, conditions_exit, check_number_status",
        "Use required variable names: test_number",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: int test_number = 42, void check_number_status(int number), if (number > 0), else if (number < 0), else",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Conditional logic module loaded",
          "linkedFunction": "static int __init conditions_init(void)",
          "exact": true
        },
        {
          "pattern": "Number 42 is positive",
          "linkedFunction": "void check_number_status(int number)",
          "exact": true
        },
        {
          "pattern": "Number -15 is negative",
          "linkedFunction": "void check_number_status(int number)",
          "exact": true
        },
        {
          "pattern": "Number 0 is zero",
          "linkedFunction": "void check_number_status(int number)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 10,
    "title": "Basic Loops - Study Loop Patterns",
    "difficulty": 2,
    "xp": 25,
    "phase": "foundations",
    "description": "Study complete working examples of for loops and iteration patterns. This demonstrates how loops are used in kernel development for processing data and implementing basic algorithms.",
    "concepts": [
      "for loops",
      "loop variables",
      "iteration patterns",
      "accumulation",
      "loop-based calculations"
    ],
    "skills": [
      "Writing for loops",
      "Managing loop counters",
      "Iterative algorithms",
      "Accumulation patterns",
      "Loop-based problem solving"
    ],
    "files": [
      {
        "name": "loops.h",
        "content": "#ifndef LOOPS_H\n#define LOOPS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\nextern int max_count;\nextern int sum_result;\n\n/* Function to print numbers from 1 to count */\nvoid print_numbers(int count);\n\n/* Function to calculate sum of numbers from 1 to n */\nint calculate_sum(int n);\n\n#endif /* LOOPS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "loops.c",
        "content": "#include \"loops.h\"\n\nint max_count = 5;\nint sum_result = 0;\n\n/* \n * Function to print numbers from 1 to count\n * Demonstrates basic for loop pattern for iteration\n */\nvoid print_numbers(int count) {\n    int i;\n    for (i = 1; i <= count; i++) {\n        printk(KERN_INFO \"Count: %d\\n\", i);\n    }\n}\n\n/* \n * Function to calculate sum of numbers from 1 to n\n * Demonstrates accumulation pattern using loops\n * Formula: sum = 1 + 2 + 3 + ... + n\n */\nint calculate_sum(int n) {\n    int i, sum = 0;\n    for (i = 1; i <= n; i++) {\n        sum += i;  // Accumulate each number into sum\n    }\n    return sum;\n}\n\nstatic int __init loops_init(void)\n{\n    printk(KERN_INFO \"Basic loops module loaded\\n\");\n    \n    // Demonstrate loop for printing sequential numbers\n    print_numbers(max_count);\n    \n    // Demonstrate loop for mathematical calculation\n    sum_result = calculate_sum(max_count);\n    printk(KERN_INFO \"Sum of 1 to %d is: %d\\n\", max_count, sum_result);\n    \n    return 0;\n}\n\nstatic void __exit loops_exit(void)\n{\n    printk(KERN_INFO \"Basic loops module unloaded\\n\");\n}\n\nmodule_init(loops_init);\nmodule_exit(loops_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning basic loops and iteration\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Basic loops module Makefile\nobj-m += loops.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "loops.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "loops_init",
          "loops_exit",
          "print_numbers",
          "calculate_sum"
        ],
        "variables": [
          {
            "name": "max_count",
            "type": "int",
            "value": 5
          },
          {
            "name": "sum_result",
            "type": "int",
            "value": 0
          }
        ],
        "outputMessages": [
          "Basic loops module loaded",
          "Count: 1",
          "Count: 2",
          "Count: 3",
          "Count: 4",
          "Count: 5",
          "Sum of 1 to 5 is: 15"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "extern int max_count",
          "extern int sum_result",
          "int max_count = 5",
          "int sum_result = 0",
          "for (i = 1; i <= count; i++)",
          "for (i = 1; i <= n; i++)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_numbers(int count)",
            "int calculate_sum(int n)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_numbers(int count)",
            "int calculate_sum(int n)",
            "static int __init loops_init(void)",
            "static void __exit loops_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Basic Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Basic loops module loaded",
              "exact": true,
              "linkedFunction": "static int __init loops_init(void)"
            },
            {
              "pattern": "Count: 1",
              "exact": true,
              "linkedFunction": "void print_numbers(int count)"
            },
            {
              "pattern": "Count: 2",
              "exact": true,
              "linkedFunction": "void print_numbers(int count)"
            },
            {
              "pattern": "Count: 3",
              "exact": true,
              "linkedFunction": "void print_numbers(int count)"
            },
            {
              "pattern": "Count: 4",
              "exact": true,
              "linkedFunction": "void print_numbers(int count)"
            },
            {
              "pattern": "Count: 5",
              "exact": true,
              "linkedFunction": "void print_numbers(int count)"
            },
            {
              "pattern": "Sum of 1 to 5 is: 15",
              "exact": true,
              "linkedFunction": "static int __init loops_init(void)"
            }
          ]
        },
        {
          "id": "advanced_loop_validation",
          "name": "Advanced Loop Pattern Validation with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "loop_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\"=== Loop Pattern Test ===\\\\n\");\\n    printf(\"SUCCESS: Loop test completed\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting loop pattern validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo 'Creating test file that includes student header...'",
              "echo '#include \"/lib/modules/loops.h\"' > /tmp/test.c",
              "echo 'int main() { print_numbers(5); calculate_sum(5); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: All function declarations found in header file'",
              "echo 'Phase 2: Module Testing'",
              "/bin/loop_tester"
            ],
            "expected": {
              "dmesg": [
                "Basic loops module loaded",
                "Count: 1",
                "Count: 2",
                "Count: 3",
                "Count: 4",
                "Count: 5",
                "Sum of 1 to 5 is: 15"
              ],
              "stdout": [
                "PASS: All function declarations found in header file",
                "SUCCESS: Loop test completed"
              ]
            },
            "timeout": 20
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Basic loops module loaded",
        "Count: 1",
        "Count: 2",
        "Count: 3",
        "Count: 4",
        "Count: 5",
        "Sum of 1 to 5 is: 15"
      ],
      "requirements": [
        "Use required function names: loops_init, loops_exit, print_numbers, calculate_sum",
        "Use required variable names: max_count, sum_result",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: extern int max_count, extern int sum_result, int max_count = 5, int sum_result = 0, for (i = 1; i <= count; i++), for (i = 1; i <= n; i++)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Basic loops module loaded",
          "linkedFunction": "static int __init loops_init(void)",
          "exact": true
        },
        {
          "pattern": "Count: 1",
          "linkedFunction": "void print_numbers(int count)",
          "exact": true
        },
        {
          "pattern": "Count: 2",
          "linkedFunction": "void print_numbers(int count)",
          "exact": true
        },
        {
          "pattern": "Count: 3",
          "linkedFunction": "void print_numbers(int count)",
          "exact": true
        },
        {
          "pattern": "Count: 4",
          "linkedFunction": "void print_numbers(int count)",
          "exact": true
        },
        {
          "pattern": "Count: 5",
          "linkedFunction": "void print_numbers(int count)",
          "exact": true
        },
        {
          "pattern": "Sum of 1 to 5 is: 15",
          "linkedFunction": "static int __init loops_init(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 11,
    "title": "Basic Loops - Implement Loop Solutions",
    "difficulty": 4,
    "xp": 40,
    "phase": "foundations",
    "description": "Implement your own loop-based solutions for iterative calculations using simple integers. Apply the patterns you studied in Problem 10 to create functions that perform mathematical calculations using loops. This focuses on pure loop logic without arrays.",
    "concepts": [
      "countdown iteration",
      "factorial calculation",
      "power calculation with loops",
      "multiplication accumulation patterns",
      "loop control variables"
    ],
    "skills": [
      "Implementing countdown loops",
      "Mathematical calculations with loops",
      "Basic accumulation algorithms",
      "Multiplication patterns",
      "Loop-based problem solving"
    ],
    "files": [
      {
        "name": "loops_impl.h",
        "content": "#ifndef LOOPS_IMPL_H\n#define LOOPS_IMPL_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\nextern int start_number;\nextern int factorial_number;\nextern int base_number;\nextern int power_number;\n\n/* TODO: Declare your functions */\n/* void print_countdown(int start); */\n/* int calculate_factorial(int n); */\n/* int calculate_power(int base, int exponent); */\n\n#endif /* LOOPS_IMPL_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "loops_impl.c",
        "content": "#include \"loops_impl.h\"\n\nint start_number = 5;      // Default: countdown from 5\nint factorial_number = 5;  // Default: calculate factorial of 5\nint base_number = 2;       // Default: base for power calculation\nint power_number = 3;      // Default: exponent for power calculation\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your loop implementations work\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(start_number, int, 0644);\nMODULE_PARM_DESC(start_number, \"Starting number for countdown testing\");\nmodule_param(factorial_number, int, 0644);\nMODULE_PARM_DESC(factorial_number, \"Number for factorial calculation testing\");\nmodule_param(base_number, int, 0644);\nMODULE_PARM_DESC(base_number, \"Base number for power calculation testing\");\nmodule_param(power_number, int, 0644);\nMODULE_PARM_DESC(power_number, \"Exponent for power calculation testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* TODO: Implement function to print countdown from start to 1 */\n/* Use a for loop starting from start down to 1 */\n/* Print: \"Count: X\" for each number */\n\n/* TODO: Implement function to calculate factorial of n */\n/* factorial(n) = n * (n-1) * (n-2) * ... * 1 */\n/* Use a for loop from 1 to n, multiply result by each number */\n\n/* TODO: Implement function to calculate power (base^exponent) */\n/* power = base * base * base * ... (exponent times) */\n/* Use accumulation pattern: start with result = 1 */\n/* Multiply result by base using for loop exponent times */\n\nstatic int __init loops_impl_init(void)\n{\n    int calculated_factorial, calculated_power;\n    \n    printk(KERN_INFO \"Loop implementation module loaded\\n\");\n    \n    /* TODO: Print countdown from start_number to 1 */\n    /* printk(KERN_INFO \"Countdown from %d:\\n\", start_number); */\n    /* print_countdown(start_number); */\n    \n    /* TODO: Calculate factorial using factorial_number as input */\n    /* calculated_factorial = calculate_factorial(factorial_number); */\n    /* printk(KERN_INFO \"Factorial of %d: %d\\n\", factorial_number, calculated_factorial); */\n    \n    /* TODO: Calculate power using base_number and power_number */\n    /* calculated_power = calculate_power(base_number, power_number); */\n    /* printk(KERN_INFO \"%d to the power of %d: %d\\n\", base_number, power_number, calculated_power); */\n    \n    return 0;\n}\n\nstatic void __exit loops_impl_exit(void)\n{\n    printk(KERN_INFO \"Loop implementation module unloaded\\n\");\n}\n\nmodule_init(loops_impl_init);\nmodule_exit(loops_impl_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Implementing basic loop calculations\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Loop implementation module Makefile\nobj-m += loops_impl.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "loops_impl.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "loops_impl_init",
          "loops_impl_exit",
          "print_countdown",
          "calculate_factorial",
          "calculate_power"
        ],
        "variables": [
          {
            "name": "start_number",
            "type": "int",
            "value": 5
          },
          {
            "name": "factorial_number",
            "type": "int",
            "value": 5
          },
          {
            "name": "base_number",
            "type": "int",
            "value": 2
          },
          {
            "name": "power_number",
            "type": "int",
            "value": 3
          }
        ],
        "outputMessages": [
          "Loop implementation module loaded",
          "Countdown from 5:",
          "Count: 5",
          "Count: 4",
          "Count: 3",
          "Count: 2",
          "Count: 1",
          "Factorial of 5: 120",
          "2 to the power of 3: 8"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "extern int start_number",
          "extern int factorial_number",
          "extern int base_number",
          "extern int power_number"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_countdown(int start)",
            "int calculate_factorial(int n)",
            "int calculate_power(int base, int exponent)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_countdown(int start)",
            "int calculate_factorial(int n)",
            "int calculate_power(int base, int exponent)",
            "static int __init loops_impl_init(void)",
            "static void __exit loops_impl_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Basic Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Loop implementation module loaded",
              "exact": true,
              "linkedFunction": "static int __init loops_impl_init(void)"
            },
            {
              "pattern": "Countdown from 5:",
              "exact": true,
              "linkedFunction": "static int __init loops_impl_init(void)"
            },
            {
              "pattern": "Count: 5",
              "exact": true,
              "linkedFunction": "void print_countdown(int start)"
            },
            {
              "pattern": "Count: 4",
              "exact": true,
              "linkedFunction": "void print_countdown(int start)"
            },
            {
              "pattern": "Count: 3",
              "exact": true,
              "linkedFunction": "void print_countdown(int start)"
            },
            {
              "pattern": "Count: 2",
              "exact": true,
              "linkedFunction": "void print_countdown(int start)"
            },
            {
              "pattern": "Count: 1",
              "exact": true,
              "linkedFunction": "void print_countdown(int start)"
            },
            {
              "pattern": "Factorial of 5: 120",
              "exact": true,
              "linkedFunction": "static int __init loops_impl_init(void)"
            },
            {
              "pattern": "2 to the power of 3: 8",
              "exact": true,
              "linkedFunction": "static int __init loops_impl_init(void)"
            }
          ]
        },
        {
          "id": "advanced_loop_implementation_validation",
          "name": "Advanced Loop Implementation with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "loop_impl_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\"=== Dynamic Loop Implementation Test ===\\\\n\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random test values\\n    int countdown_start = (rand() % 5) + 3;  // 3 to 7\\n    int factorial_n = (rand() % 5) + 3;      // 3 to 7 for reasonable factorial\\n    int base = (rand() % 3) + 2;             // 2 to 4\\n    int exponent = (rand() % 3) + 2;         // 2 to 4\\n    \\n    printf(\"Test 1: Countdown from %d, factorial of %d\\\\n\", countdown_start, factorial_n);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \"insmod /lib/modules/loops_impl.ko start_number=%d factorial_number=%d\", countdown_start, factorial_n);\\n    system(\"rmmod loops_impl 2>/dev/null\");\\n    system(cmd1);\\n    \\n    printf(\"Test 2: Power calculation %d^%d\\\\n\", base, exponent);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \"insmod /lib/modules/loops_impl.ko base_number=%d power_number=%d\", base, exponent);\\n    system(\"rmmod loops_impl\");\\n    system(cmd2);\\n    \\n    printf(\"SUCCESS: Dynamic loop test completed\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced loop implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo 'Creating test file that includes student header...'",
              "echo '#include \"/lib/modules/loops_impl.h\"' > /tmp/test.c",
              "echo 'int main() { print_countdown(5); calculate_factorial(5); calculate_power(2, 3); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: All function declarations found in header file'",
              "echo 'Phase 2: Dynamic Implementation Testing'",
              "/bin/loop_impl_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Dynamic Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "COUNTDOWN_START=$(grep -o 'Countdown from [0-9]*' /tmp/test_output.log | head -1 | cut -d' ' -f3 | cut -d',' -f1)",
              "FACTORIAL_N=$(grep -o 'factorial of [0-9]*' /tmp/test_output.log | head -1 | cut -d' ' -f3)",
              "BASE_NUM=$(grep -o 'Power calculation [0-9]*' /tmp/test_output.log | cut -d' ' -f3)",
              "EXPONENT_NUM=$(grep -o '[0-9]*\\^[0-9]*' /tmp/test_output.log | cut -d'^' -f2)",
              "echo 'Random values: countdown='$COUNTDOWN_START', factorial='$FACTORIAL_N', power='$BASE_NUM'^'$EXPONENT_NUM",
              "echo 'Validating countdown from '$COUNTDOWN_START",
              "dmesg | grep \"Countdown from $COUNTDOWN_START:\" && echo 'PASS: Countdown output correct' || echo 'PASS: Countdown working (flexible validation)'",
              "echo 'Validating factorial calculation for n='$FACTORIAL_N",
              "dmesg | grep \"Factorial of $FACTORIAL_N:\" && echo 'PASS: Factorial calculation correct' || echo 'PASS: Factorial working (flexible validation)'",
              "echo 'Validating power calculation '$BASE_NUM'^'$EXPONENT_NUM",
              "dmesg | grep \"$BASE_NUM to the power of $EXPONENT_NUM:\" && echo 'PASS: Power calculation correct' || echo 'PASS: Power working (flexible validation)'",
              "echo 'All dynamic validations completed'"
            ],
            "expected": {
              "dmesg": [
                "Loop implementation module loaded",
                "Countdown from .*:",
                "Count: .*",
                "Factorial of .* .*",
                ".* to the power of .* .*"
              ],
              "stdout": [
                "PASS: All function declarations found in header file",
                "SUCCESS: Dynamic loop test completed",
                "PASS: Countdown output correct",
                "PASS: Factorial calculation correct",
                "PASS: Power calculation correct"
              ]
            },
            "timeout": 25
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Loop implementation module loaded",
        "Countdown from 5:",
        "Count: 5",
        "Count: 4",
        "Count: 3",
        "Count: 2",
        "Count: 1",
        "Factorial of 5: 120",
        "2 to the power of 3: 8"
      ],
      "requirements": [
        "Use required function names: loops_impl_init, loops_impl_exit, print_countdown, calculate_factorial, calculate_power",
        "Use required variable names: start_number, factorial_number, base_number, power_number",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: extern int start_number, extern int factorial_number, extern int base_number, extern int power_number",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Loop implementation module loaded",
          "linkedFunction": "static int __init loops_impl_init(void)",
          "exact": true
        },
        {
          "pattern": "Countdown from 5:",
          "linkedFunction": "static int __init loops_impl_init(void)",
          "exact": true
        },
        {
          "pattern": "Count: 5",
          "linkedFunction": "void print_countdown(int start)",
          "exact": true
        },
        {
          "pattern": "Count: 4",
          "linkedFunction": "void print_countdown(int start)",
          "exact": true
        },
        {
          "pattern": "Count: 3",
          "linkedFunction": "void print_countdown(int start)",
          "exact": true
        },
        {
          "pattern": "Count: 2",
          "linkedFunction": "void print_countdown(int start)",
          "exact": true
        },
        {
          "pattern": "Count: 1",
          "linkedFunction": "void print_countdown(int start)",
          "exact": true
        },
        {
          "pattern": "Factorial of 5: 120",
          "linkedFunction": "static int __init loops_impl_init(void)",
          "exact": true
        },
        {
          "pattern": "2 to the power of 3: 8",
          "linkedFunction": "static int __init loops_impl_init(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 12,
    "title": "Arrays and Collections - Study Complete Examples",
    "difficulty": 2,
    "xp": 25,
    "phase": "foundations",
    "description": "Study complete array implementations to understand how to store and manage multiple values. This introduces data collection patterns essential for kernel development where you often need to manage lists of devices, buffers, or other resources. Observe the patterns before implementing them yourself.",
    "concepts": [
      "array declaration with #define",
      "array initialization with literal values",
      "array indexing with []",
      "array traversal with for loops",
      "maximum finding algorithms",
      "accumulation patterns",
      "linear search algorithms"
    ],
    "skills": [
      "Understanding array syntax",
      "Recognizing traversal patterns",
      "Learning search algorithms",
      "Understanding index-based access",
      "Observing accumulation patterns"
    ],
    "files": [
      {
        "name": "arrays_study.h",
        "content": "#ifndef ARRAYS_STUDY_H\n#define ARRAYS_STUDY_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* Array size definition */\n#define MAX_DEVICES 6\n\n/* Array declarations */\nextern int device_ids[MAX_DEVICES];\nextern int device_count;\n\n/* Function declarations - study these patterns */\nvoid print_all_devices(void);\nint find_max_device_id(void);\nint calculate_id_sum(void);\nbool check_device_exists(int);\n\n#endif /* ARRAYS_STUDY_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "arrays_study.c",
        "content": "#include \"arrays_study.h\"\n\n/* Array initialization with device IDs */\nint device_ids[MAX_DEVICES] = {101, 205, 150, 320, 180, 275};\nint device_count = MAX_DEVICES;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify array operations work\n * with different input values. Removing them will cause test failures.\n */\nmodule_param_array(device_ids, int, &device_count, 0644);\nMODULE_PARM_DESC(device_ids, \"Array of device IDs for testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/**\n * print_all_devices - Print all device IDs in the array\n * \n * This function demonstrates basic array traversal using a for loop.\n * Notice how we use the loop counter 'i' as an index to access\n * each array element with device_ids[i].\n */\nvoid print_all_devices(void)\n{\n    int i;\n    \n    printk(KERN_INFO \"Device listing:\\n\");\n    for (i = 0; i < device_count; i++) {\n        printk(KERN_INFO \"Device %d: ID %d\\n\", i + 1, device_ids[i]);\n    }\n}\n\n/**\n * find_max_device_id - Find the highest device ID in the array\n * Returns: The maximum device ID found\n * \n * This function shows the standard algorithm for finding maximum values:\n * 1. Start with first element as current maximum\n * 2. Compare each remaining element with current maximum\n * 3. Update maximum when a larger value is found\n */\nint find_max_device_id(void)\n{\n    int i, max_id;\n    \n    /* Initialize with first element */\n    max_id = device_ids[0];\n    \n    /* Compare with remaining elements */\n    for (i = 1; i < device_count; i++) {\n        if (device_ids[i] > max_id) {\n            max_id = device_ids[i];\n        }\n    }\n    \n    return max_id;\n}\n\n/**\n * calculate_id_sum - Calculate sum of all device IDs\n * Returns: Total sum of all device IDs\n * \n * This demonstrates the accumulation pattern:\n * 1. Initialize accumulator to 0\n * 2. Loop through array adding each element to accumulator\n * 3. Return final accumulated value\n */\nint calculate_id_sum(void)\n{\n    int i, sum = 0;\n    \n    for (i = 0; i < device_count; i++) {\n        sum += device_ids[i];\n    }\n    \n    return sum;\n}\n\n/**\n * check_device_exists - Check if a specific device ID exists in array\n * @target_id: The device ID to search for\n * Returns: true if found, false if not found\n * \n * This shows the search pattern:\n * 1. Loop through array comparing each element with target\n * 2. Return true immediately when match is found\n * 3. Return false if loop completes without finding match\n */\nbool check_device_exists(int target_id)\n{\n    int i;\n    \n    for (i = 0; i < device_count; i++) {\n        if (device_ids[i] == target_id) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nstatic int __init arrays_study_init(void)\n{\n    int max_id, total_sum;\n    bool device_found;\n    \n    printk(KERN_INFO \"Arrays study module loaded\\n\");\n    printk(KERN_INFO \"Studying array operations with %d devices\\n\", device_count);\n    \n    /* Demonstrate array traversal */\n    print_all_devices();\n    \n    /* Demonstrate maximum finding */\n    max_id = find_max_device_id();\n    printk(KERN_INFO \"Highest device ID: %d\\n\", max_id);\n    \n    /* Demonstrate accumulation */\n    total_sum = calculate_id_sum();\n    printk(KERN_INFO \"Total sum of device IDs: %d\\n\", total_sum);\n    \n    /* Demonstrate search */\n    device_found = check_device_exists(205);\n    printk(KERN_INFO \"Device 205 found: %s\\n\", device_found ? \"Yes\" : \"No\");\n    \n    device_found = check_device_exists(999);\n    printk(KERN_INFO \"Device 999 found: %s\\n\", device_found ? \"Yes\" : \"No\");\n    \n    return 0;\n}\n\nstatic void __exit arrays_study_exit(void)\n{\n    printk(KERN_INFO \"Arrays study module unloaded\\n\");\n}\n\nmodule_init(arrays_study_init);\nmodule_exit(arrays_study_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"KernelOne Educational System\");\nMODULE_DESCRIPTION(\"Study complete array implementations and patterns\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Arrays study module Makefile\nobj-m += arrays_study.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "arrays_study.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "arrays_study_init",
          "arrays_study_exit",
          "print_all_devices",
          "find_max_device_id",
          "calculate_id_sum",
          "check_device_exists"
        ],
        "variables": [
          {
            "name": "device_ids[]",
            "type": "int",
            "value": "{101, 205, 150, 320, 180, 275}"
          },
          {
            "name": "device_count",
            "type": "int",
            "value": 6
          }
        ],
        "outputMessages": [
          "Arrays study module loaded",
          "Studying array operations with 6 devices",
          "Device listing:",
          "Device 1: ID 101",
          "Device 2: ID 205",
          "Device 3: ID 150",
          "Device 4: ID 320",
          "Device 5: ID 180",
          "Device 6: ID 275",
          "Highest device ID: 320",
          "Total sum of device IDs: 1231",
          "Device 205 found: Yes",
          "Device 999 found: No"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "#define MAX_DEVICES 6",
          "int device_ids[MAX_DEVICES]",
          "module_param_array(device_ids, int, &device_count, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_all_devices(void)",
            "int find_max_device_id(void)",
            "int calculate_id_sum(void)",
            "bool check_device_exists(int)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_all_devices(void)",
            "int find_max_device_id(void)",
            "int calculate_id_sum(void)",
            "bool check_device_exists(int target_id)",
            "static int __init arrays_study_init(void)",
            "static void __exit arrays_study_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Expected Study Output",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Arrays study module loaded",
              "exact": true,
              "linkedFunction": "static int __init arrays_study_init(void)"
            },
            {
              "pattern": "Studying array operations with 6 devices",
              "exact": true,
              "linkedFunction": "static int __init arrays_study_init(void)"
            },
            {
              "pattern": "Device listing:",
              "exact": true,
              "linkedFunction": "void print_all_devices(void)"
            },
            {
              "pattern": "Device 1: ID 101",
              "exact": true,
              "linkedFunction": "void print_all_devices(void)"
            },
            {
              "pattern": "Device 6: ID 275",
              "exact": true,
              "linkedFunction": "void print_all_devices(void)"
            },
            {
              "pattern": "Highest device ID: 320",
              "exact": true,
              "linkedFunction": "static int __init arrays_study_init(void)"
            },
            {
              "pattern": "Total sum of device IDs: 1231",
              "exact": true,
              "linkedFunction": "static int __init arrays_study_init(void)"
            },
            {
              "pattern": "Device 205 found: Yes",
              "exact": true,
              "linkedFunction": "static int __init arrays_study_init(void)"
            },
            {
              "pattern": "Device 999 found: No",
              "exact": true,
              "linkedFunction": "static int __init arrays_study_init(void)"
            }
          ]
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Arrays study module loaded",
        "Studying array operations with 6 devices",
        "Device listing:",
        "Device 1: ID 101",
        "Device 2: ID 205",
        "Device 3: ID 150",
        "Device 4: ID 320",
        "Device 5: ID 180",
        "Device 6: ID 275",
        "Highest device ID: 320",
        "Total sum of device IDs: 1231",
        "Device 205 found: Yes",
        "Device 999 found: No"
      ],
      "requirements": [
        "Use required function names: arrays_study_init, arrays_study_exit, print_all_devices, find_max_device_id, calculate_id_sum, check_device_exists",
        "Use required variable names: device_ids[], device_count",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: #define MAX_DEVICES 6, int device_ids[MAX_DEVICES], module_param_array(device_ids, int, &device_count, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Arrays study module loaded",
          "linkedFunction": "static int __init arrays_study_init(void)",
          "exact": true
        },
        {
          "pattern": "Studying array operations with 6 devices",
          "linkedFunction": "static int __init arrays_study_init(void)",
          "exact": true
        },
        {
          "pattern": "Device listing:",
          "linkedFunction": "void print_all_devices(void)",
          "exact": true
        },
        {
          "pattern": "Device 1: ID 101",
          "linkedFunction": "void print_all_devices(void)",
          "exact": true
        },
        {
          "pattern": "Device 6: ID 275",
          "linkedFunction": "void print_all_devices(void)",
          "exact": true
        },
        {
          "pattern": "Highest device ID: 320",
          "linkedFunction": "static int __init arrays_study_init(void)",
          "exact": true
        },
        {
          "pattern": "Total sum of device IDs: 1231",
          "linkedFunction": "static int __init arrays_study_init(void)",
          "exact": true
        },
        {
          "pattern": "Device 205 found: Yes",
          "linkedFunction": "static int __init arrays_study_init(void)",
          "exact": true
        },
        {
          "pattern": "Device 999 found: No",
          "linkedFunction": "static int __init arrays_study_init(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 13,
    "title": "Arrays and Collections - Implement Solutions",
    "difficulty": 4,
    "xp": 40,
    "phase": "foundations",
    "description": "Implement your own array-based solutions for managing multiple values. Apply the patterns you studied in Problem 11 to create functions that process arrays, find maximum values, and calculate statistics. This builds on the complete examples you observed.",
    "concepts": [
      "array declaration",
      "array initialization",
      "array indexing",
      "array iteration",
      "data collection algorithms"
    ],
    "skills": [
      "Working with arrays",
      "Array traversal with loops",
      "Finding maximum values",
      "Calculating averages",
      "Index-based data access"
    ],
    "files": [
      {
        "name": "arrays.h",
        "content": "#ifndef ARRAYS_H\n#define ARRAYS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n#define MAX_GRADES 5\n\nextern int student_grades[MAX_GRADES];\nextern int grade_count;\n\n/* TODO: Declare your functions */\n/* void print_all_grades(void); */\n/* int find_highest_grade(void); */\n/* int calculate_average(void); */\n\n#endif /* ARRAYS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "arrays.c",
        "content": "#include \"arrays.h\"\n\n/* TODO: Initialize array with grades: {85, 92, 78, 96, 88} */\n/* int student_grades[MAX_GRADES] = {85, 92, 78, 96, 88}; */\nint grade_count = MAX_GRADES;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your array operations work\n * with different input values. Removing them will cause test failures.\n */\nmodule_param_array(student_grades, int, &grade_count, 0644);\nMODULE_PARM_DESC(student_grades, \"Array of student grades for testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* ARRAY CONCEPT: Multiple values in one variable */\n/* Instead of: int grade1=85, grade2=92, grade3=78... */\n/* We use: int student_grades[] = {85, 92, 78, 96, 88}; */\n/* Access: student_grades[0]=85, student_grades[1]=92, student_grades[2]=78... */\n/* Size: if array has 5 elements, indexes are 0,1,2,3,4 */\n\n/* ALGORITHM CONCEPT: Finding Maximum Value */\n/* How to find the largest number in a group: */\n/* Step 1: Assume first number is the largest so far */\n/* Step 2: Compare each remaining number with current largest */\n/* Step 3: If bigger number found, that becomes new largest */\n/* Example: [85,92,78]  start with 85, compare 92>85? Yesmax=92, compare 78>92? Nomax stays 92 */\n\n/* ALGORITHM CONCEPT: Sum Accumulation */\n/* To sum all numbers: start with 0, add each number to total */\n/* Pattern: sum = sum + current_number */\n/* Why start with 0? Because 0 + anything = anything (additive identity) */\n\n/* MATH CONCEPT: Average calculation */\n/* Average = total_sum / number_of_items */\n/* Example: grades [85,92,78]  sum=255, count=3, average=255/3=85 */\n\n/* TODO: Implement function to print all grades */\n/* Use array indexing concept above with a for loop */\nvoid print_all_grades(void) {\n    // Your implementation here\n    // Print format: \"Grade X: Y\"\n}\n\n/* TODO: Implement function to find highest grade */\n/* Use the maximum finding algorithm concept above */\nint find_highest_grade(void) {\n    // Your implementation here\n    // Follow the step-by-step algorithm above\n}\n\n/* TODO: Implement function to calculate average */\n/* Use sum accumulation, then apply average formula */\nint calculate_average(void) {\n    // Your implementation here\n    // Use accumulation concept, then divide for average\n}\n\nstatic int __init arrays_init(void)\n{\n    int highest, average;\n    \n    printk(KERN_INFO \"Arrays module loaded\\n\");\n    \n    /* TODO: Print all grades */\n    /* print_all_grades(); */\n    \n    /* TODO: Find and print highest grade */\n    /* highest = find_highest_grade(); */\n    /* printk(KERN_INFO \"Highest grade: %d\\n\", highest); */\n    \n    /* TODO: Calculate and print average */\n    /* average = calculate_average(); */\n    /* printk(KERN_INFO \"Average grade: %d\\n\", average); */\n    \n    return 0;\n}\n\nstatic void __exit arrays_exit(void)\n{\n    printk(KERN_INFO \"Arrays module unloaded\\n\");\n}\n\nmodule_init(arrays_init);\nmodule_exit(arrays_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning arrays and data collections\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Arrays module Makefile\nobj-m += arrays.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "arrays.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "arrays_init",
          "arrays_exit",
          "print_all_grades",
          "find_highest_grade",
          "calculate_average"
        ],
        "variables": [
          {
            "name": "student_grades[MAX_GRADES]",
            "type": "int",
            "value": "{85, 92, 78, 96, 88}"
          },
          {
            "name": "grade_count",
            "type": "int",
            "value": 5
          }
        ],
        "outputMessages": [
          "Arrays module loaded",
          "Student grades:",
          "Grade 1: 85",
          "Grade 2: 92",
          "Grade 3: 78",
          "Grade 4: 96",
          "Grade 5: 88",
          "Highest grade: 96",
          "Average grade: 87"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "#define MAX_GRADES 5",
          "extern int student_grades[MAX_GRADES]",
          "extern int grade_count",
          "int student_grades[MAX_GRADES] = {85, 92, 78, 96, 88}",
          "int grade_count = MAX_GRADES"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_all_grades(void)",
            "int find_highest_grade(void)",
            "int calculate_average(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_all_grades(void)",
            "int find_highest_grade(void)",
            "int calculate_average(void)",
            "static int __init arrays_init(void)",
            "static void __exit arrays_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Basic Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Arrays module loaded",
              "exact": true,
              "linkedFunction": "static int __init arrays_init(void)"
            },
            {
              "pattern": "Student grades:",
              "exact": true,
              "linkedFunction": "void print_all_grades(void)"
            },
            {
              "pattern": "Grade 1: 85",
              "exact": true,
              "linkedFunction": "void print_all_grades(void)"
            },
            {
              "pattern": "Grade 2: 92",
              "exact": true,
              "linkedFunction": "void print_all_grades(void)"
            },
            {
              "pattern": "Grade 3: 78",
              "exact": true,
              "linkedFunction": "void print_all_grades(void)"
            },
            {
              "pattern": "Grade 4: 96",
              "exact": true,
              "linkedFunction": "void print_all_grades(void)"
            },
            {
              "pattern": "Grade 5: 88",
              "exact": true,
              "linkedFunction": "void print_all_grades(void)"
            },
            {
              "pattern": "Highest grade: 96",
              "exact": true,
              "linkedFunction": "static int __init arrays_init(void)"
            },
            {
              "pattern": "Average grade: 87",
              "exact": true,
              "linkedFunction": "static int __init arrays_init(void)"
            }
          ]
        },
        {
          "id": "advanced_array_implementation_validation",
          "name": "Advanced Array Implementation with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "array_impl_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\"=== Dynamic Array Implementation Test ===\\\\n\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random test arrays\\n    int grades1[3] = {(rand() % 40) + 60, (rand() % 40) + 60, (rand() % 40) + 60};  // 60-99 range\\n    int grades2[4] = {(rand() % 30) + 70, (rand() % 30) + 70, (rand() % 30) + 70, (rand() % 30) + 70};  // 70-99 range\\n    \\n    printf(\"Test 1: Array with %d,%d,%d\\\\n\", grades1[0], grades1[1], grades1[2]);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \"insmod /lib/modules/arrays.ko student_grades=%d,%d,%d\", grades1[0], grades1[1], grades1[2]);\\n    system(\"rmmod arrays 2>/dev/null\");\\n    system(cmd1);\\n    \\n    printf(\"Test 2: Array with %d,%d,%d,%d\\\\n\", grades2[0], grades2[1], grades2[2], grades2[3]);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \"insmod /lib/modules/arrays.ko student_grades=%d,%d,%d,%d\", grades2[0], grades2[1], grades2[2], grades2[3]);\\n    system(\"rmmod arrays\");\\n    system(cmd2);\\n    \\n    printf(\"SUCCESS: Dynamic array test completed\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced array implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param_array(name, type, nump, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo '#define true 1' >> /tmp/linux/types.h",
              "echo '#define false 0' >> /tmp/linux/types.h",
              "echo 'Creating test file that includes student header...'",
              "echo '#include \"/lib/modules/arrays.h\"' > /tmp/test.c",
              "echo 'int main() { print_all_grades(); find_highest_grade(); calculate_average(); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: All function declarations found in header file'",
              "echo 'Phase 2: Dynamic Array Implementation Testing'",
              "/bin/array_impl_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Dynamic Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "TEST1_LINE=$(grep 'Test 1: Array with' /tmp/test_output.log)",
              "TEST2_LINE=$(grep 'Test 2: Array with' /tmp/test_output.log)",
              "echo 'Test 1 values: '$TEST1_LINE",
              "echo 'Test 2 values: '$TEST2_LINE",
              "echo 'Validating array processing output'",
              "dmesg | grep 'Student grades:' && echo 'PASS: Array output found' || echo 'FAIL: Array output missing'",
              "dmesg | grep 'Grade.*:.*[0-9]' && echo 'PASS: Grade enumeration working' || echo 'FAIL: Grade enumeration broken'",
              "dmesg | grep 'Highest grade:.*[0-9]' && echo 'PASS: Maximum finding working' || echo 'FAIL: Maximum finding broken'",
              "dmesg | grep 'Average grade:.*[0-9]' && echo 'PASS: Average calculation working' || echo 'FAIL: Average calculation broken'",
              "echo 'All dynamic validations completed'"
            ],
            "expected": {
              "dmesg": [
                "Arrays module loaded",
                "Student grades:",
                "Grade .* .*",
                "Highest grade: .*",
                "Average grade: .*"
              ],
              "stdout": [
                "PASS: All function declarations found in header file",
                "SUCCESS: Dynamic array test completed",
                "PASS: Array output found",
                "PASS: Grade enumeration working",
                "PASS: Maximum finding working",
                "PASS: Average calculation working"
              ]
            },
            "timeout": 30
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Arrays module loaded",
        "Student grades:",
        "Grade 1: 85",
        "Grade 2: 92",
        "Grade 3: 78",
        "Grade 4: 96",
        "Grade 5: 88",
        "Highest grade: 96",
        "Average grade: 87"
      ],
      "requirements": [
        "Use required function names: arrays_init, arrays_exit, print_all_grades, find_highest_grade, calculate_average",
        "Use required variable names: student_grades[MAX_GRADES], grade_count",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: #define MAX_GRADES 5, extern int student_grades[MAX_GRADES], extern int grade_count, int student_grades[MAX_GRADES] = {85, 92, 78, 96, 88}, int grade_count = MAX_GRADES",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Arrays module loaded",
          "linkedFunction": "static int __init arrays_init(void)",
          "exact": true
        },
        {
          "pattern": "Student grades:",
          "linkedFunction": "void print_all_grades(void)",
          "exact": true
        },
        {
          "pattern": "Grade 1: 85",
          "linkedFunction": "void print_all_grades(void)",
          "exact": true
        },
        {
          "pattern": "Grade 2: 92",
          "linkedFunction": "void print_all_grades(void)",
          "exact": true
        },
        {
          "pattern": "Grade 3: 78",
          "linkedFunction": "void print_all_grades(void)",
          "exact": true
        },
        {
          "pattern": "Grade 4: 96",
          "linkedFunction": "void print_all_grades(void)",
          "exact": true
        },
        {
          "pattern": "Grade 5: 88",
          "linkedFunction": "void print_all_grades(void)",
          "exact": true
        },
        {
          "pattern": "Highest grade: 96",
          "linkedFunction": "static int __init arrays_init(void)",
          "exact": true
        },
        {
          "pattern": "Average grade: 87",
          "linkedFunction": "static int __init arrays_init(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 14,
    "title": "String Basics - Arrays of Characters",
    "difficulty": 2,
    "xp": 25,
    "phase": "foundations",
    "description": "Learn that strings are just arrays of characters! This builds directly on the arrays problem - instead of int arrays, we use char arrays. No pointers, no parameters, just simple array indexing like device_name[0], device_name[1], etc.",
    "concepts": [
      "char arrays (strings) vs int arrays",
      "string initialization with literals",
      "null terminator concept (\\0)",
      "array indexing for characters",
      "manual character counting",
      "character-by-character assignment"
    ],
    "skills": [
      "Treating strings like arrays",
      "Using array indexing for characters",
      "Understanding null termination",
      "Manual character operations",
      "No-pointer string manipulation"
    ],
    "files": [
      {
        "name": "strings.h",
        "content": "#ifndef STRINGS_H\n#define STRINGS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/string.h>\n\n#define MAX_NAME_SIZE 32\n#define MAX_MESSAGE_SIZE 64\n\nextern char device_name[MAX_NAME_SIZE];\nextern char welcome_msg[MAX_MESSAGE_SIZE];\nextern int name_len;\n\n/* TODO: Declare your functions (no pointers!) */\n/* void show_device_info(void); */\n/* void count_device_name_length(void); */\n/* void update_to_new_device(void); */\n\n#endif /* STRINGS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "strings.c",
        "content": "#include \"strings.h\"\n\n/* TODO: Initialize your string arrays (just like int arrays!) */\n/* char device_name[MAX_NAME_SIZE] = \"my_device\"; */\n/* char welcome_msg[MAX_MESSAGE_SIZE] = \"Hello from kernel!\"; */\nint name_len = 0;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your string operations work\n * with different input values. Removing them will cause test failures.\n */\nmodule_param_string(device_name, device_name, MAX_NAME_SIZE, 0644);\nMODULE_PARM_DESC(device_name, \"Device name for testing string operations\");\nmodule_param_string(welcome_msg, welcome_msg, MAX_MESSAGE_SIZE, 0644);\nMODULE_PARM_DESC(welcome_msg, \"Welcome message for string operations\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* TODO: Implement function to show device information */\n/* Print device name and its length using printk */\n/* Format: \"Device: [name], Length: [X]\" */\n\n/* TODO: Implement function to count device_name length manually */\n/* Count characters in device_name until you find '\\0' */\n/* Use a for loop like: for (i = 0; i < MAX_NAME_SIZE; i++) */\n/* Update the global name_len variable */\n\n/* TODO: Implement function to manually copy \"new_device\" */\n/* Copy each character one by one: device_name[0] = 'n', device_name[1] = 'e', etc. */\n/* Don't forget to add null terminator at the end: device_name[10] = '\\0' */\n/* Call count_device_name_length() to update name_len */\n\nstatic int __init strings_init(void)\n{\n    printk(KERN_INFO \"String basics module loaded\\n\");\n    \n    /* TODO: Calculate length of device name */\n    /* count_device_name_length(); */\n    \n    /* TODO: Show initial device info */\n    /* show_device_info(); */\n    \n    /* TODO: Print the welcome message */\n/* printk(KERN_INFO \"Message: %s\\n\", welcome_msg); */\n    \n    /* TODO: Update to new device name and show info */\n    /* update_to_new_device(); */\n    /* printk(KERN_INFO \"After name change:\\n\"); */\n    /* show_device_info(); */\n    \n    return 0;\n}\n\nstatic void __exit strings_exit(void)\n{\n    printk(KERN_INFO \"String basics module unloaded\\n\");\n}\n\nmodule_init(strings_init);\nmodule_exit(strings_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning strings as character arrays\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# String basics module Makefile\nobj-m += strings.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "strings.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "strings_init",
          "strings_exit",
          "show_device_info",
          "count_device_name_length",
          "update_to_new_device"
        ],
        "variables": [
          {
            "name": "device_name[]",
            "type": "char",
            "value": "\"my_device\""
          },
          {
            "name": "welcome_msg[]",
            "type": "char",
            "value": "\"Hello from kernel!\""
          },
          {
            "name": "name_len",
            "type": "int",
            "value": " 0"
          }
        ],
        "outputMessages": [
          "String basics module loaded",
          "Device: my_device, Length: 9",
          "Message: Hello from kernel!",
          "After name change:",
          "Device: new_device, Length: 10"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/string.h"
        ],
        "mustContain": [
          "#define MAX_NAME_SIZE 32",
          "#define MAX_MESSAGE_SIZE 64",
          "char device_name[MAX_NAME_SIZE]",
          "char welcome_msg[MAX_MESSAGE_SIZE]"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header (No Pointers)",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void show_device_info(void)",
            "void count_device_name_length(void)",
            "void update_to_new_device(void)"
          ],
          "prohibitedSymbols": [
            "const char \\*",
            "char \\*"
          ]
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File (No Pointers)",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void show_device_info(void)",
            "void count_device_name_length(void)",
            "void update_to_new_device(void)",
            "static int __init strings_init(void)",
            "static void __exit strings_exit(void)"
          ],
          "prohibitedSymbols": [
            "const char \\*",
            "char \\*"
          ]
        },
        {
          "id": "exact_output",
          "name": "Expected Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "String basics module loaded",
              "exact": true,
              "linkedFunction": "static int __init strings_init(void)"
            },
            {
              "pattern": "Device: my_device, Length: 9",
              "exact": true,
              "linkedFunction": "void show_device_info(void)"
            },
            {
              "pattern": "Message: Hello from kernel!",
              "exact": true,
              "linkedFunction": "static int __init strings_init(void)"
            },
            {
              "pattern": "After name change:",
              "exact": true,
              "linkedFunction": "static int __init strings_init(void)"
            },
            {
              "pattern": "Device: new_device, Length: 10",
              "exact": true,
              "linkedFunction": "void show_device_info(void)"
            }
          ]
        },
        {
          "id": "basic_string_implementation_validation",
          "name": "Basic String Implementation with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "string_dynamic_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\"=== Dynamic String Implementation Test ===\\\\n\");\\n    \\n    // Generate randomized test cases\\n    const char* device_names[] = {\\\"sensor\\\", \\\"device\\\", \\\"module\\\", \\\"driver\\\", \\\"kernel\\\", \\\"system\\\"};\\n    const char* messages[] = {\\\"Hello\\\", \\\"Greetings\\\", \\\"Welcome\\\", \\\"Status\\\", \\\"Testing\\\", \\\"Active\\\"};\\n    \\n    srand(time(NULL));\\n    int name_idx = rand() % 6;\\n    int msg_idx = rand() % 6;\\n    \\n    printf(\\\"Test 1: Testing with device_name='%s' and welcome_msg='%s'\\\\n\\\", device_names[name_idx], messages[msg_idx]);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/strings.ko device_name=%s welcome_msg=%s\\\", device_names[name_idx], messages[msg_idx]);\\n    system(\\\"rmmod strings 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    // Generate second test with different values\\n    int name_idx2 = (name_idx + 2) % 6;\\n    int msg_idx2 = (msg_idx + 3) % 6;\\n    \\n    printf(\\\"Test 2: Testing with device_name='%s' and welcome_msg='%s'\\\\n\\\", device_names[name_idx2], messages[msg_idx2]);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/strings.ko device_name=%s welcome_msg=%s\\\", device_names[name_idx2], messages[msg_idx2]);\\n    system(\\\"rmmod strings\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Dynamic string test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting basic string implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param_string(name, string, len, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef unsigned long size_t;' > /tmp/linux/string.h",
              "echo 'size_t strlen(const char *s);' >> /tmp/linux/string.h",
              "echo 'Creating test file that includes student header...'",
              "echo '#include \"/lib/modules/strings.h\"' > /tmp/test.c",
              "echo 'int main() { show_device_info(); count_device_name_length(); update_to_new_device(); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: All function declarations found in header file'",
              "echo 'Phase 2: Dynamic String Implementation Testing'",
              "/bin/string_dynamic_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Dynamic Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "TEST1_DEVICE=$(grep -o \"Test 1: Testing with device_name='[^']*'\" /tmp/test_output.log | cut -d\"'\" -f2)",
              "TEST1_MESSAGE=$(grep -o \"Test 1: Testing with device_name='[^']*' and welcome_msg='[^']*'\" /tmp/test_output.log | cut -d\"'\" -f4)",
              "TEST2_DEVICE=$(grep -o \"Test 2: Testing with device_name='[^']*'\" /tmp/test_output.log | cut -d\"'\" -f2)",
              "TEST2_MESSAGE=$(grep -o \"Test 2: Testing with device_name='[^']*' and welcome_msg='[^']*'\" /tmp/test_output.log | cut -d\"'\" -f4)",
              "echo \"Test 1 device: '$TEST1_DEVICE', message: '$TEST1_MESSAGE'\"",
              "echo \"Test 2 device: '$TEST2_DEVICE', message: '$TEST2_MESSAGE'\"",
              "echo 'Calculating expected string lengths...'",
              "TEST1_EXPECTED_LEN=$(echo -n \"$TEST1_DEVICE\" | awk '{print length}')",
              "TEST2_EXPECTED_LEN=$(echo -n \"$TEST2_DEVICE\" | awk '{print length}')",
              "echo \"Expected: $TEST1_DEVICE = $TEST1_EXPECTED_LEN chars, $TEST2_DEVICE = $TEST2_EXPECTED_LEN chars\"",
              "echo 'Validating Test 1 string operations'",
              "dmesg | grep \"Device: $TEST1_DEVICE, Length: $TEST1_EXPECTED_LEN\" && echo 'PASS: Test 1 device name and length correct' || echo \"FAIL: Test 1 length wrong - expected $TEST1_EXPECTED_LEN for '$TEST1_DEVICE'\"",
              "dmesg | grep \"Message: $TEST1_MESSAGE\" && echo 'PASS: Test 1 message correct' || echo 'FAIL: Test 1 message wrong'",
              "echo 'Validating Test 2 string operations'",
              "dmesg | grep \"Device: $TEST2_DEVICE, Length: $TEST2_EXPECTED_LEN\" && echo 'PASS: Test 2 device name and length correct' || echo \"FAIL: Test 2 length wrong - expected $TEST2_EXPECTED_LEN for '$TEST2_DEVICE'\"",
              "dmesg | grep \"Message: $TEST2_MESSAGE\" && echo 'PASS: Test 2 message correct' || echo 'FAIL: Test 2 message wrong'",
              "echo 'Validating function behavior (new_device length should be 10)'",
              "dmesg | grep 'Device: new_device, Length: 10' && echo 'PASS: new_device length calculation correct' || echo 'FAIL: new_device length wrong - expected 10'",
              "dmesg | grep 'After name change:' && echo 'PASS: Name change function working' || echo 'FAIL: Name change function broken'",
              "echo 'All dynamic string validations completed'"
            ],
            "expected": {
              "dmesg": [
                "String basics module loaded",
                "Device: .* Length: .*",
                "Message: .*",
                "After name change:",
                "Device: .* Length: .*"
              ],
              "stdout": [
                "PASS: All function declarations found in header file",
                "SUCCESS: Dynamic string test completed",
                "PASS: Test 1 device name and length correct",
                "PASS: Test 1 message correct",
                "PASS: Test 2 device name and length correct",
                "PASS: Test 2 message correct",
                "PASS: new_device length calculation correct",
                "PASS: Name change function working"
              ]
            },
            "timeout": 30
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "String basics module loaded",
        "Device: my_device, Length: 9",
        "Message: Hello from kernel!",
        "After name change:",
        "Device: new_device, Length: 10"
      ],
      "requirements": [
        "Use required function names: strings_init, strings_exit, show_device_info, count_device_name_length, update_to_new_device",
        "Use required variable names: device_name[], welcome_msg[], name_len",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/string.h",
        "Code must contain: #define MAX_NAME_SIZE 32, #define MAX_MESSAGE_SIZE 64, char device_name[MAX_NAME_SIZE], char welcome_msg[MAX_MESSAGE_SIZE]",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "String basics module loaded",
          "linkedFunction": "static int __init strings_init(void)",
          "exact": true
        },
        {
          "pattern": "Device: my_device, Length: 9",
          "linkedFunction": "void show_device_info(void)",
          "exact": true
        },
        {
          "pattern": "Message: Hello from kernel!",
          "linkedFunction": "static int __init strings_init(void)",
          "exact": true
        },
        {
          "pattern": "After name change:",
          "linkedFunction": "static int __init strings_init(void)",
          "exact": true
        },
        {
          "pattern": "Device: new_device, Length: 10",
          "linkedFunction": "void show_device_info(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 15,
    "title": "Basic Pointers - Introduction to Memory Addresses",
    "difficulty": 3,
    "xp": 25,
    "phase": "foundations",
    "description": "Learn the fundamental concepts of pointers in C. Understand what pointers are, how to declare them, use the address-of operator (&), dereference operator (*), and perform basic operations with integers and arrays through pointers.",
    "concepts": [
      "basic pointer declaration",
      "address-of operator (&)",
      "dereference operator (*)",
      "pointer initialization",
      "array access through pointers",
      "modifying values through pointers"
    ],
    "skills": [
      "Understanding what pointers are",
      "Declaring and initializing pointers",
      "Using & to get addresses",
      "Using * to access values through pointers",
      "Basic pointer arithmetic with arrays",
      "Modifying variables through pointers"
    ],
    "files": [
      {
        "name": "basic_pointers.h",
        "content": "#ifndef BASIC_POINTERS_H\n#define BASIC_POINTERS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* Global variables for testing */\nextern int number;\nextern int array[5];\nextern int *number_ptr;\nextern int *array_ptr;\n\n/* TODO: Declare your pointer functions */\n/* void print_number_info(void); */\n/* void modify_through_pointer(int *ptr, int new_value); */\n/* void print_array_through_pointer(int *ptr); */\n\n#endif /* BASIC_POINTERS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "basic_pointers.c",
        "content": "#include \"basic_pointers.h\"\n\n/* Global variables */\nint number = 42;\nint array[5] = {10, 20, 30, 40, 50};\nint *number_ptr = NULL;\nint *array_ptr = NULL;\n\nint test_value = 42;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your pointer logic works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(test_value, int, 0644);\nMODULE_PARM_DESC(test_value, \"Test value for anti-hardcoding validation\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: Complete Beginner's Guide to Pointers */\n/* WHAT IS A POINTER? */\n/* A pointer is a variable that stores a MEMORY ADDRESS of another variable */\n/* Think of it like a home address - it tells you WHERE something is located */\n\n/* SIMPLE EXAMPLE TO UNDERSTAND POINTERS: */\n/* int a = 5; */\n/* int* ptr = &a;      // ptr points to a */\n/* */\n/* What Each Contains: */\n/* a = 5                    // The value */\n/* ptr = &a                 // Address of a (like 0x1000) */\n/* *ptr = 5                 // Value at the address ptr points to */\n\n/* THE TWO IMPORTANT OPERATORS: */\n/* & = \"address-of\" operator - gets the address where a variable lives */\n/* * = \"dereference\" operator - gets the value at an address */\n\n/* REAL WORLD ANALOGY: */\n/* Variable 'a' is like a house with the number 5 painted on it */\n/* &a is like the street address of that house (e.g., \"123 Main St\") */\n/* ptr is like writing down that address on paper */\n/* *ptr is like going to that address and reading the number on the house */\n\n/* DETAILED EXPLANATION OF POINTER DECLARATION: */\n/* int* ptr;        // Declares a pointer that can point to an integer */\n/*                  // ptr can store the address of an int variable */\n/*                  // RIGHT NOW ptr contains garbage - don't use it yet! */\n/* */\n/* int a = 5;       // Create an integer variable with value 5 */\n/* ptr = &a;        // Make ptr point to variable a */\n/*                  // Now ptr contains the address where a lives */\n\n/* WHAT HAPPENS IN MEMORY: */\n/* Memory Address: 0x1000    0x2000 */\n/*    */\n/*  a = 5          ptr = 0x1000     */\n/*    */\n/*                    */\n/*                    ptr points to this address */\n/*    a lives here */\n\n/* THE & OPERATOR (ADDRESS-OF): */\n/* &a means \"give me the address where variable a is stored\" */\n/* If a is stored at memory address 0x1000, then &a = 0x1000 */\n/* */\n/* EXAMPLES: */\n/* int a = 5; */\n/* printk(\"%d\", a);    // Prints: 5 (the value) */\n/* printk(\"%p\", &a);   // Prints: 0x1000 (the address) */\n\n/* THE * OPERATOR (DEREFERENCE): */\n/* *ptr means \"go to the address stored in ptr and get the value there\" */\n/* If ptr contains 0x1000, then *ptr gets the value at address 0x1000 */\n/* */\n/* EXAMPLES: */\n/* int a = 5; */\n/* int* ptr = &a; */\n/* printk(\"%p\", ptr);   // Prints: 0x1000 (the address) */\n/* printk(\"%d\", *ptr);  // Prints: 5 (the value at that address) */\n\n/* COMMON BEGINNER MISTAKES: */\n/* MISTAKE 1: Confusing & and * */\n/*   int a = 5; */\n/*   int* ptr = a;        // WRONG: ptr expects an address, not a value */\n/* CORRECT: */\n/*   int* ptr = &a;       // CORRECT: ptr gets the address of a */\n/* */\n/* MISTAKE 2: Using * when you want the address */\n/*   printk(\"%p\", *ptr);  // WRONG: *ptr gives value, not address */\n/* CORRECT: */\n/*   printk(\"%p\", ptr);   // CORRECT: ptr contains the address */\n/* */\n/* MISTAKE 3: Using uninitialized pointers */\n/*   int* ptr;            // ptr contains garbage */\n/*   *ptr = 5;            // WRONG: writing to random memory! */\n/* CORRECT: */\n/*   int a; */\n/*   int* ptr = &a;       // Initialize ptr first */\n/*   *ptr = 5;            // CORRECT: now a = 5 */\n\n/* POINTER ARITHMETIC WITH ARRAYS: */\n/* Arrays and pointers are closely related in C */\n/* */\n/* int arr[5] = {10, 20, 30, 40, 50}; */\n/* int* ptr = arr;              // Same as ptr = &arr[0] */\n/* */\n/* printk(\"%d\", *ptr);         // Prints: 10 (first element) */\n/* printk(\"%d\", *(ptr + 1));   // Prints: 20 (second element) */\n/* printk(\"%d\", *(ptr + 2));   // Prints: 30 (third element) */\n/* */\n/* WHY ptr + 1 WORKS: */\n/* - ptr points to arr[0] at address 0x1000 */\n/* - ptr + 1 points to arr[1] at address 0x1004 (4 bytes later for int) */\n/* - *(ptr + 1) gets the value at arr[1] */\n\n/* VISUALIZING ARRAY POINTER ARITHMETIC: */\n/* Array: [10][20][30][40][50] */\n/* Addr:  1000 1004 1008 1012 1016 */\n/* */\n/* ptr + 0  1000  *ptr = 10 */\n/* ptr + 1  1004  *(ptr+1) = 20 */\n// Explanation (ptr+1) means adding  specified bytes  (sizeof(int)) to memory address of array , moving it to next position / next address \n// Adding +1 to the pointer value, which moves it to the next int. To get the value we add asterisk : *(ptr+1)\n/* ptr + 2  1008  *(ptr+2) = 30 */\n\n/* MODIFYING VALUES THROUGH POINTERS: */\n/* Once you have a pointer, you can change the original variable */\n/* */\n/* int a = 5; */\n/* int* ptr = &a; */\n/* *ptr = 10;               // Changes a to 10! */\n/* printk(\"%d\", a);         // Prints: 10 */\n/* */\n/* This is powerful because functions can modify caller's variables */\n\n/* PRACTICAL EXAMPLES FOR THIS PROBLEM: */\n/* Example 1: Basic pointer operations */\n/* int number = 42; */\n/* int* number_ptr = &number;       // Point to number */\n/* printk(\"Value: %d\", *number_ptr); // Prints: 42 */\n/* *number_ptr = 100;               // Changes number to 100 */\n/* */\n/* Example 2: Array access through pointers */\n/* int array[5] = {10, 20, 30, 40, 50}; */\n/* int* array_ptr = array;          // Point to first element */\n/* printk(\"First: %d\", *array_ptr); // Prints: 10 */\n/* printk(\"Second: %d\", *(array_ptr + 1)); // Prints: 20 */\n\n/* MEMORY SAFETY REMINDERS: */\n/* - Always initialize pointers before using them */\n/* - Don't dereference NULL pointers */\n/* - Don't access array elements beyond bounds */\n/* - In kernel space, use proper allocation/deallocation */\n\n/* WHY LEARN POINTERS? */\n/* Pointers are fundamental to: */\n/* - Dynamic memory allocation */\n/* - Passing large data structures efficiently */\n/* - Implementing data structures (linked lists, trees) */\n/* - System programming and kernel development */\n/* - Understanding how computers actually work */\n\n/* TODO: Implement function to print number and pointer info */\nvoid print_number_info(void) {\n    /* TODO: Print the value of 'number' using direct access */\n    /* Format: \"Number value: %d\" */\n    \n    /* TODO: Print the address of 'number' using &number */\n    /* Format: \"Number address: %p\" */\n    \n    /* TODO: Print the value of 'number_ptr' (should be address of number) */\n    /* Format: \"Pointer value (address it points to): %p\" */\n    \n    /* TODO: Print the value that number_ptr points to using *number_ptr */\n    /* Format: \"Value through pointer: %d\" */\n    \n    /* Use printk(KERN_INFO \"...\", ...) for each line */\n}\n\n/* TODO: Implement function to modify value through pointer */\nvoid modify_through_pointer(int *ptr, int new_value) {\n    /* TODO: Check if ptr is not NULL */\n    /* TODO: Use *ptr = new_value to modify the value at the address */\n    /* TODO: Print confirmation message with new value */\n    /* Format: \"Modified value through pointer to: %d\" */\n}\n\n/* TODO: Implement function to print array elements through pointer */\nvoid print_array_through_pointer(int *ptr) {\n    /* TODO: Print first element using *ptr */\n    /* TODO: Print second element using *(ptr + 1) */\n    /* TODO: Print third element using *(ptr + 2) */\n    /* Use format: \"Array element %d: %d\" where first %d is position (0,1,2) */\n    /* This demonstrates basic pointer arithmetic */\n}\n\nstatic int __init basic_pointers_init(void)\n{\n    printk(KERN_INFO \"Basic pointers module loaded\\n\");\n    \n    /* Step 1: Initialize pointers */\n    number = test_value;  /* Use dynamic test value */\n    number_ptr = &number;  /* Point to number variable */\n    array_ptr = array;     /* Point to first element of array */\n    \n    printk(KERN_INFO \"=== Basic Pointer Demonstration ===\");\n    \n    /* Step 2: Show basic pointer information */\n    print_number_info();\n    \n    /* Step 3: Modify value through pointer */\n    modify_through_pointer(number_ptr, 999);\n    \n    /* Step 4: Show array access through pointer */\n    printk(KERN_INFO \"Array elements through pointer:\");\n    print_array_through_pointer(array_ptr);\n    \n    /* Step 5: Show final state */\n    printk(KERN_INFO \"Final number value: %d\", number);\n    \n    return 0;\n}\n\nstatic void __exit basic_pointers_exit(void)\n{\n    printk(KERN_INFO \"Basic pointers module unloaded\\n\");\n    \n    /* Reset pointers to NULL for safety */\n    number_ptr = NULL;\n    array_ptr = NULL;\n}\n\nmodule_init(basic_pointers_init);\nmodule_exit(basic_pointers_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning basic pointer concepts with integers and arrays\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Basic pointers module Makefile\nobj-m += basic_pointers.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "basic_pointers.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "basic_pointers_init",
          "basic_pointers_exit",
          "print_number_info",
          "modify_through_pointer",
          "print_array_through_pointer"
        ],
        "function_declarations": [
          {
            "name": "print_number_info",
            "returnType": "void",
            "parameters": []
          },
          {
            "name": "modify_through_pointer",
            "returnType": "void",
            "parameters": [
              "int *ptr",
              "int new_value"
            ]
          },
          {
            "name": "print_array_through_pointer",
            "returnType": "void",
            "parameters": [
              "int *ptr"
            ]
          }
        ],
        "variables_declarations": [
          {
            "name": "number",
            "type": "int",
            "storageClass": "extern"
          },
          {
            "name": "array",
            "type": "int",
            "storageClass": "extern"
          },
          {
            "name": "number_ptr",
            "type": "int *",
            "storageClass": "extern"
          },
          {
            "name": "array_ptr",
            "type": "int *",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "number",
            "type": "int",
            "value": "42",
            "storageClass": "none"
          },
          {
            "name": "array",
            "type": "int",
            "value": "{10, 20, 30, 40, 50}",
            "storageClass": "none"
          },
          {
            "name": "number_ptr",
            "type": "int *",
            "value": "NULL",
            "storageClass": "none"
          },
          {
            "name": "array_ptr",
            "type": "int *",
            "value": "NULL",
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Basic pointers module loaded",
          "=== Basic Pointer Demonstration ===",
          "Number value: 42",
          "Number address: (____ptrval____)",
          "Pointer value (address it points to): (____ptrval____)",
          "Value through pointer: 42",
          "Modified value through pointer to: 999",
          "Array elements through pointer:",
          "Array element 0: 10",
          "Array element 1: 20",
          "Array element 2: 30",
          "Final number value: 999",
          "Basic pointers module unloaded"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "&number",
          "*number_ptr",
          "number_ptr = &number",
          "array_ptr = array",
          "*(ptr + 1)",
          "*(ptr + 2)",
          "*ptr = new_value",
          "module_param(test_value, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_number_info(void)",
            "void modify_through_pointer(int *ptr, int new_value)",
            "void print_array_through_pointer(int *ptr)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_number_info(void)",
            "void modify_through_pointer(int *ptr, int new_value)",
            "void print_array_through_pointer(int *ptr)",
            "static int __init basic_pointers_init(void)",
            "static void __exit basic_pointers_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Basic pointers module loaded",
              "exact": true,
              "linkedFunction": "static int __init basic_pointers_init(void)"
            },
            {
              "pattern": "=== Basic Pointer Demonstration ===",
              "exact": true,
              "linkedFunction": "static int __init basic_pointers_init(void)"
            },
            {
              "pattern": "Number value: 42",
              "exact": true,
              "linkedFunction": "void print_number_info(void)"
            },
            {
              "pattern": "Number address: (____ptrval____)",
              "exact": true,
              "linkedFunction": "void print_number_info(void)"
            },
            {
              "pattern": "Pointer value (address it points to): (____ptrval____)",
              "exact": true,
              "linkedFunction": "void print_number_info(void)"
            },
            {
              "pattern": "Value through pointer: 42",
              "exact": true,
              "linkedFunction": "void print_number_info(void)"
            },
            {
              "pattern": "Modified value through pointer to: 999",
              "exact": true,
              "linkedFunction": "void modify_through_pointer(int *ptr, int new_value)"
            },
            {
              "pattern": "Array elements through pointer:",
              "exact": true,
              "linkedFunction": "static int __init basic_pointers_init(void)"
            },
            {
              "pattern": "Array element 0: 10",
              "exact": true,
              "linkedFunction": "void print_array_through_pointer(int *ptr)"
            },
            {
              "pattern": "Array element 1: 20",
              "exact": true,
              "linkedFunction": "void print_array_through_pointer(int *ptr)"
            },
            {
              "pattern": "Array element 2: 30",
              "exact": true,
              "linkedFunction": "void print_array_through_pointer(int *ptr)"
            },
            {
              "pattern": "Final number value: 999",
              "exact": true,
              "linkedFunction": "static int __init basic_pointers_init(void)"
            },
            {
              "pattern": "Basic pointers module unloaded",
              "exact": true,
              "linkedFunction": "static void __exit basic_pointers_exit(void)"
            }
          ]
        },
        {
          "id": "basic_pointer_validation",
          "name": "Basic Pointer Operations with Anti-Hardcoding Protection",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "basic_pointer_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Basic Pointer Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate unpredictable test values\\n    int random_value = (rand() % 900) + 100;  // 100-999\\n    \\n    printf(\\\"Test 1: Random pointer operations (value=%d)\\\\n\\\", random_value);\\n    \\n    // Test with random values\\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod basic_pointers 2>/dev/null\\\");\\n    \\n    char cmd[256];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/basic_pointers.ko test_value=%d\\\", random_value);\\n    printf(\\\"DEBUG: Command: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Anti-hardcoding basic pointer test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting basic pointer implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef unsigned char uint8_t;' > /tmp/linux/types.h",
              "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
              "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
              "echo 'Creating test file that includes basic pointers header...'",
              "echo '#include \"/lib/modules/basic_pointers.h\"' > /tmp/test.c",
              "echo 'int main() { number = 123; print_number_info(); modify_through_pointer(&number, 456); print_array_through_pointer(array); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
              "echo 'Phase 2: Anti-Hardcoding Dynamic Basic Pointer Test'",
              "/bin/basic_pointer_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Random Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "TEST_VALUE=$(grep -o 'Random pointer operations (value=[0-9]*)' /tmp/test_output.log | cut -d'=' -f2 | cut -d')' -f1)",
              "echo 'Extracted values: TEST_VALUE='$TEST_VALUE",
              "if [ -z \"$TEST_VALUE\" ]; then echo 'FAIL: Could not extract random test values'; else echo 'PASS: Random values extracted successfully'; fi",
              "echo 'Phase 4: Anti-Hardcoding Validation with Random Values'",
              "echo 'Validating basic pointer operations with random value '$TEST_VALUE",
              "dmesg | grep \"Number value: $TEST_VALUE\" && echo 'PASS: Basic pointer dereference with random value working' || echo 'FAIL: Basic pointer dereference with random value broken'",
              "echo 'Phase 5: Static Field Validation (Non-Randomized Fields)'",
              "dmesg | grep 'Modified value through pointer to: 999' && echo 'PASS: Pointer modification working' || echo 'FAIL: Pointer modification broken'",
              "dmesg | grep 'Array element 0: 10' && echo 'PASS: Array pointer access working' || echo 'FAIL: Array pointer access broken'",
              "dmesg | grep 'Array element 1: 20' && echo 'PASS: Pointer arithmetic working' || echo 'FAIL: Pointer arithmetic broken'",
              "dmesg | grep 'Final number value: 999' && echo 'PASS: Pointer modification persistent' || echo 'FAIL: Pointer modification not persistent'",
              "echo 'Phase 6: Basic Pointer Logic Validation'",
              "dmesg | grep '=== Basic Pointer Demonstration ===' && echo 'PASS: Module demonstration working' || echo 'FAIL: Module demonstration broken'",
              "dmesg | grep 'Basic pointers module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
              "dmesg | grep 'Basic pointers module unloaded' && echo 'PASS: Module cleanup working' || echo 'FAIL: Module cleanup broken'",
              "echo 'Phase 7: Final Validation Summary'",
              "echo 'All phases completed successfully - anti-hardcoding basic pointer protection verified'",
              "echo 'PASS: All anti-hardcoding basic pointer validation successful'"
            ],
            "expected": {
              "dmesg": [
                "Basic pointers module loaded",
                "=== Basic Pointer Demonstration ===",
                "Number value: .*",
                "Modified value through pointer to: 999",
                "Array elements through pointer:",
                "Array element 0: 10",
                "Array element 1: 20",
                "Array element 2: 30",
                "Final number value: 999",
                "Basic pointers module unloaded"
              ],
              "stdout": [
                "PASS: All function and variable declarations found in header file",
                "SUCCESS: Anti-hardcoding basic pointer test completed",
                "PASS: Random values extracted successfully",
                "PASS: Basic pointer dereference with random value working",
                "PASS: Pointer modification working",
                "PASS: Array pointer access working",
                "PASS: Pointer arithmetic working",
                "PASS: Pointer modification persistent",
                "PASS: Module demonstration working",
                "PASS: Module initialization working",
                "PASS: Module cleanup working",
                "PASS: All anti-hardcoding basic pointer validation successful"
              ]
            },
            "timeout": 15
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Basic pointers module loaded",
        "=== Basic Pointer Demonstration ===",
        "Number value: 42",
        "Number address: (____ptrval____)",
        "Pointer value (address it points to): (____ptrval____)",
        "Value through pointer: 42",
        "Modified value through pointer to: 999",
        "Array elements through pointer:",
        "Array element 0: 10",
        "Array element 1: 20",
        "Array element 2: 30",
        "Final number value: 999",
        "Basic pointers module unloaded"
      ],
      "requirements": [
        "Use required function names: basic_pointers_init, basic_pointers_exit, print_number_info, modify_through_pointer, print_array_through_pointer",
        "Use required variable names: number, array, number_ptr, array_ptr",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: &number, *number_ptr, number_ptr = &number, array_ptr = array, *(ptr + 1), *(ptr + 2), *ptr = new_value, module_param(test_value, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Basic pointers module loaded",
          "linkedFunction": "static int __init basic_pointers_init(void)",
          "exact": true
        },
        {
          "pattern": "=== Basic Pointer Demonstration ===",
          "linkedFunction": "static int __init basic_pointers_init(void)",
          "exact": true
        },
        {
          "pattern": "Number value: 42",
          "linkedFunction": "void print_number_info(void)",
          "exact": true
        },
        {
          "pattern": "Number address: (____ptrval____)",
          "linkedFunction": "void print_number_info(void)",
          "exact": true
        },
        {
          "pattern": "Pointer value (address it points to): (____ptrval____)",
          "linkedFunction": "void print_number_info(void)",
          "exact": true
        },
        {
          "pattern": "Value through pointer: 42",
          "linkedFunction": "void print_number_info(void)",
          "exact": true
        },
        {
          "pattern": "Modified value through pointer to: 999",
          "linkedFunction": "void modify_through_pointer(int *ptr, int new_value)",
          "exact": true
        },
        {
          "pattern": "Array elements through pointer:",
          "linkedFunction": "static int __init basic_pointers_init(void)",
          "exact": true
        },
        {
          "pattern": "Array element 0: 10",
          "linkedFunction": "void print_array_through_pointer(int *ptr)",
          "exact": true
        },
        {
          "pattern": "Array element 1: 20",
          "linkedFunction": "void print_array_through_pointer(int *ptr)",
          "exact": true
        },
        {
          "pattern": "Array element 2: 30",
          "linkedFunction": "void print_array_through_pointer(int *ptr)",
          "exact": true
        },
        {
          "pattern": "Final number value: 999",
          "linkedFunction": "static int __init basic_pointers_init(void)",
          "exact": true
        },
        {
          "pattern": "Basic pointers module unloaded",
          "linkedFunction": "static void __exit basic_pointers_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 16,
    "title": "Basic Structures - Organizing Related Data",
    "difficulty": 4,
    "xp": 40,
    "phase": "foundations",
    "description": "Learn to create and use basic structures to organize related data together. This introduces simple data modeling patterns essential for kernel development where structures represent system information.",
    "concepts": [
      "structure definition",
      "structure initialization",
      "structure member access",
      "designated initializers",
      "dot notation"
    ],
    "skills": [
      "Defining custom data types",
      "Organizing related data",
      "Direct structure access",
      "Structure member usage",
      "Basic data modeling"
    ],
    "files": [
      {
        "name": "structures.h",
        "content": "#ifndef STRUCTURES_H\n#define STRUCTURES_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n#define MAX_NAME_LEN 32\n\n/* PATTERN SCAFFOLDING: How to define and use basic structures in C */\n/* Basic pattern for organizing related data together:\n *\n * struct type_name {\n *     data_type field_name;\n *     data_type another_field;\n * };\n *\n * This groups related information together instead of separate variables\n */\n\n/* WHAT A STRUCTURE DEFINITION CONTAINS: */\n\n/* 1. struct keyword - Tells compiler this is a structure definition */\n/*    Usage: struct starts the definition */\n/*    Example: struct student means \"define a student structure type\" */\n\n/* 2. Structure name - The type name for this structure */\n/*    Usage: Used when creating variables of this type */\n/*    Example: student becomes the type name, like int or char */\n\n/* 3. Field definitions - The data members inside the structure */\n/*    Usage: Each field has a type and name */\n/*    Example: int id; means \"this structure has an integer field called id\" */\n\n/* 4. Closing brace and semicolon - Required to end the definition */\n/*    Usage: }; closes the structure definition */\n/*    Example: Always end structure definitions with }; */\n\n/* STRUCTURE VS SEPARATE VARIABLES COMPARISON: */\n/* Without structures (messy): */\n/* int student_id; */\n/* char student_name[32]; */\n/* int student_grade; */\n/* bool student_passed; */\n/* \n/* With structures (organized): */\n/* struct student { */\n/*     int id; */\n/*     char name[32]; */\n/*     int grade; */\n/*     bool passed; */\n/* }; */\n/* Same data, but grouped logically! */\n\n/* TODO: Define student structure with these fields: */\n/* - int id: Student identification number (like 12345) */\n/* - char name[MAX_NAME_LEN]: Student's full name (like \"Alice Smith\") */\n/* - int grade: Student's current grade percentage (0-100) */\n/* - bool passed: Whether student passed (true) or failed (false) */\n/* Remember: Use struct keyword, then student as type name, then { fields } */\nstruct student {\n    // Your structure definition here\n    // Format: data_type field_name;\n};\n\nextern struct student my_student;\n\n/* TODO: Declare your functions */\n/* Function to print all student information */\nvoid print_student_info(void);\n\n/* Function to check and print student pass/fail status */\nvoid check_student_status(void);\n\n#endif /* STRUCTURES_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "structures.c",
        "content": "#include \"structures.h\"\n\n/* PATTERN SCAFFOLDING: How to initialize and use structures in C */\n/* Basic pattern for creating and initializing a structure variable:\n *\n * struct type_name variable_name = {\n *     .field_name = value,\n *     .another_field = another_value\n * };\n *\n * This creates a variable of the structure type with initial values\n */\n\n/* WHAT STRUCTURE INITIALIZATION CONTAINS: */\n\n/* 1. struct type_name - The structure type we defined in the header */\n/*    Usage: Tells compiler what type of structure this is */\n/*    Example: struct student means \"this is a student structure variable\" */\n\n/* 2. variable_name - The actual variable name */\n/*    Usage: This becomes the variable we can use in our code */\n/*    Example: my_student becomes the variable name */\n\n/* 3. Designated initializers - The .field = value syntax */\n/*    Usage: Sets specific fields to specific values */\n/*    Example: .id = 12345 means \"set the id field to 12345\" */\n/*    Why this way? Clear, readable, and order-independent! */\n\n/* DOT OPERATOR EXPLAINED IN DETAIL: */\n/* variable.field_name means \"access field_name inside variable\" */\n\n/* HOW DOT OPERATOR WORKS: */\n/* 1. my_student.id - Gets the id field from my_student */\n/*    Contains: The integer value stored in the id field */\n/*    Usage: Can read or write: my_student.id = 99999; */\n/*    Example: printk(\"%d\", my_student.id) prints the student's ID */\n\n/* 2. my_student.name - Gets the name array from my_student */\n/*    Contains: The character array (string) stored in name field */\n/*    Usage: Can read: printk(\"%s\", my_student.name) */\n/*    Note: String fields need special handling for assignment */\n\n/* 3. my_student.grade - Gets the grade field from my_student */\n/*    Contains: The integer percentage stored in grade field */\n/*    Usage: Can read or write: my_student.grade = 95; */\n\n/* 4. my_student.passed - Gets the boolean field from my_student */\n/*    Contains: true (1) or false (0) */\n/*    Usage: Can use in if statements: if (my_student.passed) */\n\n/* MEMORY LAYOUT VISUALIZATION: */\n/* my_student variable in memory: */\n/*  */\n/*  [id: 12345][name: \"Alice Smith\"][grade: 85][passed: true]  */\n/*  */\n/* my_student.id points here                              */\n/* my_student.name points here                            */\n/* my_student.grade points here                           */\n/* my_student.passed points here                          */\n\n/* DESIGNATED INITIALIZER SYNTAX EXPLAINED: */\n/* .field_name = value means \"initialize field_name with value\" */\n/* Examples: */\n/* .id = 12345        - Set id field to integer 12345 */\n/* .name = \"Alice\"    - Set name field to string \"Alice\" */\n/* .grade = 85        - Set grade field to integer 85 */\n/* .passed = true     - Set passed field to boolean true */\n\n/* TODO: Initialize student structure using designated initializers */\n/* Use the pattern: struct student variable_name = { .field = value, ... } */\n/* Set these values: */\n/* - id: 12345 */\n/* - name: \"Alice Smith\" */\n/* - grade: 85 */\n/* - passed: true */\nstruct student my_student = {\n    // Your initialization here using .field_name = value syntax\n};\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your structure member access works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param_named(student_id, my_student.id, int, 0644);\nMODULE_PARM_DESC(student_id, \"Student ID for testing structure member access\");\nmodule_param_named(student_grade, my_student.grade, int, 0644);\nMODULE_PARM_DESC(student_grade, \"Student grade for testing structure member access\");\n/* Note: string and bool module params need special handling for structures */\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* TODO: Implement function to print student information using dot operator */\n/* Use my_student.field_name to access each field */\n/* Print format examples: */\n/* - \"Student ID: %d\" for integer fields */\n/* - \"Student Name: %s\" for string fields */\n/* Remember: my_student.id, my_student.name, my_student.grade */\nvoid print_student_info(void) {\n    // Your implementation here\n    // Use printk(KERN_INFO, \"format\", my_student.field_name);\n}\n\n/* TODO: Implement function to check student status using conditional logic */\n/* Use if statement with my_student.passed field */\n/* Boolean fields can be used directly in if conditions */\n/* Print \"Student Status: Passed\" if true, \"Student Status: Failed\" if false */\nvoid check_student_status(void) {\n    // Your implementation here\n    // Remember: my_student.passed is boolean (true/false)\n    // Use: if (my_student.passed) { ... } else { ... }\n}\n\nstatic int __init structures_init(void)\n{\n    printk(KERN_INFO \"Basic structures module loaded\\n\");\n    \n    /* TODO: Call your functions to demonstrate structure usage */\n    /* Call print_student_info() to show all student data */\n    /* Call check_student_status() to show pass/fail status */\n    \n    return 0;\n}\n\nstatic void __exit structures_exit(void)\n{\n    printk(KERN_INFO \"Basic structures module unloaded\\n\");\n}\n\nmodule_init(structures_init);\nmodule_exit(structures_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning basic structures and data organization\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Basic structures module Makefile\nobj-m += structures.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "structures.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "structures_init",
          "structures_exit",
          "print_student_info",
          "check_student_status"
        ],
        "function_declarations": [
          {
            "name": "print_student_info",
            "returnType": "void",
            "parameters": []
          },
          {
            "name": "check_student_status",
            "returnType": "void",
            "parameters": []
          }
        ],
        "variables_declarations": [
          {
            "name": "student",
            "type": "struct",
            "value": "{int id; char name[MAX_NAME_LEN]; int grade; bool passed;}",
            "storageClass": "none"
          },
          {
            "name": "my_student",
            "type": "struct student",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "my_student",
            "type": "struct student",
            "value": "{.id = 12345, .name = \"Alice Smith\", .grade = 85, .passed = true}",
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Basic structures module loaded",
          "Student ID: 12345",
          "Student Name: Alice Smith",
          "Student Grade: 85",
          "Student Status: Passed"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "struct student {",
          "extern struct student my_student",
          "struct student my_student = {",
          ".id = 12345",
          ".name = \"Alice Smith\"",
          ".grade = 85",
          ".passed = true",
          "module_param_named(student_id, my_student.id, int, 0644)",
          "module_param_named(student_grade, my_student.grade, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_student_info(void)",
            "void check_student_status(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_student_info(void)",
            "void check_student_status(void)",
            "static int __init structures_init(void)",
            "static void __exit structures_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Basic structures module loaded",
              "exact": true,
              "linkedFunction": "static int __init structures_init(void)"
            },
            {
              "pattern": "Student ID: 12345",
              "exact": true,
              "linkedFunction": "void print_student_info(void)"
            },
            {
              "pattern": "Student Name: Alice Smith",
              "exact": true,
              "linkedFunction": "void print_student_info(void)"
            },
            {
              "pattern": "Student Grade: 85",
              "exact": true,
              "linkedFunction": "void print_student_info(void)"
            },
            {
              "pattern": "Student Status: Passed",
              "exact": true,
              "linkedFunction": "void check_student_status(void)"
            }
          ]
        },
        {
          "id": "advanced_structure_implementation_validation",
          "name": "Advanced Structure Implementation with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "structure_impl_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Structure Implementation Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random student data\\n    int test_id1 = (rand() % 9000) + 10000;  // 10000-18999\\n    int test_grade1 = (rand() % 20) + 80;    // 80-99\\n    int test_id2 = (rand() % 9000) + 20000;  // 20000-28999\\n    int test_grade2 = (rand() % 30) + 60;    // 60-89\\n    \\n    printf(\\\"Test 1: Testing with student_id=%d, student_grade=%d\\\\n\\\", test_id1, test_grade1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/structures.ko student_id=%d student_grade=%d\\\", test_id1, test_grade1);\\n    system(\\\"rmmod structures 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Testing with student_id=%d, student_grade=%d\\\\n\\\", test_id2, test_grade2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/structures.ko student_id=%d student_grade=%d\\\", test_id2, test_grade2);\\n    system(\\\"rmmod structures\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Dynamic structure test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced structure implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param_named(name, var, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo '#define true 1' >> /tmp/linux/types.h",
              "echo '#define false 0' >> /tmp/linux/types.h",
              "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
              "echo 'Creating test file that includes student header...'",
              "echo '#include \"/lib/modules/structures.h\"' > /tmp/test.c",
              "echo 'int main() { my_student.id = 999; print_student_info(); check_student_status(); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
              "echo 'Phase 2: Dynamic Structure Implementation Testing'",
              "/bin/structure_impl_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Dynamic Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "TEST1_ID=$(grep -o 'Test 1: Testing with student_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
              "TEST1_GRADE=$(grep -o 'student_grade=[0-9]*' /tmp/test_output.log | head -1 | cut -d'=' -f2)",
              "TEST2_ID=$(grep -o 'Test 2: Testing with student_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
              "TEST2_GRADE=$(grep -o 'student_grade=[0-9]*' /tmp/test_output.log | tail -1 | cut -d'=' -f2)",
              "echo 'Test values: ID1='$TEST1_ID', Grade1='$TEST1_GRADE', ID2='$TEST2_ID', Grade2='$TEST2_GRADE",
              "echo 'Validating structure member access with dynamic values'",
              "dmesg | grep 'Student ID: '$TEST1_ID && echo 'PASS: Structure id member access working with '$TEST1_ID || echo 'FAIL: Structure id member access broken for '$TEST1_ID",
              "dmesg | grep 'Student Name: Alice Smith' && echo 'PASS: Structure name member access working' || echo 'FAIL: Structure name member access broken'",
              "dmesg | grep 'Student Grade: '$TEST1_GRADE && echo 'PASS: Structure grade member access working with '$TEST1_GRADE || echo 'FAIL: Structure grade member access broken for '$TEST1_GRADE",
              "dmesg | grep 'Student ID: '$TEST2_ID && echo 'PASS: Structure id member access working with '$TEST2_ID || echo 'FAIL: Structure id member access broken for '$TEST2_ID",
              "dmesg | grep 'Student Grade: '$TEST2_GRADE && echo 'PASS: Structure grade member access working with '$TEST2_GRADE || echo 'FAIL: Structure grade member access broken for '$TEST2_GRADE",
              "dmesg | grep 'Student Status: Passed' && echo 'PASS: Structure passed member conditional logic working' || echo 'FAIL: Structure passed member conditional logic broken'",
              "echo 'Phase 4: Structure Definition Validation'",
              "dmesg | grep 'Basic structures module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
              "echo 'All structure implementation validations completed'"
            ],
            "expected": {
              "dmesg": [
                "Basic structures module loaded",
                "Student ID: .*",
                "Student Name: Alice Smith",
                "Student Grade: .*",
                "Student Status: Passed"
              ],
              "stdout": [
                "PASS: All function and variable declarations found in header file",
                "SUCCESS: Dynamic structure test completed",
                "PASS: Structure id member access working with .*",
                "PASS: Structure name member access working",
                "PASS: Structure grade member access working with .*",
                "PASS: Structure passed member conditional logic working"
              ]
            },
            "timeout": 30
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Basic structures module loaded",
        "Student ID: 12345",
        "Student Name: Alice Smith",
        "Student Grade: 85",
        "Student Status: Passed"
      ],
      "requirements": [
        "Use required function names: structures_init, structures_exit, print_student_info, check_student_status",
        "Use required variable names: my_student",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: struct student {, extern struct student my_student, struct student my_student = {, .id = 12345, .name = \"Alice Smith\", .grade = 85, .passed = true, module_param_named(student_id, my_student.id, int, 0644), module_param_named(student_grade, my_student.grade, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Basic structures module loaded",
          "linkedFunction": "static int __init structures_init(void)",
          "exact": true
        },
        {
          "pattern": "Student ID: 12345",
          "linkedFunction": "void print_student_info(void)",
          "exact": true
        },
        {
          "pattern": "Student Name: Alice Smith",
          "linkedFunction": "void print_student_info(void)",
          "exact": true
        },
        {
          "pattern": "Student Grade: 85",
          "linkedFunction": "void print_student_info(void)",
          "exact": true
        },
        {
          "pattern": "Student Status: Passed",
          "linkedFunction": "void check_student_status(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 17,
    "title": "Structure Pointers - Advanced Data Manipulation",
    "difficulty": 5,
    "xp": 45,
    "phase": "foundations",
    "description": "Learn essential pointer concepts by working with pointers to structures. Focus on arrow operator (->), address-of operator (&), and passing structures to functions by reference.",
    "concepts": [
      "structure pointers",
      "pointer dereferencing",
      "arrow operator (->)",
      "address-of operator (&)",
      "structure modification via pointers"
    ],
    "skills": [
      "Working with structure pointers",
      "Using arrow operator for member access",
      "Passing structures to functions by reference",
      "Modifying structures through pointers",
      "Understanding pointer-based data manipulation"
    ],
    "files": [
      {
        "name": "struct_pointers.h",
        "content": "#ifndef STRUCT_POINTERS_H\n#define STRUCT_POINTERS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n#define MAX_NAME_LEN 32\n\n/* TODO: Define device_info structure with the following fields: */\n/* - char device_name[MAX_NAME_LEN] for storing device name */\n/* - int device_id for storing device identifier */\n/* - bool is_active for storing activation status */\n/* - int data_count for storing data counter */\n\nextern struct device_info my_device;\n\n/* TODO: Declare your functions that work with pointers */\n/* void print_device_info(struct device_info *dev); - prints all device information */\n/* void update_device_count(struct device_info *dev, int new_count); - updates device count */\n/* void activate_device(struct device_info *dev); - activates the device */\n\n#endif /* STRUCT_POINTERS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "struct_pointers.c",
        "content": "#include \"struct_pointers.h\"\n\n/* PATTERN SCAFFOLDING: How structure pointers work in C */\n/* Basic pattern for working with structure pointers:\n *\n * struct my_struct variable = {...};        // Create struct variable\n * struct my_struct* ptr = &variable;        // Get pointer to struct\n * ptr->field = value;                       // Access/modify through pointer\n *\n * This is like: variable  &variable  ptr->field\n */\n\n/* WHAT EACH EXPRESSION CONTAINS AND HOW TO USE IT: */\n\n/* 1. struct device_info my_device - Structure variable (actual data) */\n/*    Contains: The actual struct data in memory */\n/*    Usage: Direct access to fields: my_device.device_id */\n/*    Example: my_device.device_name contains the string \"sensor01\" */\n\n/* 2. struct device_info* dev - Pointer to structure */\n/*    Contains: Memory address pointing to the struct */\n/*    Usage: Access fields through arrow operator: dev->device_id */\n/*    Example: dev points to where my_device lives in memory */\n\n/* 3. &my_device - Address of the structure variable */\n/*    Contains: Memory address where my_device is stored */\n/*    Usage: Pass to functions that expect pointers */\n/*    Example: &my_device gives the address to pass to functions */\n\n/* STRUCTURE MEMBER ACCESS OPERATORS EXPLAINED: */\n\n/* DOT OPERATOR (.) - Used with structure variables: */\n/* my_device.device_id = 1001;               // Direct access to variable */\n/* my_device.is_active = true;               // Modifying field directly */\n/* Why dot? Because my_device IS the actual struct, not a pointer */\n\n/* ARROW OPERATOR (->) - Used with structure pointers: */\n/* dev->device_id = 1001;                    // Access through pointer */\n/* dev->is_active = true;                    // Modifying field through pointer */\n/* Why arrow? Because dev POINTS TO the struct, it's not the struct itself */\n\n/* ARROW OPERATOR IS ACTUALLY SHORTHAND: */\n/* dev->device_id  is exactly the same as  (*dev).device_id */\n/*   shorthand                               longhand */\n/* The arrow operator (->) is just a convenient way to write (*ptr).field */\n\n/* AMPERSAND OPERATOR (&) EXPLAINED FOR STRUCTURES: */\n/* & is the \"address-of\" operator - gets memory address of a variable */\n\n/* WHAT & PRODUCES WITH STRUCTURES: */\n/* my_device                    = The actual struct contents */\n/* &my_device                   = Pointer to where the struct is stored */\n/* */\n/* Example: */\n/* struct device_info my_device = {...};     // Struct variable */\n/* struct device_info* ptr = &my_device;     // Get pointer to the struct */\n\n/* WHY FUNCTIONS NEED POINTERS TO STRUCTURES: */\n/* Function parameter: void print_device_info(struct device_info *dev) */\n/*                                              expects a POINTER */\n/* */\n/* If we have: struct device_info my_device = {...}; */\n/* */\n/* CORRECT:   print_device_info(&my_device); */\n/*             pass address of the struct */\n/* */\n/* WRONG:     print_device_info(my_device); */\n/*             tries to pass struct contents instead of address */\n\n/* MEMORY LAYOUT VISUALIZATION FOR STRUCTURES: */\n/* Memory Address: 0x1000 */\n/*  */\n/*  my_device struct data lives here                     */\n/*  [device_name: \"sensor01\"][device_id: 1001][......]   */\n/*  */\n/*    */\n/*   This address (0x1000) is what &my_device gives us */\n\n/* WHAT EACH EXPRESSION EVALUATES TO: */\n/* my_device          = The actual struct contents (all fields together) */\n/* &my_device         = 0x1000 (the address where the struct is stored) */\n/* ptr = &my_device   = ptr now contains 0x1000 */\n/* ptr->device_id     = Access device_id field at address 0x1000 + offset */\n\n/* POINTER DEREFERENCING RELATIONSHIP: */\n/* If: struct device_info* ptr = &my_device; */\n/* Then: */\n/*   ptr                = Address of my_device (like 0x1000) */\n/*   *ptr               = Contents of my_device (entire struct) */\n/*   ptr->device_id     = my_device.device_id (same field) */\n/*   (*ptr).device_id   = my_device.device_id (same as arrow operator) */\n\n/* COMMON MISTAKES AND COMPILER ERRORS: */\n/* MISTAKE 1: Using dot instead of arrow with pointers */\n/*   struct device_info* dev = &my_device; */\n/*   dev.device_id = 1001;  // ERROR: dev is pointer, use -> not . */\n/* SOLUTION: */\n/*   dev->device_id = 1001;  // CORRECT: use -> with pointers */\n/* */\n/* MISTAKE 2: Using arrow instead of dot with variables */\n/*   my_device->device_id = 1001;  // ERROR: my_device is variable, use . not -> */\n/* SOLUTION: */\n/*   my_device.device_id = 1001;   // CORRECT: use . with variables */\n/* */\n/* MISTAKE 3: Forgetting & when passing to functions */\n/*   print_device_info(my_device);  // ERROR: function expects pointer */\n/* SOLUTION: */\n/*   print_device_info(&my_device); // CORRECT: pass address with & */\n\n/* PRACTICAL EXAMPLES IN STRUCTURE CONTEXT: */\n/* struct device_info my_device = {.device_name = \"sensor01\", .device_id = 1001}; */\n/* struct device_info* ptr = &my_device;     // ptr points to my_device */\n/* */\n/* printf(\"%s\", my_device.device_name);      // Direct access: \"sensor01\" */\n/* printf(\"%s\", ptr->device_name);           // Pointer access: \"sensor01\" */\n/* printf(\"%d\", my_device.device_id);        // Direct access: 1001 */\n/* printf(\"%d\", ptr->device_id);             // Pointer access: 1001 */\n\n/* IN OUR KERNEL CODE CONTEXT: */\n/* struct device_info my_device = {...};              // Global struct variable */\n/* void print_device_info(struct device_info *dev);  // Function takes pointer */\n/* */\n/* Inside init function: */\n/* print_device_info(&my_device);                     // Pass address to function */\n/* */\n/* Inside print_device_info function: */\n/* void print_device_info(struct device_info *dev) {  // dev is pointer parameter */\n/*     printk(\"Name: %s\", dev->device_name);           // Use -> to access fields */\n/*     printk(\"ID: %d\", dev->device_id);               // dev points to my_device */\n/* } */\n\n/* TODO: Initialize device structure */\n/* Use the pattern: struct device_info my_device = { .field = value, ... }; */\n/* Initialize with: device_name=\"sensor01\", device_id=1001, is_active=false, data_count=0 */\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your pointer operations work\n * with different input values. Removing them will cause test failures.\n */\nmodule_param_named(device_id, my_device.device_id, int, 0644);\nMODULE_PARM_DESC(device_id, \"Device ID for testing pointer member access\");\nmodule_param_named(data_count, my_device.data_count, int, 0644);\nMODULE_PARM_DESC(data_count, \"Initial data count for testing pointer operations\");\n/* Note: string and bool module params need special handling for structures */\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* TODO: Implement function to print device info using pointer */\nvoid print_device_info(struct device_info *dev) {\n    /* TODO: Print device name using dev->device_name */\n    /* TODO: Print device ID using dev->device_id */\n    /* TODO: Print device active status using dev->is_active */\n    /* TODO: Print data count using dev->data_count */\n    /* Use printk(KERN_INFO \"...\", ...) for each field */\n}\n\n/* TODO: Implement function to update device count via pointer */\nvoid update_device_count(struct device_info *dev, int new_count) {\n    /* TODO: Update dev->data_count to new_count value */\n    /* TODO: Print confirmation message with device name and new count */\n    /* Format: \"Device %s count updated to: %d\" */\n}\n\n/* TODO: Implement function to activate device via pointer */\nvoid activate_device(struct device_info *dev) {\n    /* TODO: Set dev->is_active to true */\n    /* TODO: Print confirmation message with device name */\n    /* Format: \"Device %s activated\" */\n}\n\n/* DETAILED EXPLANATION OF INIT FUNCTION - STEP BY STEP STRUCTURE POINTER ANALYSIS */\n/* This function demonstrates the complete structure pointer workflow with detailed explanations */\n\n/* UNDERSTANDING THE INIT FUNCTION CALLS: */\n/* printk(KERN_INFO \"Initial Device Information:\");  // Print header message */\n/* print_device_info(&my_device);                     // Pass structure address to function */\n/* update_device_count(&my_device, 5);               // Pass structure address + new value */\n/* activate_device(&my_device);                       // Pass structure address to function */\n/* */\n/* WHAT &my_device GIVES YOU: */\n/* - &my_device = address of the ENTIRE structure (not individual fields) */\n/* - Functions receive this address as a pointer parameter */\n/* */\n/* MEMORY LAYOUT VISUALIZATION: */\n/* Memory Address: 0x2000 */\n/*  */\n/*  my_device struct (entire thing)          */\n/*      &my_device points HERE (to start) */\n/*   device_name: \"sensor01\"               */\n/*    */\n/*   device_id: 1001                       */\n/*    */\n/*   is_active: false                      */\n/*    */\n/*   data_count: 0                         */\n/*    */\n/*  */\n/* */\n/* SO &my_device POINTS TO: */\n/* - YES: The entire struct (including all fields: device_name, device_id, is_active, data_count) */\n/* - NO: NOT just one field or partial data */\n/* */\n/* INSIDE print_device_info(&my_device): */\n/* void print_device_info(struct device_info *dev) { */\n/*     // dev parameter contains 0x2000 (address of entire my_device struct) */\n/*  */\n/*     printk(\"Device Name: %s\", dev->device_name); */\n/*     // dev->device_name accesses the device_name field at address 0x2000 + offset */\n/*     // This works because dev points to the start of my_device! */\n/* } */\n/* */\n/* INSIDE update_device_count(&my_device, 5): */\n/* void update_device_count(struct device_info *dev, int new_count) { */\n/*     // dev parameter contains 0x2000 (same address as my_device) */\n/*  */\n/*     dev->data_count = new_count; */\n/*     // This DIRECTLY modifies my_device.data_count because dev points to my_device! */\n/*     // After this line, my_device.data_count will be 5 */\n/* } */\n/* */\n/* KEY POINT: */\n/* &my_device gives you the address of the WHOLE struct, not individual fields. */\n/* Functions receive this address as a pointer and can access/modify any field. */\n/* When functions modify fields through the pointer, they're directly modifying my_device! */\n/* */\n/* THE STRUCTURE POINTER CHAIN: */\n/* 1. my_device = actual struct variable with data */\n/* 2. &my_device = pointer to entire struct */\n/* 3. function parameter gets this address */\n/* 4. Inside function: use -> to access/modify fields */\n/* 5. Changes affect the original my_device struct */\n/* */\n/* So yes, the functions receive the address of the ENTIRE struct and can modify it directly! */\n\nstatic int __init struct_pointers_init(void)\n{\n    printk(KERN_INFO \"Structure pointers module loaded\\n\");\n    \n    /* TODO: Print \"Initial Device Information:\" message */\n    /* TODO: Call print_device_info() function with pointer to my_device */\n    /* Remember to use &my_device to get the address of the structure */\n    \n    /* TODO: Update device count to 5 using update_device_count() function */\n    /* Pass &my_device and the value 5 as parameters */\n    \n    /* TODO: Activate the device using activate_device() function */\n    /* Pass &my_device as parameter */\n    \n    /* TODO: Print \"Final Device Information:\" message */\n    /* TODO: Call print_device_info() again to show updated values */\n    \n    return 0;\n}\n\nstatic void __exit struct_pointers_exit(void)\n{\n    printk(KERN_INFO \"Structure pointers module unloaded\\n\");\n}\n\nmodule_init(struct_pointers_init);\nmodule_exit(struct_pointers_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning structure pointers and basic operations\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Structure pointers module Makefile\nobj-m += struct_pointers.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "struct_pointers.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "struct_pointers_init",
          "struct_pointers_exit",
          "print_device_info",
          "update_device_count",
          "activate_device"
        ],
        "function_declarations": [
          {
            "name": "print_device_info",
            "returnType": "void",
            "parameters": [
              "struct device_info *dev"
            ]
          },
          {
            "name": "update_device_count",
            "returnType": "void",
            "parameters": [
              "struct device_info *dev",
              "int new_count"
            ]
          },
          {
            "name": "activate_device",
            "returnType": "void",
            "parameters": [
              "struct device_info *dev"
            ]
          }
        ],
        "variables_declarations": [
          {
            "name": "device_info",
            "type": "struct",
            "value": "{char device_name[MAX_NAME_LEN]; int device_id; bool is_active; int data_count;}",
            "storageClass": "none"
          },
          {
            "name": "my_device",
            "type": "struct device_info",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "my_device",
            "type": "struct device_info",
            "value": "{.device_name = \"sensor01\", .device_id = 1001, .is_active = false, .data_count = 0}",
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Structure pointers module loaded",
          "Initial Device Information:",
          "Device Name: sensor01",
          "Device ID: 1001",
          "Device Active: 0",
          "Data Count: 0",
          "Device sensor01 count updated to: 5",
          "Device sensor01 activated",
          "Final Device Information:",
          "Device Name: sensor01",
          "Device ID: 1001",
          "Device Active: 1",
          "Data Count: 5"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "struct device_info {",
          "extern struct device_info my_device",
          "struct device_info my_device = {",
          "&my_device",
          "module_param_named(device_id, my_device.device_id, int, 0644)",
          "module_param_named(data_count, my_device.data_count, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_device_info(struct device_info *dev)",
            "void update_device_count(struct device_info *dev, int new_count)",
            "void activate_device(struct device_info *dev)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_device_info(struct device_info *dev)",
            "void update_device_count(struct device_info *dev, int new_count)",
            "void activate_device(struct device_info *dev)",
            "static int __init struct_pointers_init(void)",
            "static void __exit struct_pointers_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Structure pointers module loaded",
              "exact": true,
              "linkedFunction": "static int __init struct_pointers_init(void)"
            },
            {
              "pattern": "Initial Device Information:",
              "exact": true,
              "linkedFunction": "static int __init struct_pointers_init(void)"
            },
            {
              "pattern": "Device Name: sensor01",
              "exact": true,
              "linkedFunction": "void print_device_info(struct device_info *dev)"
            },
            {
              "pattern": "Device ID: 1001",
              "exact": true,
              "linkedFunction": "void print_device_info(struct device_info *dev)"
            },
            {
              "pattern": "Device Active: 0",
              "exact": true,
              "linkedFunction": "void print_device_info(struct device_info *dev)"
            },
            {
              "pattern": "Data Count: 0",
              "exact": true,
              "linkedFunction": "void print_device_info(struct device_info *dev)"
            },
            {
              "pattern": "Device sensor01 count updated to: 5",
              "exact": true,
              "linkedFunction": "void update_device_count(struct device_info *dev, int new_count)"
            },
            {
              "pattern": "Device sensor01 activated",
              "exact": true,
              "linkedFunction": "void activate_device(struct device_info *dev)"
            },
            {
              "pattern": "Final Device Information:",
              "exact": true,
              "linkedFunction": "static int __init struct_pointers_init(void)"
            },
            {
              "pattern": "Device Name: sensor01",
              "exact": true,
              "linkedFunction": "void print_device_info(struct device_info *dev)"
            },
            {
              "pattern": "Device ID: 1001",
              "exact": true,
              "linkedFunction": "void print_device_info(struct device_info *dev)"
            },
            {
              "pattern": "Device Active: 1",
              "exact": true,
              "linkedFunction": "void print_device_info(struct device_info *dev)"
            },
            {
              "pattern": "Data Count: 5",
              "exact": true,
              "linkedFunction": "void print_device_info(struct device_info *dev)"
            }
          ]
        },
        {
          "id": "advanced_pointer_structure_validation",
          "name": "Advanced Pointer Structure Implementation with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "pointer_struct_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Pointer Structure Implementation Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random device data\\n    int test_id1 = (rand() % 9000) + 2000;  // 2000-10999\\n    int test_count1 = (rand() % 10) + 1;    // 1-10\\n    int test_id2 = (rand() % 9000) + 5000;  // 5000-13999\\n    int test_count2 = (rand() % 20) + 5;    // 5-24\\n    \\n    printf(\\\"Test 1: Testing with device_id=%d, data_count=%d\\\\n\\\", test_id1, test_count1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/struct_pointers.ko device_id=%d data_count=%d\\\", test_id1, test_count1);\\n    system(\\\"rmmod struct_pointers 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Testing with device_id=%d, data_count=%d\\\\n\\\", test_id2, test_count2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/struct_pointers.ko device_id=%d data_count=%d\\\", test_id2, test_count2);\\n    system(\\\"rmmod struct_pointers\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Dynamic pointer structure test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced pointer structure implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo '#define true 1' >> /tmp/linux/types.h",
              "echo '#define false 0' >> /tmp/linux/types.h",
              "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
              "echo 'Creating test file that includes pointer structure header...'",
              "echo '#include \"/lib/modules/struct_pointers.h\"' > /tmp/test.c",
              "echo 'int main() { my_device.device_id = 888; print_device_info(&my_device); update_device_count(&my_device, 10); activate_device(&my_device); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
              "echo 'Phase 2: Dynamic Pointer Structure Implementation Testing'",
              "/bin/pointer_struct_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Dynamic Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "TEST1_ID=$(grep -o 'Test 1: Testing with device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
              "TEST1_COUNT=$(grep -o 'data_count=[0-9]*' /tmp/test_output.log | head -1 | cut -d'=' -f2)",
              "TEST2_ID=$(grep -o 'Test 2: Testing with device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
              "TEST2_COUNT=$(grep -o 'data_count=[0-9]*' /tmp/test_output.log | tail -1 | cut -d'=' -f2)",
              "echo 'Test values: ID1='$TEST1_ID', Count1='$TEST1_COUNT', ID2='$TEST2_ID', Count2='$TEST2_COUNT",
              "echo 'Validating pointer-based structure member access with dynamic values'",
              "dmesg | grep 'Device ID: '$TEST1_ID && echo 'PASS: Pointer access to device_id working with '$TEST1_ID || echo 'FAIL: Pointer access to device_id broken for '$TEST1_ID",
              "dmesg | grep 'Device Name: sensor01' && echo 'PASS: Pointer access to device_name working' || echo 'FAIL: Pointer access to device_name broken'",
              "dmesg | grep 'Data Count: '$TEST1_COUNT && echo 'PASS: Initial data_count from module param '$TEST1_COUNT || echo 'FAIL: Module parameter data_count not working'",
              "dmesg | grep 'Device ID: '$TEST2_ID && echo 'PASS: Pointer access to device_id working with '$TEST2_ID || echo 'FAIL: Pointer access to device_id broken for '$TEST2_ID",
              "echo 'Phase 3.1: Function Logic Validation'",
              "dmesg | grep 'Device sensor01 count updated to: 5' && echo 'PASS: update_device_count function message works' || echo 'FAIL: update_device_count message broken'",
              "dmesg | grep 'Data Count: 5' && echo 'PASS: update_device_count actually modified struct data_count to 5' || echo 'FAIL: update_device_count function logic broken - struct not modified'",
              "dmesg | grep 'Device sensor01 activated' && echo 'PASS: activate_device function message works' || echo 'FAIL: activate_device message broken'",
              "dmesg | grep 'Device Active: 1' && echo 'PASS: activate_device actually modified struct is_active to true' || echo 'FAIL: activate_device function logic broken - struct not modified'",
              "echo 'Phase 3.2: Final State Validation'",
              "dmesg | grep 'Final Device Information:' && echo 'PASS: Final print_device_info called' || echo 'FAIL: Final print_device_info not called'",
              "dmesg | grep 'Data Count: 5' && echo 'PASS: Final state data_count is correct' || echo 'FAIL: Final data_count wrong'",
              "dmesg | grep 'Device Active: 1' && echo 'PASS: Final state is_active is correct' || echo 'FAIL: Final is_active wrong'",
              "echo 'Phase 4: Structure Definition Validation'",
              "dmesg | grep 'Structure pointers module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
              "echo 'All pointer structure implementation validations completed'"
            ],
            "expected": {
              "dmesg": [
                "Structure pointers module loaded",
                "Device Name: sensor01",
                "Device ID: .*",
                "Data Count: .*",
                "Device sensor01 count updated to: 5",
                "Device sensor01 activated",
                "Device Active: 1"
              ],
              "stdout": [
                "PASS: All function and variable declarations found in header file",
                "SUCCESS: Dynamic pointer structure test completed",
                "PASS: Pointer access to device_id working with .*",
                "PASS: Pointer access to device_name working",
                "PASS: Initial data_count from module param .*",
                "PASS: update_device_count function message works",
                "PASS: update_device_count actually modified struct data_count to 5",
                "PASS: activate_device function message works",
                "PASS: activate_device actually modified struct is_active to true",
                "PASS: Final print_device_info called",
                "PASS: Final state data_count is correct",
                "PASS: Final state is_active is correct"
              ]
            },
            "timeout": 15
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Structure pointers module loaded",
        "Initial Device Information:",
        "Device Name: sensor01",
        "Device ID: 1001",
        "Device Active: 0",
        "Data Count: 0",
        "Device sensor01 count updated to: 5",
        "Device sensor01 activated",
        "Final Device Information:",
        "Device Name: sensor01",
        "Device ID: 1001",
        "Device Active: 1",
        "Data Count: 5"
      ],
      "requirements": [
        "Use required function names: struct_pointers_init, struct_pointers_exit, print_device_info, update_device_count, activate_device",
        "Use required variable names: my_device",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: struct device_info {, extern struct device_info my_device, struct device_info my_device = {, &my_device, module_param_named(device_id, my_device.device_id, int, 0644), module_param_named(data_count, my_device.data_count, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Structure pointers module loaded",
          "linkedFunction": "static int __init struct_pointers_init(void)",
          "exact": true
        },
        {
          "pattern": "Initial Device Information:",
          "linkedFunction": "static int __init struct_pointers_init(void)",
          "exact": true
        },
        {
          "pattern": "Device Name: sensor01",
          "linkedFunction": "void print_device_info(struct device_info *dev)",
          "exact": true
        },
        {
          "pattern": "Device ID: 1001",
          "linkedFunction": "void print_device_info(struct device_info *dev)",
          "exact": true
        },
        {
          "pattern": "Device Active: 0",
          "linkedFunction": "void print_device_info(struct device_info *dev)",
          "exact": true
        },
        {
          "pattern": "Data Count: 0",
          "linkedFunction": "void print_device_info(struct device_info *dev)",
          "exact": true
        },
        {
          "pattern": "Device sensor01 count updated to: 5",
          "linkedFunction": "void update_device_count(struct device_info *dev, int new_count)",
          "exact": true
        },
        {
          "pattern": "Device sensor01 activated",
          "linkedFunction": "void activate_device(struct device_info *dev)",
          "exact": true
        },
        {
          "pattern": "Final Device Information:",
          "linkedFunction": "static int __init struct_pointers_init(void)",
          "exact": true
        },
        {
          "pattern": "Device Name: sensor01",
          "linkedFunction": "void print_device_info(struct device_info *dev)",
          "exact": true
        },
        {
          "pattern": "Device ID: 1001",
          "linkedFunction": "void print_device_info(struct device_info *dev)",
          "exact": true
        },
        {
          "pattern": "Device Active: 1",
          "linkedFunction": "void print_device_info(struct device_info *dev)",
          "exact": true
        },
        {
          "pattern": "Data Count: 5",
          "linkedFunction": "void print_device_info(struct device_info *dev)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 18,
    "title": "Typedef - Cleaner Type Definitions",
    "difficulty": 3,
    "xp": 35,
    "phase": "foundations",
    "description": "Learn to create cleaner, more readable code using typedef. Instead of writing 'struct device_info my_device', you can simply write 'Device my_device'. This introduces type aliasing - a fundamental concept for writing professional, maintainable kernel code.",
    "concepts": [
      "typedef keyword",
      "type aliasing",
      "struct typedef pattern",
      "cleaner syntax",
      "code readability",
      "professional coding style"
    ],
    "skills": [
      "Creating type aliases with typedef",
      "Using typedef for struct definitions",
      "Writing cleaner, more readable code",
      "Understanding type abstraction",
      "Professional kernel coding practices"
    ],
    "files": [
      {
        "name": "typedef_basics.h",
        "content": "#ifndef TYPEDEF_BASICS_H\n#define TYPEDEF_BASICS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n#define MAX_NAME_LEN 32\n\n/* TODO: Define Device typedef */\n/* typedef struct {\n *     int device_id;\n *     char name[MAX_NAME_LEN];\n *     int status_code;\n *     bool is_active;\n * } Device; */\n\nextern Device my_device;\n\n/* TODO: Declare your functions using the typedef */\n/* void print_device_details(void); */\n/* void update_device_status(int new_status); */\n/* void check_device_state(void); */\n\n#endif /* TYPEDEF_BASICS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "typedef_basics.c",
        "content": "#include \"typedef_basics.h\"\n\n/* TODO: Initialize device using clean typedef syntax */\n/* Device my_device = {\n *     .device_id = 12345,\n *     .name = \"sensor01\",\n *     .status_code = 200,\n *     .is_active = true\n * }; */\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your typedef operations work\n * with different input values. Removing them will cause test failures.\n */\nmodule_param_named(device_id, my_device.device_id, int, 0644);\nMODULE_PARM_DESC(device_id, \"Device ID for testing typedef member access\");\nmodule_param_named(status_code, my_device.status_code, int, 0644);\nMODULE_PARM_DESC(status_code, \"Device status code for testing typedef operations\");\n/* Note: string and bool module params need special handling for typedefs */\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* TODO: Implement function to print device details */\n/* void print_device_details(void) {\n *     printk(KERN_INFO \"Device ID: %d\\n\", my_device.device_id);\n *     printk(KERN_INFO \"Device Name: %s\\n\", my_device.name);\n *     printk(KERN_INFO \"Status Code: %d\\n\", my_device.status_code);\n * } */\n\n/* TODO: Implement function to update device status */\n/* void update_device_status(int new_status) {\n *     my_device.status_code = new_status;\n *     my_device.is_active = (new_status == 200) ? true : false;\n *     printk(KERN_INFO \"Status updated to: %d\\n\", new_status);\n * } */\n\n/* TODO: Implement function to check device state */\n/* void check_device_state(void) {\n *     if (my_device.is_active) {\n *         printk(KERN_INFO \"Device State: ACTIVE\\n\");\n *     } else {\n *         printk(KERN_INFO \"Device State: INACTIVE\\n\");\n *     }\n * } */\n\nstatic int __init typedef_basics_init(void)\n{\n    printk(KERN_INFO \"Typedef basics module loaded\\n\");\n    \n    /* TODO: Print initial device details */\n    /* printk(KERN_INFO \"Initial Device Information:\\n\"); */\n    /* print_device_details(); */\n    /* check_device_state(); */\n    \n    /* TODO: Update status and show changes */\n    /* update_device_status(404); */\n    /* printk(KERN_INFO \"After status update:\\n\"); */\n    /* print_device_details(); */\n    /* check_device_state(); */\n    \n    return 0;\n}\n\nstatic void __exit typedef_basics_exit(void)\n{\n    printk(KERN_INFO \"Typedef basics module unloaded\\n\");\n}\n\nmodule_init(typedef_basics_init);\nmodule_exit(typedef_basics_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning typedef for cleaner code structure\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Typedef basics module Makefile\nobj-m += typedef_basics.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "typedef_basics.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "typedef_basics_init",
          "typedef_basics_exit",
          "print_device_details",
          "update_device_status",
          "check_device_state"
        ],
        "function_declarations": [
          {
            "name": "print_device_details",
            "returnType": "void",
            "parameters": []
          },
          {
            "name": "update_device_status",
            "returnType": "void",
            "parameters": [
              "int new_status"
            ]
          },
          {
            "name": "check_device_state",
            "returnType": "void",
            "parameters": []
          }
        ],
        "variables_declarations": [
          {
            "name": "Device",
            "type": "typedef struct",
            "value": "{int device_id; char name[MAX_NAME_LEN]; int status_code; bool is_active;}",
            "storageClass": "none"
          },
          {
            "name": "my_device",
            "type": "Device",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "my_device",
            "type": "Device",
            "value": "{.device_id = 12345, .name = \"sensor01\", .status_code = 200, .is_active = true}",
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Typedef basics module loaded",
          "Initial Device Information:",
          "Device ID: 12345",
          "Device Name: sensor01",
          "Status Code: 200",
          "Device State: ACTIVE",
          "Status updated to: 404",
          "After status update:",
          "Device ID: 12345",
          "Device Name: sensor01",
          "Status Code: 404",
          "Device State: INACTIVE"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "typedef struct {",
          "} Device;",
          "extern Device my_device",
          "Device my_device = {",
          "module_param_named(device_id, my_device.device_id, int, 0644)",
          "module_param_named(status_code, my_device.status_code, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_device_details(void)",
            "void update_device_status(int new_status)",
            "void check_device_state(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_device_details(void)",
            "void update_device_status(int new_status)",
            "void check_device_state(void)",
            "static int __init typedef_basics_init(void)",
            "static void __exit typedef_basics_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Typedef basics module loaded",
              "exact": true,
              "linkedFunction": "static int __init typedef_basics_init(void)"
            },
            {
              "pattern": "Initial Device Information:",
              "exact": true,
              "linkedFunction": "static int __init typedef_basics_init(void)"
            },
            {
              "pattern": "Device ID: 12345",
              "exact": true,
              "linkedFunction": "void print_device_details(void)"
            },
            {
              "pattern": "Device Name: sensor01",
              "exact": true,
              "linkedFunction": "void print_device_details(void)"
            },
            {
              "pattern": "Status Code: 200",
              "exact": true,
              "linkedFunction": "void print_device_details(void)"
            },
            {
              "pattern": "Device State: ACTIVE",
              "exact": true,
              "linkedFunction": "void check_device_state(void)"
            },
            {
              "pattern": "Status updated to: 404",
              "exact": true,
              "linkedFunction": "void update_device_status(int new_status)"
            },
            {
              "pattern": "After status update:",
              "exact": true,
              "linkedFunction": "static int __init typedef_basics_init(void)"
            },
            {
              "pattern": "Device ID: 12345",
              "exact": true,
              "linkedFunction": "void print_device_details(void)"
            },
            {
              "pattern": "Device Name: sensor01",
              "exact": true,
              "linkedFunction": "void print_device_details(void)"
            },
            {
              "pattern": "Status Code: 404",
              "exact": true,
              "linkedFunction": "void print_device_details(void)"
            },
            {
              "pattern": "Device State: INACTIVE",
              "exact": true,
              "linkedFunction": "void check_device_state(void)"
            }
          ]
        },
        {
          "id": "advanced_typedef_implementation_validation",
          "name": "Advanced Typedef Implementation with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "typedef_dynamic_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Typedef Implementation Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random device data\\n    int test_id1 = (rand() % 9000) + 10000;     // 10000-18999\\n    int test_status1 = (rand() % 2) ? 200 : 404; // 200 or 404\\n    int test_id2 = (rand() % 9000) + 20000;     // 20000-28999\\n    int test_status2 = (rand() % 2) ? 200 : 500; // 200 or 500\\n    \\n    printf(\\\"Test 1: Testing with device_id=%d, status_code=%d\\\\n\\\", test_id1, test_status1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/typedef_basics.ko device_id=%d status_code=%d\\\", test_id1, test_status1);\\n    system(\\\"rmmod typedef_basics 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Testing with device_id=%d, status_code=%d\\\\n\\\", test_id2, test_status2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/typedef_basics.ko device_id=%d status_code=%d\\\", test_id2, test_status2);\\n    system(\\\"rmmod typedef_basics\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Dynamic typedef test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced typedef implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param_named(name, var, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo '#define true 1' >> /tmp/linux/types.h",
              "echo '#define false 0' >> /tmp/linux/types.h",
              "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
              "echo 'Creating test file that includes typedef header...'",
              "echo '#include \"/lib/modules/typedef_basics.h\"' > /tmp/test.c",
              "echo 'int main() { my_device.device_id = 999; print_device_details(); update_device_status(500); check_device_state(); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or typedef declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and typedef declarations found in header file'; fi",
              "echo 'Phase 2: Dynamic Typedef Implementation Testing'",
              "/bin/typedef_dynamic_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Dynamic Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "TEST1_ID=$(grep -o 'Test 1: Testing with device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
              "TEST1_STATUS=$(grep -o 'status_code=[0-9]*' /tmp/test_output.log | head -1 | cut -d'=' -f2)",
              "TEST2_ID=$(grep -o 'Test 2: Testing with device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
              "TEST2_STATUS=$(grep -o 'status_code=[0-9]*' /tmp/test_output.log | tail -1 | cut -d'=' -f2)",
              "echo 'Test values: ID1='$TEST1_ID', Status1='$TEST1_STATUS', ID2='$TEST2_ID', Status2='$TEST2_STATUS",
              "echo 'Validating typedef-based structure member access with dynamic values'",
              "dmesg | grep 'Device ID: '$TEST1_ID && echo 'PASS: Typedef structure member access working with '$TEST1_ID || echo 'FAIL: Typedef structure member access broken for '$TEST1_ID",
              "dmesg | grep 'Device Name: sensor01' && echo 'PASS: Typedef string member access working' || echo 'FAIL: Typedef string member access broken'",
              "dmesg | grep 'Status Code: '$TEST1_STATUS && echo 'PASS: Typedef status member access working with '$TEST1_STATUS || echo 'FAIL: Typedef status member access broken for '$TEST1_STATUS",
              "dmesg | grep 'Device ID: '$TEST2_ID && echo 'PASS: Typedef structure member access working with '$TEST2_ID || echo 'FAIL: Typedef structure member access broken for '$TEST2_ID",
              "dmesg | grep 'Status Code: '$TEST2_STATUS && echo 'PASS: Typedef status member access working with '$TEST2_STATUS || echo 'FAIL: Typedef status member access broken for '$TEST2_STATUS",
              "echo 'Phase 3.1: Function Logic Validation'",
              "dmesg | grep 'Status updated to: 404' && echo 'PASS: update_device_status function message works' || echo 'FAIL: update_device_status message broken'",
              "dmesg | grep 'Status Code: 404' && echo 'PASS: update_device_status actually modified typedef structure member' || echo 'FAIL: update_device_status function logic broken - structure not modified'",
              "dmesg | grep 'Device State: INACTIVE' && echo 'PASS: check_device_state function using typedef member correctly' || echo 'FAIL: check_device_state not using typedef structure member'",
              "echo 'Phase 3.2: Final State Validation'",
              "dmesg | grep 'After status update:' && echo 'PASS: Final print_device_details called' || echo 'FAIL: Final print_device_details not called'",
              "dmesg | grep 'Status Code: 404' && echo 'PASS: Final state shows correct typedef member modification' || echo 'FAIL: Final state typedef member modification broken'",
              "dmesg | grep 'Device State: INACTIVE' && echo 'PASS: Final state shows correct conditional logic' || echo 'FAIL: Final state conditional logic broken'",
              "echo 'Phase 4: Typedef Definition Validation'",
              "dmesg | grep 'Typedef basics module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
              "echo 'All typedef implementation validations completed'"
            ],
            "expected": {
              "dmesg": [
                "Typedef basics module loaded",
                "Device ID: .*",
                "Device Name: sensor01",
                "Status Code: .*",
                "Device State: ACTIVE",
                "Status updated to: 404"
              ],
              "stdout": [
                "PASS: All function and typedef declarations found in header file",
                "SUCCESS: Dynamic typedef test completed",
                "PASS: Typedef structure member access working with .*",
                "PASS: Typedef string member access working",
                "PASS: Typedef status member access working with .*",
                "PASS: update_device_status function message works",
                "PASS: update_device_status actually modified typedef structure member",
                "PASS: check_device_state function using typedef member correctly",
                "PASS: Final print_device_details called",
                "PASS: Final state shows correct typedef member modification",
                "PASS: Final state shows correct conditional logic"
              ]
            },
            "timeout": 15
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Typedef basics module loaded",
        "Initial Device Information:",
        "Device ID: 12345",
        "Device Name: sensor01",
        "Status Code: 200",
        "Device State: ACTIVE",
        "Status updated to: 404",
        "After status update:",
        "Device ID: 12345",
        "Device Name: sensor01",
        "Status Code: 404",
        "Device State: INACTIVE"
      ],
      "requirements": [
        "Use required function names: typedef_basics_init, typedef_basics_exit, print_device_details, update_device_status, check_device_state",
        "Use required variable names: my_device",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: typedef struct {, } Device;, extern Device my_device, Device my_device = {, module_param_named(device_id, my_device.device_id, int, 0644), module_param_named(status_code, my_device.status_code, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Typedef basics module loaded",
          "linkedFunction": "static int __init typedef_basics_init(void)",
          "exact": true
        },
        {
          "pattern": "Initial Device Information:",
          "linkedFunction": "static int __init typedef_basics_init(void)",
          "exact": true
        },
        {
          "pattern": "Device ID: 12345",
          "linkedFunction": "void print_device_details(void)",
          "exact": true
        },
        {
          "pattern": "Device Name: sensor01",
          "linkedFunction": "void print_device_details(void)",
          "exact": true
        },
        {
          "pattern": "Status Code: 200",
          "linkedFunction": "void print_device_details(void)",
          "exact": true
        },
        {
          "pattern": "Device State: ACTIVE",
          "linkedFunction": "void check_device_state(void)",
          "exact": true
        },
        {
          "pattern": "Status updated to: 404",
          "linkedFunction": "void update_device_status(int new_status)",
          "exact": true
        },
        {
          "pattern": "After status update:",
          "linkedFunction": "static int __init typedef_basics_init(void)",
          "exact": true
        },
        {
          "pattern": "Device ID: 12345",
          "linkedFunction": "void print_device_details(void)",
          "exact": true
        },
        {
          "pattern": "Device Name: sensor01",
          "linkedFunction": "void print_device_details(void)",
          "exact": true
        },
        {
          "pattern": "Status Code: 404",
          "linkedFunction": "void print_device_details(void)",
          "exact": true
        },
        {
          "pattern": "Device State: INACTIVE",
          "linkedFunction": "void check_device_state(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 19,
    "title": "Dynamic Memory - kmalloc and kfree Essentials",
    "difficulty": 4,
    "xp": 40,
    "phase": "foundations",
    "description": "Master the essential dynamic memory pattern: kmalloc(sizeof(Device), GFP_KERNEL) to allocate and kfree() to clean up. Learn the fundamental runtime allocation pattern used throughout kernel development.",
    "concepts": [
      "kmalloc() function and GFP_KERNEL",
      "kfree() function and memory cleanup",
      "NULL pointer checking",
      "Error handling with -ENOMEM",
      "Memory lifecycle: allocate, use, free"
    ],
    "skills": [
      "Using kmalloc(sizeof(Device), GFP_KERNEL)",
      "Proper error handling for memory failures",
      "Cleaning up with kfree()",
      "Setting pointers to NULL after freeing"
    ],
    "files": [
      {
        "name": "dynamic_memory.h",
        "content": "#ifndef DYNAMIC_MEMORY_H\n#define DYNAMIC_MEMORY_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n\ntypedef struct {\n    int device_id;\n    int status;\n    bool is_active;\n} Device;\n\n/* Global device pointer - starts as NULL */\nextern Device *my_device;\n\n/* TODO: Declare your functions */\n/* Device* create_device(int id); */\n/* void print_device_info(Device* dev); */\n/* void cleanup_device(void); */\n\n#endif /* DYNAMIC_MEMORY_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "dynamic_memory.c",
        "content": "#include \"dynamic_memory.h\"\n\n/* Global device pointer - starts as NULL */\nDevice *my_device = NULL;\n\nint device_id = 1001;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your dynamic allocation works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(device_id, int, 0644);\nMODULE_PARM_DESC(device_id, \"Device ID for testing dynamic allocation\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: How dynamic memory allocation works in C */\n/* Basic pattern for kmalloc and kfree:\n *\n * Device *ptr = kmalloc(sizeof(Device), GFP_KERNEL);  // Allocate memory\n * if (!ptr) {\n *     return -ENOMEM;  // Check for allocation failure\n * }\n * ptr->field = value;  // Use the allocated memory\n * kfree(ptr);  // Free the memory when done\n * ptr = NULL;  // Prevent accidental reuse\n *\n * This is the fundamental kernel memory pattern!\n */\n\n/* MEMORY OPERATORS: */\n/* kmalloc(size, flags) - allocates 'size' bytes, returns pointer */\n/* kfree(ptr) - frees memory pointed to by 'ptr' */\n/* GFP_KERNEL - standard allocation flag for kernel code */\n\n/* TODO: Implement device creation function */\nDevice* create_device(int id) {\n    printk(KERN_INFO \"Creating device with ID: %d\\n\", id);\n    \n    // Step 1: Allocate memory for one Device struct\n    /* TODO: my_device = kmalloc(sizeof(Device), GFP_KERNEL); */\n    \n    // Step 2: Check if allocation succeeded\n    if (!my_device) {\n        printk(KERN_ERR \"Failed to allocate device memory!\\n\");\n        return NULL;\n    }\n    \n    // Step 3: Initialize the allocated device\n    my_device->device_id = id;\n    my_device->status = 200;\n    my_device->is_active = true;\n    \n    printk(KERN_INFO \"Device allocated successfully!\\n\");\n    return my_device;\n}\n\n/* TODO: Implement device info function */\nvoid print_device_info(Device* dev) {\n    // Check if device pointer is valid\n    if (!dev) {\n        printk(KERN_ERR \"Cannot print info: device is NULL\\n\");\n        return;\n    }\n    \n    printk(KERN_INFO \"=== Device Info ===\\n\");\n    printk(KERN_INFO \"Device ID: %d\\n\", dev->device_id);\n    printk(KERN_INFO \"Status: %d\\n\", dev->status);\n    printk(KERN_INFO \"Active: %s\\n\", dev->is_active ? \"YES\" : \"NO\");\n}\n\n/* TODO: Implement cleanup function */\nvoid cleanup_device(void) {\n    if (my_device) {\n        printk(KERN_INFO \"Freeing device memory...\\n\");\n        /* TODO: kfree(my_device); */\n        my_device = NULL;  // Prevent accidental reuse\n        printk(KERN_INFO \"Device memory freed\\n\");\n    }\n}\n\nstatic int __init dynamic_memory_init(void)\n{\n    printk(KERN_INFO \"Dynamic memory module loaded\\n\");\n    printk(KERN_INFO \"Learning kmalloc and kfree!\\n\");\n    \n    /* Create device using runtime parameter */\n    my_device = create_device(device_id);\n    if (!my_device) {\n        printk(KERN_ERR \"Failed to create device\\n\");\n        return -ENOMEM;\n    }\n    \n    /* Print device information */\n    print_device_info(my_device);\n    \n    return 0;\n}\n\nstatic void __exit dynamic_memory_exit(void)\n{\n    printk(KERN_INFO \"Dynamic memory module unloading\\n\");\n    \n    /* Clean up allocated memory */\n    cleanup_device();\n    \n    printk(KERN_INFO \"Module unloaded cleanly\\n\");\n}\n\nmodule_init(dynamic_memory_init);\nmodule_exit(dynamic_memory_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning kmalloc and kfree essentials\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Dynamic memory module Makefile\nobj-m += dynamic_memory.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "dynamic_memory.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "dynamic_memory_init",
          "dynamic_memory_exit",
          "create_device",
          "print_device_info",
          "cleanup_device"
        ],
        "function_declarations": [
          {
            "name": "create_device",
            "returnType": "Device*",
            "parameters": [
              "int id"
            ]
          },
          {
            "name": "print_device_info",
            "returnType": "void",
            "parameters": [
              "Device* dev"
            ]
          },
          {
            "name": "cleanup_device",
            "returnType": "void",
            "parameters": []
          }
        ],
        "variables_declarations": [
          {
            "name": "Device",
            "type": "typedef struct",
            "value": "{int device_id; int status; bool is_active;}",
            "storageClass": "none"
          },
          {
            "name": "my_device",
            "type": "Device *",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "my_device",
            "type": "Device *",
            "value": "NULL",
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Dynamic memory module loaded",
          "Learning kmalloc and kfree!",
          "Creating device with ID: 1001",
          "Device allocated successfully!",
          "=== Device Info ===",
          "Device ID: 1001",
          "Status: 200",
          "Active: YES",
          "Dynamic memory module unloading",
          "Device memory freed",
          "Module unloaded cleanly"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h",
          "linux/slab.h",
          "linux/string.h"
        ],
        "mustContain": [
          "kmalloc(sizeof(Device), GFP_KERNEL)",
          "kfree(my_device)",
          "if (!my_device)",
          "my_device = NULL",
          "module_param(device_id, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "Device* create_device(int id)",
            "void print_device_info(Device* dev)",
            "void cleanup_device(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "Device* create_device(int id)",
            "void print_device_info(Device* dev)",
            "void cleanup_device(void)",
            "static int __init dynamic_memory_init(void)",
            "static void __exit dynamic_memory_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Dynamic memory module loaded",
              "exact": true,
              "linkedFunction": "static int __init dynamic_memory_init(void)"
            },
            {
              "pattern": "Learning kmalloc and kfree!",
              "exact": true,
              "linkedFunction": "static int __init dynamic_memory_init(void)"
            },
            {
              "pattern": "Creating device with ID: 1001",
              "exact": true,
              "linkedFunction": "Device* create_device(int id)"
            },
            {
              "pattern": "Device allocated successfully!",
              "exact": true,
              "linkedFunction": "Device* create_device(int id)"
            },
            {
              "pattern": "=== Device Info ===",
              "exact": true,
              "linkedFunction": "void print_device_info(Device* dev)"
            },
            {
              "pattern": "Device ID: 1001",
              "exact": true,
              "linkedFunction": "void print_device_info(Device* dev)"
            },
            {
              "pattern": "Status: 200",
              "exact": true,
              "linkedFunction": "void print_device_info(Device* dev)"
            },
            {
              "pattern": "Active: YES",
              "exact": true,
              "linkedFunction": "void print_device_info(Device* dev)"
            },
            {
              "pattern": "Dynamic memory module unloading",
              "exact": true,
              "linkedFunction": "static void __exit dynamic_memory_exit(void)"
            },
            {
              "pattern": "Device memory freed",
              "exact": true,
              "linkedFunction": "void cleanup_device(void)"
            },
            {
              "pattern": "Module unloaded cleanly",
              "exact": true,
              "linkedFunction": "static void __exit dynamic_memory_exit(void)"
            }
          ]
        },
        {
          "id": "advanced_dynamic_memory_validation",
          "name": "Advanced Dynamic Memory Implementation with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "memory_dynamic_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Memory Anti-Hardcoding Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random device IDs\\n    int test_device_id1 = (rand() % 9000) + 1000;   // 1000-9999\\n    int test_device_id2 = (rand() % 5000) + 20000;  // 20000-24999\\n    \\n    printf(\\\"Test 1: Testing kmalloc with device_id=%d\\\\n\\\", test_device_id1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/dynamic_memory.ko device_id=%d\\\", test_device_id1);\\n    system(\\\"rmmod dynamic_memory 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Testing kmalloc with device_id=%d\\\\n\\\", test_device_id2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/dynamic_memory.ko device_id=%d\\\", test_device_id2);\\n    system(\\\"rmmod dynamic_memory\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Anti-hardcoding memory test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced dynamic memory implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
              "echo '#define true 1' >> /tmp/linux/types.h",
              "echo '#define false 0' >> /tmp/linux/types.h",
              "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
              "echo '#define MAX_DEVICES 5' >> /tmp/linux/types.h",
              "echo '#define GFP_KERNEL 0' > /tmp/linux/slab.h",
              "echo '#define ENOMEM 12' >> /tmp/linux/slab.h",
              "echo 'void *kmalloc(size_t size, int flags);' >> /tmp/linux/slab.h",
              "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
              "echo 'Creating test file that includes dynamic memory header...'",
              "echo '#include \"/lib/modules/dynamic_memory.h\"' > /tmp/test.c",
              "echo 'int main() { create_device(123); print_device_info(my_device); cleanup_device(); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
              "echo 'Phase 2: Anti-Hardcoding Dynamic Memory Testing'",
              "/bin/memory_dynamic_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Random Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "DEVICE_ID1=$(grep -o 'Test 1: Testing kmalloc with device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
              "DEVICE_ID2=$(grep -o 'Test 2: Testing kmalloc with device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
              "echo 'Extracted values: DEVICE_ID1='$DEVICE_ID1', DEVICE_ID2='$DEVICE_ID2",
              "if [ -z \"$DEVICE_ID1\" ] || [ -z \"$DEVICE_ID2\" ]; then echo 'FAIL: Could not extract random test values'; else echo 'PASS: Random values extracted successfully'; fi",
              "echo 'Phase 4: Anti-Hardcoding Memory Allocation Validation'",
              "echo 'Validating kmalloc with random device ID '$DEVICE_ID1",
              "dmesg | grep \"Creating device with ID: $DEVICE_ID1\" && echo 'PASS: Device creation with random ID working' || echo 'FAIL: Device creation with random ID broken'",
              "dmesg | grep \"Device allocated successfully!\" && echo 'PASS: kmalloc allocation working' || echo 'FAIL: kmalloc allocation broken'",
              "dmesg | grep \"Device ID: $DEVICE_ID1\" && echo 'PASS: Device data access working with '$DEVICE_ID1 || echo 'FAIL: Device data access broken'",
              "echo 'Validating kmalloc with random device ID '$DEVICE_ID2",
              "dmesg | grep \"Creating device with ID: $DEVICE_ID2\" && echo 'PASS: Device creation with random ID working' || echo 'FAIL: Device creation with random ID broken'",
              "dmesg | grep \"Device ID: $DEVICE_ID2\" && echo 'PASS: Device data access working with '$DEVICE_ID2 || echo 'FAIL: Device data access broken'",
              "echo 'Phase 5: Memory Cleanup Validation'",
              "dmesg | grep 'Device memory freed' && echo 'PASS: kfree cleanup working' || echo 'FAIL: kfree cleanup broken'",
              "dmesg | grep 'Module unloaded cleanly' && echo 'PASS: Complete cleanup working' || echo 'FAIL: Complete cleanup broken'",
              "echo 'Phase 6: Function Logic Validation'",
              "dmesg | grep 'Learning kmalloc and kfree!' && echo 'PASS: Module messaging working' || echo 'FAIL: Module messaging broken'",
              "dmesg | grep 'Active: YES' && echo 'PASS: Device status working' || echo 'FAIL: Device status broken'",
              "echo 'Phase 7: Final Validation Summary'",
              "echo 'All phases completed successfully - kmalloc/kfree pattern verified'",
              "echo 'PASS: All anti-hardcoding memory validation successful'"
            ],
            "expected": {
              "dmesg": [
                "Dynamic memory module loaded",
                "Learning kmalloc and kfree!",
                "Creating device with ID: .*",
                "Device allocated successfully!",
                "Device ID: .*",
                "Active: YES",
                "Device memory freed",
                "Module unloaded cleanly"
              ],
              "stdout": [
                "PASS: All function and variable declarations found in header file",
                "SUCCESS: Anti-hardcoding memory test completed",
                "PASS: Random values extracted successfully",
                "PASS: Device creation with random ID working",
                "PASS: kmalloc allocation working",
                "PASS: Device data access working",
                "PASS: kfree cleanup working",
                "PASS: Complete cleanup working",
                "PASS: All anti-hardcoding memory validation successful"
              ]
            },
            "timeout": 15
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Dynamic memory module loaded",
        "Learning kmalloc and kfree!",
        "Creating device with ID: 1001",
        "Device allocated successfully!",
        "=== Device Info ===",
        "Device ID: 1001",
        "Status: 200",
        "Active: YES",
        "Dynamic memory module unloading",
        "Device memory freed",
        "Module unloaded cleanly"
      ],
      "requirements": [
        "Use required function names: dynamic_memory_init, dynamic_memory_exit, create_device, print_device_info, cleanup_device",
        "Use required variable names: my_device",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h, linux/slab.h, linux/string.h",
        "Code must contain: kmalloc(sizeof(Device), GFP_KERNEL), kfree(my_device), if (!my_device), my_device = NULL, module_param(device_id, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Dynamic memory module loaded",
          "linkedFunction": "static int __init dynamic_memory_init(void)",
          "exact": true
        },
        {
          "pattern": "Learning kmalloc and kfree!",
          "linkedFunction": "static int __init dynamic_memory_init(void)",
          "exact": true
        },
        {
          "pattern": "Creating device with ID: 1001",
          "linkedFunction": "Device* create_device(int id)",
          "exact": true
        },
        {
          "pattern": "Device allocated successfully!",
          "linkedFunction": "Device* create_device(int id)",
          "exact": true
        },
        {
          "pattern": "=== Device Info ===",
          "linkedFunction": "void print_device_info(Device* dev)",
          "exact": true
        },
        {
          "pattern": "Device ID: 1001",
          "linkedFunction": "void print_device_info(Device* dev)",
          "exact": true
        },
        {
          "pattern": "Status: 200",
          "linkedFunction": "void print_device_info(Device* dev)",
          "exact": true
        },
        {
          "pattern": "Active: YES",
          "linkedFunction": "void print_device_info(Device* dev)",
          "exact": true
        },
        {
          "pattern": "Dynamic memory module unloading",
          "linkedFunction": "static void __exit dynamic_memory_exit(void)",
          "exact": true
        },
        {
          "pattern": "Device memory freed",
          "linkedFunction": "void cleanup_device(void)",
          "exact": true
        },
        {
          "pattern": "Module unloaded cleanly",
          "linkedFunction": "static void __exit dynamic_memory_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 20,
    "title": "Pointer Casting - Multi-Level Type Conversion Mastery",
    "difficulty": 7,
    "xp": 60,
    "phase": "foundations",
    "description": "Master multi-level pointer casting chains: void*  generic_record*  sensor_record*. Learn the exact patterns used in production kernel parsers for safe type conversion and record processing.",
    "concepts": [
      "multi-level pointer casting",
      "void* generic pointers",
      "type-safe casting patterns",
      "polymorphic C structures",
      "record header patterns",
      "production parsing techniques"
    ],
    "skills": [
      "Casting void* to specific types safely",
      "Understanding pointer type conversion",
      "Implementing polymorphic C patterns",
      "Using casting chains like libstdf",
      "Professional kernel development practices",
      "Type safety validation"
    ],
    "files": [
      {
        "name": "pointer_casting.h",
        "content": "#ifndef POINTER_CASTING_H\n#define POINTER_CASTING_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n#define MAX_NAME_LEN 32\n\n/* Record type constants */\n#define SENSOR_RECORD 1\n#define DEVICE_RECORD 2\n\n/* Base record header (like rec_header) */\ntypedef struct {\n    uint8_t rec_type;\n    uint8_t rec_subtype;\n    uint16_t rec_length;\n} record_header;\n\n/* Generic record (like rec_unknown) */\ntypedef struct {\n    record_header header;\n    void* data;\n} generic_record;\n\n/* Specific record types (like rec_ptr, rec_mpr) */\ntypedef struct {\n    record_header header;\n    uint32_t sensor_id;\n    char sensor_name[MAX_NAME_LEN];\n    uint32_t measurement_value;\n} sensor_record;\n\ntypedef struct {\n    record_header header;\n    uint32_t device_id;\n    char device_status[MAX_NAME_LEN];\n    bool is_active;\n} device_record;\n\n/* Global record pointers for testing */\nextern generic_record *current_record;\nextern sensor_record *sensor_data;\nextern device_record *device_data;\n\n/* TODO: Declare your functions */\n/* void process_generic_record(void *raw_record); */\n/* void extract_sensor_data(generic_record *rec); */\n/* void extract_device_data(generic_record *rec); */\n/* void print_record_info(void); */\n\n#endif /* POINTER_CASTING_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "pointer_casting.c",
        "content": "#include \"pointer_casting.h\"\n\n/* Global record pointers initialized to NULL */\ngeneric_record *current_record = NULL;\nsensor_record *sensor_data = NULL;\ndevice_record *device_data = NULL;\n\nint test_record_type = SENSOR_RECORD;\nint test_sensor_id = 1001;\nint test_measurement = 257;\nint test_device_id = 2001;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your casting logic works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(test_record_type, int, 0644);\nMODULE_PARM_DESC(test_record_type, \"Record type for testing casting logic\");\nmodule_param(test_sensor_id, int, 0644);\nMODULE_PARM_DESC(test_sensor_id, \"Sensor ID for anti-hardcoding testing\");\nmodule_param(test_measurement, int, 0644);\nMODULE_PARM_DESC(test_measurement, \"Measurement value for anti-hardcoding testing\");\nmodule_param(test_device_id, int, 0644);\nMODULE_PARM_DESC(test_device_id, \"Device ID for anti-hardcoding testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: How multi-level pointer casting works in C */\n/* Basic pattern for casting pointers step by step:\n *\n * void* raw_ptr = get_generic_pointer();\n * generic_record* rec = (generic_record*)raw_ptr;  // Cast void* to generic type\n * sensor_record* sensor = (sensor_record*)rec;     // Cast generic to specific type\n *\n * This is like: void*  generic_record*  sensor_record*\n */\n\n/* WHAT EACH POINTER CONTAINS AND HOW TO USE IT: */\n\n/* 1. void* raw_ptr - Generic pointer (can point to ANY data type) */\n/*    Contains: Memory address, but no type information */\n/*    Usage: Cannot access fields directly - MUST cast first */\n/*    Example: raw_ptr points to memory, but raw_ptr->header won't work */\n\n/* 2. generic_record* rec - Pointer to generic record structure */\n/*    Contains: Same memory address, but now treats it as generic_record */\n/*    Usage: Can access generic fields: rec->header.rec_type, rec->data */\n/*    Example: rec->header.rec_type tells us if it's SENSOR or DEVICE */\n\n/* 3. sensor_record* sensor - Pointer to specific sensor record structure */\n/*    Contains: Same memory address, now treated as sensor_record */\n/*    Usage: Can access sensor fields: sensor->sensor_id, sensor->measurement_value */\n/*    Example: sensor->sensor_id gets the specific sensor ID number */\n\n/* HOW STRUCT-TO-STRUCT CASTING WORKS: */\n/* All structs start with same header layout: */\n/* generic_record: [header][data*]          <- Generic view */\n/* sensor_record:  [header][sensor_id][...] <- Specific view */\n/* device_record:  [header][device_id][...] <- Specific view */\n/* Same memory, different interpretation! */\n\n/* CASTING OPERATORS EXPLAINED: */\n/* (type_name*)pointer means \"treat this pointer as type_name*\" */\n/* Example: (sensor_record*)rec means \"treat rec as sensor_record*\" */\n/*           target type      source pointer */\n/* Why cast? To change how we interpret the memory structure */\n\n/* AMPERSAND OPERATOR (&) EXPLAINED IN DETAIL: */\n/* & is the \"address-of\" operator - it gets the memory address of a variable */\n\n/* WHAT & PRODUCES AND WHY WE NEED IT: */\n/* 1. &variable - Gets the memory address where variable is stored */\n/*    Contains: The actual memory address (like 0x7fff1234) */\n/*    Usage: Converts a variable into a pointer to that variable */\n/*    Example: &test_sensor_record gives the address where test_sensor_record lives */\n\n/* 2. variable (without &) - The actual data/contents of the variable */\n/*    Contains: The struct data itself (all the fields and values) */\n/*    Usage: Direct access to the variable's contents */\n/*    Example: test_sensor_record gives you the actual struct contents */\n\n/* WHY FUNCTIONS NEED POINTERS (ADDRESSES) NOT VALUES: */\n/* Function parameter: void process_record(void* raw_record) */\n/*                                           expects a POINTER (address) */\n/* */\n/* If we have: static generic_record test_sensor_record = {...}; */\n/* */\n/* CORRECT:   process_record((void*)&test_sensor_record); */\n/*             cast to void*   get address of the struct */\n/* */\n/* WRONG:     process_record((void*)test_sensor_record); */\n/*             tries to cast struct contents to pointer - INVALID! */\n\n/* MEMORY LAYOUT VISUALIZATION: */\n/* Memory Address: 0x1000                                    */\n/*   */\n/*  test_sensor_record struct data lives here             */\n/*  [rec_type: 1][rec_subtype: 1][rec_length: 48][...]   */\n/*   */\n/*                                                          */\n/*   This address (0x1000) is what &test_sensor_record gives us */\n\n/* WHAT EACH EXPRESSION EVALUATES TO: */\n/* test_sensor_record      = The actual struct contents (can't fit in a pointer!) */\n/* &test_sensor_record     = 0x1000 (the address - this fits in a pointer!) */\n/* (void*)&test_sensor_record = 0x1000 cast as void* (what the function wants!) */\n\n/* THE & AND * RELATIONSHIP: */\n/* & = \"address of\" operator (gets address from variable) */\n/* * = \"dereference\" operator (gets value from address) */\n/* */\n/* If: generic_record* ptr = &test_sensor_record; */\n/* Then: *ptr gives you back the original test_sensor_record contents */\n/* And: ptr gives you the address (same as &test_sensor_record) */\n\n/* COMMON MISTAKES AND COMPILER ERRORS: */\n/* ERROR: test_record = (void*)test_sensor_record; */\n/* Compiler says: \"cannot convert 'generic_record' to 'void*'\" */\n/* Why? Because test_sensor_record is struct data, not an address */\n/* */\n/* CORRECT: test_record = (void*)&test_sensor_record; */\n/* Compiler happy: &test_sensor_record is an address, void* expects address */\n\n/* PRACTICAL EXAMPLES: */\n/* int x = 42; */\n/* int* ptr = &x;          // ptr now contains address of x */\n/* print(\"%p\", &x);       // Prints address like 0x7fff1234 */\n/* print(\"%d\", x);        // Prints value: 42 */\n/* print(\"%d\", *ptr);     // Prints value through pointer: 42 */\n\n/* IN OUR KERNEL CODE CONTEXT: */\n/* static generic_record test_sensor_record = {...}; // Struct variable */\n/* void* test_record = (void*)&test_sensor_record;   // Get its address */\n/* process_generic_record(test_record);              // Pass address to function */\n/* */\n/* Inside process_generic_record(void* raw_record): */\n/* generic_record* rec = (generic_record*)raw_record; // Cast address back to typed pointer */\n/* // Now rec points to our original test_sensor_record! */\n\n/* Predefined sensor record for testing */\nstatic sensor_record test_sensor = {\n    .header = { .rec_type = SENSOR_RECORD, .rec_subtype = 1, .rec_length = 48 },\n    .sensor_id = 1001,\n    .sensor_name = \"temperature_01\",\n    .measurement_value = 257\n};\n\n/* Predefined device record for testing */\nstatic device_record test_device = {\n    .header = { .rec_type = DEVICE_RECORD, .rec_subtype = 1, .rec_length = 52 },\n    .device_id = 2001,\n    .device_status = \"operational\",\n    .is_active = true\n};\n\n/* TODO: Implement multi-level casting function */\n/* Use the pattern above: void*  generic_record*  specific_record* */\nvoid process_generic_record(void *raw_record) {\n    /* WHY WE NEED THIS CASTING CHAIN: */\n    /* */\n    /* When we call this function from init: */\n    /* process_generic_record((void*)&test_sensor); */\n    /*                                            */\n    /*                        Cast sensor_record* to void* first */\n    /* */\n    /* STEP-BY-STEP EXPLANATION: */\n    /* 1. test_sensor is type: sensor_record */\n    /* 2. &test_sensor is type: sensor_record* (pointer to sensor_record) */\n    /* 3. (void*)&test_sensor is type: void* (generic pointer) */\n    /* 4. Function parameter raw_record receives: void* (generic pointer) */\n    /* */\n    /* INSIDE THIS FUNCTION - THE REVERSE JOURNEY: */\n    /* 5. raw_record is type: void* (we lost the original type information) */\n    /* 6. Cast to generic_record*: (generic_record*)raw_record */\n    /* 7. Now we can access header: rec->header.rec_type */\n    /* 8. Based on rec_type, cast to specific type: (sensor_record*)rec */\n    /* */\n    /* WHY THIS WORKS - MEMORY LAYOUT COMPATIBILITY: */\n    /* All record types start with the SAME header layout: */\n    /* sensor_record:  [header][sensor_id][measurement_value][sensor_name] */\n    /* device_record:  [header][device_id][device_status][is_active] */\n    /* generic_record: [header][data*] */\n    /*                   Same header in all types! */\n    /* */\n    /* So casting between them is safe for accessing the header portion */\n    \n    // TODO: Step 1: Cast void* raw_record to generic_record* (so we can access header)\n    // TODO: Step 2: Check header.rec_type to determine what kind of record this is\n    // TODO: Step 3: Route to extract_sensor_data() or extract_device_data() based on record type (use if or switch statement)\n    // Your implementation here\n}\n\n/* TODO: Implement sensor data extraction */\nvoid extract_sensor_data(generic_record *rec) {\n    // Cast generic_record* rec to sensor_record*\n    // Store sensor data and print information\n    // Your implementation here\n}\n\n/* TODO: Implement device data extraction */\nvoid extract_device_data(generic_record *rec) {\n    // Cast generic_record* rec to device_record*\n    // Store device data and print information\n    // Your implementation here\n}\n\nvoid print_record_info(void) {\n    if (!current_record) {\n        printk(KERN_ERR \"No current record available\\n\");\n        return;\n    }\n    \n    printk(KERN_INFO \"Current Record Info:\\n\");\n    \n    printk(KERN_INFO \"Record Subtype: %u\\n\", current_record->header.rec_subtype);\n    printk(KERN_INFO \"Record Type: %u\\n\", current_record->header.rec_type);\n    printk(KERN_INFO \"Record Length: %u\\n\", current_record->header.rec_length);\n}\n\n/* DETAILED EXPLANATION OF INIT FUNCTION - STEP BY STEP MEMORY ANALYSIS */\n/* This function demonstrates the complete casting chain with detailed memory explanations */\n\n/* UNDERSTANDING THE INIT FUNCTION CALLS: */\n/* test_sensor.sensor_id = test_sensor_id;        // Modify struct fields */\n/* test_sensor.measurement_value = test_measurement; */\n/* test_record = (void *)&test_sensor;           // Get address of entire struct */\n/* process_generic_record(test_record);          // Pass address to function */\n/* */\n/* WHAT &test_sensor GIVES YOU: */\n/* - &test_sensor = address of the ENTIRE struct (not just sensor_id) */\n/* - test_record = pointer to the whole struct */\n/* */\n/* MEMORY LAYOUT VISUALIZATION: */\n/* Memory Address: 0x1000 */\n/*  */\n/*  test_sensor struct (entire thing)        */\n/*      &test_sensor points HERE (to start) */\n/*   header: {rec_type=1, subtype=1...}   */\n/*    */\n/*   sensor_id: 1001                       */\n/*    */\n/*   sensor_name: \\\"temperature_01\\\"         */\n/*    */\n/*   measurement_value: 257                */\n/*    */\n/*  */\n/* */\n/* SO test_record POINTS TO: */\n/* - YES: The entire struct (including header, sensor_id, sensor_name, measurement_value) */\n/* - NO: NOT just sensor_id and measurement_value */\n/* */\n/* INSIDE process_generic_record(test_record): */\n/* void process_generic_record(void *raw_record) { */\n/*     // raw_record contains 0x1000 (address of entire test_sensor struct) */\n/*  */\n/*     generic_record *rec = (generic_record *)raw_record; */\n/*     // Now rec points to the same location, but treated as generic_record */\n/*  */\n/*     rec->header.rec_type;  // Accesses the header part */\n/*     // This works because both sensor_record and generic_record  */\n/*     // start with the same header layout! */\n/* } */\n/* */\n/* KEY POINT: */\n/* &test_sensor gives you the address of the WHOLE struct, not individual fields. */\n/* The function receives a pointer to the entire struct and can access any field within it. */\n/* */\n/* THE CASTING CHAIN: */\n/* 1. test_sensor = actual struct variable */\n/* 2. &test_sensor = pointer to entire struct */\n/* 3. (void *)&test_sensor = same pointer, but cast as generic void* */\n/* 4. Inside function: cast back to access fields */\n/* */\n/* So yes, test_record is a pointer, but it points to the ENTIRE struct, giving access to all fields! */\n\nstatic int __init pointer_casting_init(void)\n{\n    void *test_record;\n    \n    printk(KERN_INFO \"Pointer casting module loaded\\n\");\n    \n    /* Test both sensor and device records for comprehensive validation */\n    \n    /* First test: Sensor record with dynamic parameter values */\n    test_sensor.sensor_id = test_sensor_id;        /* Modify struct fields */\n    test_sensor.measurement_value = test_measurement;\n    test_record = (void *)&test_sensor;           /* Get address of entire struct */\n    process_generic_record(test_record);          /* Pass address to function */\n    print_record_info();\n    \n    /* Second test: Device record with dynamic parameter values */\n    test_device.device_id = test_device_id;       /* Modify struct fields */\n    test_record = (void *)&test_device;           /* Get address of entire struct */\n    process_generic_record(test_record);          /* Pass address to function */\n    print_record_info();\n    \n    return 0;\n}\n\nstatic void __exit pointer_casting_exit(void)\n{\n    printk(KERN_INFO \"Pointer casting module unloaded\\n\");\n    \n    /* Reset pointers */\n    current_record = NULL;\n    sensor_data = NULL;\n    device_data = NULL;\n}\n\nmodule_init(pointer_casting_init);\nmodule_exit(pointer_casting_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning multi-level pointer casting and type conversion\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Pointer casting module Makefile\nobj-m += pointer_casting.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "pointer_casting.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "pointer_casting_init",
          "pointer_casting_exit",
          "process_generic_record",
          "extract_sensor_data",
          "extract_device_data",
          "print_record_info"
        ],
        "function_declarations": [
          {
            "name": "process_generic_record",
            "returnType": "void",
            "parameters": [
              "void *raw_record"
            ]
          },
          {
            "name": "extract_sensor_data",
            "returnType": "void",
            "parameters": [
              "generic_record *rec"
            ]
          },
          {
            "name": "extract_device_data",
            "returnType": "void",
            "parameters": [
              "generic_record *rec"
            ]
          },
          {
            "name": "print_record_info",
            "returnType": "void",
            "parameters": []
          }
        ],
        "variables_declarations": [
          {
            "name": "record_header",
            "type": "typedef struct",
            "value": "{uint8_t rec_type; uint8_t rec_subtype; uint16_t rec_length;}",
            "storageClass": "none"
          },
          {
            "name": "generic_record",
            "type": "typedef struct",
            "value": "{record_header header; void* data;}",
            "storageClass": "none"
          },
          {
            "name": "sensor_record",
            "type": "typedef struct",
            "value": "{record_header header; uint32_t sensor_id; char sensor_name[MAX_NAME_LEN]; uint32_t measurement_value;}",
            "storageClass": "none"
          },
          {
            "name": "device_record",
            "type": "typedef struct",
            "value": "{record_header header; uint32_t device_id; char device_status[MAX_NAME_LEN]; bool is_active;}",
            "storageClass": "none"
          },
          {
            "name": "current_record",
            "type": "generic_record *",
            "storageClass": "extern"
          },
          {
            "name": "sensor_data",
            "type": "sensor_record *",
            "storageClass": "extern"
          },
          {
            "name": "device_data",
            "type": "device_record *",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "current_record",
            "type": "generic_record *",
            "value": "NULL",
            "storageClass": "none"
          },
          {
            "name": "sensor_data",
            "type": "sensor_record *",
            "value": "NULL",
            "storageClass": "none"
          },
          {
            "name": "device_data",
            "type": "device_record *",
            "value": "NULL",
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Pointer casting module loaded",
          "Sensor Record Extracted",
          "Sensor ID: 1001",
          "Sensor Name: temperature_01",
          "Measurement: 257",
          "Current Record Info:",
          "Record Type: 1",
          "Record Subtype: 1",
          "Record Length: 48",
          "Device Record Extracted",
          "Device ID: 2001",
          "Device Status: operational",
          "Active: true",
          "Current Record Info:",
          "Record Type: 2",
          "Record Subtype: 1",
          "Record Length: 52",
          "Pointer casting module unloaded"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "generic_record *rec = (generic_record *)raw_record",
          "sensor_record *sensor = (sensor_record *)rec",
          "device_record *device = (device_record *)rec",
          "current_record = rec",
          "sensor_data = sensor",
          "device_data = device",
          "if (rec->header.rec_type == SENSOR_RECORD)",
          "module_param(test_record_type, int, 0644)",
          "module_param(test_sensor_id, int, 0644)",
          "module_param(test_measurement, int, 0644)",
          "module_param(test_device_id, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void process_generic_record(void *raw_record)",
            "void extract_sensor_data(generic_record *rec)",
            "void extract_device_data(generic_record *rec)",
            "void print_record_info(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void process_generic_record(void *raw_record)",
            "void extract_sensor_data(generic_record *rec)",
            "void extract_device_data(generic_record *rec)",
            "void print_record_info(void)",
            "static int __init pointer_casting_init(void)",
            "static void __exit pointer_casting_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Pointer casting module loaded",
              "exact": true,
              "linkedFunction": "static int __init pointer_casting_init(void)"
            },
            {
              "pattern": "Sensor Record Extracted",
              "exact": true,
              "linkedFunction": "void extract_sensor_data(generic_record *rec)"
            },
            {
              "pattern": "Sensor ID: 1001",
              "exact": true,
              "linkedFunction": "void extract_sensor_data(generic_record *rec)"
            },
            {
              "pattern": "Sensor Name: temperature_01",
              "exact": true,
              "linkedFunction": "void extract_sensor_data(generic_record *rec)"
            },
            {
              "pattern": "Measurement: 257",
              "exact": true,
              "linkedFunction": "void extract_sensor_data(generic_record *rec)"
            },
            {
              "pattern": "Current Record Info:",
              "exact": true,
              "linkedFunction": "void print_record_info(void)"
            },
            {
              "pattern": "Record Type: 1",
              "exact": true,
              "linkedFunction": "void print_record_info(void)"
            },
            {
              "pattern": "Record Subtype: 1",
              "exact": true,
              "linkedFunction": "void print_record_info(void)"
            },
            {
              "pattern": "Record Length: 48",
              "exact": true,
              "linkedFunction": "void print_record_info(void)"
            },
            {
              "pattern": "Device Record Extracted",
              "exact": true,
              "linkedFunction": "void extract_device_data(generic_record *rec)"
            },
            {
              "pattern": "Device ID: 2001",
              "exact": true,
              "linkedFunction": "void extract_device_data(generic_record *rec)"
            },
            {
              "pattern": "Device Status: operational",
              "exact": true,
              "linkedFunction": "void extract_device_data(generic_record *rec)"
            },
            {
              "pattern": "Active: true",
              "exact": true,
              "linkedFunction": "void extract_device_data(generic_record *rec)"
            },
            {
              "pattern": "Current Record Info:",
              "exact": true,
              "linkedFunction": "void print_record_info(void)"
            },
            {
              "pattern": "Record Type: 2",
              "exact": true,
              "linkedFunction": "void print_record_info(void)"
            },
            {
              "pattern": "Record Subtype: 1",
              "exact": true,
              "linkedFunction": "void print_record_info(void)"
            },
            {
              "pattern": "Record Length: 52",
              "exact": true,
              "linkedFunction": "void print_record_info(void)"
            },
            {
              "pattern": "Pointer casting module unloaded",
              "exact": true,
              "linkedFunction": "static void __exit pointer_casting_exit(void)"
            }
          ]
        },
        {
          "id": "advanced_casting_validation",
          "name": "Advanced Multi-Level Casting Implementation with Anti-Hardcoding Protection",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "casting_dynamic_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Anti-Hardcoding Casting Test ===\\\\n\\\");\\n    \\n    // Seed random number generator with current time\\n    srand(time(NULL));\\n    \\n    // Generate unpredictable sensor test values\\n    int random_sensor_id = (rand() % 9000) + 1000;  // 1000-9999\\n    int random_measurement = (rand() % 500) + 100;   // 100-599\\n    \\n    // Generate unpredictable device test values\\n    int random_device_id = (rand() % 8000) + 2000;  // 2000-9999\\n    \\n    printf(\\\"Test 1: Random sensor casting (ID=%d, measurement=%d)\\\\n\\\", random_sensor_id, random_measurement);\\n    printf(\\\"Test 2: Random device casting (ID=%d)\\\\n\\\", random_device_id);\\n    \\n    // Test sensor record casting with random values\\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod pointer_casting 2>/dev/null\\\");\\n    \\n    char cmd1[512];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/pointer_casting.ko test_record_type=1 test_sensor_id=%d test_measurement=%d\\\", random_sensor_id, random_measurement);\\n    printf(\\\"DEBUG: Sensor command: %s\\\\n\\\", cmd1);\\n    system(cmd1);\\n    \\n    \\n    // Test device record casting with random values\\n    printf(\\\"DEBUG: Switching to device test...\\\\n\\\");\\n    system(\\\"rmmod pointer_casting\\\");\\n    \\n    char cmd2[512];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/pointer_casting.ko test_record_type=2 test_device_id=%d\\\", random_device_id);\\n    printf(\\\"DEBUG: Device command: %s\\\\n\\\", cmd2);\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Anti-hardcoding casting test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced multi-level casting implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo 'typedef unsigned char uint8_t;' >> /tmp/linux/types.h",
              "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
              "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
              "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
              "echo '#define true 1' >> /tmp/linux/types.h",
              "echo '#define false 0' >> /tmp/linux/types.h",
              "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
              "echo 'Creating test file that includes casting header...'",
              "echo '#include \"/lib/modules/pointer_casting.h\"' > /tmp/test.c",
              "echo 'int main() { current_record->header.rec_type = 1; process_generic_record((void*)0); extract_sensor_data((generic_record*)0); extract_device_data((generic_record*)0); print_record_info(); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
              "echo 'Phase 2: Anti-Hardcoding Dynamic Casting Test'",
              "/bin/casting_dynamic_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Random Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "SENSOR_ID=$(grep -o 'Random sensor casting (ID=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
              "SENSOR_MEASUREMENT=$(grep -o 'measurement=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
              "DEVICE_ID=$(grep -o 'Random device casting (ID=[0-9]*)' /tmp/test_output.log | cut -d'=' -f2 | cut -d')' -f1)",
              "echo 'Extracted values: SENSOR_ID='$SENSOR_ID', MEASUREMENT='$SENSOR_MEASUREMENT', DEVICE_ID='$DEVICE_ID",
              "if [ -z \"$SENSOR_ID\" ] || [ -z \"$SENSOR_MEASUREMENT\" ] || [ -z \"$DEVICE_ID\" ]; then echo 'FAIL: Could not extract random test values'; else echo 'PASS: Random values extracted successfully'; fi",
              "echo 'Phase 4: Anti-Hardcoding Validation with Random Values'",
              "echo 'Validating sensor casting with random ID '$SENSOR_ID",
              "dmesg | grep \"Sensor ID: $SENSOR_ID\" && echo 'PASS: Sensor casting with random ID working' || echo 'FAIL: Sensor casting with random ID broken'",
              "echo 'Validating sensor measurement with random value '$SENSOR_MEASUREMENT",
              "dmesg | grep \"Measurement: $SENSOR_MEASUREMENT\" && echo 'PASS: Sensor measurement with random value working' || echo 'FAIL: Sensor measurement with random value broken'",
              "echo 'Validating device casting with random ID '$DEVICE_ID",
              "dmesg | grep \"Device ID: $DEVICE_ID\" && echo 'PASS: Device casting with random ID working' || echo 'FAIL: Device casting with random ID broken'",
              "echo 'Phase 5: Static Field Validation (Non-Randomized Fields)'",
              "dmesg | grep 'Sensor Name: temperature_01' && echo 'PASS: Sensor name field access working' || echo 'FAIL: Sensor name field access broken'",
              "dmesg | grep 'Device Status: operational' && echo 'PASS: Device status field access working' || echo 'FAIL: Device status field access broken'",
              "echo 'Phase 6: Casting Logic and Record Type Validation'",
              "dmesg | grep 'Sensor Record Extracted' && echo 'PASS: Sensor extraction logic working' || echo 'FAIL: Sensor extraction logic broken'",
              "dmesg | grep 'Device Record Extracted' && echo 'PASS: Device extraction logic working' || echo 'FAIL: Device extraction logic broken'",
              "dmesg | grep 'Current Record Info:' && echo 'PASS: Record info display working' || echo 'FAIL: Record info display broken'",
              "echo 'Phase 7: Final Validation Summary'",
              "echo 'All phases completed successfully - anti-hardcoding protection verified'",
              "echo 'PASS: All anti-hardcoding casting validation successful'"
            ],
            "expected": {
              "dmesg": [
                "Pointer casting module loaded",
                "Sensor Record Extracted",
                "Sensor ID: .*",
                "Sensor Name: temperature_01",
                "Measurement: .*",
                "Device Record Extracted",
                "Device ID: .*",
                "Device Status: operational",
                "Current Record Info:",
                "Record Type: .*"
              ],
              "stdout": [
                "PASS: All function and variable declarations found in header file",
                "SUCCESS: Anti-hardcoding casting test completed",
                "PASS: Random values extracted successfully",
                "PASS: Sensor casting with random ID working",
                "PASS: Sensor measurement with random value working",
                "PASS: Device casting with random ID working",
                "PASS: Sensor name field access working",
                "PASS: Device status field access working",
                "PASS: Sensor extraction logic working",
                "PASS: Device extraction logic working",
                "PASS: Record info display working",
                "PASS: All anti-hardcoding casting validation successful"
              ]
            },
            "timeout": 15
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Pointer casting module loaded",
        "Sensor Record Extracted",
        "Sensor ID: 1001",
        "Sensor Name: temperature_01",
        "Measurement: 257",
        "Current Record Info:",
        "Record Type: 1",
        "Record Subtype: 1",
        "Record Length: 48",
        "Device Record Extracted",
        "Device ID: 2001",
        "Device Status: operational",
        "Active: true",
        "Current Record Info:",
        "Record Type: 2",
        "Record Subtype: 1",
        "Record Length: 52",
        "Pointer casting module unloaded"
      ],
      "requirements": [
        "Use required function names: pointer_casting_init, pointer_casting_exit, process_generic_record, extract_sensor_data, extract_device_data, print_record_info",
        "Use required variable names: current_record, sensor_data, device_data",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: generic_record *rec = (generic_record *)raw_record, sensor_record *sensor = (sensor_record *)rec, device_record *device = (device_record *)rec, current_record = rec, sensor_data = sensor, device_data = device, if (rec->header.rec_type == SENSOR_RECORD), module_param(test_record_type, int, 0644), module_param(test_sensor_id, int, 0644), module_param(test_measurement, int, 0644), module_param(test_device_id, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Pointer casting module loaded",
          "linkedFunction": "static int __init pointer_casting_init(void)",
          "exact": true
        },
        {
          "pattern": "Sensor Record Extracted",
          "linkedFunction": "void extract_sensor_data(generic_record *rec)",
          "exact": true
        },
        {
          "pattern": "Sensor ID: 1001",
          "linkedFunction": "void extract_sensor_data(generic_record *rec)",
          "exact": true
        },
        {
          "pattern": "Sensor Name: temperature_01",
          "linkedFunction": "void extract_sensor_data(generic_record *rec)",
          "exact": true
        },
        {
          "pattern": "Measurement: 257",
          "linkedFunction": "void extract_sensor_data(generic_record *rec)",
          "exact": true
        },
        {
          "pattern": "Current Record Info:",
          "linkedFunction": "void print_record_info(void)",
          "exact": true
        },
        {
          "pattern": "Record Type: 1",
          "linkedFunction": "void print_record_info(void)",
          "exact": true
        },
        {
          "pattern": "Record Subtype: 1",
          "linkedFunction": "void print_record_info(void)",
          "exact": true
        },
        {
          "pattern": "Record Length: 48",
          "linkedFunction": "void print_record_info(void)",
          "exact": true
        },
        {
          "pattern": "Device Record Extracted",
          "linkedFunction": "void extract_device_data(generic_record *rec)",
          "exact": true
        },
        {
          "pattern": "Device ID: 2001",
          "linkedFunction": "void extract_device_data(generic_record *rec)",
          "exact": true
        },
        {
          "pattern": "Device Status: operational",
          "linkedFunction": "void extract_device_data(generic_record *rec)",
          "exact": true
        },
        {
          "pattern": "Active: true",
          "linkedFunction": "void extract_device_data(generic_record *rec)",
          "exact": true
        },
        {
          "pattern": "Current Record Info:",
          "linkedFunction": "void print_record_info(void)",
          "exact": true
        },
        {
          "pattern": "Record Type: 2",
          "linkedFunction": "void print_record_info(void)",
          "exact": true
        },
        {
          "pattern": "Record Subtype: 1",
          "linkedFunction": "void print_record_info(void)",
          "exact": true
        },
        {
          "pattern": "Record Length: 52",
          "linkedFunction": "void print_record_info(void)",
          "exact": true
        },
        {
          "pattern": "Pointer casting module unloaded",
          "linkedFunction": "static void __exit pointer_casting_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 21,
    "title": "Function Pointers - STDF-Style Record Processing",
    "difficulty": 7,
    "xp": 60,
    "phase": "foundations",
    "description": "Master function pointer typedefs and function dispatch patterns used in production kernel parsers like STDF. Learn to assign functions to pointers, call functions through pointers, and implement simple record processing dispatch similar to libstdf parsing architecture.",
    "concepts": [
      "function pointer typedefs",
      "function pointer assignment",
      "calling functions through pointers",
      "combining casting with function dispatch",
      "STDF-style record processing patterns",
      "simple function pointer dispatch"
    ],
    "skills": [
      "Creating function pointer typedefs",
      "Assigning functions to pointers",
      "Calling functions through pointers",
      "Combining casting chains with function pointers",
      "Understanding STDF parser function dispatch",
      "Professional kernel processing patterns"
    ],
    "files": [
      {
        "name": "function_pointers.h",
        "content": "#ifndef FUNCTION_POINTERS_H\n#define FUNCTION_POINTERS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n#define MAX_NAME_LEN 32\n\n/* Record type constants (like STDF record types) */\n#define SENSOR_RECORD 1\n#define DEVICE_RECORD 2\n\n/* Base record header (like rec_header) */\ntypedef struct {\n    uint8_t rec_type;\n    uint8_t rec_subtype;\n    uint16_t rec_length;\n} record_header;\n\n/* Generic record (like rec_unknown) */\ntypedef struct {\n    record_header header;\n    void* data;\n} generic_record;\n\n/* Function pointer typedef (like STDF processor functions) */\ntypedef int (*record_processor_t)(void* record_data, uint32_t record_id);\n\n/* Global function pointers for different record types */\nextern record_processor_t sensor_processor;\nextern record_processor_t device_processor;\nextern record_processor_t active_processor;\n\n/* Function declarations */\nvoid register_processor(uint8_t record_type, record_processor_t processor);\nint process_record_with_function_pointer(void* raw_record, uint32_t record_id);\nvoid call_processor_function(record_processor_t processor, void* data, uint32_t id);\n\n/* Predefined processor functions for students to use */\nint sensor_record_processor(void* record_data, uint32_t record_id);\nint device_record_processor(void* record_data, uint32_t record_id);\n\n#endif /* FUNCTION_POINTERS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "function_pointers.c",
        "content": "#include \"function_pointers.h\"\n\n/* Global function pointers for record processing */\nrecord_processor_t sensor_processor = NULL;\nrecord_processor_t device_processor = NULL;\nrecord_processor_t active_processor = NULL;\n\nint test_record_type = SENSOR_RECORD;\nint test_record_id = 1001;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your function pointer logic works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(test_record_type, int, 0644);\nMODULE_PARM_DESC(test_record_type, \"Record type for testing function pointer dispatch\");\nmodule_param(test_record_id, int, 0644);\nMODULE_PARM_DESC(test_record_id, \"Record ID for anti-hardcoding testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* Predefined processor functions (provided for students) */\nint sensor_record_processor(void* record_data, uint32_t record_id) {\n    printk(KERN_INFO \"Processing sensor record ID: %u\\n\", record_id);\n    printk(KERN_INFO \"Sensor data processed successfully\\n\");\n    return 0;\n}\n\nint device_record_processor(void* record_data, uint32_t record_id) {\n    printk(KERN_INFO \"Processing device record ID: %u\\n\", record_id);\n    printk(KERN_INFO \"Device data processed successfully\\n\");\n    return 0;\n}\n\n/* Predefined test records for casting demonstration */\nstatic generic_record test_sensor_record = {\n    .header = { .rec_type = SENSOR_RECORD, .rec_subtype = 1, .rec_length = 48 },\n    .data = NULL\n};\n\nstatic generic_record test_device_record = {\n    .header = { .rec_type = DEVICE_RECORD, .rec_subtype = 1, .rec_length = 52 },\n    .data = NULL\n};\n\n/* PATTERN SCAFFOLDING: How function pointer dispatch works with casting */\n/* This combines casting chains from Problem 19 with function pointers:\n *\n * Step 1: Casting chain (like STDF parser)\n * void* raw_record  generic_record* rec  extract rec_type\n *\n * Step 2: Function pointer dispatch\n * typedef int (*record_processor_t)(void* data, uint32_t id);\n * record_processor_t processor = sensor_record_processor;\n * int result = processor(data, id);  // Call through function pointer\n *\n * This is like: void*  generic_record*  get type  select function  call\n */\n\n/* WHAT EACH POINTER AND FUNCTION CONTAINS AND HOW TO USE IT: */\n\n/* 1. void* raw_record - Generic data pointer (from Problem 19) */\n/*    Contains: Memory address pointing to some record data */\n/*    Usage: Must cast to specific type before accessing fields */\n/*    Example: raw_record points to memory, but raw_record->header won't work */\n\n/* 2. generic_record* rec - Typed record pointer (from Problem 19) */\n/*    Contains: Same memory address, now treated as generic_record */\n/*    Usage: Can access header fields: rec->header.rec_type */\n/*    Example: rec->header.rec_type tells us SENSOR_RECORD or DEVICE_RECORD */\n\n/* 3. record_processor_t processor - Function pointer variable */\n/*    Contains: Memory address pointing to a function (not data!) */\n/*    Usage: Can call the function: processor(data, id) */\n/*    Example: processor = sensor_record_processor; // Assign function address */\n\n/* HOW FUNCTION POINTER ASSIGNMENT WORKS: */\n/* Function names are addresses! */\n/* sensor_record_processor = Function address (like 0x401234) */\n/* processor = sensor_record_processor; // Copy function address to processor */\n/* Now processor contains the same address as sensor_record_processor */\n\n/* CASTING REVIEW FROM PROBLEM 19 (CRITICAL FOR FUNCTION POINTERS): */\n/* (type_name*)pointer means \"treat this pointer as type_name*\" */\n/* Example: (generic_record*)raw_record */\n/*           target type      source void* pointer */\n/* Why needed? To access record->header.rec_type for function dispatch! */\n\n/* AMPERSAND OPERATOR (&) REVIEW FROM PROBLEM 19: */\n/* &variable means \"get the address of variable\" */\n/* Example: (void*)&test_sensor_record */\n/*           cast to void*   get address of struct variable */\n/* Why &? Functions expect pointers (addresses), but test_sensor_record is a struct */\n\n/* FUNCTION POINTER CALLING EXPLAINED IN DETAIL: */\n/* processor(data, id) - Call function through pointer */\n/*     function pointer variable pointing to actual function */\n/*               parameters passed to the actual function */\n\n/* WHAT HAPPENS DURING FUNCTION POINTER CALL: */\n/* 1. processor contains function address (like 0x401234) */\n/* 2. processor(data, id) jumps to address 0x401234 */\n/* 3. Executes the actual function code at that address */\n/* 4. Passes data and id as parameters to the function */\n/* 5. Returns the function's return value */\n\n/* COMPARISON: DIRECT vs FUNCTION POINTER CALLS: */\n/* DIRECT:          sensor_record_processor(data, id); */\n/*                   compiler knows exact function at compile time */\n/* FUNCTION POINTER: processor(data, id); */\n/*                   function determined at runtime from processor variable */\n\n/* WHY USE FUNCTION POINTERS? DYNAMIC DISPATCH: */\n/* Without function pointers (hardcoded): */\n/*   if (type == SENSOR_RECORD) sensor_record_processor(data, id); */\n/*   if (type == DEVICE_RECORD) device_record_processor(data, id); */\n/* */\n/* With function pointers (dynamic): */\n/*   processor = get_processor_for_type(type); // Set function pointer */\n/*   processor(data, id);                      // Call through pointer */\n\n/* FUNCTION POINTER TYPEDEF EXPLAINED: */\n/* typedef int (*record_processor_t)(void* data, uint32_t id); */\n/*                                                         */\n/*    return   function pointer      parameter types          */\n/*     type    name/type                                      */\n/* Creates a type name for \"pointer to function that takes (void*, uint32_t) and returns int\" */\n\n/* MEMORY LAYOUT OF FUNCTION POINTERS: */\n/* Memory for functions:                Memory for function pointers: */\n/* 0x401234: [sensor_record_processor]  processor variable: [0x401234] */\n/* 0x401500: [device_record_processor]  sensor_processor:  [0x401234] */\n/*            actual function code    device_processor:  [0x401500] */\n/*                                      stores address of function */\n\n/* PRACTICAL EXAMPLES IN OUR KERNEL CODE: */\n/* 1. Function pointer assignment: */\n/*    sensor_processor = sensor_record_processor; */\n/*     pointer variable gets function address */\n/* */\n/* 2. Function pointer calling: */\n/*    sensor_processor(data, id); */\n/*     calls function at address stored in sensor_processor */\n/* */\n/* 3. Combined with casting (the power pattern!): */\n/*    generic_record* rec = (generic_record*)raw_record;  // Cast data */\n/*    if (rec->header.rec_type == SENSOR_RECORD) {        // Check type */\n/*        active_processor = sensor_processor;            // Set function */\n/*        active_processor(raw_record, id);               // Call function */\n/*    } */\n\n/* COMMON MISTAKES AND SOLUTIONS: */\n/* MISTAKE 1: Forgetting to cast before accessing header */\n/*   raw_record->header.rec_type  // ERROR: void* has no header field */\n/* SOLUTION: */\n/*   generic_record* rec = (generic_record*)raw_record; */\n/*   rec->header.rec_type  // CORRECT: now we can access header */\n/* */\n/* MISTAKE 2: Calling function incorrectly through pointer */\n/*   processor->data  // ERROR: processor is function pointer, not data pointer */\n/* SOLUTION: */\n/*   processor(data, id)  // CORRECT: call function through pointer */\n/* */\n/* MISTAKE 3: NULL function pointer calls */\n/*   processor(data, id)  // CRASH if processor is NULL */\n/* SOLUTION: */\n/*   if (processor) processor(data, id);  // CORRECT: check before calling */\n\n/* TODO: Implement processor registration function */\nvoid register_processor(uint8_t record_type, record_processor_t processor) {\n    /* TODO: Check if record_type is SENSOR_RECORD or DEVICE_RECORD */\n    /* TODO: If SENSOR_RECORD, assign processor to sensor_processor global variable */\n    /* TODO: If DEVICE_RECORD, assign processor to device_processor global variable */\n    /* TODO: Print \"Registered sensor processor\" or \"Registered device processor\" */\n    /* TODO: Handle unknown record types with error message */\n}\n\n/* TODO: Implement record processing with casting + function pointers */\nint process_record_with_function_pointer(void* raw_record, uint32_t record_id) {\n    /* TODO: Step 1 - Cast void* raw_record to generic_record* (like STDF parser casting) */\n    /* TODO: Step 2 - Read rec_type from the header to determine record type */\n    /* TODO: Step 3 - If SENSOR_RECORD: set active_processor and call sensor_processor */\n    /* TODO: Step 4 - If DEVICE_RECORD: set active_processor and call device_processor */\n    /* TODO: Step 5 - Print appropriate \"Found X record, calling X processor\" message */\n    /* TODO: Step 6 - Return the result from the processor function call */\n    /* TODO: Step 7 - Handle unknown record types with error return */\n    return 0;\n}\n\n/* TODO: Implement direct function pointer calling */\nvoid call_processor_function(record_processor_t processor, void* data, uint32_t id) {\n    /* TODO: Check if the processor function pointer is not NULL */\n    /* TODO: If valid, print \"Calling processor function through pointer\" */\n    /* TODO: Call the function through the function pointer with data and id parameters */\n    /* TODO: If NULL, print error message \"Processor function pointer is NULL\" */\n}\n\nstatic int __init function_pointers_init(void)\n{\n    int ret;\n    \n    printk(KERN_INFO \"Function pointers module loaded\\n\");\n    \n    /* Register predefined processors */\n    register_processor(SENSOR_RECORD, sensor_record_processor);\n    register_processor(DEVICE_RECORD, device_record_processor);\n    \n    /* Test both sensor and device records for comprehensive validation */\n    \n    /* First test: Sensor record with function pointer dispatch */\n    printk(KERN_INFO \"Testing function pointer dispatch with record type: %d, ID: %d\\n\", SENSOR_RECORD, test_record_id);\n    ret = process_record_with_function_pointer((void*)&test_sensor_record, test_record_id);\n    if (ret) {\n        printk(KERN_ERR \"Sensor function pointer dispatch failed with error: %d\\n\", ret);\n        return ret;\n    }\n    \n    /* Test direct function pointer calling with sensor */\n    if (active_processor) {\n        call_processor_function(active_processor, (void*)&test_sensor_record, test_record_id + 1);\n    }\n    \n    /* Second test: Device record with function pointer dispatch */\n    printk(KERN_INFO \"Testing function pointer dispatch with record type: %d, ID: %d\\n\", DEVICE_RECORD, test_record_id + 100);\n    ret = process_record_with_function_pointer((void*)&test_device_record, test_record_id + 100);\n    if (ret) {\n        printk(KERN_ERR \"Device function pointer dispatch failed with error: %d\\n\", ret);\n        return ret;\n    }\n    \n    /* Test direct function pointer calling with device */\n    if (active_processor) {\n        call_processor_function(active_processor, (void*)&test_device_record, test_record_id + 101);\n    }\n    \n    return 0;\n}\n\nstatic void __exit function_pointers_exit(void)\n{\n    printk(KERN_INFO \"Function pointers module unloaded\\n\");\n    \n    /* Reset global function pointers */\n    sensor_processor = NULL;\n    device_processor = NULL;\n    active_processor = NULL;\n}\n\nmodule_init(function_pointers_init);\nmodule_exit(function_pointers_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning function pointers with STDF-style record processing\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Function pointers module Makefile\nobj-m += function_pointers.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "function_pointers.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "function_pointers_init",
          "function_pointers_exit",
          "register_processor",
          "process_record_with_function_pointer",
          "call_processor_function"
        ],
        "function_declarations": [
          {
            "name": "register_processor",
            "returnType": "void",
            "parameters": [
              "uint8_t record_type",
              "record_processor_t processor"
            ]
          },
          {
            "name": "process_record_with_function_pointer",
            "returnType": "int",
            "parameters": [
              "void* raw_record",
              "uint32_t record_id"
            ]
          },
          {
            "name": "call_processor_function",
            "returnType": "void",
            "parameters": [
              "record_processor_t processor",
              "void* data",
              "uint32_t id"
            ]
          }
        ],
        "variables_declarations": [
          {
            "name": "record_header",
            "type": "typedef struct",
            "value": "{uint8_t rec_type; uint8_t rec_subtype; uint16_t rec_length;}",
            "storageClass": "none"
          },
          {
            "name": "generic_record",
            "type": "typedef struct",
            "value": "{record_header header; void* data;}",
            "storageClass": "none"
          },
          {
            "name": "record_processor_t",
            "type": "typedef",
            "value": "int (*)(void* record_data, uint32_t record_id)",
            "storageClass": "none"
          },
          {
            "name": "sensor_processor",
            "type": "record_processor_t",
            "storageClass": "extern"
          },
          {
            "name": "device_processor",
            "type": "record_processor_t",
            "storageClass": "extern"
          },
          {
            "name": "active_processor",
            "type": "record_processor_t",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "sensor_processor",
            "type": "record_processor_t",
            "value": "NULL",
            "storageClass": "none"
          },
          {
            "name": "device_processor",
            "type": "record_processor_t",
            "value": "NULL",
            "storageClass": "none"
          },
          {
            "name": "active_processor",
            "type": "record_processor_t",
            "value": "NULL",
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Function pointers module loaded",
          "Registered sensor processor",
          "Registered device processor",
          "Testing function pointer dispatch with record type: 1, ID: 1001",
          "Found sensor record, calling sensor processor",
          "Processing sensor record ID: 1001",
          "Sensor data processed successfully",
          "Calling processor function through pointer",
          "Processing sensor record ID: 1002",
          "Testing function pointer dispatch with record type: 2, ID: 1101",
          "Found device record, calling device processor",
          "Processing device record ID: 1101",
          "Device data processed successfully",
          "Calling processor function through pointer",
          "Processing device record ID: 1102",
          "Function pointers module unloaded"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "sensor_processor = processor",
          "device_processor = processor",
          "active_processor = sensor_processor",
          "active_processor = device_processor",
          "generic_record* rec = (generic_record*)raw_record",
          "if (rec->header.rec_type == SENSOR_RECORD)",
          "if (rec->header.rec_type == DEVICE_RECORD)",
          "sensor_processor(raw_record, record_id)",
          "device_processor(raw_record, record_id)",
          "processor(data, id)",
          "module_param(test_record_type, int, 0644)",
          "module_param(test_record_id, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void register_processor(uint8_t record_type, record_processor_t processor)",
            "int process_record_with_function_pointer(void* raw_record, uint32_t record_id)",
            "void call_processor_function(record_processor_t processor, void* data, uint32_t id)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void register_processor(uint8_t record_type, record_processor_t processor)",
            "int process_record_with_function_pointer(void* raw_record, uint32_t record_id)",
            "void call_processor_function(record_processor_t processor, void* data, uint32_t id)",
            "static int __init function_pointers_init(void)",
            "static void __exit function_pointers_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Function pointers module loaded",
              "exact": true,
              "linkedFunction": "static int __init function_pointers_init(void)"
            },
            {
              "pattern": "Registered sensor processor",
              "exact": true,
              "linkedFunction": "void register_processor(uint8_t record_type, record_processor_t processor)"
            },
            {
              "pattern": "Registered device processor",
              "exact": true,
              "linkedFunction": "void register_processor(uint8_t record_type, record_processor_t processor)"
            },
            {
              "pattern": "Testing function pointer dispatch with record type: 1, ID: 1001",
              "exact": true,
              "linkedFunction": "static int __init function_pointers_init(void)"
            },
            {
              "pattern": "Found sensor record, calling sensor processor",
              "exact": true,
              "linkedFunction": "int process_record_with_function_pointer(void* raw_record, uint32_t record_id)"
            },
            {
              "pattern": "Processing sensor record ID: 1001",
              "exact": true,
              "linkedFunction": "int sensor_record_processor(void* record_data, uint32_t record_id)"
            },
            {
              "pattern": "Sensor data processed successfully",
              "exact": true,
              "linkedFunction": "int sensor_record_processor(void* record_data, uint32_t record_id)"
            },
            {
              "pattern": "Calling processor function through pointer",
              "exact": true,
              "linkedFunction": "void call_processor_function(record_processor_t processor, void* data, uint32_t id)"
            },
            {
              "pattern": "Processing sensor record ID: 1002",
              "exact": true,
              "linkedFunction": "int sensor_record_processor(void* record_data, uint32_t record_id)"
            },
            {
              "pattern": "Testing function pointer dispatch with record type: 2, ID: 1101",
              "exact": true,
              "linkedFunction": "static int __init function_pointers_init(void)"
            },
            {
              "pattern": "Found device record, calling device processor",
              "exact": true,
              "linkedFunction": "int process_record_with_function_pointer(void* raw_record, uint32_t record_id)"
            },
            {
              "pattern": "Processing device record ID: 1101",
              "exact": true,
              "linkedFunction": "int device_record_processor(void* record_data, uint32_t record_id)"
            },
            {
              "pattern": "Device data processed successfully",
              "exact": true,
              "linkedFunction": "int device_record_processor(void* record_data, uint32_t record_id)"
            },
            {
              "pattern": "Calling processor function through pointer",
              "exact": true,
              "linkedFunction": "void call_processor_function(record_processor_t processor, void* data, uint32_t id)"
            },
            {
              "pattern": "Processing device record ID: 1102",
              "exact": true,
              "linkedFunction": "int device_record_processor(void* record_data, uint32_t record_id)"
            },
            {
              "pattern": "Function pointers module unloaded",
              "exact": true,
              "linkedFunction": "static void __exit function_pointers_exit(void)"
            }
          ]
        },
        {
          "id": "advanced_function_pointer_validation",
          "name": "Advanced Function Pointer with Casting Implementation and Anti-Hardcoding Protection",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "function_pointer_dynamic_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Anti-Hardcoding Function Pointer Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate unpredictable test values\\n    int random_record_id1 = (rand() % 9000) + 1000;  // 1000-9999\\n    int random_record_id2 = (rand() % 8000) + 2000;  // 2000-9999\\n    \\n    printf(\\\"Test 1: Sensor function pointer dispatch (ID=%d)\\\\n\\\", random_record_id1);\\n    system(\\\"rmmod function_pointers 2>/dev/null\\\");\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/function_pointers.ko test_record_type=1 test_record_id=%d\\\", random_record_id1);\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Device function pointer dispatch (ID=%d)\\\\n\\\", random_record_id2);\\n    system(\\\"rmmod function_pointers\\\");\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/function_pointers.ko test_record_type=2 test_record_id=%d\\\", random_record_id2);\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Anti-hardcoding function pointer test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced function pointer dispatch implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo 'typedef unsigned char uint8_t;' >> /tmp/linux/types.h",
              "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
              "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
              "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
              "echo '#define true 1' >> /tmp/linux/types.h",
              "echo '#define false 0' >> /tmp/linux/types.h",
              "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
              "echo 'Creating test file that includes function pointers header...'",
              "echo '#include \"/lib/modules/function_pointers.h\"' > /tmp/test.c",
              "echo 'int main() { sensor_processor = (record_processor_t)0; register_processor(1, (record_processor_t)0); process_record_with_function_pointer((void*)0, 1001); call_processor_function((record_processor_t)0, (void*)0, 1001); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
              "echo 'Phase 2: Anti-Hardcoding Dynamic Function Pointer Test'",
              "/bin/function_pointer_dynamic_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Random Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "RECORD_ID1=$(grep -o 'Sensor function pointer dispatch (ID=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
              "RECORD_ID2=$(grep -o 'Device function pointer dispatch (ID=[0-9]*)' /tmp/test_output.log | cut -d'=' -f2 | cut -d')' -f1)",
              "echo 'Extracted values: SENSOR_ID='$RECORD_ID1', DEVICE_ID='$RECORD_ID2",
              "if [ -z \"$RECORD_ID1\" ] || [ -z \"$RECORD_ID2\" ]; then echo 'FAIL: Could not extract random test values'; else echo 'PASS: Random values extracted successfully'; fi",
              "echo 'Phase 4: Anti-Hardcoding Validation with Random Values'",
              "echo 'Validating sensor function pointer with random ID '$RECORD_ID1",
              "dmesg | grep \"Processing sensor record ID: $RECORD_ID1\" && echo 'PASS: Sensor function pointer with random ID working' || echo 'FAIL: Sensor function pointer with random ID broken'",
              "echo 'Validating device function pointer with random ID '$RECORD_ID2",
              "DEVICE_ID_OFFSET=$((RECORD_ID2 + 100))",
              "dmesg | grep \"Processing device record ID: $DEVICE_ID_OFFSET\" && echo 'PASS: Device function pointer with random ID working' || echo 'FAIL: Device function pointer with random ID broken'",
              "echo 'Phase 5: Function Pointer and Casting Validation'",
              "dmesg | grep 'Registered sensor processor' && echo 'PASS: Sensor processor registration working' || echo 'FAIL: Sensor processor registration broken'",
              "dmesg | grep 'Registered device processor' && echo 'PASS: Device processor registration working' || echo 'FAIL: Device processor registration broken'",
              "dmesg | grep 'Found sensor record, calling sensor processor' && echo 'PASS: Casting + function pointer dispatch working' || echo 'FAIL: Casting + function pointer dispatch broken'",
              "dmesg | grep 'Found device record, calling device processor' && echo 'PASS: Device casting + function pointer dispatch working' || echo 'FAIL: Device casting + function pointer dispatch broken'",
              "dmesg | grep 'Calling processor function through pointer' && echo 'PASS: Direct function pointer calling working' || echo 'FAIL: Direct function pointer calling broken'",
              "echo 'Phase 6: Module Validation'",
              "dmesg | grep 'Function pointers module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
              "dmesg | grep 'Function pointers module unloaded' && echo 'PASS: Module cleanup working' || echo 'FAIL: Module cleanup broken'",
              "echo 'All function pointer with casting implementation validations completed'"
            ],
            "expected": {
              "dmesg": [
                "Function pointers module loaded",
                "Registered sensor processor",
                "Registered device processor",
                "Testing function pointer dispatch with record type: .*, ID: .*",
                "Found sensor record, calling sensor processor",
                "Found device record, calling device processor",
                "Processing sensor record ID: .*",
                "Processing device record ID: .*",
                "Sensor data processed successfully",
                "Device data processed successfully",
                "Calling processor function through pointer"
              ],
              "stdout": [
                "PASS: All function and variable declarations found in header file",
                "SUCCESS: Anti-hardcoding function pointer test completed",
                "PASS: Random values extracted successfully",
                "PASS: Sensor function pointer with random ID working",
                "PASS: Device function pointer with random ID working",
                "PASS: Sensor processor registration working",
                "PASS: Device processor registration working",
                "PASS: Casting \\+ function pointer dispatch working",
                "PASS: Device casting \\+ function pointer dispatch working",
                "PASS: Direct function pointer calling working",
                "PASS: Module initialization working",
                "PASS: Module cleanup working"
              ]
            },
            "timeout": 15
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Function pointers module loaded",
        "Registered sensor processor",
        "Registered device processor",
        "Testing function pointer dispatch with record type: 1, ID: 1001",
        "Found sensor record, calling sensor processor",
        "Processing sensor record ID: 1001",
        "Sensor data processed successfully",
        "Calling processor function through pointer",
        "Processing sensor record ID: 1002",
        "Testing function pointer dispatch with record type: 2, ID: 1101",
        "Found device record, calling device processor",
        "Processing device record ID: 1101",
        "Device data processed successfully",
        "Calling processor function through pointer",
        "Processing device record ID: 1102",
        "Function pointers module unloaded"
      ],
      "requirements": [
        "Use required function names: function_pointers_init, function_pointers_exit, register_processor, process_record_with_function_pointer, call_processor_function",
        "Use required variable names: sensor_processor, device_processor, active_processor",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: sensor_processor = processor, device_processor = processor, active_processor = sensor_processor, active_processor = device_processor, generic_record* rec = (generic_record*)raw_record, if (rec->header.rec_type == SENSOR_RECORD), if (rec->header.rec_type == DEVICE_RECORD), sensor_processor(raw_record, record_id), device_processor(raw_record, record_id), processor(data, id), module_param(test_record_type, int, 0644), module_param(test_record_id, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Function pointers module loaded",
          "linkedFunction": "static int __init function_pointers_init(void)",
          "exact": true
        },
        {
          "pattern": "Registered sensor processor",
          "linkedFunction": "void register_processor(uint8_t record_type, record_processor_t processor)",
          "exact": true
        },
        {
          "pattern": "Registered device processor",
          "linkedFunction": "void register_processor(uint8_t record_type, record_processor_t processor)",
          "exact": true
        },
        {
          "pattern": "Testing function pointer dispatch with record type: 1, ID: 1001",
          "linkedFunction": "static int __init function_pointers_init(void)",
          "exact": true
        },
        {
          "pattern": "Found sensor record, calling sensor processor",
          "linkedFunction": "int process_record_with_function_pointer(void* raw_record, uint32_t record_id)",
          "exact": true
        },
        {
          "pattern": "Processing sensor record ID: 1001",
          "linkedFunction": "int sensor_record_processor(void* record_data, uint32_t record_id)",
          "exact": true
        },
        {
          "pattern": "Sensor data processed successfully",
          "linkedFunction": "int sensor_record_processor(void* record_data, uint32_t record_id)",
          "exact": true
        },
        {
          "pattern": "Calling processor function through pointer",
          "linkedFunction": "void call_processor_function(record_processor_t processor, void* data, uint32_t id)",
          "exact": true
        },
        {
          "pattern": "Processing sensor record ID: 1002",
          "linkedFunction": "int sensor_record_processor(void* record_data, uint32_t record_id)",
          "exact": true
        },
        {
          "pattern": "Testing function pointer dispatch with record type: 2, ID: 1101",
          "linkedFunction": "static int __init function_pointers_init(void)",
          "exact": true
        },
        {
          "pattern": "Found device record, calling device processor",
          "linkedFunction": "int process_record_with_function_pointer(void* raw_record, uint32_t record_id)",
          "exact": true
        },
        {
          "pattern": "Processing device record ID: 1101",
          "linkedFunction": "int device_record_processor(void* record_data, uint32_t record_id)",
          "exact": true
        },
        {
          "pattern": "Device data processed successfully",
          "linkedFunction": "int device_record_processor(void* record_data, uint32_t record_id)",
          "exact": true
        },
        {
          "pattern": "Calling processor function through pointer",
          "linkedFunction": "void call_processor_function(record_processor_t processor, void* data, uint32_t id)",
          "exact": true
        },
        {
          "pattern": "Processing device record ID: 1102",
          "linkedFunction": "int device_record_processor(void* record_data, uint32_t record_id)",
          "exact": true
        },
        {
          "pattern": "Function pointers module unloaded",
          "linkedFunction": "static void __exit function_pointers_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 22,
    "title": "Pointer Arithmetic - Buffer Navigation Fundamentals",
    "difficulty": 6,
    "xp": 50,
    "phase": "foundations",
    "description": "Master pointer arithmetic fundamentals and double pointer concepts. Learn to navigate through memory buffers, advance pointers sequentially, and understand the building blocks needed for binary data processing in Problem 22.",
    "concepts": [
      "pointer arithmetic fundamentals",
      "double pointer concepts",
      "buffer navigation",
      "memory traversal",
      "type casting basics",
      "sequential data access"
    ],
    "skills": [
      "Understanding double pointer modification",
      "Implementing pointer advancement functions",
      "Reading data types from memory buffers",
      "Traversing memory buffers safely",
      "Preparing for binary data parsing",
      "Foundation for Problem 22 concepts"
    ],
    "files": [
      {
        "name": "pointer_arithmetic.h",
        "content": "#ifndef POINTER_ARITHMETIC_H\n#define POINTER_ARITHMETIC_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n#define BUFFER_SIZE 16\n\n/* Global variables for testing */\nextern uint8_t test_buffer[BUFFER_SIZE];\nextern uint8_t *current_position;\nextern int total_bytes_read;\n\n/* TODO: Declare your pointer arithmetic functions */\n/* void advance_pointer(uint8_t **ptr, int bytes); */\n/* uint32_t read_uint32_and_advance(uint8_t **ptr); */\n/* uint16_t read_uint16_and_advance(uint8_t **ptr); */\n/* void traverse_buffer(uint8_t *buffer, size_t size); */\n/* void print_buffer_status(void); */\n\n#endif /* POINTER_ARITHMETIC_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "pointer_arithmetic.c",
        "content": "#include \"pointer_arithmetic.h\"\n\n/* Global variables */\nuint8_t test_buffer[BUFFER_SIZE] = {\n    0x01, 0x00, 0x00, 0x00,  /* uint32_t: 1 */\n    0xFF, 0x00,              /* uint16_t: 255 */\n    0x42, 0x00, 0x00, 0x00,  /* uint32_t: 66 */\n    0x7B, 0x00,              /* uint16_t: 123 */\n    0xAA, 0xBB, 0xCC, 0xDD   /* Extra bytes */\n};\n\nuint8_t *current_position = NULL;\nint total_bytes_read = 0;\n\nint test_advance_bytes = 4;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your pointer arithmetic logic works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(test_advance_bytes, int, 0644);\nMODULE_PARM_DESC(test_advance_bytes, \"Number of bytes to advance for testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: How pointer arithmetic works in C */\n/* This teaches the FOUNDATION for binary parsing:\n *\n * Memory Buffer:  [0x01][0x00][0x00][0x00][0xFF][0x00][0x42]...\n * Pointer:          ptr points here initially\n *                       ptr + 1 points here\n *                               ptr + 4 points here\n *\n * Step 1: Start with pointer at beginning of buffer\n * Step 2: Read data at current pointer location\n * Step 3: Advance pointer to next data location\n * Step 4: Repeat until buffer is fully processed\n */\n\n/* WHAT EACH POINTER OPERATION DOES AND HOW TO USE IT: */\n\n/* 1. void advance_pointer(uint8_t **ptr, int bytes) */\n/*    Purpose: Move a pointer forward by specified number of bytes */\n/*    Input: Double pointer (so we can modify caller's pointer) + byte count */\n/*    Output: None (modifies the pointer itself) */\n/*    Usage: advance_pointer(&my_ptr, 4);  // Moves my_ptr forward 4 bytes */\n\n/* 2. uint32_t read_uint32_and_advance(uint8_t **ptr) */\n/*    Purpose: Read 4 bytes as uint32_t AND move pointer forward */\n/*    Input: Double pointer to current buffer position */\n/*    Output: The 32-bit value that was read */\n/*    Side Effect: Advances pointer by 4 bytes automatically */\n/*    Usage: uint32_t value = read_uint32_and_advance(&buffer_pos); */\n\n/* 3. uint16_t read_uint16_and_advance(uint8_t **ptr) */\n/*    Purpose: Read 2 bytes as uint16_t AND move pointer forward */\n/*    Input: Double pointer to current buffer position */\n/*    Output: The 16-bit value that was read */\n/*    Side Effect: Advances pointer by 2 bytes automatically */\n/*    Usage: uint16_t value = read_uint16_and_advance(&buffer_pos); */\n\n/* POINTER ARITHMETIC BASICS EXPLAINED: */\n\n/* SINGLE POINTER ARITHMETIC: */\n/* uint8_t *ptr = buffer;       // ptr points to buffer[0] */\n/* ptr++;                       // ptr now points to buffer[1] */\n/* ptr += 4;                    // ptr now points to buffer[5] */\n/* uint8_t value = *ptr;        // Read the byte at current position */\n\n/* WHY WE NEED DOUBLE POINTERS (**): */\n/* Problem: Functions receive COPIES of pointer values */\n/* */\n/* void wrong_advance(uint8_t *ptr) { */\n/*     ptr += 4;  // Only changes the LOCAL copy! */\n/* } */\n/* // Caller's pointer stays unchanged - NOT what we want! */\n/* */\n/* Solution: Use double pointer to modify the original */\n/* void correct_advance(uint8_t **ptr) { */\n/*     *ptr += 4;  // Changes the ORIGINAL pointer! */\n/* } */\n/* // Caller's pointer gets advanced - EXACTLY what we want! */\n\n/* DOUBLE POINTER SYNTAX BREAKDOWN: */\n/* uint8_t **ptr means \"pointer to a pointer to uint8_t\" */\n/* */\n/* SIMPLE EXAMPLE TO UNDERSTAND DOUBLE POINTERS: */\n/* int a = 5; */\n/* int* ptr = &a;      // ptr points to a */\n/* int** ptr2 = &ptr;  // ptr2 points to ptr */\n/* */\n/* What Each Contains: */\n/* a = 5                    // The value */\n/* ptr = &a                 // Address of a (like 0x1000) */\n/* ptr2 = &ptr              // Address of ptr variable (like 0x2000) */\n/* */\n/* The Dereferencing Chain: */\n/* ptr2        // Address of ptr variable (0x2000) */\n/* *ptr2       // Contents of ptr variable (0x1000) - same as ptr */\n/* **ptr2      // Contents of a variable (5) - same as a */\n/* */\n/* CASTING AND DEREFERENCING EXAMPLE: */\n/* uint8_t buffer[] = {0x01, 0x00, 0x00, 0x00};  // 4 bytes representing uint32_t: 1 */\n/* uint8_t* current_position = buffer;            // Points to first byte */\n/* */\n/* When we call read_uint32_and_advance(&current_position) */\n/* Which is by declaration : read_uint32_and_advance(uint8_t **ptr) */\n/* ptr = &current_position                        // ptr points to current_position variable */\n/* *ptr = current_position                        // Gives us current_position (points to buffer[0]) */\n/* */\n/* Step-by-Step Breakdown of *(uint32_t*)(*ptr): */\n/* */\n/* *ptr                    // current_position (uint8_t* pointer to buffer[0]) */\n/* (uint32_t*)(*ptr)       // Cast to uint32_t* pointer (still points to buffer[0]) */\n/* *(uint32_t*)(*ptr)      // Dereference to get actual uint32_t VALUE (reads 4 bytes) */\n/* */\n/* What Each Expression Contains: */\n/* *ptr = 0x2000                    // Address of buffer[0] (pointer value) */\n/* (uint32_t*)(*ptr) = 0x2000       // Same address, but treated as uint32_t* */\n/* *(uint32_t*)(*ptr) = 1           // The 4-byte value: [0x01][0x00][0x00][0x00] = 1 */\n/* */\n/* Why We Need the Cast: */\n/* *ptr gives us uint8_t* (points to 1 byte) */\n/* (uint32_t*)(*ptr) changes interpretation to uint32_t* (points to 4 bytes) */\n/* *(uint32_t*)(*ptr) reads those 4 bytes as a single uint32_t value */\n/* */\n/* Memory Layout Visualization: */\n/* Buffer: [0x01][0x00][0x00][0x00][0xFF][0x00] */\n/* Address: 0x2000              0x2004        */\n/* */\n/* *ptr = 0x2000                    // Points to start of buffer */\n/* (uint32_t*)(*ptr) = 0x2000       // Same location, uint32_t* type */\n/* *(uint32_t*)(*ptr) = 1           // Reads bytes 0x2000-0x2003 as uint32_t */\n/* */\n/* APPLIED TO OUR BUFFER POINTERS: */\n/* If we have: uint8_t *buffer_pos = &buffer[0]; */\n/* And we call: advance_pointer(&buffer_pos, 4); */\n/* */\n/* Inside function: */\n/* ptr parameter contains: &buffer_pos (address of buffer_pos variable) */\n/* *ptr gives us: buffer_pos (the actual pointer value) */\n/* *ptr += 4 modifies: buffer_pos (moves it forward 4 bytes) */\n\n/* POINTER ARITHMETIC WITH TYPES: */\n/* uint8_t *ptr points to 1-byte values */\n/* ptr + 1 advances by 1 byte */\n/* ptr + 4 advances by 4 bytes */\n/* */\n/* uint32_t *ptr32 points to 4-byte values */\n/* ptr32 + 1 advances by 4 bytes (1 uint32_t) */\n/* ptr32 + 2 advances by 8 bytes (2 uint32_t values) */\n\n/* TYPE CASTING FOR DATA READING: */\n/* uint8_t *ptr = buffer; */\n/* uint32_t value = *(uint32_t*)ptr; */\n/*                               */\n/*                   |        Dereference to read value */\n/*                    Cast uint8_t* to uint32_t* */\n/* */\n/* This reads 4 bytes starting at ptr as a single uint32_t value */\n\n/* BUFFER TRAVERSAL PATTERN: */\n/* uint8_t *current = buffer;           // Start at beginning */\n/* while (current < buffer + size) {    // Check if within bounds */\n/*     process_byte(*current);          // Process current byte */\n/*     current++;                       // Move to next byte */\n/* } */\n\n/* MEMORY LAYOUT VISUALIZATION: */\n/* test_buffer:  [0x01][0x00][0x00][0x00][0xFF][0x00][0x42][0x00] */\n/* Addresses:     0x1000          0x1004  0x1006               */\n/* */\n/* uint8_t *ptr = test_buffer;     // ptr = 0x1000 */\n/* uint32_t val = *(uint32_t*)ptr; // Read bytes 0x1000-0x1003 = 1 */\n/* ptr += 4;                       // ptr = 0x1004 */\n/* uint16_t val2 = *(uint16_t*)ptr;// Read bytes 0x1004-0x1005 = 255 */\n\n/* COMMON MISTAKES AND SOLUTIONS: */\n/* MISTAKE 1: Forgetting to use double pointer for modification */\n/*   void bad_advance(uint8_t *ptr) { ptr += 4; }  // WRONG */\n/* SOLUTION: */\n/*   void good_advance(uint8_t **ptr) { *ptr += 4; }  // CORRECT */\n/* */\n/* MISTAKE 2: Confusing pointer and value dereferencing */\n/*   uint32_t val = (uint32_t)*ptr;    // WRONG - reads 1 byte, casts to uint32_t */\n/* SOLUTION: */\n/*   uint32_t val = *(uint32_t*)ptr;   // CORRECT - reads 4 bytes as uint32_t */\n/* */\n/* MISTAKE 3: Not checking buffer bounds */\n/*   ptr += 10;  // WRONG - might go past end of buffer */\n/* SOLUTION: */\n/*   if (ptr + 10 <= buffer + buffer_size) ptr += 10;  // CORRECT */\n\n/* PRACTICAL EXAMPLES FOR UNDERSTANDING: */\n/* Example 1: Reading consecutive integers from buffer */\n/* uint8_t buffer[] = {0x01, 0x00, 0x00, 0x00, 0xFF, 0x00}; */\n/* uint8_t *pos = buffer; */\n/* uint32_t first = read_uint32_and_advance(&pos);   // first = 1, pos += 4 */\n/* uint16_t second = read_uint16_and_advance(&pos);  // second = 255, pos += 2 */\n/* */\n/* Example 2: Manual buffer traversal */\n/* uint8_t *current = buffer; */\n/* for (int i = 0; i < buffer_size; i++) { */\n/*     printk(\"Byte %d: 0x%02x\\n\", i, *current); */\n/*     current++;  // Move to next byte */\n/* } */\n\n/* WHY THIS PREPARES YOU FOR PROBLEM 22: */\n/* Problem 22 (Binary Parsing) combines these concepts: */\n/* - Double pointers for buffer advancement (learned here) */\n/* - Type casting for data reading (learned here) */\n/* - Sequential data extraction (learned here) */\n/* + Dynamic memory allocation (from Problem 18) */\n/* + Structure parsing (from Problems 15-16) */\n/* = Complete binary parser capability! */\n\n/* TODO: Implement pointer advancement function */\nvoid advance_pointer(uint8_t **ptr, int bytes) {\n    /* TODO: Move the pointer forward by 'bytes' number of bytes */\n    /* TODO: Use *ptr += bytes to modify the caller's actual pointer */\n    /* TODO: This teaches the fundamental double pointer pattern */\n}\n\n/* TODO: Implement read and advance function */\nuint32_t read_uint32_and_advance(uint8_t **ptr) {\n    /* TODO: Read 4 bytes from current pointer position as uint32_t */\n    /* TODO: Cast *ptr to uint32_t* and dereference: *(uint32_t*)(*ptr) */\n    /* TODO: Advance the pointer by 4 bytes: *ptr += 4 */\n    /* TODO: Return the uint32_t value that was read */\n    return 0;\n}\n\n/* TODO: Implement read and advance function */\nuint16_t read_uint16_and_advance(uint8_t **ptr) {\n    /* TODO: Read 2 bytes from current pointer position as uint16_t */\n    /* TODO: Cast *ptr to uint16_t* and dereference: *(uint16_t*)(*ptr) */\n    /* TODO: Advance the pointer by 2 bytes: *ptr += 2 */\n    /* TODO: Return the uint16_t value that was read */\n    return 0;\n}\n\n/* TODO: Implement buffer traversal function */\nvoid traverse_buffer(uint8_t *buffer, size_t size) {\n    /* TODO: Create a pointer to traverse the buffer: uint8_t *buffer_ptr = buffer */\n    /* TODO: Loop through each byte: for (int i = 0; i < size; i++) */\n    /* TODO: Print each byte with its position: printk(\"Position %d: 0x%02x\\n\", i, *buffer_ptr) */\n    /* Format Specifier: %02x means: */\n    /* x = print as hexadecimal, 02 = pad with zeros to make it at least 2 digits */\n    /* TODO: Advance to next byte: buffer_ptr++ */\n}\n\nvoid print_buffer_status(void) {\n    if (!current_position) {\n        printk(KERN_INFO \"Buffer Status: No current position set\\n\");\n        return;\n    }\n    \n    printk(KERN_INFO \"Buffer Status:\\n\");\n    printk(KERN_INFO \"Buffer start: %p\\n\", test_buffer);\n    printk(KERN_INFO \"Current position: %p\\n\", current_position);\n    printk(KERN_INFO \"Bytes advanced: %ld\\n\", current_position - test_buffer);\n    printk(KERN_INFO \"Total bytes read: %d\\n\", total_bytes_read);\n}\n\nstatic int __init pointer_arithmetic_init(void)\n{\n    uint32_t value32;\n    uint16_t value16;\n    \n    printk(KERN_INFO \"Pointer arithmetic module loaded\\n\");\n    \n    /* Initialize current position to start of buffer */\n    current_position = test_buffer;\n    total_bytes_read = 0;\n    \n    printk(KERN_INFO \"Starting pointer arithmetic demonstration\\n\");\n    \n    /* Test 1: Read first uint32_t and advance */\n    printk(KERN_INFO \"Test 1: Reading uint32_t from buffer\\n\");\n    value32 = read_uint32_and_advance(&current_position);\n    total_bytes_read += 4;\n    printk(KERN_INFO \"Read uint32_t: %u\\n\", value32);\n    print_buffer_status();\n    \n    /* Test 2: Read uint16_t and advance */\n    printk(KERN_INFO \"Test 2: Reading uint16_t from buffer\\n\");\n    value16 = read_uint16_and_advance(&current_position);\n    total_bytes_read += 2;\n    printk(KERN_INFO \"Read uint16_t: %u\\n\", value16);\n    print_buffer_status();\n    \n    /* Test 3: Advance pointer by dynamic amount */\n    printk(KERN_INFO \"Test 3: Advancing pointer by %d bytes\\n\", test_advance_bytes);\n    advance_pointer(&current_position, test_advance_bytes);\n    total_bytes_read += test_advance_bytes;\n    print_buffer_status();\n    \n    /* Test 4: Traverse entire buffer */\n    printk(KERN_INFO \"Test 4: Traversing entire buffer\\n\");\n    traverse_buffer(test_buffer, BUFFER_SIZE);\n    \n    printk(KERN_INFO \"Pointer arithmetic demonstration completed\\n\");\n    \n    return 0;\n}\n\nstatic void __exit pointer_arithmetic_exit(void)\n{\n    printk(KERN_INFO \"Pointer arithmetic module unloaded\\n\");\n    \n    /* Reset global state */\n    current_position = NULL;\n    total_bytes_read = 0;\n}\n\nmodule_init(pointer_arithmetic_init);\nmodule_exit(pointer_arithmetic_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning pointer arithmetic fundamentals for buffer navigation\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Pointer arithmetic module Makefile\nobj-m += pointer_arithmetic.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "pointer_arithmetic.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "pointer_arithmetic_init",
          "pointer_arithmetic_exit",
          "advance_pointer",
          "read_uint32_and_advance",
          "read_uint16_and_advance",
          "traverse_buffer",
          "print_buffer_status"
        ],
        "function_declarations": [
          {
            "name": "advance_pointer",
            "returnType": "void",
            "parameters": [
              "uint8_t **ptr",
              "int bytes"
            ]
          },
          {
            "name": "read_uint32_and_advance",
            "returnType": "uint32_t",
            "parameters": [
              "uint8_t **ptr"
            ]
          },
          {
            "name": "read_uint16_and_advance",
            "returnType": "uint16_t",
            "parameters": [
              "uint8_t **ptr"
            ]
          },
          {
            "name": "traverse_buffer",
            "returnType": "void",
            "parameters": [
              "uint8_t *buffer",
              "size_t size"
            ]
          },
          {
            "name": "print_buffer_status",
            "returnType": "void",
            "parameters": []
          }
        ],
        "variables_declarations": [
          {
            "name": "test_buffer",
            "type": "uint8_t",
            "storageClass": "extern"
          },
          {
            "name": "current_position",
            "type": "uint8_t *",
            "storageClass": "extern"
          },
          {
            "name": "total_bytes_read",
            "type": "int",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "current_position",
            "type": "uint8_t *",
            "value": "NULL",
            "storageClass": "none"
          },
          {
            "name": "total_bytes_read",
            "type": "int",
            "value": "0",
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Pointer arithmetic module loaded",
          "Starting pointer arithmetic demonstration",
          "Test 1: Reading uint32_t from buffer",
          "Read uint32_t: 1",
          "Test 2: Reading uint16_t from buffer",
          "Read uint16_t: 255",
          "Test 3: Advancing pointer by 4 bytes",
          "Test 4: Traversing entire buffer",
          "Position 0: 0x01",
          "Position 1: 0x00",
          "Pointer arithmetic demonstration completed",
          "Pointer arithmetic module unloaded"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "*ptr += bytes",
          "*(uint32_t*)(*ptr)",
          "*ptr += 4",
          "*(uint16_t*)(*ptr)",
          "*ptr += 2",
          "uint8_t *buffer_ptr = buffer",
          "buffer_ptr++",
          "read_uint32_and_advance(&current_position)",
          "read_uint16_and_advance(&current_position)",
          "advance_pointer(&current_position",
          "module_param(test_advance_bytes, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void advance_pointer(uint8_t **ptr, int bytes)",
            "uint32_t read_uint32_and_advance(uint8_t **ptr)",
            "uint16_t read_uint16_and_advance(uint8_t **ptr)",
            "void traverse_buffer(uint8_t *buffer, size_t size)",
            "void print_buffer_status(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void advance_pointer(uint8_t **ptr, int bytes)",
            "uint32_t read_uint32_and_advance(uint8_t **ptr)",
            "uint16_t read_uint16_and_advance(uint8_t **ptr)",
            "void traverse_buffer(uint8_t *buffer, size_t size)",
            "void print_buffer_status(void)",
            "static int __init pointer_arithmetic_init(void)",
            "static void __exit pointer_arithmetic_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Pointer arithmetic module loaded",
              "exact": true,
              "linkedFunction": "static int __init pointer_arithmetic_init(void)"
            },
            {
              "pattern": "Starting pointer arithmetic demonstration",
              "exact": true,
              "linkedFunction": "static int __init pointer_arithmetic_init(void)"
            },
            {
              "pattern": "Test 1: Reading uint32_t from buffer",
              "exact": true,
              "linkedFunction": "static int __init pointer_arithmetic_init(void)"
            },
            {
              "pattern": "Read uint32_t: 1",
              "exact": true,
              "linkedFunction": "uint32_t read_uint32_and_advance(uint8_t **ptr)"
            },
            {
              "pattern": "Test 2: Reading uint16_t from buffer",
              "exact": true,
              "linkedFunction": "static int __init pointer_arithmetic_init(void)"
            },
            {
              "pattern": "Read uint16_t: 255",
              "exact": true,
              "linkedFunction": "uint16_t read_uint16_and_advance(uint8_t **ptr)"
            },
            {
              "pattern": "Test 3: Advancing pointer by 4 bytes",
              "exact": true,
              "linkedFunction": "static int __init pointer_arithmetic_init(void)"
            },
            {
              "pattern": "Test 4: Traversing entire buffer",
              "exact": true,
              "linkedFunction": "static int __init pointer_arithmetic_init(void)"
            },
            {
              "pattern": "Position 0: 0x01",
              "exact": true,
              "linkedFunction": "void traverse_buffer(uint8_t *buffer, size_t size)"
            },
            {
              "pattern": "Position 1: 0x00",
              "exact": true,
              "linkedFunction": "void traverse_buffer(uint8_t *buffer, size_t size)"
            },
            {
              "pattern": "Pointer arithmetic demonstration completed",
              "exact": true,
              "linkedFunction": "static int __init pointer_arithmetic_init(void)"
            },
            {
              "pattern": "Pointer arithmetic module unloaded",
              "exact": true,
              "linkedFunction": "static void __exit pointer_arithmetic_exit(void)"
            }
          ]
        },
        {
          "id": "advanced_pointer_arithmetic_validation",
          "name": "Advanced Pointer Arithmetic with Anti-Hardcoding Protection",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "pointer_arithmetic_dynamic_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Anti-Hardcoding Pointer Arithmetic Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate unpredictable test values\\n    int random_advance_bytes = (rand() % 4) + 2;  // 2-5 bytes\\n    \\n    printf(\\\"Test 1: Random pointer advancement (bytes=%d)\\\\n\\\", random_advance_bytes);\\n    \\n    // Test with random values\\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod pointer_arithmetic 2>/dev/null\\\");\\n    \\n    char cmd[256];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/pointer_arithmetic.ko test_advance_bytes=%d\\\", random_advance_bytes);\\n    printf(\\\"DEBUG: Command: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Anti-hardcoding pointer arithmetic test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced pointer arithmetic implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef unsigned char uint8_t;' > /tmp/linux/types.h",
              "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
              "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
              "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
              "echo '#define BUFFER_SIZE 16' >> /tmp/linux/types.h",
              "echo 'Creating test file that includes pointer arithmetic header...'",
              "echo '#include \"/lib/modules/pointer_arithmetic.h\"' > /tmp/test.c",
              "echo 'int main() { uint8_t *ptr; current_position = (uint8_t*)0; advance_pointer(&ptr, 4); read_uint32_and_advance(&ptr); read_uint16_and_advance(&ptr); traverse_buffer((uint8_t*)0, 16); print_buffer_status(); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
              "echo 'Phase 2: Anti-Hardcoding Dynamic Pointer Arithmetic Test'",
              "/bin/pointer_arithmetic_dynamic_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Random Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "ADVANCE_BYTES=$(grep -o 'Random pointer advancement (bytes=[0-9]*)' /tmp/test_output.log | cut -d'=' -f2 | cut -d')' -f1)",
              "echo 'Extracted values: ADVANCE_BYTES='$ADVANCE_BYTES",
              "if [ -z \"$ADVANCE_BYTES\" ]; then echo 'FAIL: Could not extract random test values'; else echo 'PASS: Random values extracted successfully'; fi",
              "echo 'Phase 4: Anti-Hardcoding Validation with Random Values'",
              "echo 'Validating pointer advancement with random value '$ADVANCE_BYTES",
              "dmesg | grep \"Test 3: Advancing pointer by $ADVANCE_BYTES bytes\" && echo 'PASS: Pointer advancement with random value working' || echo 'FAIL: Pointer advancement with random value broken'",
              "echo 'Phase 5: Static Field Validation (Non-Randomized Fields)'",
              "dmesg | grep 'Read uint32_t: 1' && echo 'PASS: uint32_t reading working' || echo 'FAIL: uint32_t reading broken'",
              "dmesg | grep 'Read uint16_t: 255' && echo 'PASS: uint16_t reading working' || echo 'FAIL: uint16_t reading broken'",
              "dmesg | grep 'Position 0: 0x01' && echo 'PASS: Buffer traversal working' || echo 'FAIL: Buffer traversal broken'",
              "echo 'Phase 6: Pointer Arithmetic Logic Validation'",
              "dmesg | grep 'Starting pointer arithmetic demonstration' && echo 'PASS: Module demonstration working' || echo 'FAIL: Module demonstration broken'",
              "dmesg | grep 'Pointer arithmetic module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
              "dmesg | grep 'Pointer arithmetic module unloaded' && echo 'PASS: Module cleanup working' || echo 'FAIL: Module cleanup broken'",
              "echo 'Phase 7: Final Validation Summary'",
              "echo 'All phases completed successfully - anti-hardcoding pointer arithmetic protection verified'",
              "echo 'PASS: All anti-hardcoding pointer arithmetic validation successful'"
            ],
            "expected": {
              "dmesg": [
                "Pointer arithmetic module loaded",
                "Starting pointer arithmetic demonstration",
                "Test 1: Reading uint32_t from buffer",
                "Read uint32_t: 1",
                "Test 2: Reading uint16_t from buffer",
                "Read uint16_t: 255",
                "Test 3: Advancing pointer by .* bytes",
                "Test 4: Traversing entire buffer",
                "Position 0: 0x01",
                "Position 1: 0x00",
                "Pointer arithmetic demonstration completed",
                "Pointer arithmetic module unloaded"
              ],
              "stdout": [
                "PASS: All function and variable declarations found in header file",
                "SUCCESS: Anti-hardcoding pointer arithmetic test completed",
                "PASS: Random values extracted successfully",
                "PASS: Pointer advancement with random value working",
                "PASS: uint32_t reading working",
                "PASS: uint16_t reading working",
                "PASS: Buffer traversal working",
                "PASS: Module demonstration working",
                "PASS: Module initialization working",
                "PASS: Module cleanup working",
                "PASS: All anti-hardcoding pointer arithmetic validation successful"
              ]
            },
            "timeout": 15
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Pointer arithmetic module loaded",
        "Starting pointer arithmetic demonstration",
        "Test 1: Reading uint32_t from buffer",
        "Read uint32_t: 1",
        "Test 2: Reading uint16_t from buffer",
        "Read uint16_t: 255",
        "Test 3: Advancing pointer by 4 bytes",
        "Test 4: Traversing entire buffer",
        "Position 0: 0x01",
        "Position 1: 0x00",
        "Pointer arithmetic demonstration completed",
        "Pointer arithmetic module unloaded"
      ],
      "requirements": [
        "Use required function names: pointer_arithmetic_init, pointer_arithmetic_exit, advance_pointer, read_uint32_and_advance, read_uint16_and_advance, traverse_buffer, print_buffer_status",
        "Use required variable names: current_position, total_bytes_read",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: *ptr += bytes, *(uint32_t*)(*ptr), *ptr += 4, *(uint16_t*)(*ptr), *ptr += 2, uint8_t *buffer_ptr = buffer, buffer_ptr++, read_uint32_and_advance(&current_position), read_uint16_and_advance(&current_position), advance_pointer(&current_position, module_param(test_advance_bytes, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Pointer arithmetic module loaded",
          "linkedFunction": "static int __init pointer_arithmetic_init(void)",
          "exact": true
        },
        {
          "pattern": "Starting pointer arithmetic demonstration",
          "linkedFunction": "static int __init pointer_arithmetic_init(void)",
          "exact": true
        },
        {
          "pattern": "Test 1: Reading uint32_t from buffer",
          "linkedFunction": "static int __init pointer_arithmetic_init(void)",
          "exact": true
        },
        {
          "pattern": "Read uint32_t: 1",
          "linkedFunction": "uint32_t read_uint32_and_advance(uint8_t **ptr)",
          "exact": true
        },
        {
          "pattern": "Test 2: Reading uint16_t from buffer",
          "linkedFunction": "static int __init pointer_arithmetic_init(void)",
          "exact": true
        },
        {
          "pattern": "Read uint16_t: 255",
          "linkedFunction": "uint16_t read_uint16_and_advance(uint8_t **ptr)",
          "exact": true
        },
        {
          "pattern": "Test 3: Advancing pointer by 4 bytes",
          "linkedFunction": "static int __init pointer_arithmetic_init(void)",
          "exact": true
        },
        {
          "pattern": "Test 4: Traversing entire buffer",
          "linkedFunction": "static int __init pointer_arithmetic_init(void)",
          "exact": true
        },
        {
          "pattern": "Position 0: 0x01",
          "linkedFunction": "void traverse_buffer(uint8_t *buffer, size_t size)",
          "exact": true
        },
        {
          "pattern": "Position 1: 0x00",
          "linkedFunction": "void traverse_buffer(uint8_t *buffer, size_t size)",
          "exact": true
        },
        {
          "pattern": "Pointer arithmetic demonstration completed",
          "linkedFunction": "static int __init pointer_arithmetic_init(void)",
          "exact": true
        },
        {
          "pattern": "Pointer arithmetic module unloaded",
          "linkedFunction": "static void __exit pointer_arithmetic_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 23,
    "title": "STDF Binary Parser - Production Semiconductor Data Processing",
    "difficulty": 9,
    "xp": 75,
    "phase": "foundations",
    "description": "Master STDF (Standard Test Data Format) parsing using real production patterns. Learn header/data separation, record type dispatch, and multi-record processing exactly as used in semiconductor test systems and libstdf parsers.",
    "concepts": [
      "STDF header/data separation",
      "record type dispatch",
      "multi-record parsing",
      "production STDF patterns",
      "semiconductor data processing",
      "libstdf architecture"
    ],
    "skills": [
      "Parsing STDF headers with length/type/subtype",
      "Implementing record type dispatch",
      "Handling multiple record formats",
      "Using production STDF field names",
      "Understanding header/data separation",
      "Building real semiconductor parsers"
    ],
    "files": [
      {
        "name": "stdf_parser.h",
        "content": "#ifndef STDF_PARSER_H\n#define STDF_PARSER_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#define MAX_NAME_LEN 32\n#define MAX_RESULTS 8\n\n/* STDF Record Type Constants (like libstdf) */\n#define REC_PTR 0x15  /* Parametric Test Record */\n#define REC_MPR 0x16  /* Multiple-Result Parametric */\n\n/* STDF Header Structure (like libstdf rec_header) */\ntypedef struct {\n    uint16_t rec_length;  /* Number of bytes to follow */\n    uint8_t rec_type;     /* Record type identifier */\n    uint8_t rec_subtype;  /* Record subtype identifier */\n} stdf_header;\n\n/* Generic STDF Record (like libstdf rec_unknown) */\ntypedef struct {\n    stdf_header header;   /* Parsed header */\n    void *data;          /* Points to record payload */\n} stdf_record;\n\n/* PTR Record Structure (like libstdf rec_ptr) */\ntypedef struct {\n    uint32_t TEST_NUM;    /* Test number */\n    uint8_t HEAD_NUM;     /* Test head number */\n    uint8_t SITE_NUM;     /* Test site number */\n    uint8_t TEST_FLG;     /* Test flags */\n    uint8_t PARM_FLG;     /* Parameter flags */\n    uint32_t RESULT;      /* Test result (as integer) */\n    char TEST_TXT[MAX_NAME_LEN]; /* Test text */\n    char ALARM_ID[MAX_NAME_LEN]; /* Alarm identifier */\n} ptr_record;\n\n/* MPR Record Structure (like libstdf rec_mpr) */\ntypedef struct {\n    uint32_t TEST_NUM;    /* Test number */\n    uint8_t HEAD_NUM;     /* Test head number */\n    uint8_t SITE_NUM;     /* Test site number */\n    uint8_t TEST_FLG;     /* Test flags */\n    uint8_t PARM_FLG;     /* Parameter flags */\n    uint16_t RTN_ICNT;    /* Return result count */\n    uint32_t RTN_RSLT[MAX_RESULTS]; /* Return results array (as integers) */\n} mpr_record;\n\n/* Global variables for testing */\nextern stdf_record *parsed_record;\nextern uint8_t *test_buffer;\nextern size_t buffer_size;\n\n/* TODO: Declare your STDF parsing functions */\n/* stdf_header* parse_stdf_header(uint8_t **buffer_ptr); */\n/* uint8_t read_uint8_from_buffer(uint8_t **buffer_ptr); */\n/* uint32_t read_uint32_from_buffer(uint8_t **buffer_ptr); */\n/* uint16_t read_uint16_from_buffer(uint8_t **buffer_ptr); */\n/* char* read_string_from_buffer(uint8_t **buffer_ptr, uint8_t *out_length); */\n/* ptr_record* parse_ptr_record(uint8_t *data, uint16_t length); */\n/* mpr_record* parse_mpr_record(uint8_t *data, uint16_t length); */\n/* stdf_record* parse_stdf_record_from_buffer(uint8_t *raw_buffer); */\n/* int parse_stdf_file_buffer(uint8_t *buffer, size_t total_size); */\n/* void print_stdf_record(stdf_record *record); */\n\n#endif /* STDF_PARSER_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "stdf_parser.c",
        "content": "#include \"stdf_parser.h\"\n\n/* Global variables */\nstdf_record *parsed_record = NULL;\nuint8_t *test_buffer = NULL;\nsize_t buffer_size = 0;\n\nint test_record_type = REC_PTR;\nint test_num = 1001;\nint test_result = 255;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your STDF parsing logic works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(test_record_type, int, 0644);\nMODULE_PARM_DESC(test_record_type, \"STDF record type for testing\");\nmodule_param(test_num, int, 0644);\nMODULE_PARM_DESC(test_num, \"Test number for anti-hardcoding testing\");\nmodule_param(test_result, int, 0644);\nMODULE_PARM_DESC(test_result, \"Test result for anti-hardcoding testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: How STDF parsing works in production systems */\n/* This is the EXACT technique used in libstdf and semiconductor test systems:\n *\n * STDF File Structure:\n * \n *  rec_length   rec_type     rec_subtype         RECORD PAYLOAD DATA          \n *  (2 bytes)    (1 byte)     (1 byte)         (rec_length bytes)              \n * \n *                header (4 bytes total)     data points here\n *\n * Step 1: Parse 4-byte header (length, type, subtype)\n * Step 2: Point data to payload after header\n * Step 3: Dispatch based on record type (PTR vs MPR)\n * Step 4: Parse fields based on specific record format\n */\n\n/* STDF HEADER/DATA SEPARATION EXPLAINED: */\n/* This is the KEY pattern that makes STDF parsing work:\n *\n * 1. Header contains metadata (length, type)\n * 2. Data points to payload (actual record fields)\n * 3. Length tells us how many payload bytes to read\n * 4. Type tells us how to interpret the payload\n *\n * Example PTR Record:\n * Header: [0x20, 0x00, 0x15, 0x10] = length=32, type=0x15, subtype=0x10\n * Data:   [TEST_NUM][HEAD_NUM][SITE_NUM][TEST_FLG][RESULT][TEST_TXT...]\n */\n\n/* RECORD TYPE DISPATCH PATTERN: */\n/* Production STDF parsers use switch-based dispatch:\n *\n * switch (header->rec_type) {\n *     case REC_PTR: return parse_ptr_record(data, length);\n *     case REC_MPR: return parse_mpr_record(data, length);\n *     default: return parse_unknown_record(data, length);\n * }\n *\n * This allows one parser to handle 30+ different record types!\n */\n\n/* STDF DATA TYPES (like libstdf): */\n/* U1 = uint8_t   (1 byte unsigned) */\n/* U2 = uint16_t  (2 byte unsigned) */\n/* U4 = uint32_t  (4 byte unsigned) */\n/* R4 = uint32_t  (4 byte data, stored as integer for kernel compatibility) */\n/* Cn = string    (1 byte length + n bytes data) */\n\n/* TODO: Implement STDF header parsing */\nstdf_header* parse_stdf_header(uint8_t **buffer_ptr) {\n    /* TODO: What do you need to store the parsed header data? */\n    /* TODO: How do you allocate memory in kernel space? */\n    /* TODO: STDF headers have 3 fields - what order should you read them? */\n    /* TODO: Look at the STDF specification - what's the first 2-byte field? */\n    /* TODO: What comes after rec_length in the header? */\n    /* TODO: Don't forget to return your populated structure */\n    return NULL;\n}\n\n/* TODO: Implement single byte reading */\nuint8_t read_uint8_from_buffer(uint8_t **buffer_ptr) {\n    /* TODO: Read 1 byte from buffer as uint8_t */\n    /* TODO: Cast *buffer_ptr to uint8_t* and dereference: *(*buffer_ptr) */\n    /* TODO: Advance *buffer_ptr by 1 byte: *buffer_ptr += 1 */\n    /* TODO: Return the uint8_t value */\n    return 0;\n}\n\n/* TODO: Implement 4-byte reading */\nuint32_t read_uint32_from_buffer(uint8_t **buffer_ptr) {\n    /* TODO: Read 4 bytes from buffer as uint32_t */\n    /* TODO: Cast *buffer_ptr to uint32_t* and dereference: *(uint32_t*)(*buffer_ptr) */\n    /* TODO: Advance *buffer_ptr by 4 bytes: *buffer_ptr += 4 */\n    /* TODO: Return the uint32_t value */\n    return 0;\n}\n\n/* TODO: Implement 2-byte reading */\nuint16_t read_uint16_from_buffer(uint8_t **buffer_ptr) {\n    /* TODO: Read 2 bytes from buffer as uint16_t */\n    /* TODO: Cast *buffer_ptr to uint16_t* and dereference: *(uint16_t*)(*buffer_ptr) */\n    /* TODO: Advance *buffer_ptr by 2 bytes: *buffer_ptr += 2 */\n    /* TODO: Return the uint16_t value */\n    return 0;\n}\n\n/* TODO: Implement STDF string reading (Cn type) */\nchar* read_string_from_buffer(uint8_t **buffer_ptr, uint8_t *out_length) {\n    /* TODO: Read first byte as string length using read_uint8_from_buffer */\n    /* TODO: Allocate memory for string using kmalloc(length + 1, GFP_KERNEL) */\n    /* TODO: Copy string data from buffer to allocated memory using memcpy */\n    /* TODO: Add null terminator to string */\n    /* TODO: Advance *buffer_ptr by length bytes: *buffer_ptr += length */\n    /* TODO: Store length in *out_length */\n    /* TODO: Return pointer to allocated string */\n    return NULL;\n}\n\n/* TODO: Implement PTR record parsing */\nptr_record* parse_ptr_record(uint8_t *data, uint16_t length) {\n    /* TODO: Allocate memory for ptr_record using kmalloc */\n    /* TODO: Create buffer position pointer: uint8_t *buffer_pos = data */\n    /* TODO: Parse TEST_NUM using read_uint32_from_buffer */\n    /* TODO: Parse HEAD_NUM using read_uint8_from_buffer */\n    /* TODO: Parse SITE_NUM using read_uint8_from_buffer */\n    /* TODO: Parse TEST_FLG using read_uint8_from_buffer */\n    /* TODO: Parse PARM_FLG using read_uint8_from_buffer */\n    /* TODO: Parse RESULT using read_uint32_from_buffer */\n    /* TODO: Parse TEST_TXT using read_string_from_buffer */\n    /* TODO: Copy string to record->TEST_TXT (max MAX_NAME_LEN-1 chars) */\n    /* TODO: Free temporary string */\n    /* TODO: Parse ALARM_ID using read_string_from_buffer */\n    /* TODO: Copy string to record->ALARM_ID (max MAX_NAME_LEN-1 chars) */\n    /* TODO: Free temporary string */\n    /* TODO: Return populated ptr_record */\n    return NULL;\n}\n\n/* TODO: Implement MPR record parsing */\nmpr_record* parse_mpr_record(uint8_t *data, uint16_t length) {\n    /* TODO: Allocate memory for mpr_record using kmalloc */\n    /* TODO: Create buffer position pointer: uint8_t *buffer_pos = data */\n    /* TODO: Parse TEST_NUM using read_uint32_from_buffer */\n    /* TODO: Parse HEAD_NUM using read_uint8_from_buffer */\n    /* TODO: Parse SITE_NUM using read_uint8_from_buffer */\n    /* TODO: Parse TEST_FLG using read_uint8_from_buffer */\n    /* TODO: Parse PARM_FLG using read_uint8_from_buffer */\n    /* TODO: Parse RTN_ICNT using read_uint16_from_buffer */\n    /* TODO: Loop through RTN_ICNT results, parsing each with read_uint32_from_buffer */\n    /* TODO: Store results in RTN_RSLT array (max MAX_RESULTS) */\n    /* TODO: Return populated mpr_record */\n    return NULL;\n}\n\n/* TODO: Implement main STDF record parser with dispatch */\nstdf_record* parse_stdf_record_from_buffer(uint8_t *raw_buffer) {\n    /* TODO: Allocate memory for stdf_record using kmalloc */\n    /* TODO: Create buffer position pointer: uint8_t *buffer_pos = raw_buffer */\n    /* TODO: Parse header using parse_stdf_header(&buffer_pos) */\n    /* TODO: Copy header to record->header */\n    /* TODO: Set record->data to point to buffer_pos (payload after header) */\n    /* TODO: Dispatch based on record type using switch statement: */\n    /* TODO:   case REC_PTR: parse PTR record from record->data */\n    /* TODO:   case REC_MPR: parse MPR record from record->data */\n    /* TODO:   default: handle unknown record type */\n    /* TODO: Return populated stdf_record */\n    return NULL;\n}\n\nvoid print_stdf_record(stdf_record *record) {\n    if (!record) {\n        printk(KERN_ERR \"No STDF record to print\\n\");\n        return;\n    }\n    \n    printk(KERN_INFO \"STDF Record Header:\\n\");\n    printk(KERN_INFO \"Record Length: %u\\n\", record->header.rec_length);\n    printk(KERN_INFO \"Record Type: 0x%02x\\n\", record->header.rec_type);\n    printk(KERN_INFO \"Record Subtype: 0x%02x\\n\", record->header.rec_subtype);\n    \n    switch (record->header.rec_type) {\n        case REC_PTR: {\n            ptr_record *ptr = (ptr_record*)record->data;\n            if (ptr) {\n                printk(KERN_INFO \"PTR Record Fields:\\n\");\n                printk(KERN_INFO \"TEST_NUM: %u\\n\", ptr->TEST_NUM);\n                printk(KERN_INFO \"HEAD_NUM: %u\\n\", ptr->HEAD_NUM);\n                printk(KERN_INFO \"SITE_NUM: %u\\n\", ptr->SITE_NUM);\n                printk(KERN_INFO \"TEST_FLG: 0x%02x\\n\", ptr->TEST_FLG);\n                printk(KERN_INFO \"RESULT: %u\\n\", ptr->RESULT);\n                printk(KERN_INFO \"TEST_TXT: %s\\n\", ptr->TEST_TXT);\n            }\n            break;\n        }\n        case REC_MPR: {\n            mpr_record *mpr = (mpr_record*)record->data;\n            if (mpr) {\n                printk(KERN_INFO \"MPR Record Fields:\\n\");\n                printk(KERN_INFO \"TEST_NUM: %u\\n\", mpr->TEST_NUM);\n                printk(KERN_INFO \"HEAD_NUM: %u\\n\", mpr->HEAD_NUM);\n                printk(KERN_INFO \"SITE_NUM: %u\\n\", mpr->SITE_NUM);\n                printk(KERN_INFO \"RTN_ICNT: %u\\n\", mpr->RTN_ICNT);\n                for (int i = 0; i < mpr->RTN_ICNT && i < MAX_RESULTS; i++) {\n                    printk(KERN_INFO \"RTN_RSLT[%d]: %u\\n\", i, mpr->RTN_RSLT[i]);\n                }\n            }\n            break;\n        }\n        default:\n            printk(KERN_INFO \"Unknown record type: 0x%02x\\n\", record->header.rec_type);\n            break;\n    }\n}\n\n/* REAL STDF FILE BUFFER: Authentic multi-record STDF data like production .stdf files */\n/* This is EXACTLY what you'd find in a real semiconductor test file! */\n/* Students must parse multiple records sequentially like libstdf does */\n\n/* \n * PRODUCTION STDF FILE STRUCTURE:\n * Real STDF files contain multiple consecutive records that must be parsed sequentially.\n * This buffer simulates a section of a real .stdf file with multiple record types.\n * \n * Layout: [PTR Record][MPR Record][PTR Record] = 89 bytes total\n * This teaches the EXACT pattern used in production semiconductor test systems!\n */\nstatic uint8_t real_stdf_file_buffer[] = {\n    /* ============ RECORD 1: PTR (Parametric Test Record) - 30 bytes ============ */\n    /* STDF Header (4 bytes) */\n    0x1A, 0x00,           /* REC_LEN = 26 bytes payload (little-endian) */\n    0x15,                 /* REC_TYP = 21 (PTR record type) */\n    0x10,                 /* REC_SUB = 16 (PTR subtype) */\n\n    /* PTR Record Payload (26 bytes) - Real STDF field layout */\n    0xE9, 0x03, 0x00, 0x00,  /* TEST_NUM = 1001 (U4, little-endian) */\n    0x01,                     /* HEAD_NUM = 1 (U1) */\n    0x01,                     /* SITE_NUM = 1 (U1) */\n    0x00,                     /* TEST_FLG = 0 (B1) - No test flags set */\n    0x00,                     /* PARM_FLG = 0 (B1) - No optional parameters */\n    0xFF, 0x00, 0x00, 0x00,  /* RESULT = 255 (U4, stored as integer for kernel) */\n\n    /* TEST_TXT field (Cn = length + string) - Real STDF Cn format */\n    0x0C,                     /* String length = 12 */\n    'V', 'o', 'l', 't', 'a', 'g', 'e', '_', 'T', 'e', 's', 't',  /* \"Voltage_Test\" */\n\n    /* ALARM_ID field (Cn format) - Empty in this test */\n    0x00,                     /* String length = 0 (no alarm) */\n\n    /* ============ RECORD 2: MPR (Multiple-Result Parametric) - 26 bytes ============ */\n    /* STDF Header (4 bytes) */\n    0x16, 0x00,           /* REC_LEN = 22 bytes payload (little-endian) */\n    0x16,                 /* REC_TYP = 22 (MPR record type) */\n    0x10,                 /* REC_SUB = 16 (MPR subtype) */\n\n    /* MPR Record Payload (22 bytes) - Real STDF field layout */\n    0xEA, 0x03, 0x00, 0x00,  /* TEST_NUM = 1002 (U4, little-endian) */\n    0x01,                     /* HEAD_NUM = 1 (U1) */\n    0x01,                     /* SITE_NUM = 1 (U1) */\n    0x00,                     /* TEST_FLG = 0 (B1) */\n    0x00,                     /* PARM_FLG = 0 (B1) */\n    0x03, 0x00,              /* RTN_ICNT = 3 (U2, little-endian) - 3 results */\n\n    /* RTN_RSLT array (3 results, each U4) */\n    0x64, 0x00, 0x00, 0x00,  /* RTN_RSLT[0] = 100 (U4) */\n    0x65, 0x00, 0x00, 0x00,  /* RTN_RSLT[1] = 101 (U4) */\n    0x66, 0x00, 0x00, 0x00,  /* RTN_RSLT[2] = 102 (U4) */\n\n    /* ============ RECORD 3: Another PTR (Parametric Test Record) - 31 bytes ============ */\n    /* STDF Header (4 bytes) */\n    0x1B, 0x00,           /* REC_LEN = 27 bytes payload (little-endian) */\n    0x15,                 /* REC_TYP = 21 (PTR record type) */\n    0x10,                 /* REC_SUB = 16 (PTR subtype) */\n\n    /* PTR Record Payload (27 bytes) - Real STDF field layout */\n    0xEB, 0x03, 0x00, 0x00,  /* TEST_NUM = 1003 (U4, little-endian) */\n    0x01,                     /* HEAD_NUM = 1 (U1) */\n    0x01,                     /* SITE_NUM = 1 (U1) */\n    0x00,                     /* TEST_FLG = 0 (B1) - No test flags set */\n    0x00,                     /* PARM_FLG = 0 (B1) - No optional parameters */\n    0x00, 0x01, 0x00, 0x00,  /* RESULT = 256 (U4, stored as integer for kernel) */\n\n    /* TEST_TXT field (Cn = length + string) - Real STDF Cn format */\n    0x0D,                     /* String length = 13 */\n    'C', 'u', 'r', 'r', 'e', 'n', 't', '_', 'T', 'e', 's', 't', '2',  /* \"Current_Test2\" */\n\n    /* ALARM_ID field (Cn format) - Empty in this test */\n    0x00,                     /* String length = 0 (no alarm) */\n\n    /* End of multi-record STDF buffer - total 89 bytes (30+26+31) */\n    /* This simulates real .stdf file content that needs sequential processing! */\n};\n\n/* TODO: Implement PRODUCTION STDF multi-record parser */\n/* This is the CORE function that students must implement - it teaches the */\n/* EXACT same pattern used in real libstdf and semiconductor test systems! */\nint parse_stdf_file_buffer(uint8_t *buffer, size_t total_size) {\n    /* TODO: What variables do you need to track your position in the buffer? */\n    /* TODO: How do you know when you've reached the end of the buffer? */\n    /* TODO: What counter should you keep for the number of records processed? */\n    \n    /* TODO: How would you loop through multiple records in a buffer? */\n    /* TODO: What condition should your loop check? */\n    /* TODO: How do you parse a single record at the current position? */\n    /* TODO: What should you do if parsing fails? */\n    /* TODO: How do you display the parsed record? */\n    /* TODO: CRITICAL: How do you move to the next record? (Think: header + payload) */\n    /* TODO: Don't forget to count each record and clean up memory! */\n    \n    /* TODO: What should this function return to indicate success? */\n    return 0;\n}\n\n/* Helper function to create real STDF multi-record buffer for testing */\nstatic uint8_t* get_real_stdf_file_buffer(uint32_t test_num, uint32_t result) {\n    uint8_t *pos;\n    \n    /* Use the complete multi-record STDF buffer */\n    buffer_size = sizeof(real_stdf_file_buffer);\n    test_buffer = kmalloc(buffer_size, GFP_KERNEL);\n    if (!test_buffer) {\n        return NULL;\n    }\n    \n    /* Copy the entire multi-record STDF file buffer */\n    memcpy(test_buffer, real_stdf_file_buffer, buffer_size);\n    \n    /* Update dynamic test values in FIRST PTR record (for validation) */\n    pos = test_buffer + 4;  /* Skip header to first PTR payload */\n    *(uint32_t*)pos = test_num;     /* Update TEST_NUM field */\n    pos += 4 + 1 + 1 + 1 + 1;      /* Skip to RESULT field */\n    *(uint32_t*)pos = result;       /* Update RESULT field */\n    \n    return test_buffer;\n}\n\nstatic int __init stdf_parser_init(void)\n{\n    int record_count;\n    \n    printk(KERN_INFO \"STDF parser module loaded\\n\");\n    \n    /* Get real STDF multi-record buffer with dynamic parameter values */\n    if (!get_real_stdf_file_buffer(test_num, (uint32_t)test_result)) {\n        printk(KERN_ERR \"Failed to create STDF test buffer\\n\");\n        return -ENOMEM;\n    }\n    \n    printk(KERN_INFO \"Created STDF buffer: type=0x%02x, test_num=%d, result=%d\\n\", \n           test_record_type, test_num, test_result);\n    \n    /* PRODUCTION LIBSTDF PATTERN: Parse multiple records sequentially */\n    /* This is EXACTLY how real semiconductor test systems process STDF files! */\n    record_count = parse_stdf_file_buffer(test_buffer, buffer_size);\n    \n    printk(KERN_INFO \"STDF file processing complete: %d records parsed\\n\", record_count);\n    \n    return 0;\n}\n\nstatic void __exit stdf_parser_exit(void)\n{\n    printk(KERN_INFO \"STDF parser module unloaded\\n\");\n    \n    /* Clean up allocated memory */\n    if (parsed_record) {\n        if (parsed_record->data) {\n            kfree(parsed_record->data);\n        }\n        kfree(parsed_record);\n        parsed_record = NULL;\n    }\n    \n    if (test_buffer) {\n        kfree(test_buffer);\n        test_buffer = NULL;\n    }\n}\n\nmodule_init(stdf_parser_init);\nmodule_exit(stdf_parser_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning STDF parsing with production header/data separation and record dispatch\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# STDF parser module Makefile\nobj-m += stdf_parser.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "stdf_parser.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "stdf_parser_init",
          "stdf_parser_exit",
          "parse_stdf_header",
          "read_uint8_from_buffer",
          "read_uint32_from_buffer",
          "read_uint16_from_buffer",
          "read_string_from_buffer",
          "parse_ptr_record",
          "parse_mpr_record",
          "parse_stdf_record_from_buffer",
          "parse_stdf_file_buffer",
          "print_stdf_record"
        ],
        "function_declarations": [
          {
            "name": "parse_stdf_header",
            "returnType": "stdf_header*",
            "parameters": [
              "uint8_t **buffer_ptr"
            ]
          },
          {
            "name": "read_uint8_from_buffer",
            "returnType": "uint8_t",
            "parameters": [
              "uint8_t **buffer_ptr"
            ]
          },
          {
            "name": "read_uint32_from_buffer",
            "returnType": "uint32_t",
            "parameters": [
              "uint8_t **buffer_ptr"
            ]
          },
          {
            "name": "read_uint16_from_buffer",
            "returnType": "uint16_t",
            "parameters": [
              "uint8_t **buffer_ptr"
            ]
          },
          {
            "name": "read_string_from_buffer",
            "returnType": "char*",
            "parameters": [
              "uint8_t **buffer_ptr",
              "uint8_t *out_length"
            ]
          },
          {
            "name": "parse_ptr_record",
            "returnType": "ptr_record*",
            "parameters": [
              "uint8_t *data",
              "uint16_t length"
            ]
          },
          {
            "name": "parse_mpr_record",
            "returnType": "mpr_record*",
            "parameters": [
              "uint8_t *data",
              "uint16_t length"
            ]
          },
          {
            "name": "parse_stdf_record_from_buffer",
            "returnType": "stdf_record*",
            "parameters": [
              "uint8_t *raw_buffer"
            ]
          },
          {
            "name": "parse_stdf_file_buffer",
            "returnType": "int",
            "parameters": [
              "uint8_t *buffer",
              "size_t total_size"
            ]
          },
          {
            "name": "print_stdf_record",
            "returnType": "void",
            "parameters": [
              "stdf_record *record"
            ]
          }
        ],
        "variables_declarations": [
          {
            "name": "stdf_header",
            "type": "typedef struct",
            "value": "{uint16_t rec_length; uint8_t rec_type; uint8_t rec_subtype;}",
            "storageClass": "none"
          },
          {
            "name": "stdf_record",
            "type": "typedef struct",
            "value": "{stdf_header header; void *data;}",
            "storageClass": "none"
          },
          {
            "name": "ptr_record",
            "type": "typedef struct",
            "value": "{uint32_t TEST_NUM; uint8_t HEAD_NUM; uint8_t SITE_NUM; uint8_t TEST_FLG; uint8_t PARM_FLG; uint32_t RESULT; char TEST_TXT[MAX_NAME_LEN]; char ALARM_ID[MAX_NAME_LEN];}",
            "storageClass": "none"
          },
          {
            "name": "mpr_record",
            "type": "typedef struct",
            "value": "{uint32_t TEST_NUM; uint8_t HEAD_NUM; uint8_t SITE_NUM; uint8_t TEST_FLG; uint8_t PARM_FLG; uint16_t RTN_ICNT; uint32_t RTN_RSLT[MAX_RESULTS];}",
            "storageClass": "none"
          },
          {
            "name": "parsed_record",
            "type": "stdf_record *",
            "storageClass": "extern"
          },
          {
            "name": "test_buffer",
            "type": "uint8_t *",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "parsed_record",
            "type": "stdf_record *",
            "value": "NULL",
            "storageClass": "none"
          },
          {
            "name": "test_buffer",
            "type": "uint8_t *",
            "value": "NULL",
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "STDF parser module loaded",
          "Created STDF buffer: type=0x15, test_num=1001, result=255",
          "STDF Record Header:",
          "Record Length: 26",
          "Record Type: 0x15",
          "Record Subtype: 0x10",
          "PTR Record Fields:",
          "TEST_NUM: 1001",
          "HEAD_NUM: 1",
          "SITE_NUM: 1",
          "TEST_FLG: 0x00",
          "RESULT: 255",
          "TEST_TXT: Voltage_Test",
          "STDF Record Header:",
          "Record Length: 22",
          "Record Type: 0x16",
          "Record Subtype: 0x10",
          "MPR Record Fields:",
          "TEST_NUM: 1002",
          "HEAD_NUM: 1",
          "SITE_NUM: 1",
          "RTN_ICNT: 3",
          "RTN_RSLT[0]: 100",
          "RTN_RSLT[1]: 101",
          "RTN_RSLT[2]: 102",
          "STDF Record Header:",
          "Record Length: 27",
          "Record Type: 0x15",
          "Record Subtype: 0x10",
          "PTR Record Fields:",
          "TEST_NUM: 1003",
          "HEAD_NUM: 1",
          "SITE_NUM: 1",
          "TEST_FLG: 0x00",
          "RESULT: 256",
          "TEST_TXT: Current_Test2",
          "STDF file processing complete: 3 records parsed",
          "STDF parser module unloaded"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h",
          "linux/slab.h",
          "linux/string.h"
        ],
        "mustContain": [
          "parse_stdf_header(&buffer_pos)",
          "read_uint8_from_buffer(&buffer_pos)",
          "*(uint32_t*)(*buffer_ptr)",
          "*buffer_ptr += 4",
          "*(uint16_t*)(*buffer_ptr)",
          "*buffer_ptr += 2",
          "switch (record->header.rec_type)",
          "case REC_PTR:",
          "case REC_MPR:",
          "record->data",
          "kmalloc",
          "kfree",
          "while (current_pos < buffer_end)",
          "current_pos += 4 + record->header.rec_length",
          "parse_stdf_file_buffer(test_buffer, buffer_size)",
          "module_param(test_record_type, int, 0644)",
          "module_param(test_num, int, 0644)",
          "module_param(test_result, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "stdf_header* parse_stdf_header(uint8_t **buffer_ptr)",
            "uint8_t read_uint8_from_buffer(uint8_t **buffer_ptr)",
            "uint32_t read_uint32_from_buffer(uint8_t **buffer_ptr)",
            "uint16_t read_uint16_from_buffer(uint8_t **buffer_ptr)",
            "char* read_string_from_buffer(uint8_t **buffer_ptr, uint8_t *out_length)",
            "ptr_record* parse_ptr_record(uint8_t *data, uint16_t length)",
            "mpr_record* parse_mpr_record(uint8_t *data, uint16_t length)",
            "stdf_record* parse_stdf_record_from_buffer(uint8_t *raw_buffer)",
            "int parse_stdf_file_buffer(uint8_t *buffer, size_t total_size)",
            "void print_stdf_record(stdf_record *record)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "stdf_header* parse_stdf_header(uint8_t **buffer_ptr)",
            "uint8_t read_uint8_from_buffer(uint8_t **buffer_ptr)",
            "uint32_t read_uint32_from_buffer(uint8_t **buffer_ptr)",
            "uint16_t read_uint16_from_buffer(uint8_t **buffer_ptr)",
            "char* read_string_from_buffer(uint8_t **buffer_ptr, uint8_t *out_length)",
            "ptr_record* parse_ptr_record(uint8_t *data, uint16_t length)",
            "mpr_record* parse_mpr_record(uint8_t *data, uint16_t length)",
            "stdf_record* parse_stdf_record_from_buffer(uint8_t *raw_buffer)",
            "int parse_stdf_file_buffer(uint8_t *buffer, size_t total_size)",
            "void print_stdf_record(stdf_record *record)",
            "static int __init stdf_parser_init(void)",
            "static void __exit stdf_parser_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "STDF parser module loaded",
              "exact": true,
              "linkedFunction": "static int __init stdf_parser_init(void)"
            },
            {
              "pattern": "Created STDF buffer: type=0x15, test_num=1001, result=255",
              "exact": true,
              "linkedFunction": "static int __init stdf_parser_init(void)"
            },
            {
              "pattern": "STDF Record Header:",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "Record Length: 26",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "Record Type: 0x15",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "Record Subtype: 0x10",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "PTR Record Fields:",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "TEST_NUM: 1001",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "HEAD_NUM: 1",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "SITE_NUM: 1",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "TEST_FLG: 0x00",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "RESULT: 255",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "TEST_TXT: Voltage_Test",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "STDF Record Header:",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "Record Length: 22",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "Record Type: 0x16",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "Record Subtype: 0x10",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "MPR Record Fields:",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "TEST_NUM: 1002",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "HEAD_NUM: 1",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "SITE_NUM: 1",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "RTN_ICNT: 3",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "RTN_RSLT[0]: 100",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "RTN_RSLT[1]: 101",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "RTN_RSLT[2]: 102",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "STDF Record Header:",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "Record Length: 27",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "Record Type: 0x15",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "Record Subtype: 0x10",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "PTR Record Fields:",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "TEST_NUM: 1003",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "HEAD_NUM: 1",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "SITE_NUM: 1",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "TEST_FLG: 0x00",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "RESULT: 256",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "TEST_TXT: Current_Test2",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "STDF file processing complete: 3 records parsed",
              "exact": true,
              "linkedFunction": "static int __init stdf_parser_init(void)"
            },
            {
              "pattern": "STDF parser module unloaded",
              "exact": true,
              "linkedFunction": "static void __exit stdf_parser_exit(void)"
            }
          ]
        },
        {
          "id": "advanced_stdf_parsing_validation",
          "name": "Advanced STDF Parsing with Anti-Hardcoding Protection",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "stdf_parsing_dynamic_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Anti-Hardcoding STDF Parsing Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate unpredictable test values\\n    int random_record_type = (rand() % 2) ? 0x15 : 0x16;  // PTR or MPR\\n    int random_test_num = (rand() % 9000) + 1000;         // 1000-9999\\n    int random_result = (rand() % 500) + 100;             // 100-599\\n    \\n    printf(\\\"Test 1: Random STDF parsing (type=0x%02x, test_num=%d, result=%d)\\\\n\\\", random_record_type, random_test_num, random_result);\\n    \\n    // Test with random values\\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod stdf_parser 2>/dev/null\\\");\\n    \\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/stdf_parser.ko test_record_type=%d test_num=%d test_result=%d\\\", random_record_type, random_test_num, random_result);\\n    printf(\\\"DEBUG: Command: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Anti-hardcoding STDF parsing test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced STDF parsing implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef unsigned char uint8_t;' > /tmp/linux/types.h",
              "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
              "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
              "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
              "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
              "echo '#define MAX_RESULTS 8' >> /tmp/linux/types.h",
              "echo '#define REC_PTR 0x15' >> /tmp/linux/types.h",
              "echo '#define REC_MPR 0x16' >> /tmp/linux/types.h",
              "echo 'void* kmalloc(size_t size, int flags);' > /tmp/linux/slab.h",
              "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
              "echo '#define GFP_KERNEL 0' >> /tmp/linux/slab.h",
              "echo 'void* memcpy(void *dest, const void *src, size_t n);' >> /tmp/linux/slab.h",
              "echo 'size_t strlen(const char *s);' >> /tmp/linux/slab.h",
              "echo 'void* memcpy(void *dest, const void *src, size_t n);' > /tmp/linux/string.h",
              "echo 'size_t strlen(const char *s);' >> /tmp/linux/string.h",
              "echo 'char* strcpy(char *dest, const char *src);' >> /tmp/linux/string.h",
              "echo 'Creating test file that includes STDF parsing header...'",
              "echo '#include \"/lib/modules/stdf_parser.h\"' > /tmp/test.c",
              "echo 'int main() { uint8_t *buf; uint8_t len; size_t size = 89; parsed_record = (stdf_record*)0; parse_stdf_header(&buf); read_uint8_from_buffer(&buf); read_uint32_from_buffer(&buf); read_uint16_from_buffer(&buf); read_string_from_buffer(&buf, &len); parse_ptr_record(buf, 26); parse_mpr_record(buf, 22); parse_stdf_record_from_buffer(buf); parse_stdf_file_buffer(buf, size); print_stdf_record((stdf_record*)0); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
              "echo 'Phase 2: Anti-Hardcoding Dynamic STDF Parsing Test'",
              "/bin/stdf_parsing_dynamic_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Random Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "RECORD_TYPE=$(grep -o 'Random STDF parsing (type=0x[0-9a-f]*' /tmp/test_output.log | cut -d'=' -f2)",
              "TEST_NUM=$(grep -o 'test_num=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
              "RESULT=$(grep -o 'result=[0-9]*)' /tmp/test_output.log | cut -d'=' -f2 | cut -d')' -f1)",
              "echo 'Extracted values: RECORD_TYPE='$RECORD_TYPE', TEST_NUM='$TEST_NUM', RESULT='$RESULT",
              "if [ -z \"$RECORD_TYPE\" ] || [ -z \"$TEST_NUM\" ] || [ -z \"$RESULT\" ]; then echo 'FAIL: Could not extract random test values'; else echo 'PASS: Random values extracted successfully'; fi",
              "echo 'Phase 4: Anti-Hardcoding Validation with Random Values'",
              "echo 'Validating STDF record type parsing with random value '$RECORD_TYPE",
              "dmesg | grep \"Record Type: $RECORD_TYPE\" && echo 'PASS: STDF record type parsing with random value working' || echo 'FAIL: STDF record type parsing with random value broken'",
              "echo 'Validating TEST_NUM parsing with random value '$TEST_NUM",
              "dmesg | grep \"TEST_NUM: $TEST_NUM\" && echo 'PASS: TEST_NUM parsing with random value working' || echo 'FAIL: TEST_NUM parsing with random value broken'",
              "echo 'Validating RESULT parsing with random value '$RESULT",
              "dmesg | grep \"RESULT: $RESULT\" && echo 'PASS: RESULT parsing with random value working' || echo 'FAIL: RESULT parsing with random value broken'",
              "echo 'Phase 5: Static Field Validation (Non-Randomized Fields)'",
              "dmesg | grep 'STDF Record Header:' && echo 'PASS: STDF header parsing working' || echo 'FAIL: STDF header parsing broken'",
              "dmesg | grep 'HEAD_NUM: 1' && echo 'PASS: HEAD_NUM parsing working' || echo 'FAIL: HEAD_NUM parsing broken'",
              "dmesg | grep 'SITE_NUM: 1' && echo 'PASS: SITE_NUM parsing working' || echo 'FAIL: SITE_NUM parsing broken'",
              "echo 'Phase 6: STDF Architecture Validation'",
              "dmesg | grep 'PTR Record Fields:' && echo 'PASS: PTR record dispatch working' || echo 'FAIL: PTR record dispatch broken'",
              "dmesg | grep 'MPR Record Fields:' && echo 'PASS: MPR record dispatch working' || echo 'FAIL: MPR record dispatch broken'",
              "dmesg | grep 'RTN_ICNT: 3' && echo 'PASS: MPR array count parsing working' || echo 'FAIL: MPR array count parsing broken'",
              "dmesg | grep 'RTN_RSLT\\[0\\]: 100' && echo 'PASS: MPR array element parsing working' || echo 'FAIL: MPR array element parsing broken'",
              "dmesg | grep 'STDF file processing complete: 3 records parsed' && echo 'PASS: Multi-record processing working' || echo 'FAIL: Multi-record processing broken'",
              "dmesg | grep 'STDF parser module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
              "dmesg | grep 'STDF parser module unloaded' && echo 'PASS: Module cleanup working' || echo 'FAIL: Module cleanup broken'",
              "echo 'Phase 7: Final Validation Summary'",
              "echo 'All phases completed successfully - anti-hardcoding STDF parsing protection verified'",
              "echo 'PASS: All anti-hardcoding STDF parsing validation successful'"
            ],
            "expected": {
              "dmesg": [
                "STDF parser module loaded",
                "Created STDF buffer: type=.*, test_num=.*, result=.*",
                "STDF Record Header:",
                "Record Length: .*",
                "Record Type: .*",
                "Record Subtype: .*",
                "PTR Record Fields:",
                "TEST_NUM: .*",
                "HEAD_NUM: .*",
                "SITE_NUM: .*",
                "TEST_FLG: .*",
                "RESULT: .*",
                "TEST_TXT: .*",
                "MPR Record Fields:",
                "RTN_ICNT: .*",
                "RTN_RSLT\\[.*\\]: .*",
                "STDF file processing complete: .* records parsed",
                "STDF parser module unloaded"
              ],
              "stdout": [
                "PASS: All function and variable declarations found in header file",
                "SUCCESS: Anti-hardcoding STDF parsing test completed",
                "PASS: Random values extracted successfully",
                "PASS: STDF record type parsing with random value working",
                "PASS: TEST_NUM parsing with random value working",
                "PASS: RESULT parsing with random value working",
                "PASS: STDF header parsing working",
                "PASS: HEAD_NUM parsing working",
                "PASS: SITE_NUM parsing working",
                "PASS: PTR record dispatch working",
                "PASS: MPR record dispatch working",
                "PASS: MPR array count parsing working",
                "PASS: MPR array element parsing working",
                "PASS: Multi-record processing working",
                "PASS: Module initialization working",
                "PASS: Module cleanup working",
                "PASS: All anti-hardcoding STDF parsing validation successful"
              ]
            },
            "timeout": 15
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "STDF parser module loaded",
        "Created STDF buffer: type=0x15, test_num=1001, result=255",
        "STDF Record Header:",
        "Record Length: 26",
        "Record Type: 0x15",
        "Record Subtype: 0x10",
        "PTR Record Fields:",
        "TEST_NUM: 1001",
        "HEAD_NUM: 1",
        "SITE_NUM: 1",
        "TEST_FLG: 0x00",
        "RESULT: 255",
        "TEST_TXT: Voltage_Test",
        "STDF Record Header:",
        "Record Length: 22",
        "Record Type: 0x16",
        "Record Subtype: 0x10",
        "MPR Record Fields:",
        "TEST_NUM: 1002",
        "HEAD_NUM: 1",
        "SITE_NUM: 1",
        "RTN_ICNT: 3",
        "RTN_RSLT[0]: 100",
        "RTN_RSLT[1]: 101",
        "RTN_RSLT[2]: 102",
        "STDF Record Header:",
        "Record Length: 27",
        "Record Type: 0x15",
        "Record Subtype: 0x10",
        "PTR Record Fields:",
        "TEST_NUM: 1003",
        "HEAD_NUM: 1",
        "SITE_NUM: 1",
        "TEST_FLG: 0x00",
        "RESULT: 256",
        "TEST_TXT: Current_Test2",
        "STDF file processing complete: 3 records parsed",
        "STDF parser module unloaded"
      ],
      "requirements": [
        "Use required function names: stdf_parser_init, stdf_parser_exit, parse_stdf_header, read_uint8_from_buffer, read_uint32_from_buffer, read_uint16_from_buffer, read_string_from_buffer, parse_ptr_record, parse_mpr_record, parse_stdf_record_from_buffer, parse_stdf_file_buffer, print_stdf_record",
        "Use required variable names: parsed_record, test_buffer",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h, linux/slab.h, linux/string.h",
        "Code must contain: parse_stdf_header(&buffer_pos), read_uint8_from_buffer(&buffer_pos), *(uint32_t*)(*buffer_ptr), *buffer_ptr += 4, *(uint16_t*)(*buffer_ptr), *buffer_ptr += 2, switch (record->header.rec_type), case REC_PTR:, case REC_MPR:, record->data, kmalloc, kfree, while (current_pos < buffer_end), current_pos += 4 + record->header.rec_length, parse_stdf_file_buffer(test_buffer, buffer_size), module_param(test_record_type, int, 0644), module_param(test_num, int, 0644), module_param(test_result, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "STDF parser module loaded",
          "linkedFunction": "static int __init stdf_parser_init(void)",
          "exact": true
        },
        {
          "pattern": "Created STDF buffer: type=0x15, test_num=1001, result=255",
          "linkedFunction": "static int __init stdf_parser_init(void)",
          "exact": true
        },
        {
          "pattern": "STDF Record Header:",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "Record Length: 26",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "Record Type: 0x15",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "Record Subtype: 0x10",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "PTR Record Fields:",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "TEST_NUM: 1001",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "HEAD_NUM: 1",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "SITE_NUM: 1",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "TEST_FLG: 0x00",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "RESULT: 255",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "TEST_TXT: Voltage_Test",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "STDF Record Header:",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "Record Length: 22",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "Record Type: 0x16",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "Record Subtype: 0x10",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "MPR Record Fields:",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "TEST_NUM: 1002",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "HEAD_NUM: 1",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "SITE_NUM: 1",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "RTN_ICNT: 3",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "RTN_RSLT[0]: 100",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "RTN_RSLT[1]: 101",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "RTN_RSLT[2]: 102",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "STDF Record Header:",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "Record Length: 27",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "Record Type: 0x15",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "Record Subtype: 0x10",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "PTR Record Fields:",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "TEST_NUM: 1003",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "HEAD_NUM: 1",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "SITE_NUM: 1",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "TEST_FLG: 0x00",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "RESULT: 256",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "TEST_TXT: Current_Test2",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "STDF file processing complete: 3 records parsed",
          "linkedFunction": "static int __init stdf_parser_init(void)",
          "exact": true
        },
        {
          "pattern": "STDF parser module unloaded",
          "linkedFunction": "static void __exit stdf_parser_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 24,
    "title": "Preprocessor Macros - Kernel-Style Code Generation",
    "difficulty": 5,
    "xp": 55,
    "phase": "foundations",
    "description": "Master essential preprocessor macros for kernel development. Learn #define constants, bit flag macros, function-like macros, and conditional compilation patterns used throughout Linux kernel code.",
    "concepts": [
      "preprocessor directives",
      "simple constant macros",
      "bit manipulation macros",
      "function-like macros",
      "conditional compilation",
      "kernel macro conventions"
    ],
    "skills": [
      "Defining constant macros for magic numbers",
      "Creating bit flag macros for status registers",
      "Writing function-like macros",
      "Using conditional compilation for debug code",
      "Understanding macro parameter safety",
      "Applying kernel-style macro patterns"
    ],
    "files": [
      {
        "name": "macro_processor.h",
        "content": "#ifndef MACRO_PROCESSOR_H\n#define MACRO_PROCESSOR_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* TODO: Define device type constants */\n/* Define DEVICE_TYPE_SENSOR with value 1 */\n/* Define DEVICE_TYPE_MOTOR with value 2 */\n\n/* TODO: Define status flag constants using bit shifts */\n/* Define STATUS_ONLINE using (1 << 0) */\n/* Define STATUS_READY using (1 << 1) */\n\n/* TODO: Define configuration constants */\n/* Define MAX_DEVICE_NAME with value 32 */\n\n/* TODO: Define function-like macros */\n/* Create macro MAKE_VERSION(major, minor) that combines major and minor into single value */\n/* Formula: (major << 16) | minor */\n\n/* TODO: Define conditional compilation macros */\n/* Create macro DEBUG_PRINT(fmt, ...) that prints debug messages */\n/* When DEBUG_MODE is defined: printk(KERN_DEBUG fmt, ##__VA_ARGS__) */\n/* When DEBUG_MODE is not defined: empty (no operation) */\n\n/* Device structure for testing */\ntypedef struct {\n    uint8_t device_type;\n    uint8_t status_flags;\n    uint32_t version;\n    char name[MAX_DEVICE_NAME];\n} device_info;\n\n/* Global test device */\nextern device_info test_device;\n\n/* TODO: Declare your macro testing functions */\n/* void test_macro_constants(void); */\n/* void test_version_and_flags(void); */\n/* void test_conditional_compilation(void); */\n/* void print_device_info(device_info *device); */\n\n#endif /* MACRO_PROCESSOR_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "macro_processor.c",
        "content": "#include \"macro_processor.h\"\n\n/* Enable debug mode for conditional compilation testing */\n#define DEBUG_MODE\n\n/* Global test device */\ndevice_info test_device = {\n    .device_type = DEVICE_TYPE_SENSOR,\n    .status_flags = 0,\n    .version = 0,\n    .name = \"Temperature Sensor\"\n};\n\nint test_device_type = DEVICE_TYPE_SENSOR;\nint test_major_version = 2;\nint test_minor_version = 4;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your macro logic works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(test_device_type, int, 0644);\nMODULE_PARM_DESC(test_device_type, \"Device type for testing macro validation\");\nmodule_param(test_major_version, int, 0644);\nMODULE_PARM_DESC(test_major_version, \"Major version for testing version macros\");\nmodule_param(test_minor_version, int, 0644);\nMODULE_PARM_DESC(test_minor_version, \"Minor version for testing version macros\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: How preprocessor macros work in kernel development */\n/* This teaches the FOUNDATION for kernel programming:\n *\n * Macro Types in Kernel Development:\n * 1. Simple Constants: #define MAX_SIZE 64\n * 2. Bit Flag Constants: #define FLAG_READY (1 << 0)\n * 3. Function-like Macros: #define MAX(a,b) ((a) > (b) ? (a) : (b))\n * 4. Conditional Compilation: #ifdef DEBUG ... #endif\n *\n * Why Macros are Essential in Kernel:\n * - Hardware register definitions use bit manipulation macros\n * - Kernel APIs heavily use function-like macros for efficiency\n * - Conditional compilation for different kernel configurations\n * - Version and feature detection macros\n */\n\n/* MACRO SAFETY PATTERNS: */\n\n/* Always wrap parameters in parentheses: */\n/* #define SQUARE(x) ((x) * (x))  // CORRECT */\n/* #define SQUARE(x) x * x        // WRONG - fails with SQUARE(a+b) */\n\n/* Always wrap entire macro in parentheses for complex expressions: */\n/* #define ADD(a,b) ((a) + (b))   // CORRECT */\n/* #define ADD(a,b) (a) + (b)     // WRONG - fails in expressions like 2 * ADD(3,4) */\n\n/* KERNEL MACRO EXAMPLES: */\n\n/* Module parameter declaration: */\n/* module_param(variable, type, permissions) */\n\n/* Kernel logging with levels: */\n/* printk(KERN_INFO \"message\") */\n\n/* Bit manipulation for hardware registers: */\n/* #define REG_ENABLE  (1 << 0) */\n/* #define REG_RESET   (1 << 1) */\n/* writel(REG_ENABLE | REG_RESET, device->base + CONTROL_REG) */\n\n/* TODO: Implement macro constants testing */\nvoid test_macro_constants(void) {\n    /* TODO: Test device type constants */\n    /* TODO: Print \"Testing macro constants:\" */\n    /* TODO: Print \"DEVICE_TYPE_SENSOR = %d\" with DEVICE_TYPE_SENSOR value */\n    /* TODO: Print \"DEVICE_TYPE_MOTOR = %d\" with DEVICE_TYPE_MOTOR value */\n    /* TODO: Print \"MAX_DEVICE_NAME = %d\" with MAX_DEVICE_NAME value */\n}\n\n/* TODO: Implement version and flags testing */\nvoid test_version_and_flags(void) {\n    /* TODO: Test bit flags */\n    /* TODO: Print \"Testing bit flags and version:\" */\n    /* TODO: Print \"STATUS_ONLINE = 0x%02x\" with STATUS_ONLINE value */\n    /* TODO: Print \"STATUS_READY = 0x%02x\" with STATUS_READY value */\n    \n    /* TODO: Test version macro */\n    /* TODO: Create version using MAKE_VERSION macro with test_major_version and test_minor_version */\n    /* TODO: Store result in variable: uint32_t version = MAKE_VERSION(test_major_version, test_minor_version) */\n    /* TODO: Print \"Created version: 0x%08x\" with version */\n    \n    /* TODO: Test combined flags */\n    /* TODO: Create variable combined_flags = STATUS_ONLINE | STATUS_READY */\n    /* TODO: Print \"Combined flags: 0x%02x\" with combined_flags */\n}\n\n/* TODO: Implement conditional compilation testing */\nvoid test_conditional_compilation(void) {\n    /* TODO: Test conditional compilation macros */\n    /* TODO: Print \"Testing conditional compilation:\" */\n    \n    /* TODO: Use DEBUG_PRINT macro to print \"Debug message: device type %d\" and test_device_type */\n    \n    /* TODO: Test preprocessor conditions */\n    /* TODO: Use #ifdef DEBUG_MODE to conditionally print \"Debug mode is enabled\" */\n    /* TODO: Use #else to print \"Debug mode is disabled\" */\n    /* TODO: Close with #endif */\n}\n\nvoid print_device_info(device_info *device) {\n    if (!device) {\n        printk(KERN_ERR \"No device information available\\n\");\n        return;\n    }\n    \n    printk(KERN_INFO \"Device: %s (Type: %d, Version: 0x%08x)\\n\", \n           device->name, device->device_type, device->version);\n}\n\nstatic int __init macro_processor_init(void)\n{\n    printk(KERN_INFO \"Macro processor module loaded\\n\");\n    \n    /* Update test device with dynamic parameter values */\n    test_device.device_type = test_device_type;\n    test_device.version = MAKE_VERSION(test_major_version, test_minor_version);\n    test_device.status_flags = STATUS_ONLINE | STATUS_READY;\n    \n    /* Test all macro categories */\n    test_macro_constants();\n    test_version_and_flags();\n    test_conditional_compilation();\n    \n    /* Display device information */\n    print_device_info(&test_device);\n    \n    printk(KERN_INFO \"Macro demonstration completed\\n\");\n    \n    return 0;\n}\n\nstatic void __exit macro_processor_exit(void)\n{\n    printk(KERN_INFO \"Macro processor module unloaded\\n\");\n}\n\nmodule_init(macro_processor_init);\nmodule_exit(macro_processor_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning essential preprocessor macros for kernel development\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Macro processor module Makefile\nobj-m += macro_processor.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "macro_processor.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "macro_processor_init",
          "macro_processor_exit",
          "test_macro_constants",
          "test_version_and_flags",
          "test_conditional_compilation",
          "print_device_info"
        ],
        "macro_declarations": [
          {
            "name": "DEVICE_TYPE_SENSOR",
            "type": "constant",
            "value": "1",
            "description": "Device type constant for sensors"
          },
          {
            "name": "DEVICE_TYPE_MOTOR",
            "type": "constant",
            "value": "2",
            "description": "Device type constant for motors"
          },
          {
            "name": "STATUS_ONLINE",
            "type": "constant",
            "value": "(1 << 0)",
            "description": "Status bit flag for online state"
          },
          {
            "name": "STATUS_READY",
            "type": "constant",
            "value": "(1 << 1)",
            "description": "Status bit flag for ready state"
          },
          {
            "name": "MAX_DEVICE_NAME",
            "type": "constant",
            "value": "32",
            "description": "Maximum device name length"
          },
          {
            "name": "MAKE_VERSION",
            "type": "function-like",
            "parameters": [
              "major",
              "minor"
            ],
            "value": "((major << 16) | minor)",
            "description": "Combine major and minor version into single value"
          },
          {
            "name": "DEBUG_PRINT",
            "type": "conditional",
            "parameters": [
              "fmt",
              "..."
            ],
            "value": "#ifdef DEBUG_MODE printk(KERN_DEBUG fmt, ##__VA_ARGS__) #else #endif",
            "description": "Conditional debug printing macro"
          }
        ],
        "macro_definitions": [
          {
            "name": "DEBUG_MODE",
            "type": "constant",
            "description": "Enable debug compilation mode"
          }
        ],
        "function_declarations": [
          {
            "name": "test_macro_constants",
            "returnType": "void",
            "parameters": [
              "void"
            ]
          },
          {
            "name": "test_version_and_flags",
            "returnType": "void",
            "parameters": [
              "void"
            ]
          },
          {
            "name": "test_conditional_compilation",
            "returnType": "void",
            "parameters": [
              "void"
            ]
          },
          {
            "name": "print_device_info",
            "returnType": "void",
            "parameters": [
              "device_info *device"
            ]
          }
        ],
        "variables_declarations": [
          {
            "name": "test_device",
            "type": "device_info",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "test_device",
            "type": "device_info",
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Macro processor module loaded",
          "Testing macro constants:",
          "DEVICE_TYPE_SENSOR = 1",
          "DEVICE_TYPE_MOTOR = 2",
          "MAX_DEVICE_NAME = 32",
          "Testing bit flags and version:",
          "STATUS_ONLINE = 0x01",
          "STATUS_READY = 0x02",
          "Created version:",
          "Combined flags: 0x03",
          "Testing conditional compilation:",
          "Debug mode is enabled",
          "Device: Temperature Sensor",
          "Macro demonstration completed",
          "Macro processor module unloaded"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "#define DEVICE_TYPE_SENSOR 1",
          "#define DEVICE_TYPE_MOTOR 2",
          "#define STATUS_ONLINE (1 << 0)",
          "#define STATUS_READY (1 << 1)",
          "#define MAX_DEVICE_NAME 32",
          "#define MAKE_VERSION(major, minor) ((major << 16) | minor)",
          "#ifdef DEBUG_MODE",
          "#define DEBUG_PRINT(fmt, ...) printk(KERN_DEBUG fmt, ##__VA_ARGS__)",
          "#else",
          "#define DEBUG_PRINT(fmt, ...)",
          "#endif",
          "MAKE_VERSION(test_major_version, test_minor_version)",
          "DEBUG_PRINT(",
          "STATUS_ONLINE | STATUS_READY",
          "module_param(test_device_type, int, 0644)",
          "module_param(test_major_version, int, 0644)",
          "module_param(test_minor_version, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void test_macro_constants(void)",
            "void test_version_and_flags(void)",
            "void test_conditional_compilation(void)",
            "void print_device_info(device_info *device)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "macro_definitions",
          "name": "Macro Definitions in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "#define DEVICE_TYPE_SENSOR 1",
            "#define DEVICE_TYPE_MOTOR 2",
            "#define STATUS_ONLINE (1 << 0)",
            "#define STATUS_READY (1 << 1)",
            "#define MAX_DEVICE_NAME 32",
            "#define MAKE_VERSION",
            "#define DEBUG_PRINT"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void test_macro_constants(void)",
            "void test_version_and_flags(void)",
            "void test_conditional_compilation(void)",
            "void print_device_info(device_info *device)",
            "static int __init macro_processor_init(void)",
            "static void __exit macro_processor_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Macro processor module loaded",
              "exact": true,
              "linkedFunction": "static int __init macro_processor_init(void)"
            },
            {
              "pattern": "Testing macro constants:",
              "exact": true,
              "linkedFunction": "void test_macro_constants(void)"
            },
            {
              "pattern": "DEVICE_TYPE_SENSOR = 1",
              "exact": true,
              "linkedFunction": "void test_macro_constants(void)"
            },
            {
              "pattern": "DEVICE_TYPE_MOTOR = 2",
              "exact": true,
              "linkedFunction": "void test_macro_constants(void)"
            },
            {
              "pattern": "MAX_DEVICE_NAME = 32",
              "exact": true,
              "linkedFunction": "void test_macro_constants(void)"
            },
            {
              "pattern": "Testing bit flags and version:",
              "exact": true,
              "linkedFunction": "void test_version_and_flags(void)"
            },
            {
              "pattern": "STATUS_ONLINE = 0x01",
              "exact": true,
              "linkedFunction": "void test_version_and_flags(void)"
            },
            {
              "pattern": "STATUS_READY = 0x02",
              "exact": true,
              "linkedFunction": "void test_version_and_flags(void)"
            },
            {
              "pattern": "Combined flags: 0x03",
              "exact": true,
              "linkedFunction": "void test_version_and_flags(void)"
            },
            {
              "pattern": "Testing conditional compilation:",
              "exact": true,
              "linkedFunction": "void test_conditional_compilation(void)"
            },
            {
              "pattern": "Debug mode is enabled",
              "exact": true,
              "linkedFunction": "void test_conditional_compilation(void)"
            },
            {
              "pattern": "Device: Temperature Sensor",
              "exact": true,
              "linkedFunction": "void print_device_info(device_info *device)"
            },
            {
              "pattern": "Macro demonstration completed",
              "exact": true,
              "linkedFunction": "static int __init macro_processor_init(void)"
            },
            {
              "pattern": "Macro processor module unloaded",
              "exact": true,
              "linkedFunction": "static void __exit macro_processor_exit(void)"
            }
          ]
        },
        {
          "id": "simplified_macro_validation",
          "name": "Simplified Macro Processing with Anti-Hardcoding Protection",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "macro_dynamic_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Macro Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate test values\\n    int random_device_type = ((rand() % 2) + 1);  // 1 or 2\\n    int random_major = (rand() % 5) + 1;          // 1-5\\n    int random_minor = (rand() % 10) + 1;         // 1-10\\n    \\n    printf(\\\"Random macro test (device=%d, ver=%d.%d)\\\\n\\\", random_device_type, random_major, random_minor);\\n    \\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod macro_processor 2>/dev/null\\\");\\n    \\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/macro_processor.ko test_device_type=%d test_major_version=%d test_minor_version=%d\\\", random_device_type, random_major, random_minor);\\n    printf(\\\"DEBUG: Command: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Macro test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting simplified macro validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: TCC Header Validation'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_DEBUG' >> /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef unsigned char uint8_t;' > /tmp/linux/types.h",
              "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
              "echo '#include \"/lib/modules/macro_processor.h\"' > /tmp/test.c",
              "echo 'int main() { device_info dev; test_macro_constants(); test_version_and_flags(); test_conditional_compilation(); print_device_info(&dev); return 0; }' >> /tmp/test.c",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or macro definition missing'; cat /tmp/tcc_error.log; else echo 'PASS: All declarations found in header'; fi",
              "echo 'Phase 2: Dynamic Macro Test'",
              "/bin/macro_dynamic_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Macro Validation'",
              "sleep 1",
              "dmesg | grep 'DEVICE_TYPE_SENSOR = 1' && echo 'PASS: Device constants working' || echo 'FAIL: Device constants broken'",
              "dmesg | grep 'STATUS_ONLINE = 0x01' && echo 'PASS: Bit flags working' || echo 'FAIL: Bit flags broken'",
              "dmesg | grep 'Combined flags: 0x03' && echo 'PASS: Flag combination working' || echo 'FAIL: Flag combination broken'",
              "dmesg | grep 'Debug mode is enabled' && echo 'PASS: Conditional compilation working' || echo 'FAIL: Conditional compilation broken'",
              "dmesg | grep 'Testing macro constants:' && echo 'PASS: Constant testing working' || echo 'FAIL: Constant testing broken'",
              "dmesg | grep 'Testing bit flags and version:' && echo 'PASS: Version testing working' || echo 'FAIL: Version testing broken'",
              "dmesg | grep 'Macro processor module loaded' && echo 'PASS: Module loading working' || echo 'FAIL: Module loading broken'",
              "echo 'PASS: All macro validation successful'"
            ],
            "expected": {
              "dmesg": [
                "Macro processor module loaded",
                "Testing macro constants:",
                "DEVICE_TYPE_SENSOR = 1",
                "DEVICE_TYPE_MOTOR = 2",
                "MAX_DEVICE_NAME = 32",
                "Testing bit flags and version:",
                "STATUS_ONLINE = 0x01",
                "STATUS_READY = 0x02",
                "Created version: .*",
                "Combined flags: 0x03",
                "Testing conditional compilation:",
                "Debug mode is enabled",
                "Device: Temperature Sensor",
                "Macro demonstration completed",
                "Macro processor module unloaded"
              ],
              "stdout": [
                "PASS: All declarations found in header",
                "SUCCESS: Macro test completed",
                "PASS: Device constants working",
                "PASS: Bit flags working",
                "PASS: Flag combination working",
                "PASS: Conditional compilation working",
                "PASS: Constant testing working",
                "PASS: Version testing working",
                "PASS: Module loading working",
                "PASS: All macro validation successful"
              ]
            },
            "timeout": 15
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Macro processor module loaded",
        "Testing macro constants:",
        "DEVICE_TYPE_SENSOR = 1",
        "DEVICE_TYPE_MOTOR = 2",
        "MAX_DEVICE_NAME = 32",
        "Testing bit flags and version:",
        "STATUS_ONLINE = 0x01",
        "STATUS_READY = 0x02",
        "Created version:",
        "Combined flags: 0x03",
        "Testing conditional compilation:",
        "Debug mode is enabled",
        "Device: Temperature Sensor",
        "Macro demonstration completed",
        "Macro processor module unloaded"
      ],
      "requirements": [
        "Use required function names: macro_processor_init, macro_processor_exit, test_macro_constants, test_version_and_flags, test_conditional_compilation, print_device_info",
        "Use required variable names: test_device",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: #define DEVICE_TYPE_SENSOR 1, #define DEVICE_TYPE_MOTOR 2, #define STATUS_ONLINE (1 << 0), #define STATUS_READY (1 << 1), #define MAX_DEVICE_NAME 32, #define MAKE_VERSION(major, minor) ((major << 16) | minor), #ifdef DEBUG_MODE, #define DEBUG_PRINT(fmt, ...) printk(KERN_DEBUG fmt, ##__VA_ARGS__), #else, #define DEBUG_PRINT(fmt, ...), #endif, MAKE_VERSION(test_major_version, test_minor_version), DEBUG_PRINT(, STATUS_ONLINE | STATUS_READY, module_param(test_device_type, int, 0644), module_param(test_major_version, int, 0644), module_param(test_minor_version, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Macro processor module loaded",
          "linkedFunction": "static int __init macro_processor_init(void)",
          "exact": true
        },
        {
          "pattern": "Testing macro constants:",
          "linkedFunction": "void test_macro_constants(void)",
          "exact": true
        },
        {
          "pattern": "DEVICE_TYPE_SENSOR = 1",
          "linkedFunction": "void test_macro_constants(void)",
          "exact": true
        },
        {
          "pattern": "DEVICE_TYPE_MOTOR = 2",
          "linkedFunction": "void test_macro_constants(void)",
          "exact": true
        },
        {
          "pattern": "MAX_DEVICE_NAME = 32",
          "linkedFunction": "void test_macro_constants(void)",
          "exact": true
        },
        {
          "pattern": "Testing bit flags and version:",
          "linkedFunction": "void test_version_and_flags(void)",
          "exact": true
        },
        {
          "pattern": "STATUS_ONLINE = 0x01",
          "linkedFunction": "void test_version_and_flags(void)",
          "exact": true
        },
        {
          "pattern": "STATUS_READY = 0x02",
          "linkedFunction": "void test_version_and_flags(void)",
          "exact": true
        },
        {
          "pattern": "Combined flags: 0x03",
          "linkedFunction": "void test_version_and_flags(void)",
          "exact": true
        },
        {
          "pattern": "Testing conditional compilation:",
          "linkedFunction": "void test_conditional_compilation(void)",
          "exact": true
        },
        {
          "pattern": "Debug mode is enabled",
          "linkedFunction": "void test_conditional_compilation(void)",
          "exact": true
        },
        {
          "pattern": "Device: Temperature Sensor",
          "linkedFunction": "void print_device_info(device_info *device)",
          "exact": true
        },
        {
          "pattern": "Macro demonstration completed",
          "linkedFunction": "static int __init macro_processor_init(void)",
          "exact": true
        },
        {
          "pattern": "Macro processor module unloaded",
          "linkedFunction": "static void __exit macro_processor_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 79,
    "title": "Secure String Handling - Modern Kernel Text Operations",
    "difficulty": 4,
    "xp": 40,
    "phase": "foundations",
    "description": "Learn modern, secure string handling in kernel space using current best practices. Master strscpy(), snprintf(), and safe string operations essential for handling device names, user messages, and configuration data in kernel modules.",
    "concepts": [
      "secure string copying with strscpy()",
      "safe string formatting with snprintf()",
      "string validation and error handling",
      "module parameter strings",
      "kernel logging best practices",
      "buffer overflow prevention"
    ],
    "skills": [
      "Using modern kernel string functions",
      "Implementing secure string operations",
      "Error handling in string operations",
      "Input validation and sanitization",
      "Safe buffer management in kernel space",
      "Professional kernel logging patterns"
    ],
    "files": [
      {
        "name": "strings.h",
        "content": "#ifndef STRINGS_H\n#define STRINGS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n\n#define MAX_DEVICE_NAME 32\n#define MAX_STATUS_MSG 64\n#define MAX_BUFFER_SIZE 128\n\nextern char device_name[MAX_DEVICE_NAME];\nextern char status_message[MAX_STATUS_MSG];\nextern int name_length;\n\n/* TODO: Declare your functions */\n/* void display_device_info(void); */\n/* ssize_t update_device_name(const char *new_name); */\n/* int format_status_message(const char *status); */\n/* int validate_string_input(const char *input); */\n\n#endif /* STRINGS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "strings.c",
        "content": "#include \"strings.h\"\n\n/* TODO: Initialize device name and status message */\n/* char device_name[MAX_DEVICE_NAME] = \"sensor_001\"; */\n/* char status_message[MAX_STATUS_MSG] = \"initializing\"; */\nint name_length = 0;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your string operations work\n * with different input values. Removing them will cause test failures.\n */\nmodule_param_string(device_name, device_name, MAX_DEVICE_NAME, 0644);\nMODULE_PARM_DESC(device_name, \"Device name for testing string operations\");\nmodule_param_string(status_message, status_message, MAX_STATUS_MSG, 0644);\nMODULE_PARM_DESC(status_message, \"Status message for string formatting tests\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* TODO: Implement function to display device information */\n/* Use printk with KERN_INFO to display device name, length, and status */\n/* Format: \"Device: [name] (Length: [X])\" and \"Status: [status]\" */\n\n/* TODO: Implement function to safely update device name using strscpy() */\n/* Use strscpy() instead of manual copying for security */\n/* Return the number of characters copied, or negative on error */\n/* Update name_length after successful copy */\n\n/* TODO: Implement function to format status message using snprintf() */\n/* Use snprintf() to safely format: \"Device [name] is [status]\" */\n/* Return 0 on success, negative on error */\n/* Check for truncation and log warning if needed */\n\n/* TODO: Implement function to validate string input */\n/* Check if input is not NULL and length is reasonable */\n/* Use strlen() to get length, return length or -EINVAL on error */\n/* Reject empty strings and strings that are too long */\n\nstatic int __init strings_init(void)\n{\n    printk(KERN_INFO \"Secure string handling module loaded\\n\");\n    \n    /* TODO: Validate and calculate initial name length */\n    /* name_length = validate_string_input(device_name); */\n    /* if (name_length < 0) { */\n    /*     printk(KERN_ERR \"Invalid device name\\n\"); */\n    /*     return name_length; */\n    /* } */\n    \n    /* TODO: Display initial device information */\n    /* display_device_info(); */\n    \n    /* TODO: Update device name and display results */\n    /* ssize_t result = update_device_name(\"updated_sensor\"); */\n    /* if (result < 0) { */\n    /*     printk(KERN_WARNING \"Device name update failed: %zd\\n\", result); */\n    /* } else { */\n    /*     printk(KERN_INFO \"Device name updated successfully\\n\"); */\n    /*     display_device_info(); */\n    /* } */\n    \n    /* TODO: Format and display status message */\n    /* int fmt_result = format_status_message(\"active\"); */\n    /* if (fmt_result < 0) { */\n    /*     printk(KERN_WARNING \"Status formatting failed: %d\\n\", fmt_result); */\n    /* } */\n    \n    return 0;\n}\n\nstatic void __exit strings_exit(void)\n{\n    printk(KERN_INFO \"Secure string handling module unloaded\\n\");\n}\n\nmodule_init(strings_init);\nmodule_exit(strings_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning secure string handling in kernel space\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# String handling module Makefile\nobj-m += strings.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "strings.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "strings_init",
          "strings_exit",
          "display_device_info",
          "update_device_name",
          "format_status_message",
          "validate_string_input"
        ],
        "variables": [
          {
            "name": "device_name",
            "type": "char[]",
            "value": "\"sensor_001\""
          },
          {
            "name": "status_message",
            "type": "char[]",
            "value": "\"initializing\""
          },
          {
            "name": "name_length",
            "type": "int",
            "value": 0
          }
        ],
        "outputMessages": [
          "Secure string handling module loaded",
          "Device: sensor_001 (Length: 10)",
          "Status: initializing",
          "Device name updated successfully",
          "Device: updated_sensor (Length: 14)",
          "Status: Device updated_sensor is active"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h",
          "linux/string.h"
        ],
        "mustContain": [
          "#define MAX_DEVICE_NAME 32",
          "#define MAX_STATUS_MSG 64",
          "extern char device_name[MAX_DEVICE_NAME]",
          "extern char status_message[MAX_STATUS_MSG]",
          "module_param_string(device_name, device_name, MAX_DEVICE_NAME, 0644)",
          "module_param_string(status_message, status_message, MAX_STATUS_MSG, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void display_device_info(void)",
            "ssize_t update_device_name(const char *new_name)",
            "int format_status_message(const char *status)",
            "int validate_string_input(const char *input)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void display_device_info(void)",
            "ssize_t update_device_name(const char *new_name)",
            "int format_status_message(const char *status)",
            "int validate_string_input(const char *input)",
            "static int __init strings_init(void)",
            "static void __exit strings_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "advanced_string_implementation_validation",
          "name": "Advanced String Implementation with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "string_impl_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\"=== Dynamic String Implementation Test ===\\\\n\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random device names and statuses\\n    const char* device_prefixes[] = {\"sensor\", \"actuator\", \"controller\", \"monitor\"};\\n    const char* statuses[] = {\"active\", \"idle\", \"error\", \"maintenance\", \"ready\"};\\n    \\n    int device_idx = rand() % 4;\\n    int device_num = (rand() % 100) + 1;\\n    int status_idx = rand() % 5;\\n    \\n    char device_name[32];\\n    snprintf(device_name, sizeof(device_name), \"%s_%03d\", device_prefixes[device_idx], device_num);\\n    \\n    printf(\"Test 1: Device name '%s' with status '%s'\\\\n\", device_name, statuses[status_idx]);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \"insmod /lib/modules/strings.ko device_name=%s status_message=%s\", device_name, statuses[status_idx]);\\n    system(\"rmmod strings 2>/dev/null\");\\n    system(cmd1);\\n    \\n    // Second test with different values\\n    device_idx = rand() % 4;\\n    device_num = (rand() % 100) + 1;\\n    status_idx = rand() % 5;\\n    snprintf(device_name, sizeof(device_name), \"%s_%03d\", device_prefixes[device_idx], device_num);\\n    \\n    printf(\"Test 2: Device name '%s' with status '%s'\\\\n\", device_name, statuses[status_idx]);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \"insmod /lib/modules/strings.ko device_name=%s status_message=%s\", device_name, statuses[status_idx]);\\n    system(\"rmmod strings\");\\n    system(cmd2);\\n    \\n    printf(\"SUCCESS: Dynamic string test completed\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced string implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo '#define KERN_WARNING' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param_string(name, string, len, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef long ssize_t;' > /tmp/linux/types.h",
              "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
              "echo 'ssize_t strscpy(char *dest, const char *src, size_t count);' > /tmp/linux/string.h",
              "echo 'int snprintf(char *buf, size_t size, const char *fmt, ...);' >> /tmp/linux/string.h",
              "echo 'size_t strlen(const char *s);' >> /tmp/linux/string.h",
              "echo '#define EINVAL 22' > /tmp/linux/errno.h",
              "echo '#define E2BIG 7' >> /tmp/linux/errno.h",
              "echo 'Creating test file that includes student header...'",
              "echo '#include \"/lib/modules/strings.h\"' > /tmp/test.c",
              "echo 'int main() { display_device_info(); update_device_name(\"test\"); format_status_message(\"active\"); validate_string_input(\"input\"); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: All function declarations found in header file'",
              "echo 'Phase 2: Dynamic String Implementation Testing'",
              "/bin/string_impl_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Dynamic Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "TEST1_LINE=$(grep 'Test 1: Device name' /tmp/test_output.log)",
              "TEST2_LINE=$(grep 'Test 2: Device name' /tmp/test_output.log)",
              "echo 'Test 1 values: '$TEST1_LINE",
              "echo 'Test 2 values: '$TEST2_LINE",
              "echo 'Validating string operation output'",
              "dmesg | grep 'Secure string handling module loaded' && echo 'PASS: Module loaded correctly' || echo 'FAIL: Module loading issue'",
              "dmesg | grep 'Device:.*Length:' && echo 'PASS: Device info display working' || echo 'FAIL: Device info display broken'",
              "dmesg | grep 'Status:' && echo 'PASS: Status message working' || echo 'FAIL: Status message broken'",
              "dmesg | grep 'Device name updated successfully' && echo 'PASS: String update working' || echo 'FAIL: String update broken'",
              "echo 'All dynamic string validations completed'"
            ],
            "expected": {
              "dmesg": [
                "Secure string handling module loaded",
                "Device: .* \\(Length: .*\\)",
                "Status: .*",
                "Device name updated successfully"
              ],
              "stdout": [
                "PASS: All function declarations found in header file",
                "SUCCESS: Dynamic string test completed",
                "PASS: Module loaded correctly",
                "PASS: Device info display working",
                "PASS: Status message working",
                "PASS: String update working"
              ]
            },
            "timeout": 35
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Secure string handling module loaded",
        "Device: sensor_001 (Length: 10)",
        "Status: initializing",
        "Device name updated successfully",
        "Device: updated_sensor (Length: 14)",
        "Status: Device updated_sensor is active"
      ],
      "requirements": [
        "Use required function names: strings_init, strings_exit, display_device_info, update_device_name, format_status_message, validate_string_input",
        "Use required variable names: device_name, status_message, name_length",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h, linux/string.h",
        "Code must contain: #define MAX_DEVICE_NAME 32, #define MAX_STATUS_MSG 64, extern char device_name[MAX_DEVICE_NAME], extern char status_message[MAX_STATUS_MSG], module_param_string(device_name, device_name, MAX_DEVICE_NAME, 0644), module_param_string(status_message, status_message, MAX_STATUS_MSG, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ]
    }
  },
  {
    "id": 80,
    "title": "Simple Driver - File Creation Challenge",
    "difficulty": 5,
    "xp": 60,
    "phase": "drivers",
    "description": "Create a simple kernel driver by implementing missing files. You are given a partial driver structure and need to create the missing source and header files to complete the driver implementation.",
    "concepts": [
      "file creation",
      "multi-file architecture",
      "character devices",
      "device operations",
      "kernel module structure"
    ],
    "skills": [
      "Creating header files",
      "Implementing device operations",
      "Character device management",
      "Resource management",
      "Multi-file project organization"
    ],
    "files": [
      {
        "name": "driver_main.c",
        "content": "#include \"driver_main.h\"\n#include \"device_ops.h\"\n\n/* Main driver structure */\nstruct simple_driver_data *driver_data = NULL;\n\nstatic int __init simple_driver_init(void)\n{\n    int result;\n    \n    pr_info(\"simple_driver: initializing\\n\");\n    \n    /* TODO: Allocate driver data structure */\n    driver_data = kzalloc(sizeof(struct simple_driver_data), GFP_KERNEL);\n    if (!driver_data) {\n        pr_err(\"simple_driver: failed to allocate driver data\\n\");\n        return -ENOMEM;\n    }\n    \n    /* TODO: Initialize the device */\n    result = device_init(driver_data);\n    if (result < 0) {\n        pr_err(\"simple_driver: device initialization failed\\n\");\n        kfree(driver_data);\n        return result;\n    }\n    \n    pr_info(\"simple_driver: loaded successfully\\n\");\n    return 0;\n}\n\nstatic void __exit simple_driver_exit(void)\n{\n    pr_info(\"simple_driver: unloading\\n\");\n    \n    if (driver_data) {\n        /* TODO: Clean up the device */\n        device_cleanup(driver_data);\n        kfree(driver_data);\n    }\n    \n    pr_info(\"simple_driver: unloaded\\n\");\n}\n\nmodule_init(simple_driver_init);\nmodule_exit(simple_driver_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Simple Driver Creation Challenge\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "driver_main.h",
        "content": "#ifndef DRIVER_MAIN_H\n#define DRIVER_MAIN_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n#define DRIVER_NAME \"simple_driver\"\n#define DEVICE_NAME \"simpledev\"\n#define CLASS_NAME \"simple_class\"\n\n/* Driver data structure */\nstruct simple_driver_data {\n    dev_t device_number;\n    struct cdev cdev;\n    struct class *device_class;\n    struct device *device_struct;\n    char *buffer;\n    size_t buffer_size;\n};\n\n/* Global driver data */\nextern struct simple_driver_data *driver_data;\n\n#endif /* DRIVER_MAIN_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "Makefile",
        "content": "# Simple driver Makefile\nobj-m += simple_driver.o\n\n# Object files that make up this module\nsimple_driver-objs := driver_main.o device_ops.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "driver_main.c",
    "requiredFiles": [
      {
        "name": "device_ops.h",
        "description": "Header file containing device operation declarations",
        "hints": [
          "Should include function declarations for device_init() and device_cleanup()",
          "Should include any necessary includes for device operations",
          "Should define any constants needed for device operations"
        ]
      },
      {
        "name": "device_ops.c",
        "description": "Implementation file containing device operations",
        "hints": [
          "Should implement device_init() function that sets up character device",
          "Should implement device_cleanup() function that cleans up resources",
          "Should include file operations structure with basic read/write functions"
        ]
      }
    ],
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "device_init",
          "device_cleanup",
          "simple_driver_init",
          "simple_driver_exit"
        ],
        "variables": [],
        "outputMessages": [
          "simple_driver: loaded successfully",
          "simple_driver: unloaded"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/fs.h",
          "linux/cdev.h"
        ],
        "mustContain": [
          "alloc_chrdev_region",
          "cdev_init",
          "cdev_add",
          "class_create",
          "device_create"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int device_init(struct simple_driver_data *driver_data)",
            "void device_cleanup(struct simple_driver_data *driver_data)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int device_init(struct simple_driver_data *driver_data)",
            "void device_cleanup(struct simple_driver_data *driver_data)",
            "static int __init simple_driver_init(void)",
            "static void __exit simple_driver_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "driver_functionality",
          "name": "Driver Functionality Test",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "device_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <fcntl.h>\\n#include <unistd.h>\\n#include <string.h>\\n\\n#define DEVICE_PATH \"/dev/simpledev\"\\n\\nint main() {\\n    int fd;\\n    char buffer[256];\\n    ssize_t bytes;\\n    \\n    printf(\"=== Simple Driver Test ===\\\\n\");\\n    \\n    fd = open(DEVICE_PATH, O_RDWR);\\n    if (fd < 0) {\\n        printf(\"INFO: Device not found (this is expected in basic test)\\\\n\");\\n        return 0;\\n    }\\n    \\n    printf(\"SUCCESS: Device opened\\\\n\");\\n    \\n    bytes = write(fd, \"test\", 4);\\n    if (bytes > 0) {\\n        printf(\"SUCCESS: Written %zd bytes\\\\n\", bytes);\\n    }\\n    \\n    close(fd);\\n    printf(\"SUCCESS: Driver test completed\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Setting up simple driver test'",
              "mkdir -p /dev"
            ],
            "testCommands": [
              "echo 'Creating device node...'",
              "major=$(grep simpledev /proc/devices | cut -d' ' -f1)",
              "if [ -z \"$major\" ]; then echo 'ERROR: simpledev not found'; exit 1; fi",
              "mknod /dev/simpledev c $major 0",
              "chmod 666 /dev/simpledev",
              "echo 'Running driver test'",
              "/bin/device_tester",
              "echo 'Checking driver registration'",
              "grep simple_driver /proc/modules 2>/dev/null || echo 'Driver loaded successfully'"
            ],
            "expected": {
              "dmesg": [
                "simple_driver.*loaded successfully",
                "simple_driver.*unloaded"
              ],
              "stdout": [
                "Simple Driver Test",
                "SUCCESS: Driver test completed"
              ]
            },
            "timeout": 30
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "simple_driver: loaded successfully",
        "simple_driver: unloaded"
      ],
      "requirements": [
        "Use required function names: device_init, device_cleanup, simple_driver_init, simple_driver_exit",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/fs.h, linux/cdev.h",
        "Code must contain: alloc_chrdev_region, cdev_init, cdev_add, class_create, device_create",
        "Must include MODULE_LICENSE(\"GPL\")",
        "Test Environment: Create missing device operation files to complete the driver",
        "Userspace Test: Basic device testing will be performed automatically",
        "Test Setup: Create device_ops.h with function declarations",
        "Test Setup: Create device_ops.c with complete implementation",
        "Test Setup: Ensure all required kernel APIs are used"
      ]
    }
  }
];

export default problemBank;
