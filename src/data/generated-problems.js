// Auto-generated from problems/ directory
// DO NOT EDIT THIS FILE DIRECTLY - Edit problems/*.json instead
// Generated at: 2025-11-16T19:23:16.789Z

const problemBank = [
  {
    "id": 1,
    "title": "Hello World - Your First Kernel Module",
    "difficulty": 1,
    "xp": 10,
    "phase": "foundations",
    "description": "Welcome to kernel programming! Create your very first kernel module - a simple \"Hello World\" program that runs inside the Linux kernel. This introduction uses just one file to keep things simple and help you understand the basics before moving to more advanced topics.",
    "concepts": [
      "kernel modules",
      "printk function",
      "module_init and module_exit",
      "basic kernel programming",
      "module lifecycle"
    ],
    "skills": [
      "Understanding kernel vs userspace",
      "Using printk for kernel output",
      "Creating init and exit functions",
      "Basic module structure",
      "Kernel module compilation"
    ],
    "files": [
      {
        "name": "hello.c",
        "content": "/* WELCOME TO KERNEL PROGRAMMING!\n *\n * What is this program?\n * - This is a \"kernel module\" - code that runs inside the Linux operating system\n * - Think of it like adding a small program to your computer's core brain\n * - When you load this module, it will print a message you can see with 'dmesg'\n * \n * Don't worry if you don't understand everything - just follow the TODOs!\n * Programming is learned by doing, step by step.\n */\n\n#include <linux/module.h>    /* For all kernel modules */\n#include <linux/kernel.h>    /* For printk() function */\n#include <linux/init.h>      /* For __init and __exit macros */\n\n/* TODO: Create the init function */\n/* This function runs when the module is loaded into memory */\n/* 'static' means only this file can use this function */\n/* 'int' means this function returns a number (0 = success) */\nstatic int __init hello_init(void)\n{\n    /* TODO: Print \"Hello World from kernel!\" using printk */\n    /* printk is like printf, but for kernel messages */\n    /* KERN_INFO means \"information level\" message */\n    /* \\n means \"new line\" (like pressing Enter) */\n    /* Use: printk(KERN_INFO \"Your message here\\n\"); */\n    \n    return 0;  /* Return 0 means \"success, everything worked!\" */\n}\n\n/* TODO: Create the exit function */\n/* This function runs when the module is unloaded from memory */\n/* 'void' means this function doesn't return anything */\nstatic void __exit hello_exit(void)\n{\n    /* TODO: Print \"Goodbye from kernel!\" using printk */\n    /* This lets us know the module was unloaded successfully */\n    /* Use: printk(KERN_INFO \"Your message here\\n\"); */\n}\n\n/* These lines tell the kernel which functions to call */\n/* They register your functions with the kernel */\nmodule_init(hello_init);   /* This registers the init function */\nmodule_exit(hello_exit);   /* This registers the exit function */\n\n/* Module information - these are required by the kernel */\n/* Think of these like a \"name tag\" for your module */\nMODULE_LICENSE(\"GPL\");     /* GPL is a common open source license */\nMODULE_AUTHOR(\"Student\");   /* That's you! */\nMODULE_DESCRIPTION(\"My first kernel module - Hello World\");\nMODULE_VERSION(\"1.0\");     /* Version 1.0 - your first try! */",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Simple Makefile for hello world kernel module\nobj-m += hello.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      },
      {
        "name": "BEGINNER_GUIDE.md",
        "content": "# Beginner's Guide to Your First Kernel Module\n\n## What You're Going to Do\n\nYou're going to write your first kernel module - a simple \"Hello World\" program that runs inside the Linux kernel. Your task is straightforward: add two print statements to the code.\n\nDon't worry if you've never programmed before. This guide gives you exactly what you need to complete this task. You can learn the deeper concepts later.\n\n---\n\n## Your Task: Add Two Lines of Code\n\nYou need to add printk statements in two places:\n\n**Step 1: Add printk to hello_init**\n\nFind this section in hello.c:\n\n```c\nstatic int __init hello_init(void)\n{\n    /* TODO: Print \"Hello World from kernel!\" using printk */\n    \n    return 0;\n}\n```\n\nAdd this line where the TODO is:\n\n```c\nprintk(KERN_INFO \"Hello World from kernel!\\n\");\n```\n\nSo it becomes:\n\n```c\nstatic int __init hello_init(void)\n{\n    printk(KERN_INFO \"Hello World from kernel!\\n\");\n    \n    return 0;\n}\n```\n\n**Step 2: Add printk to hello_exit**\n\nFind this section:\n\n```c\nstatic void __exit hello_exit(void)\n{\n    /* TODO: Print \"Goodbye from kernel!\" using printk */\n}\n```\n\nAdd this line where the TODO is:\n\n```c\nprintk(KERN_INFO \"Goodbye from kernel!\\n\");\n```\n\nSo it becomes:\n\n```c\nstatic void __exit hello_exit(void)\n{\n    printk(KERN_INFO \"Goodbye from kernel!\\n\");\n}\n```\n\n**Important: Type the messages exactly as shown**\n\n- \"Hello World from kernel!\" (exactly this text)\n- \"Goodbye from kernel!\" (exactly this text)\n- Include the `\\n` at the end (this means \"new line\")\n- Don't forget the semicolon `;` at the end\n\n---\n\n## Essential Syntax Rules\n\nWhen writing C code, you need to follow these rules:\n\n**Every statement ends with a semicolon**\n```c\nprintk(KERN_INFO \"Hello\\n\");  // Correct\nprintk(KERN_INFO \"Hello\\n\")   // Wrong - missing semicolon\n```\n\n**Text must be in quotes**\n```c\nprintk(KERN_INFO \"Hello\\n\");  // Correct\nprintk(KERN_INFO Hello\\n);     // Wrong - no quotes\n```\n\n**Spelling must be exact**\n```c\nprintk(KERN_INFO \"Hello\\n\");  // Correct\nprintf(KERN_INFO \"Hello\\n\");   // Wrong - it's printk not printf\n```\n\n---\n\n## What is printk?\n\nprintk is a function that prints messages from kernel code. It's similar to printf in regular C programs, but it works inside the Linux kernel.\n\nWhen you use printk, the message goes to the kernel log. You can see these messages using the dmesg command.\n\n**Format:**\n```c\nprintk(KERN_INFO \"Your message here\\n\");\n```\n\n- KERN_INFO means \"this is an informational message\"\n- The text in quotes is what gets printed\n- `\\n` creates a new line (like pressing Enter)\n\n---\n\n## Common Mistakes\n\nHere are the most common errors beginners make:\n\n**Mistake 1: Forgot the semicolon**\n```c\nprintk(KERN_INFO \"Hello\\n\")   // Missing semicolon - will not compile\n```\n\n**Mistake 2: Forgot the quotes around the message**\n```c\nprintk(KERN_INFO Hello\\n);     // Missing quotes - will not compile\n```\n\n**Mistake 3: Typo in the message**\n```c\nprintk(KERN_INFO \"Hello World form kernel!\\n\");  // \"form\" instead of \"from\"\n```\nThe message must match exactly: \"Hello World from kernel!\"\n\n**Mistake 4: Forgot the newline at the end**\n```c\nprintk(KERN_INFO \"Hello World from kernel!\");  // Missing \\n\n```\nAlways include `\\n` to create a new line.\n\n---\n\n## What Happens When You Run It\n\nWhen you submit your code:\n\n1. The system compiles your code into a kernel module file (hello.ko)\n2. The module is loaded into the kernel (like installing a plugin)\n3. Your hello_init() function runs automatically\n4. You see \"Hello World from kernel!\" in the kernel log\n5. The module is unloaded from the kernel\n6. Your hello_exit() function runs automatically\n7. You see \"Goodbye from kernel!\" in the kernel log\n\nThe test checks that both messages appear in the correct format.\n\n---\n\n## Quick Reference\n\n**What you need to add:**\n\nIn hello_init:\n```c\nprintk(KERN_INFO \"Hello World from kernel!\\n\");\n```\n\nIn hello_exit:\n```c\nprintk(KERN_INFO \"Goodbye from kernel!\\n\");\n```\n\n**Remember:**\n- Semicolon at the end\n- Text in quotes\n- Exact spelling\n- Include newline at the end\n\n---\n\n## Understanding Functions\n\n**What is a Function?**\n\nA function is a named block of code that performs a specific task. Think of it like a recipe - it has a name and a list of instructions.\n\nReal-world analogy:\n```\nFunction name: \"Make Coffee\"\nSteps:\n  1. Boil water\n  2. Add coffee grounds\n  3. Pour water\n  4. Wait 5 minutes\n```\n\nIn C:\n```c\nFunction name: hello_init\nSteps:\n{\n    printk(KERN_INFO \"Hello World from kernel!\\n\");\n    return 0;\n}\n```\n\n**Function Structure**\n\nLet's break down a function:\n\n```c\nstatic int __init hello_init(void)\n{\n    printk(KERN_INFO \"Hello World from kernel!\\n\");\n    return 0;\n}\n```\n\nParts:\n- `static` - This function is private to this file\n- `int` - This function returns an integer (whole number)\n- `__init` - Special kernel marker meaning \"runs at initialization\"\n- `hello_init` - The name of the function\n- `(void)` - This function takes no input parameters\n- `{ ... }` - The body of the function (the actual code)\n- `return 0;` - Return 0 to indicate success\n\n**What Does void Mean?**\n\nvoid means \"nothing\" or \"empty\".\n\nTwo ways you'll see it:\n\nFunction takes no input:\n```c\nstatic int hello_init(void)  // Takes nothing as input\n```\n\nFunction returns nothing:\n```c\nstatic void hello_exit(void)  // Returns nothing\n```\n\nThink of void as saying \"there's nothing here\".\n\n---\n\n## Understanding the Kernel\n\n**What is the Kernel?**\n\nThe kernel is the core of the operating system. It's the boss that controls everything in your computer.\n\nComputer layers:\n```\n    ┌──────────────────────────────┐\n    │  Applications (Browser, etc) │  <- User level\n    ├──────────────────────────────┤\n    │  Operating System (Linux)    │  <- System level\n    ├──────────────────────────────┤\n    │  KERNEL (The Boss)           │  <- We're here\n    ├──────────────────────────────┤\n    │  Hardware (CPU, Memory)      │  <- Physical level\n    └──────────────────────────────┘\n```\n\nWhat the kernel does:\n- Controls hardware (CPU, memory, disk, network)\n- Manages running programs\n- Handles files and security\n- Decides which programs get resources\n\n**What is a Kernel Module?**\n\nA kernel module is code you can add to the kernel without restarting the computer. It's like a plugin or extension.\n\nWhy kernel modules are useful:\n- Add features to the kernel dynamically\n- Load drivers for hardware\n- Extend kernel functionality\n- Can be loaded and unloaded on demand\n\nYour hello module:\n- Loads into the kernel\n- Prints a message\n- Unloads cleanly\n\n---\n\n## Understanding Your Code Line-by-Line\n\n**The Include Statements**\n\n```c\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n```\n\nWhat is include?\n\ninclude tells the compiler to \"include code from another file\". Think of it like saying \"before you start, read these instruction manuals first.\"\n\nWhy we need these:\n- `<linux/module.h>` - Definitions for creating kernel modules\n- `<linux/kernel.h>` - Contains printk and other kernel functions\n- `<linux/init.h>` - Contains __init and __exit markers\n\n**The Init Function**\n\n```c\nstatic int __init hello_init(void)\n{\n    printk(KERN_INFO \"Hello World from kernel!\\n\");\n    return 0;\n}\n```\n\nWhen does this run?\n\nThis function runs once when the module is loaded into the kernel.\n\nWhat does it do?\n- Prints \"Hello World from kernel!\" to the kernel log\n- Returns 0 to indicate success\n\nWhy return 0?\n\nIn kernel programming:\n- 0 means \"success, everything is OK\"\n- Non-zero means \"error, something went wrong\"\n\n**The Exit Function**\n\n```c\nstatic void __exit hello_exit(void)\n{\n    printk(KERN_INFO \"Goodbye from kernel!\\n\");\n}\n```\n\nWhen does this run?\n\nThis function runs once when the module is unloaded from the kernel.\n\nWhat does it do?\n- Prints \"Goodbye from kernel!\" to the kernel log\n- Cleans up before the module is removed\n\nWhy no return?\n\nThe function is void, meaning it doesn't return a value. Exit functions don't need to return success/failure.\n\n**Registering Your Functions**\n\n```c\nmodule_init(hello_init);\nmodule_exit(hello_exit);\n```\n\nWhat do these do?\n\nThese lines tell the kernel:\n- \"When someone loads this module, call hello_init\"\n- \"When someone unloads this module, call hello_exit\"\n\nWithout these lines, the kernel wouldn't know which functions to call.\n\n**Module Metadata**\n\n```c\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"My first kernel module - Hello World\");\nMODULE_VERSION(\"1.0\");\n```\n\nWhat are these?\n\nThese are information tags about your module. Think of them like a business card.\n\nEach line:\n- `MODULE_LICENSE(\"GPL\")` - The software license (GPL = open source). Required!\n- `MODULE_AUTHOR(\"Student\")` - Your name\n- `MODULE_DESCRIPTION(...)` - What the module does\n- `MODULE_VERSION(\"1.0\")` - Version number\n\nThe license is required - the kernel won't load modules without it.\n\n---\n\n## The Module Lifecycle\n\nHere's what happens step by step:\n\n**Loading the Module**\n\n```\n1. You run: insmod hello.ko\n   |\n   v\n2. Kernel receives the module file\n   |\n   v\n3. Kernel loads it into memory\n   |\n   v\n4. Kernel looks for module_init()\n   |\n   v\n5. Kernel calls hello_init()\n   |\n   v\n6. hello_init() runs:\n   - printk(\"Hello World from kernel!\\n\")\n   - returns 0\n   |\n   v\n7. Module is now loaded and active\n```\n\n**Unloading the Module**\n\n```\n1. You run: rmmod hello\n   |\n   v\n2. Kernel looks for module_exit()\n   |\n   v\n3. Kernel calls hello_exit()\n   |\n   v\n4. hello_exit() runs:\n   - printk(\"Goodbye from kernel!\\n\")\n   |\n   v\n5. Kernel removes module from memory\n   |\n   v\n6. Module is unloaded\n```\n\n---\n\n## Understanding printk Levels\n\nprintk has different \"levels\" to indicate how important a message is:\n\n```c\nKERN_EMERG   // Emergency - system is unusable\nKERN_ALERT   // Alert - action must be taken immediately\nKERN_CRIT    // Critical condition\nKERN_ERR     // Error condition\nKERN_WARNING // Warning condition\nKERN_NOTICE  // Normal but significant\nKERN_INFO    // Informational (we use this one)\nKERN_DEBUG   // Debug-level messages\n```\n\nWhy levels matter:\n\nThe kernel can filter messages by level. For example, you might want to see only errors and warnings, not informational messages.\n\nFor our hello world:\n\nWe use KERN_INFO because our messages are just informational - we're not reporting an error or warning.\n\n---\n\n## Glossary\n\n**C** - A programming language used for system programming\n\n**Compiler** - A program that translates your C code into machine code the computer can run\n\n**Function** - A named block of code that performs a specific task\n\n**Kernel** - The core part of the operating system that controls everything\n\n**Module** - Code that can be loaded into and unloaded from the kernel\n\n**printk** - A function that prints messages from kernel code\n\n**Return value** - The value a function gives back when it finishes\n\n**Semicolon** - The character that marks the end of a statement\n\n**Statement** - A single instruction in your code\n\n**String** - Text data (must be in quotes)\n\n**void** - Means \"nothing\" or \"empty\"\n\n---\n\n## Tips for Success\n\n- Type carefully - Spelling must be exact\n- Don't forget semicolons - Every statement needs one\n- Match the messages exactly - \"Hello World from kernel!\" and \"Goodbye from kernel!\"\n- Include the newline - Always end messages with `\\n`\n- Check your quotes - Text must be in double quotes\n\n---\n\n## You're Ready!\n\nYou now have everything you need to complete this exercise. Remember:\n\n1. Add `printk(KERN_INFO \"Hello World from kernel!\\n\");` to hello_init\n2. Add `printk(KERN_INFO \"Goodbye from kernel!\\n\");` to hello_exit\n3. Make sure you have semicolons and quotes\n4. Submit and run the tests\n\nDon't worry if you make mistakes - that's how everyone learns. The error messages will help you fix any problems.\n\nWelcome to kernel programming!\n",
        "readOnly": true,
        "language": "txt"
      }
    ],
    "mainFile": "hello.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "hello_init",
          "hello_exit"
        ],
        "outputMessages": [
          "Hello World from kernel!",
          "Goodbye from kernel!"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h"
        ],
        "mustContain": [
          "printk",
          "KERN_INFO"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "static int __init hello_init(void)",
            "static void __exit hello_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "kernel_functionality_test",
          "name": "Kernel Module Functionality Test",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "hello_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\\\"=== Hello World Module Test ===\\\\n\\\");\\n    \\n    printf(\\\"Test: Loading hello module...\\\\n\\\");\\n    system(\\\"insmod /lib/modules/hello.ko\\\");\\n    \\n    printf(\\\"Test: Unloading hello module...\\\\n\\\");\\n    system(\\\"rmmod hello\\\");\\n    \\n    printf(\\\"SUCCESS: Module load/unload completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "testCommands": [
              "echo 'Testing kernel module compilation and basic functionality...'",
              "/bin/hello_tester",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Checking for kernel logging functionality...'",
              "dmesg | grep 'Hello World from kernel' && echo 'PASS: init function logging working' || echo 'FAIL: init function logging missing'",
              "dmesg | grep 'Goodbye from kernel' && echo 'PASS: exit function logging working' || echo 'FAIL: exit function logging missing'",
              "echo 'PASS: All kernel functionality tests completed'"
            ],
            "expected": {
              "dmesg": [
                "Hello World from kernel!",
                "Goodbye from kernel!"
              ],
              "stdout": [
                "Hello World Module Test",
                "SUCCESS: Module load/unload completed",
                "PASS: All kernel functionality tests completed"
              ]
            },
            "timeout": 10
          }
        },
        {
          "id": "exact_output",
          "name": "Function-Linked Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Hello World from kernel!",
              "exact": true,
              "linkedFunction": "static int __init hello_init(void)"
            },
            {
              "pattern": "Goodbye from kernel!",
              "exact": true,
              "linkedFunction": "static void __exit hello_exit(void)"
            }
          ]
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Hello World from kernel!",
        "Goodbye from kernel!"
      ],
      "requirements": [
        "Use required function names: hello_init, hello_exit",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h",
        "Code must contain: printk, KERN_INFO",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Hello World from kernel!",
          "linkedFunction": "static int __init hello_init(void)",
          "exact": true
        },
        {
          "pattern": "Goodbye from kernel!",
          "linkedFunction": "static void __exit hello_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 2,
    "title": "Hello World - Multi-File Kernel Module",
    "difficulty": 1,
    "xp": 15,
    "phase": "foundations",
    "description": "Create your first multi-file kernel module with a separate header file. This introduces you to kernel module structure with proper file organization. Note: Module init/exit functions are static and don't need header declarations.",
    "concepts": [
      "multi-file modules",
      "header files",
      "module_init",
      "module_exit",
      "printk",
      "Makefile"
    ],
    "skills": [
      "Header file creation",
      "File organization",
      "Module lifecycle",
      "Kernel logging",
      "Build system understanding"
    ],
    "files": [
      {
        "name": "hello.h",
        "content": "#ifndef HELLO_H\n#define HELLO_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n/* TODO: Add any shared constants or structures here */\n/* Note: Module init/exit functions are static and don't need declarations */\n\n#endif /* HELLO_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "hello.c",
        "content": "#include \"hello.h\"\n\n/* TODO: Implement your init function */\nstatic int __init hello_init(void)\n{\n    /* TODO: Print \"Hello from multi-file kernel module!\" */\n    return 0;\n}\n\n/* TODO: Implement your exit function */\nstatic void __exit hello_exit(void)\n{\n    /* TODO: Print \"Goodbye from multi-file kernel module!\" */\n}\n\n/* TODO: Set module init and exit functions */\nmodule_init(hello_init);\nmodule_exit(hello_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Multi-file Hello World kernel module\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Multi-file kernel module Makefile\nobj-m += hello.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "hello.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "hello_init",
          "hello_exit"
        ],
        "outputMessages": [
          "Hello from multi-file kernel module!",
          "Goodbye from multi-file kernel module!"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h"
        ],
        "mustContain": [
          "printk",
          "KERN_INFO"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "header_structure",
          "name": "Header File Structure",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "#ifndef HELLO_H",
            "#define HELLO_H",
            "#endif"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [],
          "prohibitedSymbols": [
            "static.*hello_init",
            "static.*hello_exit"
          ]
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "static int __init hello_init(void)",
            "static void __exit hello_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "multifile_functionality_test",
          "name": "Multi-File Module Functionality Test",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "multifile_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\\\"=== Multi-File Module Test ===\\\\n\\\");\\n    \\n    printf(\\\"Test: Loading multi-file hello module...\\\\n\\\");\\n    system(\\\"insmod /lib/modules/hello.ko\\\");\\n    \\n    printf(\\\"Test: Unloading multi-file hello module...\\\\n\\\");\\n    system(\\\"rmmod hello\\\");\\n    \\n    printf(\\\"SUCCESS: Multi-file module load/unload completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "testCommands": [
              "echo 'Testing multi-file kernel module functionality...'",
              "/bin/multifile_tester",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Checking for module information and functionality...'",
              "dmesg | grep 'Hello from multi-file kernel module' && echo 'PASS: init function with proper message' || echo 'FAIL: init function message missing'",
              "dmesg | grep 'Goodbye from multi-file kernel module' && echo 'PASS: exit function with proper message' || echo 'FAIL: exit function message missing'",
              "echo 'PASS: All multi-file functionality tests completed'"
            ],
            "expected": {
              "dmesg": [
                "Hello from multi-file kernel module!",
                "Goodbye from multi-file kernel module!"
              ],
              "stdout": [
                "Multi-File Module Test",
                "SUCCESS: Multi-file module load/unload completed",
                "PASS: All multi-file functionality tests completed"
              ]
            },
            "timeout": 10
          }
        },
        {
          "id": "exact_output",
          "name": "Function-Linked Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Hello from multi-file kernel module!",
              "exact": true,
              "linkedFunction": "static int __init hello_init(void)"
            },
            {
              "pattern": "Goodbye from multi-file kernel module!",
              "exact": true,
              "linkedFunction": "static void __exit hello_exit(void)"
            }
          ]
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Hello from multi-file kernel module!",
        "Goodbye from multi-file kernel module!"
      ],
      "requirements": [
        "Use required function names: hello_init, hello_exit",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h",
        "Code must contain: printk, KERN_INFO",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Hello from multi-file kernel module!",
          "linkedFunction": "static int __init hello_init(void)",
          "exact": true
        },
        {
          "pattern": "Goodbye from multi-file kernel module!",
          "linkedFunction": "static void __exit hello_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 3,
    "title": "Create Your First Variable",
    "difficulty": 1,
    "xp": 15,
    "phase": "foundations",
    "description": "Learn to create variables in kernel modules using proper file structure. You'll work with separate header and C files - a fundamental practice in professional kernel development that builds good coding habits from day one.",
    "concepts": [
      "variable declaration",
      "variable definition",
      "header files",
      "extern keyword",
      "file structure"
    ],
    "skills": [
      "Proper file organization",
      "Header/C file separation",
      "Variable management",
      "Professional coding habits"
    ],
    "files": [
      {
        "name": "variables.h",
        "content": "#ifndef VARIABLES_H\n#define VARIABLES_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n/* TODO: Declare your variable here */\n/* extern int my_number; */\n\n#endif /* VARIABLES_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "variables.c",
        "content": "#include \"variables.h\"\n\n/* TODO: Define your variable here with value 42 */\n/* int my_number = 42; */\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your variable is declared correctly.\n * Removing them will cause test failures.\n */\nmodule_param(my_number, int, 0644);\nMODULE_PARM_DESC(my_number, \"Variable for testing proper declaration\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\nstatic int __init variables_init(void)\n{\n    printk(KERN_INFO \"Variables module loaded\\n\");\n    /* TODO: Print the variable value to show it exists */\n    /* printk(KERN_INFO \"Variable value: %d\\n\", my_number); */\n    return 0;\n}\n\nstatic void __exit variables_exit(void)\n{\n    printk(KERN_INFO \"Variables module unloaded\\n\");\n}\n\nmodule_init(variables_init);\nmodule_exit(variables_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning variables with proper file structure\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Variables module Makefile\nobj-m += variables.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "variables.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "variables_init",
          "variables_exit"
        ],
        "variables_declarations": [
          {
            "name": "my_number",
            "type": "int",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "my_number",
            "type": "int",
            "value": 42,
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Variables module loaded"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h"
        ],
        "mustContain": [
          "#ifndef VARIABLES_H",
          "#define VARIABLES_H",
          "extern int my_number",
          "int my_number = 42",
          "#include \"variables.h\""
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "header_guards",
          "name": "Proper Header Guards",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "#ifndef VARIABLES_H",
            "#define VARIABLES_H",
            "#endif"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "variable_declaration",
          "name": "Variable Declaration in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "extern int my_number"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "variable_definition",
          "name": "Variable Definition in C File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int my_number = 42"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "static int __init variables_init(void)",
            "static void __exit variables_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "variable_functionality_test",
          "name": "Variable Declaration and Definition Test",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "variable_param_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Variable Parameter Validation Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random test values\\n    int test_val1 = (rand() % 50) + 10;  // 10-59\\n    int test_val2 = (rand() % 50) + 60;  // 60-109\\n    \\n    printf(\\\"Test 1: Loading with my_number=%d\\\\n\\\", test_val1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/variables.ko my_number=%d\\\", test_val1);\\n    system(\\\"rmmod variables 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Loading with my_number=%d\\\\n\\\", test_val2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/variables.ko my_number=%d\\\", test_val2);\\n    system(\\\"rmmod variables\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Variable parameter test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo 'Creating test file that validates extern variable declaration...'",
              "echo '#include \"/lib/modules/variables.h\"' > /tmp/test.c",
              "echo 'int main() { my_number = 42; return my_number; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: extern int my_number not properly declared in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: extern int my_number found in header file'",
              "echo 'Phase 2: Dynamic Parameter Testing'",
              "/bin/variable_param_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Phase 2.1: Variable parameter extraction...'",
              "TEST_VAL1=$(grep -o 'Test 1: Loading with my_number=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
              "TEST_VAL2=$(grep -o 'Test 2: Loading with my_number=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
              "echo 'Test value 1: '$TEST_VAL1",
              "echo 'Test value 2: '$TEST_VAL2",
              "echo 'Phase 2.2: Module parameter validation...'",
              "dmesg | grep 'Variables module loaded' && echo 'PASS: Module loads with parameter' || echo 'FAIL: Module loading failed'",
              "echo 'Phase 3: Default value validation (must be 42)...'",
              "rmmod variables 2>/dev/null",
              "insmod /lib/modules/variables.ko",
              "sleep 1",
              "DEFAULT_VALUE=$(cat /sys/module/variables/parameters/my_number 2>/dev/null || echo 'ERROR')",
              "echo 'Default value from parameter: '$DEFAULT_VALUE",
              "if [ \"$DEFAULT_VALUE\" = \"42\" ]; then",
              "    echo 'PASS: Variable initialized to 42 correctly'",
              "else",
              "    echo 'FAIL: Variable not initialized to 42 (got: '$DEFAULT_VALUE')'",
              "fi",
              "echo 'Phase 4: Value reassignment test (ensuring variable is mutable)...'",
              "echo 99 > /sys/module/variables/parameters/my_number 2>/dev/null",
              "NEW_VALUE=$(cat /sys/module/variables/parameters/my_number 2>/dev/null || echo 'ERROR')",
              "echo 'Value after reassignment: '$NEW_VALUE",
              "if [ \"$NEW_VALUE\" = \"99\" ]; then",
              "    echo 'PASS: Variable is mutable and reassignable'",
              "else",
              "    echo 'FAIL: Variable is not properly mutable (expected 99, got: '$NEW_VALUE')'",
              "fi",
              "echo 'Phase 5: Parameter accessibility validation...'",
              "ls /sys/module/variables/parameters/my_number >/dev/null 2>&1 && echo 'PASS: Variable exposed as module parameter' || echo 'FAIL: Variable not declared as module parameter'",
              "echo 'PASS: All variable validation tests completed'"
            ],
            "expected": {
              "dmesg": [
                "Variables module loaded",
                "Variables module unloaded"
              ],
              "stdout": [
                "PASS: extern int my_number found in header file",
                "Variable Parameter Validation Test",
                "SUCCESS: Variable parameter test completed",
                "PASS: Variable initialized to 42 correctly",
                "PASS: Variable is mutable and reassignable",
                "PASS: All variable validation tests completed"
              ]
            },
            "timeout": 10
          }
        },
        {
          "id": "exact_output",
          "name": "Exact Output Message",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Variables module loaded",
              "exact": true,
              "linkedFunction": "static int __init variables_init(void)"
            }
          ]
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Variables module loaded"
      ],
      "requirements": [
        "Use required function names: variables_init, variables_exit",
        "Use required variable names: my_number",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h",
        "Code must contain: #ifndef VARIABLES_H, #define VARIABLES_H, extern int my_number, int my_number = 42, #include \"variables.h\"",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Variables module loaded",
          "linkedFunction": "static int __init variables_init(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 4,
    "title": "Use Your Variable",
    "difficulty": 2,
    "xp": 20,
    "phase": "foundations",
    "description": "Learn to use variables by printing them with proper format specifiers. Build on your knowledge of header/C file structure while introducing printk formatting - a crucial skill for kernel debugging.",
    "concepts": [
      "variable usage",
      "printk formatting",
      "format specifiers",
      "integer printing",
      "debugging output"
    ],
    "skills": [
      "Using variables in printk",
      "printk with format specifiers",
      "Variable access in kernel modules",
      "Debugging output"
    ],
    "files": [
      {
        "name": "use_vars.h",
        "content": "#ifndef USE_VARS_H\n#define USE_VARS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nextern int my_number;\n\n#endif /* USE_VARS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "use_vars.c",
        "content": "#include \"use_vars.h\"\n\nint my_number = 42;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your variable usage works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(my_number, int, 0644);\nMODULE_PARM_DESC(my_number, \"Number to print for testing variable usage\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\nstatic int __init use_vars_init(void)\n{\n    printk(KERN_INFO \"Variable usage module loaded\\n\");\n    /* TODO: Print the variable using printk */\n    /* printk(KERN_INFO \"My number is: %d\\n\", my_number); */\n    return 0;\n}\n\nstatic void __exit use_vars_exit(void)\n{\n    printk(KERN_INFO \"Variable usage module unloaded\\n\");\n}\n\nmodule_init(use_vars_init);\nmodule_exit(use_vars_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning to use variables with printk formatting\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Variable usage module Makefile\nobj-m += use_vars.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "use_vars.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "use_vars_init",
          "use_vars_exit"
        ],
        "variables_declarations": [
          {
            "name": "my_number",
            "type": "int",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "my_number",
            "type": "int",
            "value": 42,
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Variable usage module loaded",
          "My number is: 42"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h"
        ],
        "mustContain": [
          "printk(KERN_INFO \"My number is: %d\\n\", my_number)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "static int __init use_vars_init(void)",
            "static void __exit use_vars_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "variable_usage_test",
          "name": "Variable Usage and Formatting Test",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "variable_usage_dynamic_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Variable Usage Dynamic Validation Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random test values\\n    int test_val1 = (rand() % 50) + 10;  // 10-59\\n    int test_val2 = (rand() % 50) + 60;  // 60-109\\n    int test_val3 = (rand() % 20) + 1;   // 1-20\\n    \\n    printf(\\\"Test 1: Testing with my_number=%d\\\\n\\\", test_val1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/use_vars.ko my_number=%d\\\", test_val1);\\n    system(\\\"rmmod use_vars 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Testing with my_number=%d\\\\n\\\", test_val2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/use_vars.ko my_number=%d\\\", test_val2);\\n    system(\\\"rmmod use_vars\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"Test 3: Testing with my_number=%d\\\\n\\\", test_val3);\\n    char cmd3[256];\\n    snprintf(cmd3, sizeof(cmd3), \\\"insmod /lib/modules/use_vars.ko my_number=%d\\\", test_val3);\\n    system(\\\"rmmod use_vars\\\");\\n    system(cmd3);\\n    \\n    printf(\\\"SUCCESS: Variable usage dynamic test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo 'Creating test file that validates extern variable declaration...'",
              "echo '#include \"/lib/modules/use_vars.h\"' > /tmp/test.c",
              "echo 'int main() { my_number = 99; return my_number; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: extern int my_number not properly declared in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: extern int my_number found in header file'",
              "echo 'Phase 2: Dynamic Variable Usage Testing'",
              "/bin/variable_usage_dynamic_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Phase 2.1: Dynamic test value extraction...'",
              "TEST_VAL1=$(grep -o 'Test 1: Testing with my_number=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
              "TEST_VAL2=$(grep -o 'Test 2: Testing with my_number=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
              "TEST_VAL3=$(grep -o 'Test 3: Testing with my_number=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
              "echo 'Test values: '$TEST_VAL1', '$TEST_VAL2', '$TEST_VAL3",
              "echo 'Phase 2.2: Basic module functionality check...'",
              "dmesg | grep 'Variable usage module loaded' && echo 'PASS: use_vars_init function working' || echo 'FAIL: use_vars_init function missing'",
              "echo 'Phase 3: Dynamic variable usage validation...'",
              "dmesg | grep \"My number is: $TEST_VAL1\" && echo \"PASS: Variable correctly prints value $TEST_VAL1\" || echo \"FAIL: Variable not used or wrong value (expected $TEST_VAL1)\"",
              "dmesg | grep \"My number is: $TEST_VAL2\" && echo \"PASS: Variable correctly prints value $TEST_VAL2\" || echo \"FAIL: Variable not used or wrong value (expected $TEST_VAL2)\"",
              "dmesg | grep \"My number is: $TEST_VAL3\" && echo \"PASS: Variable correctly prints value $TEST_VAL3\" || echo \"FAIL: Variable not used or wrong value (expected $TEST_VAL3)\"",
              "echo 'Phase 4: Default value validation (must be 42)...'",
              "rmmod use_vars 2>/dev/null",
              "insmod /lib/modules/use_vars.ko",
              "sleep 1",
              "dmesg | grep 'My number is: 42' && echo 'PASS: Default value 42 correctly displayed' || echo 'FAIL: Default value not 42 or not printed'",
              "echo 'Phase 5: Module unload check...'",
              "dmesg | grep 'Variable usage module unloaded' && echo 'PASS: use_vars_exit function working' || echo 'FAIL: use_vars_exit function missing'",
              "echo 'PASS: All variable usage dynamic validation tests completed'"
            ],
            "expected": {
              "dmesg": [
                "Variable usage module loaded",
                "My number is: .*",
                "Variable usage module unloaded"
              ],
              "stdout": [
                "PASS: extern int my_number found in header file",
                "Variable Usage Dynamic Validation Test",
                "SUCCESS: Variable usage dynamic test completed",
                "PASS: Default value 42 correctly displayed",
                "PASS: All variable usage dynamic validation tests completed"
              ]
            },
            "timeout": 10
          }
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Variable usage module loaded",
              "exact": true,
              "linkedFunction": "static int __init use_vars_init(void)"
            },
            {
              "pattern": "My number is: 42",
              "exact": true,
              "linkedFunction": "static int __init use_vars_init(void)"
            }
          ]
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Variable usage module loaded",
        "My number is: 42"
      ],
      "requirements": [
        "Use required function names: use_vars_init, use_vars_exit",
        "Use required variable names: my_number",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h",
        "Code must contain: printk(KERN_INFO \"My number is: %d\\n\", my_number)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Variable usage module loaded",
          "linkedFunction": "static int __init use_vars_init(void)",
          "exact": true
        },
        {
          "pattern": "My number is: 42",
          "linkedFunction": "static int __init use_vars_init(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 5,
    "title": "Multiple Variables - Study Complete Example",
    "difficulty": 2,
    "xp": 25,
    "phase": "foundations",
    "description": "Study a complete working example with multiple data types. See how int, char, and bool variables work together with proper format specifiers. This example includes advanced module parameter support that will be used in later problems.",
    "concepts": [
      "multiple data types",
      "integer variables",
      "character variables",
      "boolean variables",
      "format specifiers for different types"
    ],
    "skills": [
      "Managing multiple variables",
      "Understanding data type differences",
      "Using appropriate format specifiers",
      "Code organization with multiple variables"
    ],
    "files": [
      {
        "name": "multi_vars.h",
        "content": "#ifndef MULTI_VARS_H\n#define MULTI_VARS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* Function to print student information */\nvoid print_student_info(void);\n\n#endif /* MULTI_VARS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "multi_vars.c",
        "content": "#include \"multi_vars.h\"\n\n/* Complete working example\n * Study how these three different data types work together\n * Notice the different format specifiers for each type\n */\n\n/* Variable definitions with different data types */\nint student_id = 12345;      // Integer variable\nchar student_grade = 'A';    // Character variable  \nbool student_passed = true;  // Boolean variable\n\n/* Module parameters for advanced testing */\nmodule_param(student_id, int, 0644);\nMODULE_PARM_DESC(student_id, \"Student ID number\");\n/* Note: char and bool parameters need special handling */\n\n/* Complete function implementation - study the pattern */\nvoid print_student_info(void)\n{\n    printk(KERN_INFO \"=== Student Information ===\\n\");\n    printk(KERN_INFO \"Student ID: %d\\n\", student_id);        // %d for int\n    printk(KERN_INFO \"Student Grade: %c\\n\", student_grade);   // %c for char\n    printk(KERN_INFO \"Student Passed: %d\\n\", student_passed); // %d for bool (shows 0/1)\n}\n\nstatic int __init multi_vars_init(void)\n{\n    printk(KERN_INFO \"Multi-variable module loaded\\n\");\n    print_student_info();\n    return 0;\n}\n\nstatic void __exit multi_vars_exit(void)\n{\n    printk(KERN_INFO \"Multi-variable module unloaded\\n\");\n}\n\nmodule_init(multi_vars_init);\nmodule_exit(multi_vars_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Complete example: multiple variables and data types\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Multi-variable module Makefile\nobj-m += multi_vars.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "multi_vars.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "multi_vars_init",
          "multi_vars_exit",
          "print_student_info"
        ],
        "variables": [
          {
            "name": "student_id",
            "type": "int",
            "value": 12345
          },
          {
            "name": "student_grade",
            "type": "char",
            "value": "'A'"
          },
          {
            "name": "student_passed",
            "type": "bool",
            "value": true
          }
        ],
        "outputMessages": [
          "Multi-variable module loaded",
          "Student ID: 12345",
          "Student Grade: A",
          "Student Passed: 1"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "int student_id = 12345",
          "char student_grade = 'A'",
          "bool student_passed = true",
          "void print_student_info(void)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "multiple_definitions",
          "name": "Multiple Variable Definitions",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int student_id = 12345",
            "char student_grade = 'A'",
            "bool student_passed = true"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_structure",
          "name": "Print Function Implementation",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_student_info(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_student_info(void)",
            "static int __init multi_vars_init(void)",
            "static void __exit multi_vars_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_student_info(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Basic Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Multi-variable module loaded",
              "exact": true,
              "linkedFunction": "static int __init multi_vars_init(void)"
            },
            {
              "pattern": "Student Information",
              "exact": true,
              "linkedFunction": "void print_student_info(void)"
            },
            {
              "pattern": "Student ID: 12345",
              "exact": true,
              "linkedFunction": "void print_student_info(void)"
            },
            {
              "pattern": "Student Grade: A",
              "exact": true,
              "linkedFunction": "void print_student_info(void)"
            },
            {
              "pattern": "Student Passed: 1",
              "exact": true,
              "linkedFunction": "void print_student_info(void)"
            }
          ]
        },
        {
          "id": "demonstration_test",
          "name": "Study Example with Dynamic Testing",
          "type": "kernel_project_test",
          "critical": false,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "demo_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\"=== Part A Demo Test ===\\\\n\");\\n    printf(\"Demonstrating dynamic module parameters\\\\n\");\\n    \\n    printf(\"Test: Loading with student_id=99999\\\\n\");\\n    system(\"rmmod multi_vars 2>/dev/null\");\\n    system(\"insmod /lib/modules/multi_vars.ko student_id=99999\");\\n    \\n    printf(\"SUCCESS: Demo completed\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Demonstrating module parameter functionality'"
            ],
            "testCommands": [
              "/bin/demo_tester",
              "echo 'Check: Module parameter works'",
              "dmesg | grep 'Student ID: 99999' && echo 'DEMO: Parameter worked!' || echo 'INFO: Using default value'"
            ],
            "expected": {
              "dmesg": [
                "Multi-variable module loaded"
              ],
              "stdout": [
                "Part A Demo Test",
                "SUCCESS: Demo completed"
              ]
            },
            "timeout": 30
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Multi-variable module loaded",
        "Student ID: 12345",
        "Student Grade: A",
        "Student Passed: 1"
      ],
      "requirements": [
        "Use required function names: multi_vars_init, multi_vars_exit, print_student_info",
        "Use required variable names: student_id, student_grade, student_passed",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: int student_id = 12345, char student_grade = 'A', bool student_passed = true, void print_student_info(void)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Multi-variable module loaded",
          "linkedFunction": "static int __init multi_vars_init(void)",
          "exact": true
        },
        {
          "pattern": "Student Information",
          "linkedFunction": "void print_student_info(void)",
          "exact": true
        },
        {
          "pattern": "Student ID: 12345",
          "linkedFunction": "void print_student_info(void)",
          "exact": true
        },
        {
          "pattern": "Student Grade: A",
          "linkedFunction": "void print_student_info(void)",
          "exact": true
        },
        {
          "pattern": "Student Passed: 1",
          "linkedFunction": "void print_student_info(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 6,
    "title": "Multiple Variables - Guided Practice",
    "difficulty": 3,
    "xp": 35,
    "phase": "foundations",
    "description": "Build on Problem 4 by completing a partially implemented solution. Fill in strategic gaps while working with module parameters for dynamic testing. This bridges complete examples to independent creation.",
    "concepts": [
      "guided practice",
      "multiple data types",
      "format specifier completion",
      "variable initialization",
      "pattern application"
    ],
    "skills": [
      "Completing partial implementations",
      "Applying learned patterns",
      "Working with three data types",
      "Format specifier selection",
      "Code completion skills"
    ],
    "files": [
      {
        "name": "practice_vars.h",
        "content": "#ifndef PRACTICE_VARS_H\n#define PRACTICE_VARS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* Function to complete */\nvoid print_employee_info(void);\n\n#endif /* PRACTICE_VARS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "practice_vars.c",
        "content": "#include \"practice_vars.h\"\n\n/* Complete the strategic gaps below\n * Build on what you learned from Problem 4's complete example\n * This time YOU fill in the missing pieces!\n */\n\n/* TODO: Complete the variable definitions with these values:\n * employee_id = 67890\n * performance_grade = 'A'\n * is_promoted = true\n */\nint employee_id = _____;\nchar performance_grade = _____;\nbool is_promoted = _____;\n\n/* Module parameters for dynamic testing - DO NOT REMOVE! */\nmodule_param(employee_id, int, 0644);\nMODULE_PARM_DESC(employee_id, \"Employee ID for testing\");\n/* char and bool parameters handled separately */\n\nvoid print_employee_info(void)\n{\n    printk(KERN_INFO \"=== Employee Information ===\\n\");\n    \n    /* TODO: Complete these printk statements with correct format specifiers */\n    /* Hint: Use %d for int, %c for char, %d for bool */\n    printk(KERN_INFO \"Employee ID: %___, _____);    // Fill in format and variable\n    printk(KERN_INFO \"Grade: %___, _____);          // Fill in format and variable  \n    printk(KERN_INFO \"Promoted: %___, _____);       // Fill in format and variable\n}\n\nstatic int __init practice_vars_init(void)\n{\n    printk(KERN_INFO \"Practice variables module loaded\\n\");\n    print_employee_info();\n    return 0;\n}\n\nstatic void __exit practice_vars_exit(void)\n{\n    printk(KERN_INFO \"Practice variables module unloaded\\n\");\n}\n\nmodule_init(practice_vars_init);\nmodule_exit(practice_vars_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Guided practice with multiple variables and dynamic testing\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Practice variables module Makefile\nobj-m += practice_vars.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "practice_vars.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "practice_vars_init",
          "practice_vars_exit",
          "print_employee_info"
        ],
        "variables": [
          {
            "name": "employee_id",
            "type": "int",
            "value": 67890
          },
          {
            "name": "performance_grade",
            "type": "char",
            "value": "'A'"
          },
          {
            "name": "is_promoted",
            "type": "bool",
            "value": true
          }
        ],
        "outputMessages": [
          "Practice variables module loaded",
          "Employee Information",
          "Employee ID: 67890",
          "Grade: A",
          "Promoted: 1"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "int employee_id = 67890",
          "char performance_grade = 'A'",
          "bool is_promoted = true",
          "void print_employee_info(void)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "variable_completion",
          "name": "Variable Value Completion",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int employee_id = 67890",
            "char performance_grade = 'A'",
            "bool is_promoted = true"
          ],
          "prohibitedSymbols": [
            "_____"
          ]
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_employee_info(void)",
            "static int __init practice_vars_init(void)",
            "static void __exit practice_vars_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_employee_info(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Function-Linked Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Practice variables module loaded",
              "exact": true,
              "linkedFunction": "static int __init practice_vars_init(void)"
            },
            {
              "pattern": "Employee Information",
              "exact": true,
              "linkedFunction": "void print_employee_info(void)"
            },
            {
              "pattern": "Employee ID: 67890",
              "exact": true,
              "linkedFunction": "void print_employee_info(void)"
            },
            {
              "pattern": "Grade: A",
              "exact": true,
              "linkedFunction": "void print_employee_info(void)"
            },
            {
              "pattern": "Promoted: 1",
              "exact": true,
              "linkedFunction": "void print_employee_info(void)"
            }
          ]
        },
        {
          "id": "guided_dynamic_testing",
          "name": "Guided Dynamic Testing",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "practice_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\"=== Part B Practice Test ===\\\\n\");\\n    printf(\"Testing guided completion with dynamic values\\\\n\");\\n    \\n    printf(\"Test: Loading with employee_id=88888\\\\n\");\\n    system(\"rmmod practice_vars 2>/dev/null\");\\n    system(\"insmod /lib/modules/practice_vars.ko employee_id=88888\");\\n    \\n    printf(\"SUCCESS: Practice test completed\\\\n\");\\n    printf(\"PASS: Variable completion works\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting guided practice testing'"
            ],
            "testCommands": [
              "/bin/practice_tester",
              "echo 'Checking dynamic value'",
              "dmesg | grep 'Employee ID: 88888' && echo 'PASS: Dynamic employee_id worked' || echo 'FAIL: Must use variables, not hardcoded values'"
            ],
            "expected": {
              "dmesg": [
                "Practice variables module loaded",
                "Employee ID: 88888"
              ],
              "stdout": [
                "Part B Practice Test",
                "SUCCESS: Practice test completed",
                "PASS: Variable completion works"
              ]
            },
            "timeout": 30
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Practice variables module loaded",
        "Employee Information",
        "Employee ID: 67890",
        "Grade: A",
        "Promoted: 1"
      ],
      "requirements": [
        "Use required function names: practice_vars_init, practice_vars_exit, print_employee_info",
        "Use required variable names: employee_id, performance_grade, is_promoted",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: int employee_id = 67890, char performance_grade = 'A', bool is_promoted = true, void print_employee_info(void)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Practice variables module loaded",
          "linkedFunction": "static int __init practice_vars_init(void)",
          "exact": true
        },
        {
          "pattern": "Employee Information",
          "linkedFunction": "void print_employee_info(void)",
          "exact": true
        },
        {
          "pattern": "Employee ID: 67890",
          "linkedFunction": "void print_employee_info(void)",
          "exact": true
        },
        {
          "pattern": "Grade: A",
          "linkedFunction": "void print_employee_info(void)",
          "exact": true
        },
        {
          "pattern": "Promoted: 1",
          "linkedFunction": "void print_employee_info(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 7,
    "title": "Multiple Variables - Advanced Dynamic Testing",
    "difficulty": 4,
    "xp": 45,
    "phase": "foundations",
    "description": "Master advanced variable usage with dynamic testing! Create a complete solution that works with changing values - the system will test your code with different inputs to ensure you're using variables correctly, not hardcoding values.",
    "concepts": [
      "independent creation",
      "four data types",
      "complete implementation",
      "format specifier mastery",
      "creative problem solving"
    ],
    "skills": [
      "Writing code from requirements",
      "Managing four different data types",
      "Creating complete solutions",
      "Independent problem solving",
      "Applying learned patterns creatively"
    ],
    "files": [
      {
        "name": "create_vars.h",
        "content": "#ifndef CREATE_VARS_H\n#define CREATE_VARS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* TODO: Declare your function */\n/* void print_server_status(void); */\n\n#endif /* CREATE_VARS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "create_vars.c",
        "content": "#include \"create_vars.h\"\n\n/* CHALLENGE: Advanced Variable Creation with Dynamic Testing!\n * \n * REQUIREMENTS:\n * Create 4 variables with these default values:\n * - server_id = 1001 (int)\n * - status_code = 'R' for Ready (char)  \n * - temperature = 68 (int)\n * - online = true (bool)\n * \n * Print them in this exact format:\n * \"Server %d: Status %c, Temp %d, Online: %d\"\n * \n * CRITICAL WARNING: The testing system will change values dynamically!\n * You MUST use actual variables, not hardcoded values, or you will fail!\n */\n\n/* TODO: Define all 4 variables with the specified default values */\n\n\n\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your variables work with different values.\n * Removing them will cause test failures.\n */\nmodule_param(server_id, int, 0644);\nMODULE_PARM_DESC(server_id, \"Server ID for testing\");\nmodule_param(temperature, int, 0644);\nMODULE_PARM_DESC(temperature, \"Temperature value for testing\");\n/* Note: char and bool module params need special handling, so we only test int params */\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* TODO: Implement print_server_status function */\n/* Use appropriate format specifiers: %d for int, %c for char, %d for bool */\n/* WARNING: Use actual variables! The system tests with different values! */\nvoid print_server_status(void)\n{\n    /* TODO: Print the server information using the variables above */\n    \n    \n}\n\nstatic int __init create_vars_init(void)\n{\n    printk(KERN_INFO \"Variable creation module loaded\\n\");\n    print_server_status();\n    return 0;\n}\n\nstatic void __exit create_vars_exit(void)\n{\n    printk(KERN_INFO \"Variable creation module unloaded\\n\");\n}\n\nmodule_init(create_vars_init);\nmodule_exit(create_vars_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Advanced variable creation with dynamic testing\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Variable creation module Makefile\nobj-m += create_vars.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "create_vars.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "create_vars_init",
          "create_vars_exit",
          "print_server_status"
        ],
        "variables": [
          {
            "name": "server_id",
            "type": "int",
            "value": 1001
          },
          {
            "name": "status_code",
            "type": "char",
            "value": "'R'"
          },
          {
            "name": "temperature",
            "type": "int",
            "value": 68
          },
          {
            "name": "online",
            "type": "bool",
            "value": true
          }
        ],
        "outputMessages": [
          "Variable creation module loaded",
          "Server 1001: Status R, Temp 68, Online: 1"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "int server_id = 1001",
          "char status_code = 'R'",
          "int temperature = 68",
          "bool online = true",
          "void print_server_status(void)",
          "module_param(server_id, int, 0644)",
          "module_param(temperature, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "variable_definitions",
          "name": "Variable Definitions in Source",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int server_id = 1001",
            "char status_code = 'R'",
            "int temperature = 68",
            "bool online = true"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "module_parameters",
          "name": "Module Parameter Infrastructure",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "module_param(server_id, int, 0644)",
            "module_param(temperature, int, 0644)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_server_status(void)",
            "static int __init create_vars_init(void)",
            "static void __exit create_vars_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_server_status(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Basic Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Variable creation module loaded",
              "exact": true,
              "linkedFunction": "static int __init create_vars_init(void)"
            },
            {
              "pattern": "Server 1001: Status R, Temp 68, Online: 1",
              "exact": true,
              "linkedFunction": "void print_server_status(void)"
            }
          ]
        },
        {
          "id": "dynamic_variable_testing",
          "name": "Dynamic Variable Testing",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "variable_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\"=== Dynamic Variable Test ===\\\\n\");\\n    \\n    printf(\"Test 1: Testing server_id=2001, temperature=85\\\\n\");\\n    system(\"rmmod create_vars 2>/dev/null\");\\n    system(\"insmod /lib/modules/create_vars.ko server_id=2001 temperature=85\");\\n    \\n    printf(\"Test 2: Testing server_id=3001, temperature=92\\\\n\");\\n    system(\"rmmod create_vars\");\\n    system(\"insmod /lib/modules/create_vars.ko server_id=3001 temperature=92\");\\n    \\n    printf(\"SUCCESS: Dynamic test completed\\\\n\");\\n    printf(\"PASS: Variable usage detected\\\\n\");\\n    printf(\"PASS: Module parameters work\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting dynamic variable testing'"
            ],
            "testCommands": [
              "/bin/variable_tester",
              "echo 'Checking kernel output for dynamic values'",
              "dmesg | grep 'Server 2001' && echo 'PASS: 2001 test worked' || echo 'FAIL: 2001 test failed'",
              "dmesg | grep 'Temp 85' && echo 'PASS: 85 test worked' || echo 'FAIL: 85 test failed'",
              "dmesg | grep 'Server 3001' && echo 'PASS: 3001 test worked' || echo 'FAIL: 3001 test failed'",
              "dmesg | grep 'Temp 92' && echo 'PASS: 92 test worked' || echo 'FAIL: 92 test failed'"
            ],
            "expected": {
              "dmesg": [
                "Variable creation module loaded",
                "Server 2001: Status R, Temp 85, Online: 1",
                "Server 3001: Status R, Temp 92, Online: 1"
              ],
              "stdout": [
                "Dynamic Variable Test",
                "SUCCESS: Dynamic test completed",
                "PASS: Variable usage detected",
                "PASS: Module parameters work"
              ]
            },
            "timeout": 45
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Variable creation module loaded",
        "Server 1001: Status R, Temp 68, Online: 1"
      ],
      "requirements": [
        "Use required function names: create_vars_init, create_vars_exit, print_server_status",
        "Use required variable names: server_id, status_code, temperature, online",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: int server_id = 1001, char status_code = 'R', int temperature = 68, bool online = true, void print_server_status(void), module_param(server_id, int, 0644), module_param(temperature, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Variable creation module loaded",
          "linkedFunction": "static int __init create_vars_init(void)",
          "exact": true
        },
        {
          "pattern": "Server 1001: Status R, Temp 68, Online: 1",
          "linkedFunction": "void print_server_status(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 8,
    "title": "Function Parameters - Advanced Dynamic Testing",
    "difficulty": 4,
    "xp": 40,
    "phase": "foundations",
    "description": "Master function parameters and return values with dynamic testing! Create functions that work with changing input values - the system will test your functions with different parameters to ensure they work correctly, not just with hardcoded values.",
    "concepts": [
      "function parameters",
      "return values",
      "function calls with arguments",
      "local variables",
      "modulo operator",
      "boolean logic"
    ],
    "skills": [
      "Writing functions with parameters",
      "Understanding return values",
      "Function composition",
      "Mathematical operations in kernel space",
      "Boolean operations and logic"
    ],
    "files": [
      {
        "name": "functions.h",
        "content": "#ifndef FUNCTIONS_H\n#define FUNCTIONS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* TODO: Declare functions with parameters */\n/* int add_numbers(int a, int b); */\n/* void print_calculation(int num1, int num2, int result); */\n/* bool is_even(int number); */\n\n/* Variables for dynamic testing */\nextern int first;\nextern int second;\n\n#endif /* FUNCTIONS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "functions.c",
        "content": "#include \"functions.h\"\n\n/* CHALLENGE: Advanced Function Parameters with Dynamic Testing!\n *\n * REQUIREMENTS:\n * Create these functions:\n * - add_numbers(int a, int b) -> returns a + b\n * - print_calculation(int num1, int num2, int result) -> prints \"num1 + num2 = result\"\n * - is_even(int number) -> returns true if number is even, false if odd\n *\n * CRITICAL WARNING: The testing system will use different input values!\n * Your functions must work with ANY inputs, not just the defaults below.\n */\n\n/* Variables for dynamic testing */\nint first = 15;\nint second = 25;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your functions work with different inputs.\n * Removing them will cause test failures.\n */\nmodule_param(first, int, 0644);\nMODULE_PARM_DESC(first, \"First number for testing\");\nmodule_param(second, int, 0644);\nMODULE_PARM_DESC(second, \"Second number for testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* TODO: Implement add_numbers function */\n/* Return the sum of a and b */\n\n\n/* TODO: Implement print_calculation function */  \n/* Print in format: \"num1 + num2 = result\" */\n\n\n/* TODO: Implement is_even function */\n/* Return true if number is even, false if odd */\n/* Hint: Use modulo operator (%) */\n\n\nstatic int __init functions_init(void)\n{\n    int sum;\n    bool even_check;\n    \n    printk(KERN_INFO \"Function parameters module loaded\\n\");\n    \n    /* TODO: Call add_numbers and store result */\n    /* sum = add_numbers(first, second); */\n    \n    /* TODO: Call print_calculation to display result */\n    /* print_calculation(first, second, sum); */\n    \n    /* TODO: Check if sum is even and print result */\n    /* even_check = is_even(sum); */\n    /* printk(KERN_INFO \"Sum is even: %d\\n\", even_check); */\n    \n    return 0;\n}\n\nstatic void __exit functions_exit(void)\n{\n    printk(KERN_INFO \"Function parameters module unloaded\\n\");\n}\n\nmodule_init(functions_init);\nmodule_exit(functions_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Advanced function parameters with dynamic testing\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Functions module Makefile\nobj-m += functions.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "functions.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "functions_init",
          "functions_exit",
          "add_numbers",
          "print_calculation",
          "is_even"
        ],
        "variables": [
          {
            "name": "first",
            "type": "int",
            "value": 15
          },
          {
            "name": "second",
            "type": "int",
            "value": 25
          }
        ],
        "outputMessages": [
          "Function parameters module loaded",
          "15 + 25 = 40",
          "Sum is even: 1"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "int add_numbers(int a, int b)",
          "void print_calculation(int num1, int num2, int result)",
          "bool is_even(int number)",
          "return a + b",
          "number % 2 == 0",
          "add_numbers(first, second)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int add_numbers(int a, int b)",
            "void print_calculation(int num1, int num2, int result)",
            "bool is_even(int number)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_implementations",
          "name": "Function Implementations",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "return a + b",
            "return (number % 2 == 0)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_calls",
          "name": "Proper Function Calls",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "add_numbers(first, second)",
            "print_calculation(first, second, sum)",
            "is_even(sum)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "modulo_operator",
          "name": "Modulo Operator Usage",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "number % 2"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "return_values",
          "name": "Proper Return Value Usage",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "sum = add_numbers",
            "even_check = is_even"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int add_numbers(int a, int b)",
            "void print_calculation(int num1, int num2, int result)",
            "bool is_even(int number)",
            "static int __init functions_init(void)",
            "static void __exit functions_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Basic Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Function parameters module loaded",
              "exact": true,
              "linkedFunction": "static int __init functions_init(void)"
            },
            {
              "pattern": "15 + 25 = 40",
              "exact": true,
              "linkedFunction": "void print_calculation(int num1, int num2, int result)"
            },
            {
              "pattern": "Sum is even: 1",
              "exact": true,
              "linkedFunction": "static int __init functions_init(void)"
            }
          ]
        },
        {
          "id": "advanced_function_testing",
          "name": "Advanced Function Parameter Testing",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "function_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\"=== Dynamic Function Test ===\\\\n\");\\n    printf(\"Test 1: Testing first=10, second=30 (sum=40, even)\\\\n\");\\n    system(\"rmmod functions 2>/dev/null\");\\n    system(\"insmod /lib/modules/functions.ko first=10 second=30\");\\n    printf(\"Test 2: Testing first=7, second=8 (sum=15, odd)\\\\n\");\\n    system(\"rmmod functions\");\\n    system(\"insmod /lib/modules/functions.ko first=7 second=8\");\\n    printf(\"SUCCESS: Dynamic test completed\\\\n\");\\n    printf(\"PASS: Function parameters detected\\\\n\");\\n    printf(\"PASS: Module parameters work\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting comprehensive validation'",
              "cp /lib/modules/functions.h /lib/modules/ 2>/dev/null"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo 'Creating test file that includes student header...'",
              "echo '#include \"/lib/modules/functions.h\"' > /tmp/test.c",
              "echo 'int main() { add_numbers(1,2); print_calculation(1,2,3); is_even(4); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declarations missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: All function declarations found in header file'",
              "echo 'Phase 2: Dynamic Parameter Testing'",
              "echo 'Marking start of dynamic tests for validation...'",
              "echo 'DYNAMIC_TEST_START' > /tmp/test_marker",
              "/bin/function_tester",
              "echo 'Phase 3: Context-Aware Logic Validation'",
              "echo 'Validating Test 1: first=10, second=30 (sum=40, should be even)'",
              "dmesg | grep '10 + 30 = 40' && echo 'PASS: add_numbers(10,30) calculation correct' || { echo 'FAIL: add_numbers(10,30) calculation wrong or missing'; exit 1; }",
              "dmesg | grep -A1 '10 + 30 = 40' | grep 'Sum is even: 1' && echo 'PASS: is_even(40) correctly identifies even number' || { echo 'FAIL: is_even(40) wrong - should return 1 for even number 40'; exit 1; }",
              "echo 'Validating Test 2: first=7, second=8 (sum=15, should be odd)'",
              "dmesg | grep '7 + 8 = 15' && echo 'PASS: add_numbers(7,8) calculation correct' || { echo 'FAIL: add_numbers(7,8) calculation wrong or missing'; exit 1; }",
              "dmesg | grep -A1 '7 + 8 = 15' | grep 'Sum is even: 0' && echo 'PASS: is_even(15) correctly identifies odd number' || { echo 'FAIL: is_even(15) wrong - should return 0 for odd number 15'; exit 1; }",
              "echo 'Phase 4: Cross-Validation (ensuring test-specific results are correct)'",
              "echo 'Checking that 40 (even) produces Sum is even: 1'",
              "TEST1_CORRECT=$(dmesg | grep -A1 '10 + 30 = 40' | grep -c 'Sum is even: 1')",
              "echo 'Checking that 15 (odd) produces Sum is even: 0'",
              "TEST2_CORRECT=$(dmesg | grep -A1 '7 + 8 = 15' | grep -c 'Sum is even: 0')",
              "echo 'Test 1 correct results: '$TEST1_CORRECT' (expected: 1)'",
              "echo 'Test 2 correct results: '$TEST2_CORRECT' (expected: 1)'",
              "if [ $TEST1_CORRECT -eq 1 ] && [ $TEST2_CORRECT -eq 1 ]; then echo 'PASS: Both tests show correct even/odd logic'; else echo 'FAIL: Logic validation failed - Test 1: '$TEST1_CORRECT', Test 2: '$TEST2_CORRECT' (expected 1 each)'; exit 1; fi"
            ],
            "expected": {
              "dmesg": [
                "Function parameters module loaded",
                "10 \\+ 30 = 40",
                "Sum is even: 1",
                "7 \\+ 8 = 15",
                "Sum is even: 0"
              ],
              "stdout": [
                "PASS: All function declarations found in header file",
                "SUCCESS: Dynamic test completed",
                "PASS: Both tests show correct even/odd logic"
              ]
            },
            "timeout": 25
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Function parameters module loaded",
        "15 + 25 = 40",
        "Sum is even: 1"
      ],
      "requirements": [
        "Use required function names: functions_init, functions_exit, add_numbers, print_calculation, is_even",
        "Use required variable names: first, second",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: int add_numbers(int a, int b), void print_calculation(int num1, int num2, int result), bool is_even(int number), return a + b, number % 2 == 0, add_numbers(first, second)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Function parameters module loaded",
          "linkedFunction": "static int __init functions_init(void)",
          "exact": true
        },
        {
          "pattern": "15 + 25 = 40",
          "linkedFunction": "void print_calculation(int num1, int num2, int result)",
          "exact": true
        },
        {
          "pattern": "Sum is even: 1",
          "linkedFunction": "static int __init functions_init(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 9,
    "title": "Conditional Logic - Making Decisions",
    "difficulty": 3,
    "xp": 35,
    "phase": "foundations",
    "description": "Learn to make decisions in your code using if/else statements and comparison operators. This introduces logical thinking and decision-making patterns essential for kernel development where conditions determine code flow.",
    "concepts": [
      "if statements",
      "else if statements",
      "comparison operators",
      "logical decision making",
      "conditional execution"
    ],
    "skills": [
      "Writing conditional statements",
      "Using comparison operators",
      "Logical thinking and flow control",
      "Decision-based programming",
      "Testing multiple conditions"
    ],
    "files": [
      {
        "name": "conditions.h",
        "content": "#ifndef CONDITIONS_H\n#define CONDITIONS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* TODO: Declare your function */\n/* void check_number_status(int number); */\n\n#endif /* CONDITIONS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "conditions.c",
        "content": "#include \"conditions.h\"\n\nint test_number = 42;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your conditional logic works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(test_number, int, 0644);\nMODULE_PARM_DESC(test_number, \"Number to test with conditional logic\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: How if/else works in C */\n/* Basic pattern for making decisions:\n *\n * if (condition1) {\n *     // do something when condition1 is true\n * } else if (condition2) {\n *     // do something when condition2 is true\n * } else {\n *     // do something when both conditions are false\n * }\n */\n\n/* COMPARISON OPERATORS: */\n/* > means \"greater than\"    (5 > 3 is true) */\n/* < means \"less than\"       (3 < 5 is true) */\n/* == means \"equal to\"       (5 == 5 is true) - NOTE: double equals! */\n\n/* TODO: Implement function to check if number is positive, negative, or zero */\n/* Use the pattern above with appropriate conditions */\n/* Print format: \"Number X is positive/negative/zero\" */\nvoid check_number_status(int number) {\n    // Your implementation here\n    // Follow the if/else pattern shown above\n}\n\nstatic int __init conditions_init(void)\n{\n    printk(KERN_INFO \"Conditional logic module loaded\\n\");\n    \n    // Call your function with the test parameter\n    check_number_status(test_number);\n    \n    // Test with fixed values for basic verification\n    check_number_status(42);\n    check_number_status(-15);\n    check_number_status(0);\n    \n    return 0;\n}\n\nstatic void __exit conditions_exit(void)\n{\n    printk(KERN_INFO \"Conditional logic module unloaded\\n\");\n}\n\nmodule_init(conditions_init);\nmodule_exit(conditions_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning conditional logic and decision making\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Conditional logic module Makefile\nobj-m += conditions.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "conditions.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "conditions_init",
          "conditions_exit",
          "check_number_status"
        ],
        "variables": [
          {
            "name": "test_number",
            "type": "int",
            "value": 42
          }
        ],
        "outputMessages": [
          "Conditional logic module loaded",
          "Number 42 is positive",
          "Number -15 is negative",
          "Number 0 is zero"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "int test_number = 42",
          "void check_number_status(int number)",
          "if (number > 0)",
          "else if (number < 0)",
          "else"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void check_number_status(int number)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void check_number_status(int number)",
            "static int __init conditions_init(void)",
            "static void __exit conditions_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Basic Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Conditional logic module loaded",
              "exact": true,
              "linkedFunction": "static int __init conditions_init(void)"
            },
            {
              "pattern": "Number 42 is positive",
              "exact": true,
              "linkedFunction": "void check_number_status(int number)"
            },
            {
              "pattern": "Number -15 is negative",
              "exact": true,
              "linkedFunction": "void check_number_status(int number)"
            },
            {
              "pattern": "Number 0 is zero",
              "exact": true,
              "linkedFunction": "void check_number_status(int number)"
            }
          ]
        },
        {
          "id": "advanced_conditional_testing",
          "name": "Advanced Conditional Logic with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "conditional_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\"=== Dynamic Conditional Test ===\\\\n\");\\n    \\n    // Seed random number generator with current time\\n    srand(time(NULL));\\n    \\n    // Generate random test values within -100 to 100\\n    int positive_val = (rand() % 90) + 10;  // 10 to 99\\n    int negative_val = -((rand() % 90) + 10); // -99 to -10\\n    int zero_val = 0;  // Always test zero\\n    \\n    printf(\"Test 1: Testing positive number (%d)\\\\n\", positive_val);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \"insmod /lib/modules/conditions.ko test_number=%d\", positive_val);\\n    system(\"rmmod conditions 2>/dev/null\");\\n    system(cmd1);\\n    \\n    printf(\"Test 2: Testing negative number (%d)\\\\n\", negative_val);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \"insmod /lib/modules/conditions.ko test_number=%d\", negative_val);\\n    system(\"rmmod conditions\");\\n    system(cmd2);\\n    \\n    printf(\"Test 3: Testing zero (%d)\\\\n\", zero_val);\\n    system(\"rmmod conditions\");\\n    system(\"insmod /lib/modules/conditions.ko test_number=0\");\\n    \\n    printf(\"SUCCESS: Dynamic test completed\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting comprehensive conditional logic validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo 'Creating test file that includes student header...'",
              "echo '#include \"/lib/modules/conditions.h\"' > /tmp/test.c",
              "echo 'int main() { check_number_status(42); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: Function declaration found in header file'",
              "echo 'Phase 2: Dynamic Parameter Testing'",
              "/bin/conditional_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Dynamic Randomized Conditional Logic Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "POSITIVE_VAL=$(grep -o 'Testing positive number ([0-9]*)' /tmp/test_output.log | cut -d'(' -f2 | cut -d')' -f1)",
              "NEGATIVE_VAL=$(grep -o 'Testing negative number (-[0-9]*)' /tmp/test_output.log | cut -d'(' -f2 | cut -d')' -f1)",
              "echo 'Extracted positive value: '$POSITIVE_VAL",
              "echo 'Extracted negative value: '$NEGATIVE_VAL",
              "echo 'Random positive value: '$POSITIVE_VAL",
              "echo 'Random negative value: '$NEGATIVE_VAL",
              "echo 'Validating positive number logic with random value '$POSITIVE_VAL",
              "dmesg | grep \"Number $POSITIVE_VAL is positive\" && echo 'PASS: Positive number logic correct' || echo 'FAIL: Positive number logic wrong'",
              "echo 'Validating negative number logic with random value '$NEGATIVE_VAL",
              "dmesg | grep \"Number $NEGATIVE_VAL is negative\" && echo 'PASS: Negative number logic correct' || echo 'FAIL: Negative number logic wrong'",
              "echo 'Validating zero logic (0 should be zero)'",
              "dmesg | grep 'Number 0 is zero' && echo 'PASS: Zero logic correct' || echo 'FAIL: Zero logic wrong'",
              "echo 'All individual validations completed'",
              "echo 'Phase 4: Dynamic Cross-Validation Consistency Check'",
              "echo 'Checking that random test values produced correct results'",
              "TEST_POSITIVE=$(dmesg | grep -c \"Number $POSITIVE_VAL is positive\")",
              "TEST_NEGATIVE=$(dmesg | grep -c \"Number $NEGATIVE_VAL is negative\")",
              "TEST_ZERO=$(dmesg | grep -c 'Number 0 is zero')",
              "echo 'Test positive '$POSITIVE_VAL' results: '$TEST_POSITIVE' (expected: 1)'",
              "echo 'Test negative '$NEGATIVE_VAL' results: '$TEST_NEGATIVE' (expected: 1)'",
              "echo 'Test 0 zero results: '$TEST_ZERO' (expected: at least 1)'",
              "if [ $TEST_POSITIVE -eq 1 ] && [ $TEST_NEGATIVE -eq 1 ] && [ $TEST_ZERO -ge 1 ]; then echo 'PASS: All conditional logic working correctly'; else echo 'FAIL: Conditional logic validation failed - Positive: '$TEST_POSITIVE', Negative: '$TEST_NEGATIVE', Zero: '$TEST_ZERO; fi"
            ],
            "expected": {
              "dmesg": [
                "Conditional logic module loaded",
                "Number .* is positive",
                "Number .* is negative",
                "Number 0 is zero"
              ],
              "stdout": [
                "PASS: Function declaration found in header file",
                "SUCCESS: Dynamic test completed",
                "PASS: All conditional logic working correctly"
              ]
            },
            "timeout": 25
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Conditional logic module loaded",
        "Number 42 is positive",
        "Number -15 is negative",
        "Number 0 is zero"
      ],
      "requirements": [
        "Use required function names: conditions_init, conditions_exit, check_number_status",
        "Use required variable names: test_number",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: int test_number = 42, void check_number_status(int number), if (number > 0), else if (number < 0), else",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Conditional logic module loaded",
          "linkedFunction": "static int __init conditions_init(void)",
          "exact": true
        },
        {
          "pattern": "Number 42 is positive",
          "linkedFunction": "void check_number_status(int number)",
          "exact": true
        },
        {
          "pattern": "Number -15 is negative",
          "linkedFunction": "void check_number_status(int number)",
          "exact": true
        },
        {
          "pattern": "Number 0 is zero",
          "linkedFunction": "void check_number_status(int number)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 10,
    "title": "Basic Loops - Study Loop Patterns",
    "difficulty": 2,
    "xp": 25,
    "phase": "foundations",
    "description": "Study complete working examples of for loops and iteration patterns. This demonstrates how loops are used in kernel development for processing data and implementing basic algorithms.",
    "concepts": [
      "for loops",
      "loop variables",
      "iteration patterns",
      "accumulation",
      "loop-based calculations"
    ],
    "skills": [
      "Writing for loops",
      "Managing loop counters",
      "Iterative algorithms",
      "Accumulation patterns",
      "Loop-based problem solving"
    ],
    "files": [
      {
        "name": "loops.h",
        "content": "#ifndef LOOPS_H\n#define LOOPS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\nextern int max_count;\nextern int sum_result;\n\n/* Function to print numbers from 1 to count */\nvoid print_numbers(int count);\n\n/* Function to calculate sum of numbers from 1 to n */\nint calculate_sum(int n);\n\n#endif /* LOOPS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "loops.c",
        "content": "#include \"loops.h\"\n\nint max_count = 5;\nint sum_result = 0;\n\n/* \n * Function to print numbers from 1 to count\n * Demonstrates basic for loop pattern for iteration\n */\nvoid print_numbers(int count) {\n    int i;\n    for (i = 1; i <= count; i++) {\n        printk(KERN_INFO \"Count: %d\\n\", i);\n    }\n}\n\n/* \n * Function to calculate sum of numbers from 1 to n\n * Demonstrates accumulation pattern using loops\n * Formula: sum = 1 + 2 + 3 + ... + n\n */\nint calculate_sum(int n) {\n    int i, sum = 0;\n    for (i = 1; i <= n; i++) {\n        sum += i;  // Accumulate each number into sum\n    }\n    return sum;\n}\n\nstatic int __init loops_init(void)\n{\n    printk(KERN_INFO \"Basic loops module loaded\\n\");\n    \n    // Demonstrate loop for printing sequential numbers\n    print_numbers(max_count);\n    \n    // Demonstrate loop for mathematical calculation\n    sum_result = calculate_sum(max_count);\n    printk(KERN_INFO \"Sum of 1 to %d is: %d\\n\", max_count, sum_result);\n    \n    return 0;\n}\n\nstatic void __exit loops_exit(void)\n{\n    printk(KERN_INFO \"Basic loops module unloaded\\n\");\n}\n\nmodule_init(loops_init);\nmodule_exit(loops_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning basic loops and iteration\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Basic loops module Makefile\nobj-m += loops.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "loops.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "loops_init",
          "loops_exit",
          "print_numbers",
          "calculate_sum"
        ],
        "variables": [
          {
            "name": "max_count",
            "type": "int",
            "value": 5
          },
          {
            "name": "sum_result",
            "type": "int",
            "value": 0
          }
        ],
        "outputMessages": [
          "Basic loops module loaded",
          "Count: 1",
          "Count: 2",
          "Count: 3",
          "Count: 4",
          "Count: 5",
          "Sum of 1 to 5 is: 15"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "extern int max_count",
          "extern int sum_result",
          "int max_count = 5",
          "int sum_result = 0",
          "for (i = 1; i <= count; i++)",
          "for (i = 1; i <= n; i++)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_numbers(int count)",
            "int calculate_sum(int n)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_numbers(int count)",
            "int calculate_sum(int n)",
            "static int __init loops_init(void)",
            "static void __exit loops_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Basic Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Basic loops module loaded",
              "exact": true,
              "linkedFunction": "static int __init loops_init(void)"
            },
            {
              "pattern": "Count: 1",
              "exact": true,
              "linkedFunction": "void print_numbers(int count)"
            },
            {
              "pattern": "Count: 2",
              "exact": true,
              "linkedFunction": "void print_numbers(int count)"
            },
            {
              "pattern": "Count: 3",
              "exact": true,
              "linkedFunction": "void print_numbers(int count)"
            },
            {
              "pattern": "Count: 4",
              "exact": true,
              "linkedFunction": "void print_numbers(int count)"
            },
            {
              "pattern": "Count: 5",
              "exact": true,
              "linkedFunction": "void print_numbers(int count)"
            },
            {
              "pattern": "Sum of 1 to 5 is: 15",
              "exact": true,
              "linkedFunction": "static int __init loops_init(void)"
            }
          ]
        },
        {
          "id": "advanced_loop_validation",
          "name": "Advanced Loop Pattern Validation with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "loop_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\"=== Loop Pattern Test ===\\\\n\");\\n    printf(\"SUCCESS: Loop test completed\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting loop pattern validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo 'Creating test file that includes student header...'",
              "echo '#include \"/lib/modules/loops.h\"' > /tmp/test.c",
              "echo 'int main() { print_numbers(5); calculate_sum(5); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: All function declarations found in header file'",
              "echo 'Phase 2: Module Testing'",
              "/bin/loop_tester"
            ],
            "expected": {
              "dmesg": [
                "Basic loops module loaded",
                "Count: 1",
                "Count: 2",
                "Count: 3",
                "Count: 4",
                "Count: 5",
                "Sum of 1 to 5 is: 15"
              ],
              "stdout": [
                "PASS: All function declarations found in header file",
                "SUCCESS: Loop test completed"
              ]
            },
            "timeout": 20
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Basic loops module loaded",
        "Count: 1",
        "Count: 2",
        "Count: 3",
        "Count: 4",
        "Count: 5",
        "Sum of 1 to 5 is: 15"
      ],
      "requirements": [
        "Use required function names: loops_init, loops_exit, print_numbers, calculate_sum",
        "Use required variable names: max_count, sum_result",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: extern int max_count, extern int sum_result, int max_count = 5, int sum_result = 0, for (i = 1; i <= count; i++), for (i = 1; i <= n; i++)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Basic loops module loaded",
          "linkedFunction": "static int __init loops_init(void)",
          "exact": true
        },
        {
          "pattern": "Count: 1",
          "linkedFunction": "void print_numbers(int count)",
          "exact": true
        },
        {
          "pattern": "Count: 2",
          "linkedFunction": "void print_numbers(int count)",
          "exact": true
        },
        {
          "pattern": "Count: 3",
          "linkedFunction": "void print_numbers(int count)",
          "exact": true
        },
        {
          "pattern": "Count: 4",
          "linkedFunction": "void print_numbers(int count)",
          "exact": true
        },
        {
          "pattern": "Count: 5",
          "linkedFunction": "void print_numbers(int count)",
          "exact": true
        },
        {
          "pattern": "Sum of 1 to 5 is: 15",
          "linkedFunction": "static int __init loops_init(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 11,
    "title": "Basic Loops - Implement Loop Solutions",
    "difficulty": 4,
    "xp": 40,
    "phase": "foundations",
    "description": "Implement your own loop-based solutions for iterative calculations using simple integers. Apply the patterns you studied in Problem 10 to create functions that perform mathematical calculations using loops. This focuses on pure loop logic without arrays.",
    "concepts": [
      "countdown iteration",
      "factorial calculation",
      "power calculation with loops",
      "multiplication accumulation patterns",
      "loop control variables"
    ],
    "skills": [
      "Implementing countdown loops",
      "Mathematical calculations with loops",
      "Basic accumulation algorithms",
      "Multiplication patterns",
      "Loop-based problem solving"
    ],
    "files": [
      {
        "name": "loops_impl.h",
        "content": "#ifndef LOOPS_IMPL_H\n#define LOOPS_IMPL_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\nextern int start_number;\nextern int factorial_number;\nextern int base_number;\nextern int power_number;\n\n/* TODO: Declare your functions */\n/* void print_countdown(int start); */\n/* int calculate_factorial(int n); */\n/* int calculate_power(int base, int exponent); */\n\n#endif /* LOOPS_IMPL_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "loops_impl.c",
        "content": "#include \"loops_impl.h\"\n\nint start_number = 5;      // Default: countdown from 5\nint factorial_number = 5;  // Default: calculate factorial of 5\nint base_number = 2;       // Default: base for power calculation\nint power_number = 3;      // Default: exponent for power calculation\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your loop implementations work\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(start_number, int, 0644);\nMODULE_PARM_DESC(start_number, \"Starting number for countdown testing\");\nmodule_param(factorial_number, int, 0644);\nMODULE_PARM_DESC(factorial_number, \"Number for factorial calculation testing\");\nmodule_param(base_number, int, 0644);\nMODULE_PARM_DESC(base_number, \"Base number for power calculation testing\");\nmodule_param(power_number, int, 0644);\nMODULE_PARM_DESC(power_number, \"Exponent for power calculation testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* TODO: Implement function to print countdown from start to 1 */\n/* Use a for loop starting from start down to 1 */\n/* Print: \"Count: X\" for each number */\n\n/* TODO: Implement function to calculate factorial of n */\n/* factorial(n) = n * (n-1) * (n-2) * ... * 1 */\n/* Use a for loop from 1 to n, multiply result by each number */\n\n/* TODO: Implement function to calculate power (base^exponent) */\n/* power = base * base * base * ... (exponent times) */\n/* Use accumulation pattern: start with result = 1 */\n/* Multiply result by base using for loop exponent times */\n\nstatic int __init loops_impl_init(void)\n{\n    int calculated_factorial, calculated_power;\n    \n    printk(KERN_INFO \"Loop implementation module loaded\\n\");\n    \n    /* TODO: Print countdown from start_number to 1 */\n    /* printk(KERN_INFO \"Countdown from %d:\\n\", start_number); */\n    /* print_countdown(start_number); */\n    \n    /* TODO: Calculate factorial using factorial_number as input */\n    /* calculated_factorial = calculate_factorial(factorial_number); */\n    /* printk(KERN_INFO \"Factorial of %d: %d\\n\", factorial_number, calculated_factorial); */\n    \n    /* TODO: Calculate power using base_number and power_number */\n    /* calculated_power = calculate_power(base_number, power_number); */\n    /* printk(KERN_INFO \"%d to the power of %d: %d\\n\", base_number, power_number, calculated_power); */\n    \n    return 0;\n}\n\nstatic void __exit loops_impl_exit(void)\n{\n    printk(KERN_INFO \"Loop implementation module unloaded\\n\");\n}\n\nmodule_init(loops_impl_init);\nmodule_exit(loops_impl_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Implementing basic loop calculations\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Loop implementation module Makefile\nobj-m += loops_impl.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "loops_impl.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "loops_impl_init",
          "loops_impl_exit",
          "print_countdown",
          "calculate_factorial",
          "calculate_power"
        ],
        "variables": [
          {
            "name": "start_number",
            "type": "int",
            "value": 5
          },
          {
            "name": "factorial_number",
            "type": "int",
            "value": 5
          },
          {
            "name": "base_number",
            "type": "int",
            "value": 2
          },
          {
            "name": "power_number",
            "type": "int",
            "value": 3
          }
        ],
        "outputMessages": [
          "Loop implementation module loaded",
          "Countdown from 5:",
          "Count: 5",
          "Count: 4",
          "Count: 3",
          "Count: 2",
          "Count: 1",
          "Factorial of 5: 120",
          "2 to the power of 3: 8"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "extern int start_number",
          "extern int factorial_number",
          "extern int base_number",
          "extern int power_number"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_countdown(int start)",
            "int calculate_factorial(int n)",
            "int calculate_power(int base, int exponent)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_countdown(int start)",
            "int calculate_factorial(int n)",
            "int calculate_power(int base, int exponent)",
            "static int __init loops_impl_init(void)",
            "static void __exit loops_impl_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Basic Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Loop implementation module loaded",
              "exact": true,
              "linkedFunction": "static int __init loops_impl_init(void)"
            },
            {
              "pattern": "Countdown from 5:",
              "exact": true,
              "linkedFunction": "static int __init loops_impl_init(void)"
            },
            {
              "pattern": "Count: 5",
              "exact": true,
              "linkedFunction": "void print_countdown(int start)"
            },
            {
              "pattern": "Count: 4",
              "exact": true,
              "linkedFunction": "void print_countdown(int start)"
            },
            {
              "pattern": "Count: 3",
              "exact": true,
              "linkedFunction": "void print_countdown(int start)"
            },
            {
              "pattern": "Count: 2",
              "exact": true,
              "linkedFunction": "void print_countdown(int start)"
            },
            {
              "pattern": "Count: 1",
              "exact": true,
              "linkedFunction": "void print_countdown(int start)"
            },
            {
              "pattern": "Factorial of 5: 120",
              "exact": true,
              "linkedFunction": "static int __init loops_impl_init(void)"
            },
            {
              "pattern": "2 to the power of 3: 8",
              "exact": true,
              "linkedFunction": "static int __init loops_impl_init(void)"
            }
          ]
        },
        {
          "id": "advanced_loop_implementation_validation",
          "name": "Advanced Loop Implementation with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "loop_impl_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\"=== Dynamic Loop Implementation Test ===\\\\n\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random test values\\n    int countdown_start = (rand() % 5) + 3;  // 3 to 7\\n    int factorial_n = (rand() % 5) + 3;      // 3 to 7 for reasonable factorial\\n    int base = (rand() % 3) + 2;             // 2 to 4\\n    int exponent = (rand() % 3) + 2;         // 2 to 4\\n    \\n    printf(\"Test 1: Countdown from %d, factorial of %d\\\\n\", countdown_start, factorial_n);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \"insmod /lib/modules/loops_impl.ko start_number=%d factorial_number=%d\", countdown_start, factorial_n);\\n    system(\"rmmod loops_impl 2>/dev/null\");\\n    system(cmd1);\\n    \\n    printf(\"Test 2: Power calculation %d^%d\\\\n\", base, exponent);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \"insmod /lib/modules/loops_impl.ko base_number=%d power_number=%d\", base, exponent);\\n    system(\"rmmod loops_impl\");\\n    system(cmd2);\\n    \\n    printf(\"SUCCESS: Dynamic loop test completed\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced loop implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo 'Creating test file that includes student header...'",
              "echo '#include \"/lib/modules/loops_impl.h\"' > /tmp/test.c",
              "echo 'int main() { print_countdown(5); calculate_factorial(5); calculate_power(2, 3); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: All function declarations found in header file'",
              "echo 'Phase 2: Dynamic Implementation Testing'",
              "/bin/loop_impl_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Dynamic Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "COUNTDOWN_START=$(grep -o 'Countdown from [0-9]*' /tmp/test_output.log | head -1 | cut -d' ' -f3 | cut -d',' -f1)",
              "FACTORIAL_N=$(grep -o 'factorial of [0-9]*' /tmp/test_output.log | head -1 | cut -d' ' -f3)",
              "BASE_NUM=$(grep -o 'Power calculation [0-9]*' /tmp/test_output.log | cut -d' ' -f3)",
              "EXPONENT_NUM=$(grep -o '[0-9]*\\^[0-9]*' /tmp/test_output.log | cut -d'^' -f2)",
              "echo 'Random values: countdown='$COUNTDOWN_START', factorial='$FACTORIAL_N', power='$BASE_NUM'^'$EXPONENT_NUM",
              "echo 'Validating countdown from '$COUNTDOWN_START",
              "dmesg | grep \"Countdown from $COUNTDOWN_START:\" && echo 'PASS: Countdown output correct' || echo 'PASS: Countdown working (flexible validation)'",
              "echo 'Validating factorial calculation for n='$FACTORIAL_N",
              "dmesg | grep \"Factorial of $FACTORIAL_N:\" && echo 'PASS: Factorial calculation correct' || echo 'PASS: Factorial working (flexible validation)'",
              "echo 'Validating power calculation '$BASE_NUM'^'$EXPONENT_NUM",
              "dmesg | grep \"$BASE_NUM to the power of $EXPONENT_NUM:\" && echo 'PASS: Power calculation correct' || echo 'PASS: Power working (flexible validation)'",
              "echo 'All dynamic validations completed'"
            ],
            "expected": {
              "dmesg": [
                "Loop implementation module loaded",
                "Countdown from .*:",
                "Count: .*",
                "Factorial of .* .*",
                ".* to the power of .* .*"
              ],
              "stdout": [
                "PASS: All function declarations found in header file",
                "SUCCESS: Dynamic loop test completed",
                "PASS: Countdown output correct",
                "PASS: Factorial calculation correct",
                "PASS: Power calculation correct"
              ]
            },
            "timeout": 25
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Loop implementation module loaded",
        "Countdown from 5:",
        "Count: 5",
        "Count: 4",
        "Count: 3",
        "Count: 2",
        "Count: 1",
        "Factorial of 5: 120",
        "2 to the power of 3: 8"
      ],
      "requirements": [
        "Use required function names: loops_impl_init, loops_impl_exit, print_countdown, calculate_factorial, calculate_power",
        "Use required variable names: start_number, factorial_number, base_number, power_number",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: extern int start_number, extern int factorial_number, extern int base_number, extern int power_number",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Loop implementation module loaded",
          "linkedFunction": "static int __init loops_impl_init(void)",
          "exact": true
        },
        {
          "pattern": "Countdown from 5:",
          "linkedFunction": "static int __init loops_impl_init(void)",
          "exact": true
        },
        {
          "pattern": "Count: 5",
          "linkedFunction": "void print_countdown(int start)",
          "exact": true
        },
        {
          "pattern": "Count: 4",
          "linkedFunction": "void print_countdown(int start)",
          "exact": true
        },
        {
          "pattern": "Count: 3",
          "linkedFunction": "void print_countdown(int start)",
          "exact": true
        },
        {
          "pattern": "Count: 2",
          "linkedFunction": "void print_countdown(int start)",
          "exact": true
        },
        {
          "pattern": "Count: 1",
          "linkedFunction": "void print_countdown(int start)",
          "exact": true
        },
        {
          "pattern": "Factorial of 5: 120",
          "linkedFunction": "static int __init loops_impl_init(void)",
          "exact": true
        },
        {
          "pattern": "2 to the power of 3: 8",
          "linkedFunction": "static int __init loops_impl_init(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 12,
    "title": "Arrays and Collections - Study Complete Examples",
    "difficulty": 2,
    "xp": 25,
    "phase": "foundations",
    "description": "Study complete array implementations to understand how to store and manage multiple values. This introduces data collection patterns essential for kernel development where you often need to manage lists of devices, buffers, or other resources. Observe the patterns before implementing them yourself.",
    "concepts": [
      "array declaration with #define",
      "array initialization with literal values",
      "array indexing with []",
      "array traversal with for loops",
      "maximum finding algorithms",
      "accumulation patterns",
      "linear search algorithms"
    ],
    "skills": [
      "Understanding array syntax",
      "Recognizing traversal patterns",
      "Learning search algorithms",
      "Understanding index-based access",
      "Observing accumulation patterns"
    ],
    "files": [
      {
        "name": "arrays_study.h",
        "content": "#ifndef ARRAYS_STUDY_H\n#define ARRAYS_STUDY_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* Array size definition */\n#define MAX_DEVICES 6\n\n/* Array declarations */\nextern int device_ids[MAX_DEVICES];\nextern int device_count;\n\n/* Function declarations - study these patterns */\nvoid print_all_devices(void);\nint find_max_device_id(void);\nint calculate_id_sum(void);\nbool check_device_exists(int);\n\n#endif /* ARRAYS_STUDY_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "arrays_study.c",
        "content": "#include \"arrays_study.h\"\n\n/* Array initialization with device IDs */\nint device_ids[MAX_DEVICES] = {101, 205, 150, 320, 180, 275};\nint device_count = MAX_DEVICES;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify array operations work\n * with different input values. Removing them will cause test failures.\n */\nmodule_param_array(device_ids, int, &device_count, 0644);\nMODULE_PARM_DESC(device_ids, \"Array of device IDs for testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/**\n * print_all_devices - Print all device IDs in the array\n * \n * This function demonstrates basic array traversal using a for loop.\n * Notice how we use the loop counter 'i' as an index to access\n * each array element with device_ids[i].\n */\nvoid print_all_devices(void)\n{\n    int i;\n    \n    printk(KERN_INFO \"Device listing:\\n\");\n    for (i = 0; i < device_count; i++) {\n        printk(KERN_INFO \"Device %d: ID %d\\n\", i + 1, device_ids[i]);\n    }\n}\n\n/**\n * find_max_device_id - Find the highest device ID in the array\n * Returns: The maximum device ID found\n * \n * This function shows the standard algorithm for finding maximum values:\n * 1. Start with first element as current maximum\n * 2. Compare each remaining element with current maximum\n * 3. Update maximum when a larger value is found\n */\nint find_max_device_id(void)\n{\n    int i, max_id;\n    \n    /* Initialize with first element */\n    max_id = device_ids[0];\n    \n    /* Compare with remaining elements */\n    for (i = 1; i < device_count; i++) {\n        if (device_ids[i] > max_id) {\n            max_id = device_ids[i];\n        }\n    }\n    \n    return max_id;\n}\n\n/**\n * calculate_id_sum - Calculate sum of all device IDs\n * Returns: Total sum of all device IDs\n * \n * This demonstrates the accumulation pattern:\n * 1. Initialize accumulator to 0\n * 2. Loop through array adding each element to accumulator\n * 3. Return final accumulated value\n */\nint calculate_id_sum(void)\n{\n    int i, sum = 0;\n    \n    for (i = 0; i < device_count; i++) {\n        sum += device_ids[i];\n    }\n    \n    return sum;\n}\n\n/**\n * check_device_exists - Check if a specific device ID exists in array\n * @target_id: The device ID to search for\n * Returns: true if found, false if not found\n * \n * This shows the search pattern:\n * 1. Loop through array comparing each element with target\n * 2. Return true immediately when match is found\n * 3. Return false if loop completes without finding match\n */\nbool check_device_exists(int target_id)\n{\n    int i;\n    \n    for (i = 0; i < device_count; i++) {\n        if (device_ids[i] == target_id) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nstatic int __init arrays_study_init(void)\n{\n    int max_id, total_sum;\n    bool device_found;\n    \n    printk(KERN_INFO \"Arrays study module loaded\\n\");\n    printk(KERN_INFO \"Studying array operations with %d devices\\n\", device_count);\n    \n    /* Demonstrate array traversal */\n    print_all_devices();\n    \n    /* Demonstrate maximum finding */\n    max_id = find_max_device_id();\n    printk(KERN_INFO \"Highest device ID: %d\\n\", max_id);\n    \n    /* Demonstrate accumulation */\n    total_sum = calculate_id_sum();\n    printk(KERN_INFO \"Total sum of device IDs: %d\\n\", total_sum);\n    \n    /* Demonstrate search */\n    device_found = check_device_exists(205);\n    printk(KERN_INFO \"Device 205 found: %s\\n\", device_found ? \"Yes\" : \"No\");\n    \n    device_found = check_device_exists(999);\n    printk(KERN_INFO \"Device 999 found: %s\\n\", device_found ? \"Yes\" : \"No\");\n    \n    return 0;\n}\n\nstatic void __exit arrays_study_exit(void)\n{\n    printk(KERN_INFO \"Arrays study module unloaded\\n\");\n}\n\nmodule_init(arrays_study_init);\nmodule_exit(arrays_study_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"KernelOne Educational System\");\nMODULE_DESCRIPTION(\"Study complete array implementations and patterns\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Arrays study module Makefile\nobj-m += arrays_study.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "arrays_study.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "arrays_study_init",
          "arrays_study_exit",
          "print_all_devices",
          "find_max_device_id",
          "calculate_id_sum",
          "check_device_exists"
        ],
        "variables": [
          {
            "name": "device_ids[]",
            "type": "int",
            "value": "{101, 205, 150, 320, 180, 275}"
          },
          {
            "name": "device_count",
            "type": "int",
            "value": 6
          }
        ],
        "outputMessages": [
          "Arrays study module loaded",
          "Studying array operations with 6 devices",
          "Device listing:",
          "Device 1: ID 101",
          "Device 2: ID 205",
          "Device 3: ID 150",
          "Device 4: ID 320",
          "Device 5: ID 180",
          "Device 6: ID 275",
          "Highest device ID: 320",
          "Total sum of device IDs: 1231",
          "Device 205 found: Yes",
          "Device 999 found: No"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "#define MAX_DEVICES 6",
          "int device_ids[MAX_DEVICES]",
          "module_param_array(device_ids, int, &device_count, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_all_devices(void)",
            "int find_max_device_id(void)",
            "int calculate_id_sum(void)",
            "bool check_device_exists(int)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_all_devices(void)",
            "int find_max_device_id(void)",
            "int calculate_id_sum(void)",
            "bool check_device_exists(int target_id)",
            "static int __init arrays_study_init(void)",
            "static void __exit arrays_study_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Expected Study Output",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Arrays study module loaded",
              "exact": true,
              "linkedFunction": "static int __init arrays_study_init(void)"
            },
            {
              "pattern": "Studying array operations with 6 devices",
              "exact": true,
              "linkedFunction": "static int __init arrays_study_init(void)"
            },
            {
              "pattern": "Device listing:",
              "exact": true,
              "linkedFunction": "void print_all_devices(void)"
            },
            {
              "pattern": "Device 1: ID 101",
              "exact": true,
              "linkedFunction": "void print_all_devices(void)"
            },
            {
              "pattern": "Device 6: ID 275",
              "exact": true,
              "linkedFunction": "void print_all_devices(void)"
            },
            {
              "pattern": "Highest device ID: 320",
              "exact": true,
              "linkedFunction": "static int __init arrays_study_init(void)"
            },
            {
              "pattern": "Total sum of device IDs: 1231",
              "exact": true,
              "linkedFunction": "static int __init arrays_study_init(void)"
            },
            {
              "pattern": "Device 205 found: Yes",
              "exact": true,
              "linkedFunction": "static int __init arrays_study_init(void)"
            },
            {
              "pattern": "Device 999 found: No",
              "exact": true,
              "linkedFunction": "static int __init arrays_study_init(void)"
            }
          ]
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Arrays study module loaded",
        "Studying array operations with 6 devices",
        "Device listing:",
        "Device 1: ID 101",
        "Device 2: ID 205",
        "Device 3: ID 150",
        "Device 4: ID 320",
        "Device 5: ID 180",
        "Device 6: ID 275",
        "Highest device ID: 320",
        "Total sum of device IDs: 1231",
        "Device 205 found: Yes",
        "Device 999 found: No"
      ],
      "requirements": [
        "Use required function names: arrays_study_init, arrays_study_exit, print_all_devices, find_max_device_id, calculate_id_sum, check_device_exists",
        "Use required variable names: device_ids[], device_count",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: #define MAX_DEVICES 6, int device_ids[MAX_DEVICES], module_param_array(device_ids, int, &device_count, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Arrays study module loaded",
          "linkedFunction": "static int __init arrays_study_init(void)",
          "exact": true
        },
        {
          "pattern": "Studying array operations with 6 devices",
          "linkedFunction": "static int __init arrays_study_init(void)",
          "exact": true
        },
        {
          "pattern": "Device listing:",
          "linkedFunction": "void print_all_devices(void)",
          "exact": true
        },
        {
          "pattern": "Device 1: ID 101",
          "linkedFunction": "void print_all_devices(void)",
          "exact": true
        },
        {
          "pattern": "Device 6: ID 275",
          "linkedFunction": "void print_all_devices(void)",
          "exact": true
        },
        {
          "pattern": "Highest device ID: 320",
          "linkedFunction": "static int __init arrays_study_init(void)",
          "exact": true
        },
        {
          "pattern": "Total sum of device IDs: 1231",
          "linkedFunction": "static int __init arrays_study_init(void)",
          "exact": true
        },
        {
          "pattern": "Device 205 found: Yes",
          "linkedFunction": "static int __init arrays_study_init(void)",
          "exact": true
        },
        {
          "pattern": "Device 999 found: No",
          "linkedFunction": "static int __init arrays_study_init(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 13,
    "title": "Arrays and Collections - Implement Solutions",
    "difficulty": 4,
    "xp": 40,
    "phase": "foundations",
    "description": "Implement your own array-based solutions for managing multiple values. Apply the patterns you studied in Problem 11 to create functions that process arrays, find maximum values, and calculate statistics. This builds on the complete examples you observed.",
    "concepts": [
      "array declaration",
      "array initialization",
      "array indexing",
      "array iteration",
      "data collection algorithms"
    ],
    "skills": [
      "Working with arrays",
      "Array traversal with loops",
      "Finding maximum values",
      "Calculating averages",
      "Index-based data access"
    ],
    "files": [
      {
        "name": "arrays.h",
        "content": "#ifndef ARRAYS_H\n#define ARRAYS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n#define MAX_GRADES 5\n\nextern int student_grades[MAX_GRADES];\nextern int grade_count;\n\n/* TODO: Declare your functions */\n/* void print_all_grades(void); */\n/* int find_highest_grade(void); */\n/* int calculate_average(void); */\n\n#endif /* ARRAYS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "arrays.c",
        "content": "#include \"arrays.h\"\n\n/* TODO: Initialize array with grades: {85, 92, 78, 96, 88} */\n/* int student_grades[MAX_GRADES] = {85, 92, 78, 96, 88}; */\nint grade_count = MAX_GRADES;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your array operations work\n * with different input values. Removing them will cause test failures.\n */\nmodule_param_array(student_grades, int, &grade_count, 0644);\nMODULE_PARM_DESC(student_grades, \"Array of student grades for testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* ARRAY CONCEPT: Multiple values in one variable */\n/* Instead of: int grade1=85, grade2=92, grade3=78... */\n/* We use: int student_grades[] = {85, 92, 78, 96, 88}; */\n/* Access: student_grades[0]=85, student_grades[1]=92, student_grades[2]=78... */\n/* Size: if array has 5 elements, indexes are 0,1,2,3,4 */\n\n/* ALGORITHM CONCEPT: Finding Maximum Value */\n/* How to find the largest number in a group: */\n/* Step 1: Assume first number is the largest so far */\n/* Step 2: Compare each remaining number with current largest */\n/* Step 3: If bigger number found, that becomes new largest */\n/* Example: [85,92,78] → start with 85, compare 92>85? Yes→max=92, compare 78>92? No→max stays 92 */\n\n/* ALGORITHM CONCEPT: Sum Accumulation */\n/* To sum all numbers: start with 0, add each number to total */\n/* Pattern: sum = sum + current_number */\n/* Why start with 0? Because 0 + anything = anything (additive identity) */\n\n/* MATH CONCEPT: Average calculation */\n/* Average = total_sum / number_of_items */\n/* Example: grades [85,92,78] → sum=255, count=3, average=255/3=85 */\n\n/* TODO: Implement function to print all grades */\n/* Use array indexing concept above with a for loop */\nvoid print_all_grades(void) {\n    // Your implementation here\n    // Print format: \"Grade X: Y\"\n}\n\n/* TODO: Implement function to find highest grade */\n/* Use the maximum finding algorithm concept above */\nint find_highest_grade(void) {\n    // Your implementation here\n    // Follow the step-by-step algorithm above\n}\n\n/* TODO: Implement function to calculate average */\n/* Use sum accumulation, then apply average formula */\nint calculate_average(void) {\n    // Your implementation here\n    // Use accumulation concept, then divide for average\n}\n\nstatic int __init arrays_init(void)\n{\n    int highest, average;\n    \n    printk(KERN_INFO \"Arrays module loaded\\n\");\n    \n    /* TODO: Print all grades */\n    /* print_all_grades(); */\n    \n    /* TODO: Find and print highest grade */\n    /* highest = find_highest_grade(); */\n    /* printk(KERN_INFO \"Highest grade: %d\\n\", highest); */\n    \n    /* TODO: Calculate and print average */\n    /* average = calculate_average(); */\n    /* printk(KERN_INFO \"Average grade: %d\\n\", average); */\n    \n    return 0;\n}\n\nstatic void __exit arrays_exit(void)\n{\n    printk(KERN_INFO \"Arrays module unloaded\\n\");\n}\n\nmodule_init(arrays_init);\nmodule_exit(arrays_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning arrays and data collections\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Arrays module Makefile\nobj-m += arrays.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "arrays.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "arrays_init",
          "arrays_exit",
          "print_all_grades",
          "find_highest_grade",
          "calculate_average"
        ],
        "variables": [
          {
            "name": "student_grades[MAX_GRADES]",
            "type": "int",
            "value": "{85, 92, 78, 96, 88}"
          },
          {
            "name": "grade_count",
            "type": "int",
            "value": 5
          }
        ],
        "outputMessages": [
          "Arrays module loaded",
          "Student grades:",
          "Grade 1: 85",
          "Grade 2: 92",
          "Grade 3: 78",
          "Grade 4: 96",
          "Grade 5: 88",
          "Highest grade: 96",
          "Average grade: 87"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "#define MAX_GRADES 5",
          "extern int student_grades[MAX_GRADES]",
          "extern int grade_count",
          "int student_grades[MAX_GRADES] = {85, 92, 78, 96, 88}",
          "int grade_count = MAX_GRADES"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_all_grades(void)",
            "int find_highest_grade(void)",
            "int calculate_average(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_all_grades(void)",
            "int find_highest_grade(void)",
            "int calculate_average(void)",
            "static int __init arrays_init(void)",
            "static void __exit arrays_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Basic Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Arrays module loaded",
              "exact": true,
              "linkedFunction": "static int __init arrays_init(void)"
            },
            {
              "pattern": "Student grades:",
              "exact": true,
              "linkedFunction": "void print_all_grades(void)"
            },
            {
              "pattern": "Grade 1: 85",
              "exact": true,
              "linkedFunction": "void print_all_grades(void)"
            },
            {
              "pattern": "Grade 2: 92",
              "exact": true,
              "linkedFunction": "void print_all_grades(void)"
            },
            {
              "pattern": "Grade 3: 78",
              "exact": true,
              "linkedFunction": "void print_all_grades(void)"
            },
            {
              "pattern": "Grade 4: 96",
              "exact": true,
              "linkedFunction": "void print_all_grades(void)"
            },
            {
              "pattern": "Grade 5: 88",
              "exact": true,
              "linkedFunction": "void print_all_grades(void)"
            },
            {
              "pattern": "Highest grade: 96",
              "exact": true,
              "linkedFunction": "static int __init arrays_init(void)"
            },
            {
              "pattern": "Average grade: 87",
              "exact": true,
              "linkedFunction": "static int __init arrays_init(void)"
            }
          ]
        },
        {
          "id": "advanced_array_implementation_validation",
          "name": "Advanced Array Implementation with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "array_impl_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\"=== Dynamic Array Implementation Test ===\\\\n\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random test arrays\\n    int grades1[3] = {(rand() % 40) + 60, (rand() % 40) + 60, (rand() % 40) + 60};  // 60-99 range\\n    int grades2[4] = {(rand() % 30) + 70, (rand() % 30) + 70, (rand() % 30) + 70, (rand() % 30) + 70};  // 70-99 range\\n    \\n    printf(\"Test 1: Array with %d,%d,%d\\\\n\", grades1[0], grades1[1], grades1[2]);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \"insmod /lib/modules/arrays.ko student_grades=%d,%d,%d\", grades1[0], grades1[1], grades1[2]);\\n    system(\"rmmod arrays 2>/dev/null\");\\n    system(cmd1);\\n    \\n    printf(\"Test 2: Array with %d,%d,%d,%d\\\\n\", grades2[0], grades2[1], grades2[2], grades2[3]);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \"insmod /lib/modules/arrays.ko student_grades=%d,%d,%d,%d\", grades2[0], grades2[1], grades2[2], grades2[3]);\\n    system(\"rmmod arrays\");\\n    system(cmd2);\\n    \\n    printf(\"SUCCESS: Dynamic array test completed\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced array implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param_array(name, type, nump, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo '#define true 1' >> /tmp/linux/types.h",
              "echo '#define false 0' >> /tmp/linux/types.h",
              "echo 'Creating test file that includes student header...'",
              "echo '#include \"/lib/modules/arrays.h\"' > /tmp/test.c",
              "echo 'int main() { print_all_grades(); find_highest_grade(); calculate_average(); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: All function declarations found in header file'",
              "echo 'Phase 2: Dynamic Array Implementation Testing'",
              "/bin/array_impl_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Dynamic Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "TEST1_LINE=$(grep 'Test 1: Array with' /tmp/test_output.log)",
              "TEST2_LINE=$(grep 'Test 2: Array with' /tmp/test_output.log)",
              "echo 'Test 1 values: '$TEST1_LINE",
              "echo 'Test 2 values: '$TEST2_LINE",
              "echo 'Validating array processing output'",
              "dmesg | grep 'Student grades:' && echo 'PASS: Array output found' || echo 'FAIL: Array output missing'",
              "dmesg | grep 'Grade.*:.*[0-9]' && echo 'PASS: Grade enumeration working' || echo 'FAIL: Grade enumeration broken'",
              "dmesg | grep 'Highest grade:.*[0-9]' && echo 'PASS: Maximum finding working' || echo 'FAIL: Maximum finding broken'",
              "dmesg | grep 'Average grade:.*[0-9]' && echo 'PASS: Average calculation working' || echo 'FAIL: Average calculation broken'",
              "echo 'All dynamic validations completed'"
            ],
            "expected": {
              "dmesg": [
                "Arrays module loaded",
                "Student grades:",
                "Grade .* .*",
                "Highest grade: .*",
                "Average grade: .*"
              ],
              "stdout": [
                "PASS: All function declarations found in header file",
                "SUCCESS: Dynamic array test completed",
                "PASS: Array output found",
                "PASS: Grade enumeration working",
                "PASS: Maximum finding working",
                "PASS: Average calculation working"
              ]
            },
            "timeout": 30
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Arrays module loaded",
        "Student grades:",
        "Grade 1: 85",
        "Grade 2: 92",
        "Grade 3: 78",
        "Grade 4: 96",
        "Grade 5: 88",
        "Highest grade: 96",
        "Average grade: 87"
      ],
      "requirements": [
        "Use required function names: arrays_init, arrays_exit, print_all_grades, find_highest_grade, calculate_average",
        "Use required variable names: student_grades[MAX_GRADES], grade_count",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: #define MAX_GRADES 5, extern int student_grades[MAX_GRADES], extern int grade_count, int student_grades[MAX_GRADES] = {85, 92, 78, 96, 88}, int grade_count = MAX_GRADES",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Arrays module loaded",
          "linkedFunction": "static int __init arrays_init(void)",
          "exact": true
        },
        {
          "pattern": "Student grades:",
          "linkedFunction": "void print_all_grades(void)",
          "exact": true
        },
        {
          "pattern": "Grade 1: 85",
          "linkedFunction": "void print_all_grades(void)",
          "exact": true
        },
        {
          "pattern": "Grade 2: 92",
          "linkedFunction": "void print_all_grades(void)",
          "exact": true
        },
        {
          "pattern": "Grade 3: 78",
          "linkedFunction": "void print_all_grades(void)",
          "exact": true
        },
        {
          "pattern": "Grade 4: 96",
          "linkedFunction": "void print_all_grades(void)",
          "exact": true
        },
        {
          "pattern": "Grade 5: 88",
          "linkedFunction": "void print_all_grades(void)",
          "exact": true
        },
        {
          "pattern": "Highest grade: 96",
          "linkedFunction": "static int __init arrays_init(void)",
          "exact": true
        },
        {
          "pattern": "Average grade: 87",
          "linkedFunction": "static int __init arrays_init(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 14,
    "title": "String Basics - Arrays of Characters",
    "difficulty": 2,
    "xp": 25,
    "phase": "foundations",
    "description": "Learn that strings are just arrays of characters! This builds directly on the arrays problem - instead of int arrays, we use char arrays. No pointers, no parameters, just simple array indexing like device_name[0], device_name[1], etc.",
    "concepts": [
      "char arrays (strings) vs int arrays",
      "string initialization with literals",
      "null terminator concept (\\0)",
      "array indexing for characters",
      "manual character counting",
      "character-by-character assignment"
    ],
    "skills": [
      "Treating strings like arrays",
      "Using array indexing for characters",
      "Understanding null termination",
      "Manual character operations",
      "No-pointer string manipulation"
    ],
    "files": [
      {
        "name": "strings.h",
        "content": "#ifndef STRINGS_H\n#define STRINGS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/string.h>\n\n#define MAX_NAME_SIZE 32\n#define MAX_MESSAGE_SIZE 64\n\nextern char device_name[MAX_NAME_SIZE];\nextern char welcome_msg[MAX_MESSAGE_SIZE];\nextern int name_len;\n\n/* TODO: Declare your functions (no pointers!) */\n/* void show_device_info(void); */\n/* void count_device_name_length(void); */\n/* void update_to_new_device(void); */\n\n#endif /* STRINGS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "strings.c",
        "content": "#include \"strings.h\"\n\n/* TODO: Initialize your string arrays (just like int arrays!) */\n/* char device_name[MAX_NAME_SIZE] = \"my_device\"; */\n/* char welcome_msg[MAX_MESSAGE_SIZE] = \"Hello from kernel!\"; */\nint name_len = 0;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your string operations work\n * with different input values. Removing them will cause test failures.\n */\nmodule_param_string(device_name, device_name, MAX_NAME_SIZE, 0644);\nMODULE_PARM_DESC(device_name, \"Device name for testing string operations\");\nmodule_param_string(welcome_msg, welcome_msg, MAX_MESSAGE_SIZE, 0644);\nMODULE_PARM_DESC(welcome_msg, \"Welcome message for string operations\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* TODO: Implement function to show device information */\n/* Print device name and its length using printk */\n/* Format: \"Device: [name], Length: [X]\" */\n\n/* TODO: Implement function to count device_name length manually */\n/* Count characters in device_name until you find '\\0' */\n/* Use a for loop like: for (i = 0; i < MAX_NAME_SIZE; i++) */\n/* Update the global name_len variable */\n\n/* TODO: Implement function to manually copy \"new_device\" */\n/* Copy each character one by one: device_name[0] = 'n', device_name[1] = 'e', etc. */\n/* Don't forget to add null terminator at the end: device_name[10] = '\\0' */\n/* Call count_device_name_length() to update name_len */\n\nstatic int __init strings_init(void)\n{\n    printk(KERN_INFO \"String basics module loaded\\n\");\n    \n    /* TODO: Calculate length of device name */\n    /* count_device_name_length(); */\n    \n    /* TODO: Show initial device info */\n    /* show_device_info(); */\n    \n    /* TODO: Print the welcome message */\n/* printk(KERN_INFO \"Message: %s\\n\", welcome_msg); */\n    \n    /* TODO: Update to new device name and show info */\n    /* update_to_new_device(); */\n    /* printk(KERN_INFO \"After name change:\\n\"); */\n    /* show_device_info(); */\n    \n    return 0;\n}\n\nstatic void __exit strings_exit(void)\n{\n    printk(KERN_INFO \"String basics module unloaded\\n\");\n}\n\nmodule_init(strings_init);\nmodule_exit(strings_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning strings as character arrays\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# String basics module Makefile\nobj-m += strings.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "strings.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "strings_init",
          "strings_exit",
          "show_device_info",
          "count_device_name_length",
          "update_to_new_device"
        ],
        "variables": [
          {
            "name": "device_name[]",
            "type": "char",
            "value": "\"my_device\""
          },
          {
            "name": "welcome_msg[]",
            "type": "char",
            "value": "\"Hello from kernel!\""
          },
          {
            "name": "name_len",
            "type": "int",
            "value": " 0"
          }
        ],
        "outputMessages": [
          "String basics module loaded",
          "Device: my_device, Length: 9",
          "Message: Hello from kernel!",
          "After name change:",
          "Device: new_device, Length: 10"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/string.h"
        ],
        "mustContain": [
          "#define MAX_NAME_SIZE 32",
          "#define MAX_MESSAGE_SIZE 64",
          "char device_name[MAX_NAME_SIZE]",
          "char welcome_msg[MAX_MESSAGE_SIZE]"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header (No Pointers)",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void show_device_info(void)",
            "void count_device_name_length(void)",
            "void update_to_new_device(void)"
          ],
          "prohibitedSymbols": [
            "const char \\*",
            "char \\*"
          ]
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File (No Pointers)",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void show_device_info(void)",
            "void count_device_name_length(void)",
            "void update_to_new_device(void)",
            "static int __init strings_init(void)",
            "static void __exit strings_exit(void)"
          ],
          "prohibitedSymbols": [
            "const char \\*",
            "char \\*"
          ]
        },
        {
          "id": "exact_output",
          "name": "Expected Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "String basics module loaded",
              "exact": true,
              "linkedFunction": "static int __init strings_init(void)"
            },
            {
              "pattern": "Device: my_device, Length: 9",
              "exact": true,
              "linkedFunction": "void show_device_info(void)"
            },
            {
              "pattern": "Message: Hello from kernel!",
              "exact": true,
              "linkedFunction": "static int __init strings_init(void)"
            },
            {
              "pattern": "After name change:",
              "exact": true,
              "linkedFunction": "static int __init strings_init(void)"
            },
            {
              "pattern": "Device: new_device, Length: 10",
              "exact": true,
              "linkedFunction": "void show_device_info(void)"
            }
          ]
        },
        {
          "id": "basic_string_implementation_validation",
          "name": "Basic String Implementation with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "string_dynamic_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\"=== Dynamic String Implementation Test ===\\\\n\");\\n    \\n    // Generate randomized test cases\\n    const char* device_names[] = {\\\"sensor\\\", \\\"device\\\", \\\"module\\\", \\\"driver\\\", \\\"kernel\\\", \\\"system\\\"};\\n    const char* messages[] = {\\\"Hello\\\", \\\"Greetings\\\", \\\"Welcome\\\", \\\"Status\\\", \\\"Testing\\\", \\\"Active\\\"};\\n    \\n    srand(time(NULL));\\n    int name_idx = rand() % 6;\\n    int msg_idx = rand() % 6;\\n    \\n    printf(\\\"Test 1: Testing with device_name='%s' and welcome_msg='%s'\\\\n\\\", device_names[name_idx], messages[msg_idx]);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/strings.ko device_name=%s welcome_msg=%s\\\", device_names[name_idx], messages[msg_idx]);\\n    system(\\\"rmmod strings 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    // Generate second test with different values\\n    int name_idx2 = (name_idx + 2) % 6;\\n    int msg_idx2 = (msg_idx + 3) % 6;\\n    \\n    printf(\\\"Test 2: Testing with device_name='%s' and welcome_msg='%s'\\\\n\\\", device_names[name_idx2], messages[msg_idx2]);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/strings.ko device_name=%s welcome_msg=%s\\\", device_names[name_idx2], messages[msg_idx2]);\\n    system(\\\"rmmod strings\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Dynamic string test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting basic string implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param_string(name, string, len, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef unsigned long size_t;' > /tmp/linux/string.h",
              "echo 'size_t strlen(const char *s);' >> /tmp/linux/string.h",
              "echo 'Creating test file that includes student header...'",
              "echo '#include \"/lib/modules/strings.h\"' > /tmp/test.c",
              "echo 'int main() { show_device_info(); count_device_name_length(); update_to_new_device(); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: All function declarations found in header file'",
              "echo 'Phase 2: Dynamic String Implementation Testing'",
              "/bin/string_dynamic_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Dynamic Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "TEST1_DEVICE=$(grep -o \"Test 1: Testing with device_name='[^']*'\" /tmp/test_output.log | cut -d\"'\" -f2)",
              "TEST1_MESSAGE=$(grep -o \"Test 1: Testing with device_name='[^']*' and welcome_msg='[^']*'\" /tmp/test_output.log | cut -d\"'\" -f4)",
              "TEST2_DEVICE=$(grep -o \"Test 2: Testing with device_name='[^']*'\" /tmp/test_output.log | cut -d\"'\" -f2)",
              "TEST2_MESSAGE=$(grep -o \"Test 2: Testing with device_name='[^']*' and welcome_msg='[^']*'\" /tmp/test_output.log | cut -d\"'\" -f4)",
              "echo \"Test 1 device: '$TEST1_DEVICE', message: '$TEST1_MESSAGE'\"",
              "echo \"Test 2 device: '$TEST2_DEVICE', message: '$TEST2_MESSAGE'\"",
              "echo 'Calculating expected string lengths...'",
              "TEST1_EXPECTED_LEN=$(echo -n \"$TEST1_DEVICE\" | awk '{print length}')",
              "TEST2_EXPECTED_LEN=$(echo -n \"$TEST2_DEVICE\" | awk '{print length}')",
              "echo \"Expected: $TEST1_DEVICE = $TEST1_EXPECTED_LEN chars, $TEST2_DEVICE = $TEST2_EXPECTED_LEN chars\"",
              "echo 'Validating Test 1 string operations'",
              "dmesg | grep \"Device: $TEST1_DEVICE, Length: $TEST1_EXPECTED_LEN\" && echo 'PASS: Test 1 device name and length correct' || echo \"FAIL: Test 1 length wrong - expected $TEST1_EXPECTED_LEN for '$TEST1_DEVICE'\"",
              "dmesg | grep \"Message: $TEST1_MESSAGE\" && echo 'PASS: Test 1 message correct' || echo 'FAIL: Test 1 message wrong'",
              "echo 'Validating Test 2 string operations'",
              "dmesg | grep \"Device: $TEST2_DEVICE, Length: $TEST2_EXPECTED_LEN\" && echo 'PASS: Test 2 device name and length correct' || echo \"FAIL: Test 2 length wrong - expected $TEST2_EXPECTED_LEN for '$TEST2_DEVICE'\"",
              "dmesg | grep \"Message: $TEST2_MESSAGE\" && echo 'PASS: Test 2 message correct' || echo 'FAIL: Test 2 message wrong'",
              "echo 'Validating function behavior (new_device length should be 10)'",
              "dmesg | grep 'Device: new_device, Length: 10' && echo 'PASS: new_device length calculation correct' || echo 'FAIL: new_device length wrong - expected 10'",
              "dmesg | grep 'After name change:' && echo 'PASS: Name change function working' || echo 'FAIL: Name change function broken'",
              "echo 'All dynamic string validations completed'"
            ],
            "expected": {
              "dmesg": [
                "String basics module loaded",
                "Device: .* Length: .*",
                "Message: .*",
                "After name change:",
                "Device: .* Length: .*"
              ],
              "stdout": [
                "PASS: All function declarations found in header file",
                "SUCCESS: Dynamic string test completed",
                "PASS: Test 1 device name and length correct",
                "PASS: Test 1 message correct",
                "PASS: Test 2 device name and length correct",
                "PASS: Test 2 message correct",
                "PASS: new_device length calculation correct",
                "PASS: Name change function working"
              ]
            },
            "timeout": 30
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "String basics module loaded",
        "Device: my_device, Length: 9",
        "Message: Hello from kernel!",
        "After name change:",
        "Device: new_device, Length: 10"
      ],
      "requirements": [
        "Use required function names: strings_init, strings_exit, show_device_info, count_device_name_length, update_to_new_device",
        "Use required variable names: device_name[], welcome_msg[], name_len",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/string.h",
        "Code must contain: #define MAX_NAME_SIZE 32, #define MAX_MESSAGE_SIZE 64, char device_name[MAX_NAME_SIZE], char welcome_msg[MAX_MESSAGE_SIZE]",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "String basics module loaded",
          "linkedFunction": "static int __init strings_init(void)",
          "exact": true
        },
        {
          "pattern": "Device: my_device, Length: 9",
          "linkedFunction": "void show_device_info(void)",
          "exact": true
        },
        {
          "pattern": "Message: Hello from kernel!",
          "linkedFunction": "static int __init strings_init(void)",
          "exact": true
        },
        {
          "pattern": "After name change:",
          "linkedFunction": "static int __init strings_init(void)",
          "exact": true
        },
        {
          "pattern": "Device: new_device, Length: 10",
          "linkedFunction": "void show_device_info(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 15,
    "title": "Basic Pointers - Introduction to Memory Addresses",
    "difficulty": 3,
    "xp": 25,
    "phase": "foundations",
    "description": "Learn the fundamental concepts of pointers in C. Understand what pointers are, how to declare them, use the address-of operator (&), dereference operator (*), and perform basic operations with integers and arrays through pointers.",
    "concepts": [
      "basic pointer declaration",
      "address-of operator (&)",
      "dereference operator (*)",
      "pointer initialization",
      "array access through pointers",
      "modifying values through pointers"
    ],
    "skills": [
      "Understanding what pointers are",
      "Declaring and initializing pointers",
      "Using & to get addresses",
      "Using * to access values through pointers",
      "Basic pointer arithmetic with arrays",
      "Modifying variables through pointers"
    ],
    "files": [
      {
        "name": "POINTER_VISUAL_GUIDE.md",
        "content": "# Pointers - Visual Guide for Absolute Beginners\n\n## Understanding the Core Concept\n\nThis guide uses **generic examples** (not the specific problem solution) to help you understand pointers step-by-step with visual diagrams.\n\n## What is a Pointer? The House Analogy\n\nThink of your computer's memory as a street with houses:\n\n```\nStreet: Memory\n   \n House at      House at      House at      House at    \n 0x1000        0x1004        0x1008        0x100C      \n                                                       \n Contains: 5   Contains: 0   Contains: 0   Contains: 0 \n   \n```\n\n**Variable = The house with a value inside**\n**Address = The street address of the house (0x1000)**\n**Pointer = A piece of paper with an address written on it**\n\n---\n\n## Part 1: Variables and Memory Addresses\n\n### Every Variable Lives Somewhere in Memory\n\nWhen you create a variable:\n```c\nint age = 25;\n```\n\nThe computer:\n1. Finds empty space in memory (say, address 0x1000)\n2. Stores the value 25 there\n3. Remembers \"age\" refers to address 0x1000\n\n**Memory Visualization:**\n```\nVariable Name: age\nMemory Address: 0x1000\n\n  age = 25          The variable holds the VALUE\n\n     \n     Address: 0x1000   The LOCATION where it's stored\n```\n\n---\n\n## Part 2: The & Operator (Address-Of)\n\n### What & Does: \"Tell me WHERE this variable lives\"\n\n```c\nint age = 25;\nint* address_of_age = &age;  // & means \"get the address of age\"\n```\n\n**Visual Explanation:**\n\n```\nBEFORE using &:\nYou have: age (the house with value 25)\n\nAFTER using &age:\nYou get: 0x1000 (the street address of the house)\n\nMemory:\n         age variable           address_of_age variable\n   \n Address: 0x1000             Address: 0x2000      \n Value: 25                   Value: 0x1000          Stores address of age!\n   \n                                       \n                                       \n         \n              Points to age\n```\n\n**Key Insight:**\n- `age` gives you **25** (the value)\n- `&age` gives you **0x1000** (the address where 25 is stored)\n\n---\n\n## Part 3: Pointer Declaration\n\n### What is int* ?\n\n```c\nint* ptr;\n```\n\nThis declares a variable that can **store an address** of an integer.\n\n**Breaking it down:**\n```\nint*  ptr\n      \n |      Variable name\n |\n  Type: \"pointer to an integer\"\n```\n\n**Memory Visualization:**\n```\nUninitialized pointer:\n\n ptr = ????????     Contains garbage! DON'T USE YET!\n\n\nInitialized pointer:\nint age = 25;\nint* ptr = &age;\n\n   Points to   \n ptr = 0x1000       age = 25         \n                \n  Address: 0x2000                     Address: 0x1000\n```\n\n**Important Rules:**\n1. **ALWAYS** initialize pointers before using them\n2. Uninitialized pointers contain random garbage\n3. Using an uninitialized pointer = **CRASH!**\n\n---\n\n## Part 4: The * Operator (Dereference)\n\n### What * Does: \"Go to the address and get the value there\"\n\n```c\nint age = 25;\nint* ptr = &age;   // ptr now contains 0x1000\nint value = *ptr;  // * means \"get value at address ptr\"\n```\n\n**Step-by-Step Visual:**\n\n```\nSTEP 1: Create variable\n\n age = 25         \n\n  Address: 0x1000\n\nSTEP 2: Get address\nint* ptr = &age;\n\n         \n ptr = 0x1000       age = 25         \n         \n  Address: 0x2000             Address: 0x1000\n\nSTEP 3: Dereference\nint value = *ptr;\n\nWhat happens:\n1. ptr contains 0x1000\n2. *ptr means \"go to address 0x1000\"\n3. Read the value there: 25\n4. value now equals 25\n\nResult:\n\n value = 25          Got the value from age through the pointer!\n\n```\n\n**Key Insight:**\n- `ptr` gives you **0x1000** (the address)\n- `*ptr` gives you **25** (the value at that address)\n\n---\n\n## Part 5: The Two Faces of *\n\n### * Has Two Different Meanings! (Common Source of Confusion)\n\n**Meaning 1: Declaration (when creating a pointer)**\n```c\nint* ptr;\n    \n    Declares ptr as a \"pointer to int\"\n```\n\n**Meaning 2: Dereference (when using a pointer)**\n```c\n*ptr = 10;\n \n \"Go to the address in ptr and put 10 there\"\n```\n\n**Visual Example:**\n```c\nint age = 25;\nint* ptr = &age;  // * in declaration: \"ptr is a pointer to int\"\n*ptr = 30;        // * in use: \"set value at address ptr to 30\"\n```\n\n**Memory Changes:**\n```\nBEFORE: *ptr = 30;\n         \n ptr = 0x1000       age = 25         \n         \n\nAFTER: *ptr = 30;\n         \n ptr = 0x1000       age = 30           Changed!\n         \n```\n\n**Now age == 30 because we modified it through the pointer!**\n\n---\n\n## Part 6: Complete Example - Step by Step\n\nLet's walk through a complete example with full memory visualization:\n\n```c\nint score = 100;\nint* score_ptr = &score;\n*score_ptr = 200;\n```\n\n### Step 1: Create Variable\n\n```c\nint score = 100;\n```\n\n```\nMemory Map:\nAddress    Variable    Value\n0x1000     score       100\n\nVisual:\n\n score = 100         \n\n  Address: 0x1000\n```\n\n### Step 2: Create Pointer\n\n```c\nint* score_ptr = &score;\n```\n\n```\nMemory Map:\nAddress    Variable      Value\n0x1000     score         100\n0x2000     score_ptr     0x1000   Points to score!\n\nVisual:\n         \n score_ptr = 0x1000    score = 100         \n         \n  Address: 0x2000                 Address: 0x1000\n\nRelationship:\n- score_ptr CONTAINS the address 0x1000\n- score_ptr POINTS TO score\n- Following the pointer gets you from score_ptr to score\n```\n\n### Step 3: Modify Through Pointer\n\n```c\n*score_ptr = 200;\n```\n\n```\nWhat happens:\n1. score_ptr contains 0x1000\n2. *score_ptr means \"go to address 0x1000\"\n3. Set the value there to 200\n4. Since score lives at 0x1000, score is now 200!\n\nMemory Map BEFORE:\nAddress    Variable      Value\n0x1000     score         100     About to change\n0x2000     score_ptr     0x1000\n\nMemory Map AFTER:\nAddress    Variable      Value\n0x1000     score         200     Changed!\n0x2000     score_ptr     0x1000  Unchanged (still points to same place)\n\nVisual:\n         \n score_ptr = 0x1000    score = 200           Modified!\n         \n  Address: 0x2000                 Address: 0x1000\n```\n\n**Result: score is now 200, even though we modified it through score_ptr!**\n\n---\n\n## Part 7: Pointer Arithmetic with Arrays\n\n### Arrays and Pointers are Closely Related\n\n```c\nint numbers[3] = {10, 20, 30};\nint* ptr = numbers;  // Same as ptr = &numbers[0]\n```\n\n**Memory Layout of Array:**\n\n```\nArray in memory (contiguous):\n  \n  10     20     30  \n  \n                  \n                  \n0x1000   0x1004   0x1008   Each int takes 4 bytes\n\nIndex:    0        1        2\n```\n\n**Pointer to Array:**\n\n```\nint* ptr = numbers;\n\n\n ptr = 0x1000     \n         \n                            \nArray:                     \n                           10     20     30  \n                           \n                          0x1000   0x1004   0x1008\n\nptr points to the FIRST element (index 0)\n```\n\n### Accessing Array Elements Through Pointer\n\n**Three Ways to Access the Same Element:**\n\n```c\nnumbers[0]    // Array notation\n*ptr          // Pointer dereference\n*(ptr + 0)    // Pointer arithmetic\n```\n\nAll three give you **10** (the first element).\n\n**Visual Explanation of Pointer Arithmetic:**\n\n```\nAccessing numbers[1] (the value 20):\n\nMethod 1: Array notation\nnumbers[1]   20\n\nMethod 2: Pointer arithmetic\nptr + 1      Calculate new address: 0x1000 + (1  4 bytes) = 0x1004\n*(ptr + 1)   Go to address 0x1004 and get value: 20\n\nVisual:\n         ptr\n          \n  \n  10     20     30  \n  \n 0x1000   0x1004   0x1008\n          \n        ptr + 1\n\n*(ptr + 1) = 20\n```\n\n**Why +1 Adds 4 Bytes:**\n\nPointers are \"smart\" - they know the size of what they point to:\n- ptr is an `int*` (pointer to int)\n- Ints are 4 bytes on most systems\n- ptr + 1 automatically adds 4 bytes (sizeof(int))\n- ptr + 2 adds 8 bytes, ptr + 3 adds 12 bytes, etc.\n\n**Complete Array Access Examples:**\n\n```\nArray: numbers = {10, 20, 30}\nPointer: int* ptr = numbers;\n\nAccessing each element:\n\n\n Array Notation    Pointer Math     Value        \n\n numbers[0]        *(ptr + 0)       10           \n numbers[1]        *(ptr + 1)       20           \n numbers[2]        *(ptr + 2)       30           \n\n\nVisual:\n         *ptr      *(ptr+1)   *(ptr+2)\n                              \n  \n  10     20     30  \n  \n 0x1000   0x1004   0x1008\n    \n   ptr\n```\n\n---\n\n## Part 8: Modifying Values Through Pointers\n\n### Why This is Powerful\n\nPointers let you **modify variables indirectly**.\n\n**Example: Function that Modifies a Variable**\n\n```c\nvoid double_value(int* ptr) {\n    *ptr = *ptr * 2;  // Double the value at the address\n}\n\nint main() {\n    int num = 5;\n    double_value(&num);  // Pass address of num\n    // Now num == 10!\n}\n```\n\n**Step-by-Step Visual:**\n\n```\nSTEP 1: Initial state\n\n num = 5          \n\n  Address: 0x1000\n\nSTEP 2: Call double_value(&num)\nPassing 0x1000 to the function\n\nInside double_value:\n         \n ptr = 0x1000       num = 5          \n         \n  (parameter)                 (caller's variable)\n\nSTEP 3: Execute *ptr = *ptr * 2\n1. *ptr (right side) = 5     (get current value)\n2. 5 * 2 = 10                (calculate)\n3. *ptr (left side) = 10     (store at address 0x1000)\n\n         \n ptr = 0x1000       num = 10           Changed!\n         \n\nSTEP 4: Return from function\nBack in main(), num is now 10!\n\n num = 10           Successfully modified through pointer!\n\n```\n\n**This is how functions modify caller's variables!**\n\n---\n\n## Part 9: Common Mistakes (Visualized)\n\n### Mistake 1: Confusing Value and Address\n\n```c\nint age = 25;\nint* ptr = age;  //  WRONG! age is a value (25), not an address\n```\n\n```\nWhat you're trying:\n\n ptr = 25           Pointer contains 25, thinks it's an address!\n\n\nIf you try *ptr:\nComputer goes to address 25 (0x00000019)\nThat's probably not valid memory  CRASH!\n\nCORRECT version:\nint* ptr = &age;  //  Use & to get the address\n\n         \n ptr = 0x1000       age = 25         \n         \n```\n\n### Mistake 2: Dereferencing Uninitialized Pointer\n\n```c\nint* ptr;        // Contains garbage (random address)\n*ptr = 10;       //  CRASH! Writing to random memory location\n```\n\n```\nUninitialized:\n\n ptr = 0xDEADBEEF   Random garbage address!\n\n         \n          ????   Points to who knows where!\n\nWhen you do *ptr = 10:\nComputer tries to write 10 to address 0xDEADBEEF\nThat's not your memory  CRASH!\n\nCORRECT version:\nint value = 0;\nint* ptr = &value;  //  Initialize first!\n*ptr = 10;          //  Now safe\n```\n\n### Mistake 3: Forgetting the *\n\n```c\nint age = 25;\nint* ptr = &age;\nptr = 30;        //  WRONG! Sets ptr to address 30, not the value\n```\n\n```\nWRONG (ptr = 30):\nBEFORE:                       AFTER:\n         \n ptr = 0x1000               ptr = 30           Now points to invalid address!\n         \n                                     \n                                      CRASH!\n         \n age = 25                   age = 25           Unchanged!\n         \n\nCORRECT (*ptr = 30):\nBEFORE:                       AFTER:\n         \n ptr = 0x1000               ptr = 0x1000       Still points to age\n         \n                                     \n                                     \n         \n age = 25                   age = 30           Changed through pointer!\n         \n```\n\n### Mistake 4: Using NULL Pointer\n\n```c\nint* ptr = NULL;\n*ptr = 10;       //  CRASH! NULL means \"points to nothing\"\n```\n\n```\nNULL pointer:\n\n ptr = NULL         (nothing)\n\n\n*ptr tries to access memory at address 0\n Segmentation Fault (CRASH!)\n\nCORRECT version - Check before using:\nif (ptr != NULL) {\n    *ptr = 10;  //  Safe\n}\n```\n\n---\n\n## Part 10: Quick Reference Chart\n\n### Operator Summary\n\n```\n\n Operator     Name                  What it does   \n\n &variable    Address-of            Get address    \n *pointer     Dereference           Get value      \n int* ptr     Pointer declaration   Declare ptr    \n ptr + n      Pointer arithmetic    Move n items   \n\n```\n\n### Complete Example Flow\n\n```c\nint age = 25;          // Create variable\nint* ptr = &age;       // Get its address\nint value = *ptr;      // Read through pointer (value = 25)\n*ptr = 30;             // Write through pointer (age = 30)\n```\n\n```\nVisual Flow:\n\nStep 1: int age = 25\n\n age = 25         \n\n  0x1000\n\nStep 2: int* ptr = &age\n         \n ptr = 0x1000       age = 25         \n         \n  0x2000                       0x1000\n\nStep 3: int value = *ptr\n                  \n ptr = 0x1000       age = 25                   value = 25       \n                  \n  0x2000                       0x1000                       0x3000\n                                    \n                                     Copied to value\n\nStep 4: *ptr = 30\n         \n ptr = 0x1000       age = 30           Modified!\n         \n  0x2000                       0x1000\n```\n\n---\n\n## Part 11: Memory Layout Summary\n\n### Understanding Addresses\n\nReal computer memory:\n```\nLow addresses (0x0000...)\n        \n\n  System Memory  \n\n  Program Code   \n\n  Your Variables   This is where age, ptr, etc. live\n\n  Stack          \n\n  Heap           \n\n  ...            \n\n        \nHigh addresses (0xFFFF...)\n```\n\n### Size of Things in Memory\n\n```\n\n Type             Size (bytes)  Example         \n\n char             1             'A'             \n int              4             42              \n long             8             1000000         \n pointer (any*)   8             0x1000          \n\n\nNote: Pointers are always the same size (8 bytes on 64-bit systems),\nregardless of what they point to!\n```\n\n---\n\n## Part 12: Practical Examples\n\n### Example 1: Swap Two Numbers\n\n```c\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint x = 5, y = 10;\nswap(&x, &y);\n// Now x = 10, y = 5\n```\n\n**Visual:**\n```\nBEFORE swap:\n  \n x = 5       y = 10   \n  \n  0x1000        0x1004\n\nCall swap(&x, &y):\nInside swap:\n      \n a=0x1000  x = 5       b=0x1004  y = 10   \n      \n\nExecute: temp = *a\n\n temp = 5 \n\n\nExecute: *a = *b\n  \n a=0x1000  x = 10     Changed!\n  \n\nExecute: *b = temp\n  \n b=0x1004  y = 5      Changed!\n  \n\nAFTER swap:\n  \n x = 10      y = 5      Swapped!\n  \n```\n\n### Example 2: Array Iteration with Pointer\n\n```c\nint numbers[3] = {10, 20, 30};\nint* ptr = numbers;\n\n// Print all elements\nfor (int i = 0; i < 3; i++) {\n    printk(\"%d \", *(ptr + i));\n}\n// Prints: 10 20 30\n```\n\n**Visual:**\n```\nArray in memory:\n  \n  10     20     30  \n  \n 0x1000   0x1004   0x1008\n\nIteration:\ni = 0: *(ptr + 0)  *(0x1000) = 10\n       \n  \n  10     20     30  \n  \n\ni = 1: *(ptr + 1)  *(0x1004) = 20\n              \n  \n  10     20     30  \n  \n\ni = 2: *(ptr + 2)  *(0x1008) = 30\n                     \n  \n  10     20     30  \n  \n```\n\n---\n\n## Key Takeaways\n\n### The Essential Rules\n\n1. **& gives you an address**\n   ```c\n   &variable  Returns the memory address where variable lives\n   ```\n\n2. **\\* accesses the value at an address**\n   ```c\n   *pointer  Goes to the address and gets/sets the value there\n   ```\n\n3. **Always initialize pointers**\n   ```c\n   int* ptr = &some_variable;  //  Good\n   int* ptr;                   //  Dangerous!\n   ```\n\n4. **Pointers and arrays are related**\n   ```c\n   array[i]  *(array + i)  // Same thing!\n   ```\n\n5. **NULL means \"points to nothing\"**\n   ```c\n   if (ptr != NULL) {  //  Always check before using\n       *ptr = value;\n   }\n   ```\n\n### Mental Model\n\nAlways remember:\n- **Variable** = A box holding a value\n- **Address** = The location of that box in memory\n- **Pointer** = A variable that stores an address\n- **&** = \"Where is this box?\" (get address)\n- **\\*** = \"What's inside the box at this address?\" (get/set value)\n\n---\n\n## You're Ready!\n\nNow apply these concepts to your problem:\n1. Declare pointers correctly\n2. Use & to get addresses\n3. Use * to access/modify values\n4. Practice pointer arithmetic with arrays\n\nPointers are the foundation of C programming. Master them here, and everything else becomes easier!\n",
        "readOnly": true,
        "language": "txt"
      },
      {
        "name": "basic_pointers.h",
        "content": "#ifndef BASIC_POINTERS_H\n#define BASIC_POINTERS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* Global variables for testing */\nextern int number;\nextern int array[5];\nextern int *number_ptr;\nextern int *array_ptr;\n\n/* TODO: Declare your pointer functions */\n/* void print_number_info(void); */\n/* void modify_through_pointer(int *ptr, int new_value); */\n/* void print_array_through_pointer(int *ptr); */\n\n#endif /* BASIC_POINTERS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "basic_pointers.c",
        "content": "#include \"basic_pointers.h\"\n\n/* Global variables */\nint number = 42;\nint array[5] = {10, 20, 30, 40, 50};\nint *number_ptr = NULL;\nint *array_ptr = NULL;\n\nint test_value = 42;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your pointer logic works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(test_value, int, 0644);\nMODULE_PARM_DESC(test_value, \"Test value for anti-hardcoding validation\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: Complete Beginner's Guide to Pointers */\n/* WHAT IS A POINTER? */\n/* A pointer is a variable that stores a MEMORY ADDRESS of another variable */\n/* Think of it like a home address - it tells you WHERE something is located */\n\n/* SIMPLE EXAMPLE TO UNDERSTAND POINTERS: */\n/* int a = 5; */\n/* int* ptr = &a;      // ptr points to a */\n/* */\n/* What Each Contains: */\n/* a = 5                    // The value */\n/* ptr = &a                 // Address of a (like 0x1000) */\n/* *ptr = 5                 // Value at the address ptr points to */\n\n/* THE TWO IMPORTANT OPERATORS: */\n/* & = \"address-of\" operator - gets the address where a variable lives */\n/* * = \"dereference\" operator - gets the value at an address */\n\n/* REAL WORLD ANALOGY: */\n/* Variable 'a' is like a house with the number 5 painted on it */\n/* &a is like the street address of that house (e.g., \"123 Main St\") */\n/* ptr is like writing down that address on paper */\n/* *ptr is like going to that address and reading the number on the house */\n\n/* DETAILED EXPLANATION OF POINTER DECLARATION: */\n/* int* ptr;        // Declares a pointer that can point to an integer */\n/*                  // ptr can store the address of an int variable */\n/*                  // RIGHT NOW ptr contains garbage - don't use it yet! */\n/* */\n/* int a = 5;       // Create an integer variable with value 5 */\n/* ptr = &a;        // Make ptr point to variable a */\n/*                  // Now ptr contains the address where a lives */\n\n/* WHAT HAPPENS IN MEMORY: */\n/* Memory Address: 0x1000    0x2000 */\n/*    */\n/*  a = 5          ptr = 0x1000     */\n/*    */\n/*                    */\n/*                    ptr points to this address */\n/*    a lives here */\n\n/* THE & OPERATOR (ADDRESS-OF): */\n/* &a means \"give me the address where variable a is stored\" */\n/* If a is stored at memory address 0x1000, then &a = 0x1000 */\n/* */\n/* EXAMPLES: */\n/* int a = 5; */\n/* printk(\"%d\", a);    // Prints: 5 (the value) */\n/* printk(\"%p\", &a);   // Prints: 0x1000 (the address) */\n\n/* THE * OPERATOR (DEREFERENCE): */\n/* *ptr means \"go to the address stored in ptr and get the value there\" */\n/* If ptr contains 0x1000, then *ptr gets the value at address 0x1000 */\n/* */\n/* EXAMPLES: */\n/* int a = 5; */\n/* int* ptr = &a; */\n/* printk(\"%p\", ptr);   // Prints: 0x1000 (the address) */\n/* printk(\"%d\", *ptr);  // Prints: 5 (the value at that address) */\n\n/* COMMON BEGINNER MISTAKES: */\n/* MISTAKE 1: Confusing & and * */\n/*   int a = 5; */\n/*   int* ptr = a;        // WRONG: ptr expects an address, not a value */\n/* CORRECT: */\n/*   int* ptr = &a;       // CORRECT: ptr gets the address of a */\n/* */\n/* MISTAKE 2: Using * when you want the address */\n/*   printk(\"%p\", *ptr);  // WRONG: *ptr gives value, not address */\n/* CORRECT: */\n/*   printk(\"%p\", ptr);   // CORRECT: ptr contains the address */\n/* */\n/* MISTAKE 3: Using uninitialized pointers */\n/*   int* ptr;            // ptr contains garbage */\n/*   *ptr = 5;            // WRONG: writing to random memory! */\n/* CORRECT: */\n/*   int a; */\n/*   int* ptr = &a;       // Initialize ptr first */\n/*   *ptr = 5;            // CORRECT: now a = 5 */\n\n/* POINTER ARITHMETIC WITH ARRAYS: */\n/* Arrays and pointers are closely related in C */\n/* */\n/* int arr[5] = {10, 20, 30, 40, 50}; */\n/* int* ptr = arr;              // Same as ptr = &arr[0] */\n/* */\n/* printk(\"%d\", *ptr);         // Prints: 10 (first element) */\n/* printk(\"%d\", *(ptr + 1));   // Prints: 20 (second element) */\n/* printk(\"%d\", *(ptr + 2));   // Prints: 30 (third element) */\n/* */\n/* WHY ptr + 1 WORKS: */\n/* - ptr points to arr[0] at address 0x1000 */\n/* - ptr + 1 points to arr[1] at address 0x1004 (4 bytes later for int) */\n/* - *(ptr + 1) gets the value at arr[1] */\n\n/* VISUALIZING ARRAY POINTER ARITHMETIC: */\n/* Array: [10][20][30][40][50] */\n/* Addr:  1000 1004 1008 1012 1016 */\n/* */\n/* ptr + 0  1000  *ptr = 10 */\n/* ptr + 1  1004  *(ptr+1) = 20 */\n// Explanation (ptr+1) means adding  specified bytes  (sizeof(int)) to memory address of array , moving it to next position / next address \n// Adding +1 to the pointer value, which moves it to the next int. To get the value we add asterisk : *(ptr+1)\n/* ptr + 2  1008  *(ptr+2) = 30 */\n\n/* MODIFYING VALUES THROUGH POINTERS: */\n/* Once you have a pointer, you can change the original variable */\n/* */\n/* int a = 5; */\n/* int* ptr = &a; */\n/* *ptr = 10;               // Changes a to 10! */\n/* printk(\"%d\", a);         // Prints: 10 */\n/* */\n/* This is powerful because functions can modify caller's variables */\n\n/* PRACTICAL EXAMPLES FOR THIS PROBLEM: */\n/* Example 1: Basic pointer operations */\n/* int number = 42; */\n/* int* number_ptr = &number;       // Point to number */\n/* printk(\"Value: %d\", *number_ptr); // Prints: 42 */\n/* *number_ptr = 100;               // Changes number to 100 */\n/* */\n/* Example 2: Array access through pointers */\n/* int array[5] = {10, 20, 30, 40, 50}; */\n/* int* array_ptr = array;          // Point to first element */\n/* printk(\"First: %d\", *array_ptr); // Prints: 10 */\n/* printk(\"Second: %d\", *(array_ptr + 1)); // Prints: 20 */\n\n/* MEMORY SAFETY REMINDERS: */\n/* - Always initialize pointers before using them */\n/* - Don't dereference NULL pointers */\n/* - Don't access array elements beyond bounds */\n/* - In kernel space, use proper allocation/deallocation */\n\n/* WHY LEARN POINTERS? */\n/* Pointers are fundamental to: */\n/* - Dynamic memory allocation */\n/* - Passing large data structures efficiently */\n/* - Implementing data structures (linked lists, trees) */\n/* - System programming and kernel development */\n/* - Understanding how computers actually work */\n\n/* TODO: Implement function to print number and pointer info */\nvoid print_number_info(void) {\n    /* TODO: Print the value of 'number' using direct access */\n    /* Format: \"Number value: %d\" */\n    \n    /* TODO: Print the address of 'number' using &number */\n    /* Format: \"Number address: %p\" */\n    \n    /* TODO: Print the value of 'number_ptr' (should be address of number) */\n    /* Format: \"Pointer value (address it points to): %p\" */\n    \n    /* TODO: Print the value that number_ptr points to using *number_ptr */\n    /* Format: \"Value through pointer: %d\" */\n    \n    /* Use printk(KERN_INFO \"...\", ...) for each line */\n}\n\n/* TODO: Implement function to modify value through pointer */\nvoid modify_through_pointer(int *ptr, int new_value) {\n    /* TODO: Check if ptr is not NULL */\n    /* TODO: Use *ptr = new_value to modify the value at the address */\n    /* TODO: Print confirmation message with new value */\n    /* Format: \"Modified value through pointer to: %d\" */\n}\n\n/* TODO: Implement function to print array elements through pointer */\nvoid print_array_through_pointer(int *ptr) {\n    /* TODO: Print first element using *ptr */\n    /* TODO: Print second element using *(ptr + 1) */\n    /* TODO: Print third element using *(ptr + 2) */\n    /* Use format: \"Array element %d: %d\" where first %d is position (0,1,2) */\n    /* This demonstrates basic pointer arithmetic */\n}\n\nstatic int __init basic_pointers_init(void)\n{\n    printk(KERN_INFO \"Basic pointers module loaded\\n\");\n    \n    /* Step 1: Initialize pointers */\n    number = test_value;  /* Use dynamic test value */\n    number_ptr = &number;  /* Point to number variable */\n    array_ptr = array;     /* Point to first element of array */\n    \n    printk(KERN_INFO \"=== Basic Pointer Demonstration ===\");\n    \n    /* Step 2: Show basic pointer information */\n    print_number_info();\n    \n    /* Step 3: Modify value through pointer */\n    modify_through_pointer(number_ptr, 999);\n    \n    /* Step 4: Show array access through pointer */\n    printk(KERN_INFO \"Array elements through pointer:\");\n    print_array_through_pointer(array_ptr);\n    \n    /* Step 5: Show final state */\n    printk(KERN_INFO \"Final number value: %d\", number);\n    \n    return 0;\n}\n\nstatic void __exit basic_pointers_exit(void)\n{\n    printk(KERN_INFO \"Basic pointers module unloaded\\n\");\n    \n    /* Reset pointers to NULL for safety */\n    number_ptr = NULL;\n    array_ptr = NULL;\n}\n\nmodule_init(basic_pointers_init);\nmodule_exit(basic_pointers_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning basic pointer concepts with integers and arrays\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Basic pointers module Makefile\nobj-m += basic_pointers.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "basic_pointers.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "basic_pointers_init",
          "basic_pointers_exit",
          "print_number_info",
          "modify_through_pointer",
          "print_array_through_pointer"
        ],
        "function_declarations": [
          {
            "name": "print_number_info",
            "returnType": "void",
            "parameters": []
          },
          {
            "name": "modify_through_pointer",
            "returnType": "void",
            "parameters": [
              "int *ptr",
              "int new_value"
            ]
          },
          {
            "name": "print_array_through_pointer",
            "returnType": "void",
            "parameters": [
              "int *ptr"
            ]
          }
        ],
        "variables_declarations": [
          {
            "name": "number",
            "type": "int",
            "storageClass": "extern"
          },
          {
            "name": "array",
            "type": "int",
            "storageClass": "extern"
          },
          {
            "name": "number_ptr",
            "type": "int *",
            "storageClass": "extern"
          },
          {
            "name": "array_ptr",
            "type": "int *",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "number",
            "type": "int",
            "value": "42",
            "storageClass": "none"
          },
          {
            "name": "array",
            "type": "int",
            "value": "{10, 20, 30, 40, 50}",
            "storageClass": "none"
          },
          {
            "name": "number_ptr",
            "type": "int *",
            "value": "NULL",
            "storageClass": "none"
          },
          {
            "name": "array_ptr",
            "type": "int *",
            "value": "NULL",
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Basic pointers module loaded",
          "=== Basic Pointer Demonstration ===",
          "Number value: 42",
          "Number address: (____ptrval____)",
          "Pointer value (address it points to): (____ptrval____)",
          "Value through pointer: 42",
          "Modified value through pointer to: 999",
          "Array elements through pointer:",
          "Array element 0: 10",
          "Array element 1: 20",
          "Array element 2: 30",
          "Final number value: 999",
          "Basic pointers module unloaded"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "&number",
          "*number_ptr",
          "number_ptr = &number",
          "array_ptr = array",
          "*(ptr + 1)",
          "*(ptr + 2)",
          "*ptr = new_value",
          "module_param(test_value, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_number_info(void)",
            "void modify_through_pointer(int *ptr, int new_value)",
            "void print_array_through_pointer(int *ptr)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_number_info(void)",
            "void modify_through_pointer(int *ptr, int new_value)",
            "void print_array_through_pointer(int *ptr)",
            "static int __init basic_pointers_init(void)",
            "static void __exit basic_pointers_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Basic pointers module loaded",
              "exact": true,
              "linkedFunction": "static int __init basic_pointers_init(void)"
            },
            {
              "pattern": "=== Basic Pointer Demonstration ===",
              "exact": true,
              "linkedFunction": "static int __init basic_pointers_init(void)"
            },
            {
              "pattern": "Number value: 42",
              "exact": true,
              "linkedFunction": "void print_number_info(void)"
            },
            {
              "pattern": "Number address: (____ptrval____)",
              "exact": true,
              "linkedFunction": "void print_number_info(void)"
            },
            {
              "pattern": "Pointer value (address it points to): (____ptrval____)",
              "exact": true,
              "linkedFunction": "void print_number_info(void)"
            },
            {
              "pattern": "Value through pointer: 42",
              "exact": true,
              "linkedFunction": "void print_number_info(void)"
            },
            {
              "pattern": "Modified value through pointer to: 999",
              "exact": true,
              "linkedFunction": "void modify_through_pointer(int *ptr, int new_value)"
            },
            {
              "pattern": "Array elements through pointer:",
              "exact": true,
              "linkedFunction": "static int __init basic_pointers_init(void)"
            },
            {
              "pattern": "Array element 0: 10",
              "exact": true,
              "linkedFunction": "void print_array_through_pointer(int *ptr)"
            },
            {
              "pattern": "Array element 1: 20",
              "exact": true,
              "linkedFunction": "void print_array_through_pointer(int *ptr)"
            },
            {
              "pattern": "Array element 2: 30",
              "exact": true,
              "linkedFunction": "void print_array_through_pointer(int *ptr)"
            },
            {
              "pattern": "Final number value: 999",
              "exact": true,
              "linkedFunction": "static int __init basic_pointers_init(void)"
            },
            {
              "pattern": "Basic pointers module unloaded",
              "exact": true,
              "linkedFunction": "static void __exit basic_pointers_exit(void)"
            }
          ]
        },
        {
          "id": "basic_pointer_validation",
          "name": "Basic Pointer Operations with Anti-Hardcoding Protection",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "basic_pointer_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Basic Pointer Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate unpredictable test values\\n    int random_value = (rand() % 900) + 100;  // 100-999\\n    \\n    printf(\\\"Test 1: Random pointer operations (value=%d)\\\\n\\\", random_value);\\n    \\n    // Test with random values\\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod basic_pointers 2>/dev/null\\\");\\n    \\n    char cmd[256];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/basic_pointers.ko test_value=%d\\\", random_value);\\n    printf(\\\"DEBUG: Command: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Anti-hardcoding basic pointer test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting basic pointer implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef unsigned char uint8_t;' > /tmp/linux/types.h",
              "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
              "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
              "echo 'Creating test file that includes basic pointers header...'",
              "echo '#include \"/lib/modules/basic_pointers.h\"' > /tmp/test.c",
              "echo 'int main() { number = 123; print_number_info(); modify_through_pointer(&number, 456); print_array_through_pointer(array); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
              "echo 'Phase 2: Anti-Hardcoding Dynamic Basic Pointer Test'",
              "/bin/basic_pointer_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Random Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "TEST_VALUE=$(grep -o 'Random pointer operations (value=[0-9]*)' /tmp/test_output.log | cut -d'=' -f2 | cut -d')' -f1)",
              "echo 'Extracted values: TEST_VALUE='$TEST_VALUE",
              "if [ -z \"$TEST_VALUE\" ]; then echo 'FAIL: Could not extract random test values'; else echo 'PASS: Random values extracted successfully'; fi",
              "echo 'Phase 4: Anti-Hardcoding Validation with Random Values'",
              "echo 'Validating basic pointer operations with random value '$TEST_VALUE",
              "dmesg | grep \"Number value: $TEST_VALUE\" && echo 'PASS: Basic pointer dereference with random value working' || echo 'FAIL: Basic pointer dereference with random value broken'",
              "echo 'Phase 5: Static Field Validation (Non-Randomized Fields)'",
              "dmesg | grep 'Modified value through pointer to: 999' && echo 'PASS: Pointer modification working' || echo 'FAIL: Pointer modification broken'",
              "dmesg | grep 'Array element 0: 10' && echo 'PASS: Array pointer access working' || echo 'FAIL: Array pointer access broken'",
              "dmesg | grep 'Array element 1: 20' && echo 'PASS: Pointer arithmetic working' || echo 'FAIL: Pointer arithmetic broken'",
              "dmesg | grep 'Final number value: 999' && echo 'PASS: Pointer modification persistent' || echo 'FAIL: Pointer modification not persistent'",
              "echo 'Phase 6: Basic Pointer Logic Validation'",
              "dmesg | grep '=== Basic Pointer Demonstration ===' && echo 'PASS: Module demonstration working' || echo 'FAIL: Module demonstration broken'",
              "dmesg | grep 'Basic pointers module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
              "dmesg | grep 'Basic pointers module unloaded' && echo 'PASS: Module cleanup working' || echo 'FAIL: Module cleanup broken'",
              "echo 'Phase 7: Final Validation Summary'",
              "echo 'All phases completed successfully - anti-hardcoding basic pointer protection verified'",
              "echo 'PASS: All anti-hardcoding basic pointer validation successful'"
            ],
            "expected": {
              "dmesg": [
                "Basic pointers module loaded",
                "=== Basic Pointer Demonstration ===",
                "Number value: .*",
                "Modified value through pointer to: 999",
                "Array elements through pointer:",
                "Array element 0: 10",
                "Array element 1: 20",
                "Array element 2: 30",
                "Final number value: 999",
                "Basic pointers module unloaded"
              ],
              "stdout": [
                "PASS: All function and variable declarations found in header file",
                "SUCCESS: Anti-hardcoding basic pointer test completed",
                "PASS: Random values extracted successfully",
                "PASS: Basic pointer dereference with random value working",
                "PASS: Pointer modification working",
                "PASS: Array pointer access working",
                "PASS: Pointer arithmetic working",
                "PASS: Pointer modification persistent",
                "PASS: Module demonstration working",
                "PASS: Module initialization working",
                "PASS: Module cleanup working",
                "PASS: All anti-hardcoding basic pointer validation successful"
              ]
            },
            "timeout": 15
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Basic pointers module loaded",
        "=== Basic Pointer Demonstration ===",
        "Number value: 42",
        "Number address: (____ptrval____)",
        "Pointer value (address it points to): (____ptrval____)",
        "Value through pointer: 42",
        "Modified value through pointer to: 999",
        "Array elements through pointer:",
        "Array element 0: 10",
        "Array element 1: 20",
        "Array element 2: 30",
        "Final number value: 999",
        "Basic pointers module unloaded"
      ],
      "requirements": [
        "Use required function names: basic_pointers_init, basic_pointers_exit, print_number_info, modify_through_pointer, print_array_through_pointer",
        "Use required variable names: number, array, number_ptr, array_ptr",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: &number, *number_ptr, number_ptr = &number, array_ptr = array, *(ptr + 1), *(ptr + 2), *ptr = new_value, module_param(test_value, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Basic pointers module loaded",
          "linkedFunction": "static int __init basic_pointers_init(void)",
          "exact": true
        },
        {
          "pattern": "=== Basic Pointer Demonstration ===",
          "linkedFunction": "static int __init basic_pointers_init(void)",
          "exact": true
        },
        {
          "pattern": "Number value: 42",
          "linkedFunction": "void print_number_info(void)",
          "exact": true
        },
        {
          "pattern": "Number address: (____ptrval____)",
          "linkedFunction": "void print_number_info(void)",
          "exact": true
        },
        {
          "pattern": "Pointer value (address it points to): (____ptrval____)",
          "linkedFunction": "void print_number_info(void)",
          "exact": true
        },
        {
          "pattern": "Value through pointer: 42",
          "linkedFunction": "void print_number_info(void)",
          "exact": true
        },
        {
          "pattern": "Modified value through pointer to: 999",
          "linkedFunction": "void modify_through_pointer(int *ptr, int new_value)",
          "exact": true
        },
        {
          "pattern": "Array elements through pointer:",
          "linkedFunction": "static int __init basic_pointers_init(void)",
          "exact": true
        },
        {
          "pattern": "Array element 0: 10",
          "linkedFunction": "void print_array_through_pointer(int *ptr)",
          "exact": true
        },
        {
          "pattern": "Array element 1: 20",
          "linkedFunction": "void print_array_through_pointer(int *ptr)",
          "exact": true
        },
        {
          "pattern": "Array element 2: 30",
          "linkedFunction": "void print_array_through_pointer(int *ptr)",
          "exact": true
        },
        {
          "pattern": "Final number value: 999",
          "linkedFunction": "static int __init basic_pointers_init(void)",
          "exact": true
        },
        {
          "pattern": "Basic pointers module unloaded",
          "linkedFunction": "static void __exit basic_pointers_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 16,
    "title": "Basic Structures - Organizing Related Data",
    "difficulty": 4,
    "xp": 40,
    "phase": "foundations",
    "description": "Learn to create and use basic structures to organize related data together. This introduces simple data modeling patterns essential for kernel development where structures represent system information.",
    "concepts": [
      "structure definition",
      "structure initialization",
      "structure member access",
      "designated initializers",
      "dot notation"
    ],
    "skills": [
      "Defining custom data types",
      "Organizing related data",
      "Direct structure access",
      "Structure member usage",
      "Basic data modeling"
    ],
    "files": [
      {
        "name": "structures.h",
        "content": "#ifndef STRUCTURES_H\n#define STRUCTURES_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n#define MAX_NAME_LEN 32\n\n/* PATTERN SCAFFOLDING: How to define and use basic structures in C */\n/* Basic pattern for organizing related data together:\n *\n * struct type_name {\n *     data_type field_name;\n *     data_type another_field;\n * };\n *\n * This groups related information together instead of separate variables\n */\n\n/* WHAT A STRUCTURE DEFINITION CONTAINS: */\n\n/* 1. struct keyword - Tells compiler this is a structure definition */\n/*    Usage: struct starts the definition */\n/*    Example: struct student means \"define a student structure type\" */\n\n/* 2. Structure name - The type name for this structure */\n/*    Usage: Used when creating variables of this type */\n/*    Example: student becomes the type name, like int or char */\n\n/* 3. Field definitions - The data members inside the structure */\n/*    Usage: Each field has a type and name */\n/*    Example: int id; means \"this structure has an integer field called id\" */\n\n/* 4. Closing brace and semicolon - Required to end the definition */\n/*    Usage: }; closes the structure definition */\n/*    Example: Always end structure definitions with }; */\n\n/* STRUCTURE VS SEPARATE VARIABLES COMPARISON: */\n/* Without structures (messy): */\n/* int student_id; */\n/* char student_name[32]; */\n/* int student_grade; */\n/* bool student_passed; */\n/* \n/* With structures (organized): */\n/* struct student { */\n/*     int id; */\n/*     char name[32]; */\n/*     int grade; */\n/*     bool passed; */\n/* }; */\n/* Same data, but grouped logically! */\n\n/* TODO: Define student structure with these fields: */\n/* - int id: Student identification number (like 12345) */\n/* - char name[MAX_NAME_LEN]: Student's full name (like \"Alice Smith\") */\n/* - int grade: Student's current grade percentage (0-100) */\n/* - bool passed: Whether student passed (true) or failed (false) */\n/* Remember: Use struct keyword, then student as type name, then { fields } */\nstruct student {\n    // Your structure definition here\n    // Format: data_type field_name;\n};\n\nextern struct student my_student;\n\n/* TODO: Declare your functions */\n/* Function to print all student information */\nvoid print_student_info(void);\n\n/* Function to check and print student pass/fail status */\nvoid check_student_status(void);\n\n#endif /* STRUCTURES_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "structures.c",
        "content": "#include \"structures.h\"\n\n/* PATTERN SCAFFOLDING: How to initialize and use structures in C */\n/* Basic pattern for creating and initializing a structure variable:\n *\n * struct type_name variable_name = {\n *     .field_name = value,\n *     .another_field = another_value\n * };\n *\n * This creates a variable of the structure type with initial values\n */\n\n/* WHAT STRUCTURE INITIALIZATION CONTAINS: */\n\n/* 1. struct type_name - The structure type we defined in the header */\n/*    Usage: Tells compiler what type of structure this is */\n/*    Example: struct student means \"this is a student structure variable\" */\n\n/* 2. variable_name - The actual variable name */\n/*    Usage: This becomes the variable we can use in our code */\n/*    Example: my_student becomes the variable name */\n\n/* 3. Designated initializers - The .field = value syntax */\n/*    Usage: Sets specific fields to specific values */\n/*    Example: .id = 12345 means \"set the id field to 12345\" */\n/*    Why this way? Clear, readable, and order-independent! */\n\n/* DOT OPERATOR EXPLAINED IN DETAIL: */\n/* variable.field_name means \"access field_name inside variable\" */\n\n/* HOW DOT OPERATOR WORKS: */\n/* 1. my_student.id - Gets the id field from my_student */\n/*    Contains: The integer value stored in the id field */\n/*    Usage: Can read or write: my_student.id = 99999; */\n/*    Example: printk(\"%d\", my_student.id) prints the student's ID */\n\n/* 2. my_student.name - Gets the name array from my_student */\n/*    Contains: The character array (string) stored in name field */\n/*    Usage: Can read: printk(\"%s\", my_student.name) */\n/*    Note: String fields need special handling for assignment */\n\n/* 3. my_student.grade - Gets the grade field from my_student */\n/*    Contains: The integer percentage stored in grade field */\n/*    Usage: Can read or write: my_student.grade = 95; */\n\n/* 4. my_student.passed - Gets the boolean field from my_student */\n/*    Contains: true (1) or false (0) */\n/*    Usage: Can use in if statements: if (my_student.passed) */\n\n/* MEMORY LAYOUT VISUALIZATION: */\n/* my_student variable in memory: */\n/* ┌─────────────────────────────────────────────────────┐ */\n/* │ [id: 12345][name: \"Alice Smith\"][grade: 85][passed: true] │ */\n/* └─────────────────────────────────────────────────────┘ */\n/* my_student.id points here ↑                             */\n/* my_student.name points here      ↑                      */\n/* my_student.grade points here           ↑                */\n/* my_student.passed points here              ↑            */\n\n/* DESIGNATED INITIALIZER SYNTAX EXPLAINED: */\n/* .field_name = value means \"initialize field_name with value\" */\n/* Examples: */\n/* .id = 12345        - Set id field to integer 12345 */\n/* .name = \"Alice\"    - Set name field to string \"Alice\" */\n/* .grade = 85        - Set grade field to integer 85 */\n/* .passed = true     - Set passed field to boolean true */\n\n/* TODO: Initialize student structure using designated initializers */\n/* Use the pattern: struct student variable_name = { .field = value, ... } */\n/* Set these values: */\n/* - id: 12345 */\n/* - name: \"Alice Smith\" */\n/* - grade: 85 */\n/* - passed: true */\nstruct student my_student = {\n    // Your initialization here using .field_name = value syntax\n};\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your structure member access works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param_named(student_id, my_student.id, int, 0644);\nMODULE_PARM_DESC(student_id, \"Student ID for testing structure member access\");\nmodule_param_named(student_grade, my_student.grade, int, 0644);\nMODULE_PARM_DESC(student_grade, \"Student grade for testing structure member access\");\n/* Note: string and bool module params need special handling for structures */\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* TODO: Implement function to print student information using dot operator */\n/* Use my_student.field_name to access each field */\n/* Print format examples: */\n/* - \"Student ID: %d\" for integer fields */\n/* - \"Student Name: %s\" for string fields */\n/* Remember: my_student.id, my_student.name, my_student.grade */\nvoid print_student_info(void) {\n    // Your implementation here\n    // Use printk(KERN_INFO, \"format\", my_student.field_name);\n}\n\n/* TODO: Implement function to check student status using conditional logic */\n/* Use if statement with my_student.passed field */\n/* Boolean fields can be used directly in if conditions */\n/* Print \"Student Status: Passed\" if true, \"Student Status: Failed\" if false */\nvoid check_student_status(void) {\n    // Your implementation here\n    // Remember: my_student.passed is boolean (true/false)\n    // Use: if (my_student.passed) { ... } else { ... }\n}\n\nstatic int __init structures_init(void)\n{\n    printk(KERN_INFO \"Basic structures module loaded\\n\");\n    \n    /* TODO: Call your functions to demonstrate structure usage */\n    /* Call print_student_info() to show all student data */\n    /* Call check_student_status() to show pass/fail status */\n    \n    return 0;\n}\n\nstatic void __exit structures_exit(void)\n{\n    printk(KERN_INFO \"Basic structures module unloaded\\n\");\n}\n\nmodule_init(structures_init);\nmodule_exit(structures_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning basic structures and data organization\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Basic structures module Makefile\nobj-m += structures.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "structures.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "structures_init",
          "structures_exit",
          "print_student_info",
          "check_student_status"
        ],
        "function_declarations": [
          {
            "name": "print_student_info",
            "returnType": "void",
            "parameters": []
          },
          {
            "name": "check_student_status",
            "returnType": "void",
            "parameters": []
          }
        ],
        "variables_declarations": [
          {
            "name": "student",
            "type": "struct",
            "value": "{int id; char name[MAX_NAME_LEN]; int grade; bool passed;}",
            "storageClass": "none"
          },
          {
            "name": "my_student",
            "type": "struct student",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "my_student",
            "type": "struct student",
            "value": "{.id = 12345, .name = \"Alice Smith\", .grade = 85, .passed = true}",
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Basic structures module loaded",
          "Student ID: 12345",
          "Student Name: Alice Smith",
          "Student Grade: 85",
          "Student Status: Passed"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "struct student {",
          "extern struct student my_student",
          "struct student my_student = {",
          ".id = 12345",
          ".name = \"Alice Smith\"",
          ".grade = 85",
          ".passed = true",
          "module_param_named(student_id, my_student.id, int, 0644)",
          "module_param_named(student_grade, my_student.grade, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_student_info(void)",
            "void check_student_status(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_student_info(void)",
            "void check_student_status(void)",
            "static int __init structures_init(void)",
            "static void __exit structures_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Basic structures module loaded",
              "exact": true,
              "linkedFunction": "static int __init structures_init(void)"
            },
            {
              "pattern": "Student ID: 12345",
              "exact": true,
              "linkedFunction": "void print_student_info(void)"
            },
            {
              "pattern": "Student Name: Alice Smith",
              "exact": true,
              "linkedFunction": "void print_student_info(void)"
            },
            {
              "pattern": "Student Grade: 85",
              "exact": true,
              "linkedFunction": "void print_student_info(void)"
            },
            {
              "pattern": "Student Status: Passed",
              "exact": true,
              "linkedFunction": "void check_student_status(void)"
            }
          ]
        },
        {
          "id": "advanced_structure_implementation_validation",
          "name": "Advanced Structure Implementation with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "structure_impl_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Structure Implementation Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random student data\\n    int test_id1 = (rand() % 9000) + 10000;  // 10000-18999\\n    int test_grade1 = (rand() % 20) + 80;    // 80-99\\n    int test_id2 = (rand() % 9000) + 20000;  // 20000-28999\\n    int test_grade2 = (rand() % 30) + 60;    // 60-89\\n    \\n    printf(\\\"Test 1: Testing with student_id=%d, student_grade=%d\\\\n\\\", test_id1, test_grade1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/structures.ko student_id=%d student_grade=%d\\\", test_id1, test_grade1);\\n    system(\\\"rmmod structures 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Testing with student_id=%d, student_grade=%d\\\\n\\\", test_id2, test_grade2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/structures.ko student_id=%d student_grade=%d\\\", test_id2, test_grade2);\\n    system(\\\"rmmod structures\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Dynamic structure test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced structure implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param_named(name, var, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo '#define true 1' >> /tmp/linux/types.h",
              "echo '#define false 0' >> /tmp/linux/types.h",
              "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
              "echo 'Creating test file that includes student header...'",
              "echo '#include \"/lib/modules/structures.h\"' > /tmp/test.c",
              "echo 'int main() { my_student.id = 999; print_student_info(); check_student_status(); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
              "echo 'Phase 2: Dynamic Structure Implementation Testing'",
              "/bin/structure_impl_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Dynamic Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "TEST1_ID=$(grep -o 'Test 1: Testing with student_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
              "TEST1_GRADE=$(grep -o 'student_grade=[0-9]*' /tmp/test_output.log | head -1 | cut -d'=' -f2)",
              "TEST2_ID=$(grep -o 'Test 2: Testing with student_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
              "TEST2_GRADE=$(grep -o 'student_grade=[0-9]*' /tmp/test_output.log | tail -1 | cut -d'=' -f2)",
              "echo 'Test values: ID1='$TEST1_ID', Grade1='$TEST1_GRADE', ID2='$TEST2_ID', Grade2='$TEST2_GRADE",
              "echo 'Validating structure member access with dynamic values'",
              "dmesg | grep 'Student ID: '$TEST1_ID && echo 'PASS: Structure id member access working with '$TEST1_ID || echo 'FAIL: Structure id member access broken for '$TEST1_ID",
              "dmesg | grep 'Student Name: Alice Smith' && echo 'PASS: Structure name member access working' || echo 'FAIL: Structure name member access broken'",
              "dmesg | grep 'Student Grade: '$TEST1_GRADE && echo 'PASS: Structure grade member access working with '$TEST1_GRADE || echo 'FAIL: Structure grade member access broken for '$TEST1_GRADE",
              "dmesg | grep 'Student ID: '$TEST2_ID && echo 'PASS: Structure id member access working with '$TEST2_ID || echo 'FAIL: Structure id member access broken for '$TEST2_ID",
              "dmesg | grep 'Student Grade: '$TEST2_GRADE && echo 'PASS: Structure grade member access working with '$TEST2_GRADE || echo 'FAIL: Structure grade member access broken for '$TEST2_GRADE",
              "dmesg | grep 'Student Status: Passed' && echo 'PASS: Structure passed member conditional logic working' || echo 'FAIL: Structure passed member conditional logic broken'",
              "echo 'Phase 4: Structure Definition Validation'",
              "dmesg | grep 'Basic structures module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
              "echo 'All structure implementation validations completed'"
            ],
            "expected": {
              "dmesg": [
                "Basic structures module loaded",
                "Student ID: .*",
                "Student Name: Alice Smith",
                "Student Grade: .*",
                "Student Status: Passed"
              ],
              "stdout": [
                "PASS: All function and variable declarations found in header file",
                "SUCCESS: Dynamic structure test completed",
                "PASS: Structure id member access working with .*",
                "PASS: Structure name member access working",
                "PASS: Structure grade member access working with .*",
                "PASS: Structure passed member conditional logic working"
              ]
            },
            "timeout": 30
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Basic structures module loaded",
        "Student ID: 12345",
        "Student Name: Alice Smith",
        "Student Grade: 85",
        "Student Status: Passed"
      ],
      "requirements": [
        "Use required function names: structures_init, structures_exit, print_student_info, check_student_status",
        "Use required variable names: my_student",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: struct student {, extern struct student my_student, struct student my_student = {, .id = 12345, .name = \"Alice Smith\", .grade = 85, .passed = true, module_param_named(student_id, my_student.id, int, 0644), module_param_named(student_grade, my_student.grade, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Basic structures module loaded",
          "linkedFunction": "static int __init structures_init(void)",
          "exact": true
        },
        {
          "pattern": "Student ID: 12345",
          "linkedFunction": "void print_student_info(void)",
          "exact": true
        },
        {
          "pattern": "Student Name: Alice Smith",
          "linkedFunction": "void print_student_info(void)",
          "exact": true
        },
        {
          "pattern": "Student Grade: 85",
          "linkedFunction": "void print_student_info(void)",
          "exact": true
        },
        {
          "pattern": "Student Status: Passed",
          "linkedFunction": "void check_student_status(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 17,
    "title": "Structure Pointers - Advanced Data Manipulation",
    "difficulty": 5,
    "xp": 45,
    "phase": "foundations",
    "description": "Learn essential pointer concepts by working with pointers to structures. Focus on arrow operator (->), address-of operator (&), and passing structures to functions by reference.",
    "concepts": [
      "structure pointers",
      "pointer dereferencing",
      "arrow operator (->)",
      "address-of operator (&)",
      "structure modification via pointers"
    ],
    "skills": [
      "Working with structure pointers",
      "Using arrow operator for member access",
      "Passing structures to functions by reference",
      "Modifying structures through pointers",
      "Understanding pointer-based data manipulation"
    ],
    "files": [
      {
        "name": "struct_pointers.h",
        "content": "#ifndef STRUCT_POINTERS_H\n#define STRUCT_POINTERS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n#define MAX_NAME_LEN 32\n\n/* TODO: Define device_info structure with the following fields: */\n/* - char device_name[MAX_NAME_LEN] for storing device name */\n/* - int device_id for storing device identifier */\n/* - bool is_active for storing activation status */\n/* - int data_count for storing data counter */\n\nextern struct device_info my_device;\n\n/* TODO: Declare your functions that work with pointers */\n/* void print_device_info(struct device_info *dev); - prints all device information */\n/* void update_device_count(struct device_info *dev, int new_count); - updates device count */\n/* void activate_device(struct device_info *dev); - activates the device */\n\n#endif /* STRUCT_POINTERS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "struct_pointers.c",
        "content": "#include \"struct_pointers.h\"\n\n/* PATTERN SCAFFOLDING: How structure pointers work in C */\n/* Basic pattern for working with structure pointers:\n *\n * struct my_struct variable = {...};        // Create struct variable\n * struct my_struct* ptr = &variable;        // Get pointer to struct\n * ptr->field = value;                       // Access/modify through pointer\n *\n * This is like: variable → &variable → ptr->field\n */\n\n/* WHAT EACH EXPRESSION CONTAINS AND HOW TO USE IT: */\n\n/* 1. struct device_info my_device - Structure variable (actual data) */\n/*    Contains: The actual struct data in memory */\n/*    Usage: Direct access to fields: my_device.device_id */\n/*    Example: my_device.device_name contains the string \"sensor01\" */\n\n/* 2. struct device_info* dev - Pointer to structure */\n/*    Contains: Memory address pointing to the struct */\n/*    Usage: Access fields through arrow operator: dev->device_id */\n/*    Example: dev points to where my_device lives in memory */\n\n/* 3. &my_device - Address of the structure variable */\n/*    Contains: Memory address where my_device is stored */\n/*    Usage: Pass to functions that expect pointers */\n/*    Example: &my_device gives the address to pass to functions */\n\n/* STRUCTURE MEMBER ACCESS OPERATORS EXPLAINED: */\n\n/* DOT OPERATOR (.) - Used with structure variables: */\n/* my_device.device_id = 1001;               // Direct access to variable */\n/* my_device.is_active = true;               // Modifying field directly */\n/* Why dot? Because my_device IS the actual struct, not a pointer */\n\n/* ARROW OPERATOR (->) - Used with structure pointers: */\n/* dev->device_id = 1001;                    // Access through pointer */\n/* dev->is_active = true;                    // Modifying field through pointer */\n/* Why arrow? Because dev POINTS TO the struct, it's not the struct itself */\n\n/* ARROW OPERATOR IS ACTUALLY SHORTHAND: */\n/* dev->device_id  is exactly the same as  (*dev).device_id */\n/*  ↑ shorthand                              ↑ longhand */\n/* The arrow operator (->) is just a convenient way to write (*ptr).field */\n\n/* AMPERSAND OPERATOR (&) EXPLAINED FOR STRUCTURES: */\n/* & is the \"address-of\" operator - gets memory address of a variable */\n\n/* WHAT & PRODUCES WITH STRUCTURES: */\n/* my_device                    = The actual struct contents */\n/* &my_device                   = Pointer to where the struct is stored */\n/* */\n/* Example: */\n/* struct device_info my_device = {...};     // Struct variable */\n/* struct device_info* ptr = &my_device;     // Get pointer to the struct */\n\n/* WHY FUNCTIONS NEED POINTERS TO STRUCTURES: */\n/* Function parameter: void print_device_info(struct device_info *dev) */\n/*                                             ↑ expects a POINTER */\n/* */\n/* If we have: struct device_info my_device = {...}; */\n/* */\n/* CORRECT:   print_device_info(&my_device); */\n/*            ↑ pass address of the struct */\n/* */\n/* WRONG:     print_device_info(my_device); */\n/*            ↑ tries to pass struct contents instead of address */\n\n/* MEMORY LAYOUT VISUALIZATION FOR STRUCTURES: */\n/* Memory Address: 0x1000 */\n/* ┌─────────────────────────────────────────────────────┐ */\n/* │ my_device struct data lives here                    │ */\n/* │ [device_name: \"sensor01\"][device_id: 1001][......]  │ */\n/* └─────────────────────────────────────────────────────┘ */\n/*   ↑ */\n/*   This address (0x1000) is what &my_device gives us */\n\n/* WHAT EACH EXPRESSION EVALUATES TO: */\n/* my_device          = The actual struct contents (all fields together) */\n/* &my_device         = 0x1000 (the address where the struct is stored) */\n/* ptr = &my_device   = ptr now contains 0x1000 */\n/* ptr->device_id     = Access device_id field at address 0x1000 + offset */\n\n/* POINTER DEREFERENCING RELATIONSHIP: */\n/* If: struct device_info* ptr = &my_device; */\n/* Then: */\n/*   ptr                = Address of my_device (like 0x1000) */\n/*   *ptr               = Contents of my_device (entire struct) */\n/*   ptr->device_id     = my_device.device_id (same field) */\n/*   (*ptr).device_id   = my_device.device_id (same as arrow operator) */\n\n/* COMMON MISTAKES AND COMPILER ERRORS: */\n/* MISTAKE 1: Using dot instead of arrow with pointers */\n/*   struct device_info* dev = &my_device; */\n/*   dev.device_id = 1001;  // ERROR: dev is pointer, use -> not . */\n/* SOLUTION: */\n/*   dev->device_id = 1001;  // CORRECT: use -> with pointers */\n/* */\n/* MISTAKE 2: Using arrow instead of dot with variables */\n/*   my_device->device_id = 1001;  // ERROR: my_device is variable, use . not -> */\n/* SOLUTION: */\n/*   my_device.device_id = 1001;   // CORRECT: use . with variables */\n/* */\n/* MISTAKE 3: Forgetting & when passing to functions */\n/*   print_device_info(my_device);  // ERROR: function expects pointer */\n/* SOLUTION: */\n/*   print_device_info(&my_device); // CORRECT: pass address with & */\n\n/* PRACTICAL EXAMPLES IN STRUCTURE CONTEXT: */\n/* struct device_info my_device = {.device_name = \"sensor01\", .device_id = 1001}; */\n/* struct device_info* ptr = &my_device;     // ptr points to my_device */\n/* */\n/* printf(\"%s\", my_device.device_name);      // Direct access: \"sensor01\" */\n/* printf(\"%s\", ptr->device_name);           // Pointer access: \"sensor01\" */\n/* printf(\"%d\", my_device.device_id);        // Direct access: 1001 */\n/* printf(\"%d\", ptr->device_id);             // Pointer access: 1001 */\n\n/* IN OUR KERNEL CODE CONTEXT: */\n/* struct device_info my_device = {...};              // Global struct variable */\n/* void print_device_info(struct device_info *dev);  // Function takes pointer */\n/* */\n/* Inside init function: */\n/* print_device_info(&my_device);                     // Pass address to function */\n/* */\n/* Inside print_device_info function: */\n/* void print_device_info(struct device_info *dev) {  // dev is pointer parameter */\n/*     printk(\"Name: %s\", dev->device_name);           // Use -> to access fields */\n/*     printk(\"ID: %d\", dev->device_id);               // dev points to my_device */\n/* } */\n\n/* TODO: Initialize device structure */\n/* Use the pattern: struct device_info my_device = { .field = value, ... }; */\n/* Initialize with: device_name=\"sensor01\", device_id=1001, is_active=false, data_count=0 */\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your pointer operations work\n * with different input values. Removing them will cause test failures.\n */\nmodule_param_named(device_id, my_device.device_id, int, 0644);\nMODULE_PARM_DESC(device_id, \"Device ID for testing pointer member access\");\nmodule_param_named(data_count, my_device.data_count, int, 0644);\nMODULE_PARM_DESC(data_count, \"Initial data count for testing pointer operations\");\n/* Note: string and bool module params need special handling for structures */\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* TODO: Implement function to print device info using pointer */\nvoid print_device_info(struct device_info *dev) {\n    /* TODO: Print device name using dev->device_name */\n    /* TODO: Print device ID using dev->device_id */\n    /* TODO: Print device active status using dev->is_active */\n    /* TODO: Print data count using dev->data_count */\n    /* Use printk(KERN_INFO \"...\", ...) for each field */\n}\n\n/* TODO: Implement function to update device count via pointer */\nvoid update_device_count(struct device_info *dev, int new_count) {\n    /* TODO: Update dev->data_count to new_count value */\n    /* TODO: Print confirmation message with device name and new count */\n    /* Format: \"Device %s count updated to: %d\" */\n}\n\n/* TODO: Implement function to activate device via pointer */\nvoid activate_device(struct device_info *dev) {\n    /* TODO: Set dev->is_active to true */\n    /* TODO: Print confirmation message with device name */\n    /* Format: \"Device %s activated\" */\n}\n\n/* DETAILED EXPLANATION OF INIT FUNCTION - STEP BY STEP STRUCTURE POINTER ANALYSIS */\n/* This function demonstrates the complete structure pointer workflow with detailed explanations */\n\n/* UNDERSTANDING THE INIT FUNCTION CALLS: */\n/* printk(KERN_INFO \"Initial Device Information:\");  // Print header message */\n/* print_device_info(&my_device);                     // Pass structure address to function */\n/* update_device_count(&my_device, 5);               // Pass structure address + new value */\n/* activate_device(&my_device);                       // Pass structure address to function */\n/* */\n/* WHAT &my_device GIVES YOU: */\n/* - &my_device = address of the ENTIRE structure (not individual fields) */\n/* - Functions receive this address as a pointer parameter */\n/* */\n/* MEMORY LAYOUT VISUALIZATION: */\n/* Memory Address: 0x2000 */\n/* ┌─────────────────────────────────────────┐ */\n/* │ my_device struct (entire thing)         │ */\n/* │ ┌─────────────────────────────────────┐ │  ← &my_device points HERE (to start) */\n/* │ │ device_name: \"sensor01\"             │ │ */\n/* │ ├─────────────────────────────────────┤ │ */\n/* │ │ device_id: 1001                     │ │ */\n/* │ ├─────────────────────────────────────┤ │ */\n/* │ │ is_active: false                    │ │ */\n/* │ ├─────────────────────────────────────┤ │ */\n/* │ │ data_count: 0                       │ │ */\n/* │ └─────────────────────────────────────┘ │ */\n/* └─────────────────────────────────────────┘ */\n/* */\n/* SO &my_device POINTS TO: */\n/* - YES: The entire struct (including all fields: device_name, device_id, is_active, data_count) */\n/* - NO: NOT just one field or partial data */\n/* */\n/* INSIDE print_device_info(&my_device): */\n/* void print_device_info(struct device_info *dev) { */\n/*     // dev parameter contains 0x2000 (address of entire my_device struct) */\n/*  */\n/*     printk(\"Device Name: %s\", dev->device_name); */\n/*     // dev->device_name accesses the device_name field at address 0x2000 + offset */\n/*     // This works because dev points to the start of my_device! */\n/* } */\n/* */\n/* INSIDE update_device_count(&my_device, 5): */\n/* void update_device_count(struct device_info *dev, int new_count) { */\n/*     // dev parameter contains 0x2000 (same address as my_device) */\n/*  */\n/*     dev->data_count = new_count; */\n/*     // This DIRECTLY modifies my_device.data_count because dev points to my_device! */\n/*     // After this line, my_device.data_count will be 5 */\n/* } */\n/* */\n/* KEY POINT: */\n/* &my_device gives you the address of the WHOLE struct, not individual fields. */\n/* Functions receive this address as a pointer and can access/modify any field. */\n/* When functions modify fields through the pointer, they're directly modifying my_device! */\n/* */\n/* THE STRUCTURE POINTER CHAIN: */\n/* 1. my_device = actual struct variable with data */\n/* 2. &my_device = pointer to entire struct */\n/* 3. function parameter gets this address */\n/* 4. Inside function: use -> to access/modify fields */\n/* 5. Changes affect the original my_device struct */\n/* */\n/* So yes, the functions receive the address of the ENTIRE struct and can modify it directly! */\n\nstatic int __init struct_pointers_init(void)\n{\n    printk(KERN_INFO \"Structure pointers module loaded\\n\");\n    \n    /* TODO: Print \"Initial Device Information:\" message */\n    /* TODO: Call print_device_info() function with pointer to my_device */\n    /* Remember to use &my_device to get the address of the structure */\n    \n    /* TODO: Update device count to 5 using update_device_count() function */\n    /* Pass &my_device and the value 5 as parameters */\n    \n    /* TODO: Activate the device using activate_device() function */\n    /* Pass &my_device as parameter */\n    \n    /* TODO: Print \"Final Device Information:\" message */\n    /* TODO: Call print_device_info() again to show updated values */\n    \n    return 0;\n}\n\nstatic void __exit struct_pointers_exit(void)\n{\n    printk(KERN_INFO \"Structure pointers module unloaded\\n\");\n}\n\nmodule_init(struct_pointers_init);\nmodule_exit(struct_pointers_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning structure pointers and basic operations\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Structure pointers module Makefile\nobj-m += struct_pointers.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "struct_pointers.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "struct_pointers_init",
          "struct_pointers_exit",
          "print_device_info",
          "update_device_count",
          "activate_device"
        ],
        "function_declarations": [
          {
            "name": "print_device_info",
            "returnType": "void",
            "parameters": [
              "struct device_info *dev"
            ]
          },
          {
            "name": "update_device_count",
            "returnType": "void",
            "parameters": [
              "struct device_info *dev",
              "int new_count"
            ]
          },
          {
            "name": "activate_device",
            "returnType": "void",
            "parameters": [
              "struct device_info *dev"
            ]
          }
        ],
        "variables_declarations": [
          {
            "name": "device_info",
            "type": "struct",
            "value": "{char device_name[MAX_NAME_LEN]; int device_id; bool is_active; int data_count;}",
            "storageClass": "none"
          },
          {
            "name": "my_device",
            "type": "struct device_info",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "my_device",
            "type": "struct device_info",
            "value": "{.device_name = \"sensor01\", .device_id = 1001, .is_active = false, .data_count = 0}",
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Structure pointers module loaded",
          "Initial Device Information:",
          "Device Name: sensor01",
          "Device ID: 1001",
          "Device Active: 0",
          "Data Count: 0",
          "Device sensor01 count updated to: 5",
          "Device sensor01 activated",
          "Final Device Information:",
          "Device Name: sensor01",
          "Device ID: 1001",
          "Device Active: 1",
          "Data Count: 5"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "struct device_info {",
          "extern struct device_info my_device",
          "struct device_info my_device = {",
          "&my_device",
          "module_param_named(device_id, my_device.device_id, int, 0644)",
          "module_param_named(data_count, my_device.data_count, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_device_info(struct device_info *dev)",
            "void update_device_count(struct device_info *dev, int new_count)",
            "void activate_device(struct device_info *dev)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_device_info(struct device_info *dev)",
            "void update_device_count(struct device_info *dev, int new_count)",
            "void activate_device(struct device_info *dev)",
            "static int __init struct_pointers_init(void)",
            "static void __exit struct_pointers_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Structure pointers module loaded",
              "exact": true,
              "linkedFunction": "static int __init struct_pointers_init(void)"
            },
            {
              "pattern": "Initial Device Information:",
              "exact": true,
              "linkedFunction": "static int __init struct_pointers_init(void)"
            },
            {
              "pattern": "Device Name: sensor01",
              "exact": true,
              "linkedFunction": "void print_device_info(struct device_info *dev)"
            },
            {
              "pattern": "Device ID: 1001",
              "exact": true,
              "linkedFunction": "void print_device_info(struct device_info *dev)"
            },
            {
              "pattern": "Device Active: 0",
              "exact": true,
              "linkedFunction": "void print_device_info(struct device_info *dev)"
            },
            {
              "pattern": "Data Count: 0",
              "exact": true,
              "linkedFunction": "void print_device_info(struct device_info *dev)"
            },
            {
              "pattern": "Device sensor01 count updated to: 5",
              "exact": true,
              "linkedFunction": "void update_device_count(struct device_info *dev, int new_count)"
            },
            {
              "pattern": "Device sensor01 activated",
              "exact": true,
              "linkedFunction": "void activate_device(struct device_info *dev)"
            },
            {
              "pattern": "Final Device Information:",
              "exact": true,
              "linkedFunction": "static int __init struct_pointers_init(void)"
            },
            {
              "pattern": "Device Name: sensor01",
              "exact": true,
              "linkedFunction": "void print_device_info(struct device_info *dev)"
            },
            {
              "pattern": "Device ID: 1001",
              "exact": true,
              "linkedFunction": "void print_device_info(struct device_info *dev)"
            },
            {
              "pattern": "Device Active: 1",
              "exact": true,
              "linkedFunction": "void print_device_info(struct device_info *dev)"
            },
            {
              "pattern": "Data Count: 5",
              "exact": true,
              "linkedFunction": "void print_device_info(struct device_info *dev)"
            }
          ]
        },
        {
          "id": "advanced_pointer_structure_validation",
          "name": "Advanced Pointer Structure Implementation with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "pointer_struct_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Pointer Structure Implementation Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random device data\\n    int test_id1 = (rand() % 9000) + 2000;  // 2000-10999\\n    int test_count1 = (rand() % 10) + 1;    // 1-10\\n    int test_id2 = (rand() % 9000) + 5000;  // 5000-13999\\n    int test_count2 = (rand() % 20) + 5;    // 5-24\\n    \\n    printf(\\\"Test 1: Testing with device_id=%d, data_count=%d\\\\n\\\", test_id1, test_count1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/struct_pointers.ko device_id=%d data_count=%d\\\", test_id1, test_count1);\\n    system(\\\"rmmod struct_pointers 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Testing with device_id=%d, data_count=%d\\\\n\\\", test_id2, test_count2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/struct_pointers.ko device_id=%d data_count=%d\\\", test_id2, test_count2);\\n    system(\\\"rmmod struct_pointers\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Dynamic pointer structure test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced pointer structure implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo '#define true 1' >> /tmp/linux/types.h",
              "echo '#define false 0' >> /tmp/linux/types.h",
              "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
              "echo 'Creating test file that includes pointer structure header...'",
              "echo '#include \"/lib/modules/struct_pointers.h\"' > /tmp/test.c",
              "echo 'int main() { my_device.device_id = 888; print_device_info(&my_device); update_device_count(&my_device, 10); activate_device(&my_device); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
              "echo 'Phase 2: Dynamic Pointer Structure Implementation Testing'",
              "/bin/pointer_struct_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Dynamic Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "TEST1_ID=$(grep -o 'Test 1: Testing with device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
              "TEST1_COUNT=$(grep -o 'data_count=[0-9]*' /tmp/test_output.log | head -1 | cut -d'=' -f2)",
              "TEST2_ID=$(grep -o 'Test 2: Testing with device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
              "TEST2_COUNT=$(grep -o 'data_count=[0-9]*' /tmp/test_output.log | tail -1 | cut -d'=' -f2)",
              "echo 'Test values: ID1='$TEST1_ID', Count1='$TEST1_COUNT', ID2='$TEST2_ID', Count2='$TEST2_COUNT",
              "echo 'Validating pointer-based structure member access with dynamic values'",
              "dmesg | grep 'Device ID: '$TEST1_ID && echo 'PASS: Pointer access to device_id working with '$TEST1_ID || echo 'FAIL: Pointer access to device_id broken for '$TEST1_ID",
              "dmesg | grep 'Device Name: sensor01' && echo 'PASS: Pointer access to device_name working' || echo 'FAIL: Pointer access to device_name broken'",
              "dmesg | grep 'Data Count: '$TEST1_COUNT && echo 'PASS: Initial data_count from module param '$TEST1_COUNT || echo 'FAIL: Module parameter data_count not working'",
              "dmesg | grep 'Device ID: '$TEST2_ID && echo 'PASS: Pointer access to device_id working with '$TEST2_ID || echo 'FAIL: Pointer access to device_id broken for '$TEST2_ID",
              "echo 'Phase 3.1: Function Logic Validation'",
              "dmesg | grep 'Device sensor01 count updated to: 5' && echo 'PASS: update_device_count function message works' || echo 'FAIL: update_device_count message broken'",
              "dmesg | grep 'Data Count: 5' && echo 'PASS: update_device_count actually modified struct data_count to 5' || echo 'FAIL: update_device_count function logic broken - struct not modified'",
              "dmesg | grep 'Device sensor01 activated' && echo 'PASS: activate_device function message works' || echo 'FAIL: activate_device message broken'",
              "dmesg | grep 'Device Active: 1' && echo 'PASS: activate_device actually modified struct is_active to true' || echo 'FAIL: activate_device function logic broken - struct not modified'",
              "echo 'Phase 3.2: Final State Validation'",
              "dmesg | grep 'Final Device Information:' && echo 'PASS: Final print_device_info called' || echo 'FAIL: Final print_device_info not called'",
              "dmesg | grep 'Data Count: 5' && echo 'PASS: Final state data_count is correct' || echo 'FAIL: Final data_count wrong'",
              "dmesg | grep 'Device Active: 1' && echo 'PASS: Final state is_active is correct' || echo 'FAIL: Final is_active wrong'",
              "echo 'Phase 4: Structure Definition Validation'",
              "dmesg | grep 'Structure pointers module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
              "echo 'All pointer structure implementation validations completed'"
            ],
            "expected": {
              "dmesg": [
                "Structure pointers module loaded",
                "Device Name: sensor01",
                "Device ID: .*",
                "Data Count: .*",
                "Device sensor01 count updated to: 5",
                "Device sensor01 activated",
                "Device Active: 1"
              ],
              "stdout": [
                "PASS: All function and variable declarations found in header file",
                "SUCCESS: Dynamic pointer structure test completed",
                "PASS: Pointer access to device_id working with .*",
                "PASS: Pointer access to device_name working",
                "PASS: Initial data_count from module param .*",
                "PASS: update_device_count function message works",
                "PASS: update_device_count actually modified struct data_count to 5",
                "PASS: activate_device function message works",
                "PASS: activate_device actually modified struct is_active to true",
                "PASS: Final print_device_info called",
                "PASS: Final state data_count is correct",
                "PASS: Final state is_active is correct"
              ]
            },
            "timeout": 15
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Structure pointers module loaded",
        "Initial Device Information:",
        "Device Name: sensor01",
        "Device ID: 1001",
        "Device Active: 0",
        "Data Count: 0",
        "Device sensor01 count updated to: 5",
        "Device sensor01 activated",
        "Final Device Information:",
        "Device Name: sensor01",
        "Device ID: 1001",
        "Device Active: 1",
        "Data Count: 5"
      ],
      "requirements": [
        "Use required function names: struct_pointers_init, struct_pointers_exit, print_device_info, update_device_count, activate_device",
        "Use required variable names: my_device",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: struct device_info {, extern struct device_info my_device, struct device_info my_device = {, &my_device, module_param_named(device_id, my_device.device_id, int, 0644), module_param_named(data_count, my_device.data_count, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Structure pointers module loaded",
          "linkedFunction": "static int __init struct_pointers_init(void)",
          "exact": true
        },
        {
          "pattern": "Initial Device Information:",
          "linkedFunction": "static int __init struct_pointers_init(void)",
          "exact": true
        },
        {
          "pattern": "Device Name: sensor01",
          "linkedFunction": "void print_device_info(struct device_info *dev)",
          "exact": true
        },
        {
          "pattern": "Device ID: 1001",
          "linkedFunction": "void print_device_info(struct device_info *dev)",
          "exact": true
        },
        {
          "pattern": "Device Active: 0",
          "linkedFunction": "void print_device_info(struct device_info *dev)",
          "exact": true
        },
        {
          "pattern": "Data Count: 0",
          "linkedFunction": "void print_device_info(struct device_info *dev)",
          "exact": true
        },
        {
          "pattern": "Device sensor01 count updated to: 5",
          "linkedFunction": "void update_device_count(struct device_info *dev, int new_count)",
          "exact": true
        },
        {
          "pattern": "Device sensor01 activated",
          "linkedFunction": "void activate_device(struct device_info *dev)",
          "exact": true
        },
        {
          "pattern": "Final Device Information:",
          "linkedFunction": "static int __init struct_pointers_init(void)",
          "exact": true
        },
        {
          "pattern": "Device Name: sensor01",
          "linkedFunction": "void print_device_info(struct device_info *dev)",
          "exact": true
        },
        {
          "pattern": "Device ID: 1001",
          "linkedFunction": "void print_device_info(struct device_info *dev)",
          "exact": true
        },
        {
          "pattern": "Device Active: 1",
          "linkedFunction": "void print_device_info(struct device_info *dev)",
          "exact": true
        },
        {
          "pattern": "Data Count: 5",
          "linkedFunction": "void print_device_info(struct device_info *dev)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 18,
    "title": "Typedef - Cleaner Type Definitions",
    "difficulty": 3,
    "xp": 35,
    "phase": "foundations",
    "description": "Learn to create cleaner, more readable code using typedef. Instead of writing 'struct device_info my_device', you can simply write 'Device my_device'. This introduces type aliasing - a fundamental concept for writing professional, maintainable kernel code.",
    "concepts": [
      "typedef keyword",
      "type aliasing",
      "struct typedef pattern",
      "cleaner syntax",
      "code readability",
      "professional coding style"
    ],
    "skills": [
      "Creating type aliases with typedef",
      "Using typedef for struct definitions",
      "Writing cleaner, more readable code",
      "Understanding type abstraction",
      "Professional kernel coding practices"
    ],
    "files": [
      {
        "name": "typedef_basics.h",
        "content": "#ifndef TYPEDEF_BASICS_H\n#define TYPEDEF_BASICS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n#define MAX_NAME_LEN 32\n\n/* TODO: Define Device typedef */\n/* typedef struct {\n *     int device_id;\n *     char name[MAX_NAME_LEN];\n *     int status_code;\n *     bool is_active;\n * } Device; */\n\nextern Device my_device;\n\n/* TODO: Declare your functions using the typedef */\n/* void print_device_details(void); */\n/* void update_device_status(int new_status); */\n/* void check_device_state(void); */\n\n#endif /* TYPEDEF_BASICS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "typedef_basics.c",
        "content": "#include \"typedef_basics.h\"\n\n/* TODO: Initialize device using clean typedef syntax */\n/* Device my_device = {\n *     .device_id = 12345,\n *     .name = \"sensor01\",\n *     .status_code = 200,\n *     .is_active = true\n * }; */\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your typedef operations work\n * with different input values. Removing them will cause test failures.\n */\nmodule_param_named(device_id, my_device.device_id, int, 0644);\nMODULE_PARM_DESC(device_id, \"Device ID for testing typedef member access\");\nmodule_param_named(status_code, my_device.status_code, int, 0644);\nMODULE_PARM_DESC(status_code, \"Device status code for testing typedef operations\");\n/* Note: string and bool module params need special handling for typedefs */\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* TODO: Implement function to print device details */\n/* void print_device_details(void) {\n *     printk(KERN_INFO \"Device ID: %d\\n\", my_device.device_id);\n *     printk(KERN_INFO \"Device Name: %s\\n\", my_device.name);\n *     printk(KERN_INFO \"Status Code: %d\\n\", my_device.status_code);\n * } */\n\n/* TODO: Implement function to update device status */\n/* void update_device_status(int new_status) {\n *     my_device.status_code = new_status;\n *     my_device.is_active = (new_status == 200) ? true : false;\n *     printk(KERN_INFO \"Status updated to: %d\\n\", new_status);\n * } */\n\n/* TODO: Implement function to check device state */\n/* void check_device_state(void) {\n *     if (my_device.is_active) {\n *         printk(KERN_INFO \"Device State: ACTIVE\\n\");\n *     } else {\n *         printk(KERN_INFO \"Device State: INACTIVE\\n\");\n *     }\n * } */\n\nstatic int __init typedef_basics_init(void)\n{\n    printk(KERN_INFO \"Typedef basics module loaded\\n\");\n    \n    /* TODO: Print initial device details */\n    /* printk(KERN_INFO \"Initial Device Information:\\n\"); */\n    /* print_device_details(); */\n    /* check_device_state(); */\n    \n    /* TODO: Update status and show changes */\n    /* update_device_status(404); */\n    /* printk(KERN_INFO \"After status update:\\n\"); */\n    /* print_device_details(); */\n    /* check_device_state(); */\n    \n    return 0;\n}\n\nstatic void __exit typedef_basics_exit(void)\n{\n    printk(KERN_INFO \"Typedef basics module unloaded\\n\");\n}\n\nmodule_init(typedef_basics_init);\nmodule_exit(typedef_basics_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning typedef for cleaner code structure\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Typedef basics module Makefile\nobj-m += typedef_basics.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "typedef_basics.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "typedef_basics_init",
          "typedef_basics_exit",
          "print_device_details",
          "update_device_status",
          "check_device_state"
        ],
        "function_declarations": [
          {
            "name": "print_device_details",
            "returnType": "void",
            "parameters": []
          },
          {
            "name": "update_device_status",
            "returnType": "void",
            "parameters": [
              "int new_status"
            ]
          },
          {
            "name": "check_device_state",
            "returnType": "void",
            "parameters": []
          }
        ],
        "variables_declarations": [
          {
            "name": "Device",
            "type": "typedef struct",
            "value": "{int device_id; char name[MAX_NAME_LEN]; int status_code; bool is_active;}",
            "storageClass": "none"
          },
          {
            "name": "my_device",
            "type": "Device",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "my_device",
            "type": "Device",
            "value": "{.device_id = 12345, .name = \"sensor01\", .status_code = 200, .is_active = true}",
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Typedef basics module loaded",
          "Initial Device Information:",
          "Device ID: 12345",
          "Device Name: sensor01",
          "Status Code: 200",
          "Device State: ACTIVE",
          "Status updated to: 404",
          "After status update:",
          "Device ID: 12345",
          "Device Name: sensor01",
          "Status Code: 404",
          "Device State: INACTIVE"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "typedef struct {",
          "} Device;",
          "extern Device my_device",
          "Device my_device = {",
          "module_param_named(device_id, my_device.device_id, int, 0644)",
          "module_param_named(status_code, my_device.status_code, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_device_details(void)",
            "void update_device_status(int new_status)",
            "void check_device_state(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void print_device_details(void)",
            "void update_device_status(int new_status)",
            "void check_device_state(void)",
            "static int __init typedef_basics_init(void)",
            "static void __exit typedef_basics_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Typedef basics module loaded",
              "exact": true,
              "linkedFunction": "static int __init typedef_basics_init(void)"
            },
            {
              "pattern": "Initial Device Information:",
              "exact": true,
              "linkedFunction": "static int __init typedef_basics_init(void)"
            },
            {
              "pattern": "Device ID: 12345",
              "exact": true,
              "linkedFunction": "void print_device_details(void)"
            },
            {
              "pattern": "Device Name: sensor01",
              "exact": true,
              "linkedFunction": "void print_device_details(void)"
            },
            {
              "pattern": "Status Code: 200",
              "exact": true,
              "linkedFunction": "void print_device_details(void)"
            },
            {
              "pattern": "Device State: ACTIVE",
              "exact": true,
              "linkedFunction": "void check_device_state(void)"
            },
            {
              "pattern": "Status updated to: 404",
              "exact": true,
              "linkedFunction": "void update_device_status(int new_status)"
            },
            {
              "pattern": "After status update:",
              "exact": true,
              "linkedFunction": "static int __init typedef_basics_init(void)"
            },
            {
              "pattern": "Device ID: 12345",
              "exact": true,
              "linkedFunction": "void print_device_details(void)"
            },
            {
              "pattern": "Device Name: sensor01",
              "exact": true,
              "linkedFunction": "void print_device_details(void)"
            },
            {
              "pattern": "Status Code: 404",
              "exact": true,
              "linkedFunction": "void print_device_details(void)"
            },
            {
              "pattern": "Device State: INACTIVE",
              "exact": true,
              "linkedFunction": "void check_device_state(void)"
            }
          ]
        },
        {
          "id": "advanced_typedef_implementation_validation",
          "name": "Advanced Typedef Implementation with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "typedef_dynamic_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Typedef Implementation Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random device data\\n    int test_id1 = (rand() % 9000) + 10000;     // 10000-18999\\n    int test_status1 = (rand() % 2) ? 200 : 404; // 200 or 404\\n    int test_id2 = (rand() % 9000) + 20000;     // 20000-28999\\n    int test_status2 = (rand() % 2) ? 200 : 500; // 200 or 500\\n    \\n    printf(\\\"Test 1: Testing with device_id=%d, status_code=%d\\\\n\\\", test_id1, test_status1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/typedef_basics.ko device_id=%d status_code=%d\\\", test_id1, test_status1);\\n    system(\\\"rmmod typedef_basics 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Testing with device_id=%d, status_code=%d\\\\n\\\", test_id2, test_status2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/typedef_basics.ko device_id=%d status_code=%d\\\", test_id2, test_status2);\\n    system(\\\"rmmod typedef_basics\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Dynamic typedef test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced typedef implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param_named(name, var, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo '#define true 1' >> /tmp/linux/types.h",
              "echo '#define false 0' >> /tmp/linux/types.h",
              "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
              "echo 'Creating test file that includes typedef header...'",
              "echo '#include \"/lib/modules/typedef_basics.h\"' > /tmp/test.c",
              "echo 'int main() { my_device.device_id = 999; print_device_details(); update_device_status(500); check_device_state(); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or typedef declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and typedef declarations found in header file'; fi",
              "echo 'Phase 2: Dynamic Typedef Implementation Testing'",
              "/bin/typedef_dynamic_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Dynamic Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "TEST1_ID=$(grep -o 'Test 1: Testing with device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
              "TEST1_STATUS=$(grep -o 'status_code=[0-9]*' /tmp/test_output.log | head -1 | cut -d'=' -f2)",
              "TEST2_ID=$(grep -o 'Test 2: Testing with device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
              "TEST2_STATUS=$(grep -o 'status_code=[0-9]*' /tmp/test_output.log | tail -1 | cut -d'=' -f2)",
              "echo 'Test values: ID1='$TEST1_ID', Status1='$TEST1_STATUS', ID2='$TEST2_ID', Status2='$TEST2_STATUS",
              "echo 'Validating typedef-based structure member access with dynamic values'",
              "dmesg | grep 'Device ID: '$TEST1_ID && echo 'PASS: Typedef structure member access working with '$TEST1_ID || echo 'FAIL: Typedef structure member access broken for '$TEST1_ID",
              "dmesg | grep 'Device Name: sensor01' && echo 'PASS: Typedef string member access working' || echo 'FAIL: Typedef string member access broken'",
              "dmesg | grep 'Status Code: '$TEST1_STATUS && echo 'PASS: Typedef status member access working with '$TEST1_STATUS || echo 'FAIL: Typedef status member access broken for '$TEST1_STATUS",
              "dmesg | grep 'Device ID: '$TEST2_ID && echo 'PASS: Typedef structure member access working with '$TEST2_ID || echo 'FAIL: Typedef structure member access broken for '$TEST2_ID",
              "dmesg | grep 'Status Code: '$TEST2_STATUS && echo 'PASS: Typedef status member access working with '$TEST2_STATUS || echo 'FAIL: Typedef status member access broken for '$TEST2_STATUS",
              "echo 'Phase 3.1: Function Logic Validation'",
              "dmesg | grep 'Status updated to: 404' && echo 'PASS: update_device_status function message works' || echo 'FAIL: update_device_status message broken'",
              "dmesg | grep 'Status Code: 404' && echo 'PASS: update_device_status actually modified typedef structure member' || echo 'FAIL: update_device_status function logic broken - structure not modified'",
              "dmesg | grep 'Device State: INACTIVE' && echo 'PASS: check_device_state function using typedef member correctly' || echo 'FAIL: check_device_state not using typedef structure member'",
              "echo 'Phase 3.2: Final State Validation'",
              "dmesg | grep 'After status update:' && echo 'PASS: Final print_device_details called' || echo 'FAIL: Final print_device_details not called'",
              "dmesg | grep 'Status Code: 404' && echo 'PASS: Final state shows correct typedef member modification' || echo 'FAIL: Final state typedef member modification broken'",
              "dmesg | grep 'Device State: INACTIVE' && echo 'PASS: Final state shows correct conditional logic' || echo 'FAIL: Final state conditional logic broken'",
              "echo 'Phase 4: Typedef Definition Validation'",
              "dmesg | grep 'Typedef basics module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
              "echo 'All typedef implementation validations completed'"
            ],
            "expected": {
              "dmesg": [
                "Typedef basics module loaded",
                "Device ID: .*",
                "Device Name: sensor01",
                "Status Code: .*",
                "Device State: ACTIVE",
                "Status updated to: 404"
              ],
              "stdout": [
                "PASS: All function and typedef declarations found in header file",
                "SUCCESS: Dynamic typedef test completed",
                "PASS: Typedef structure member access working with .*",
                "PASS: Typedef string member access working",
                "PASS: Typedef status member access working with .*",
                "PASS: update_device_status function message works",
                "PASS: update_device_status actually modified typedef structure member",
                "PASS: check_device_state function using typedef member correctly",
                "PASS: Final print_device_details called",
                "PASS: Final state shows correct typedef member modification",
                "PASS: Final state shows correct conditional logic"
              ]
            },
            "timeout": 15
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Typedef basics module loaded",
        "Initial Device Information:",
        "Device ID: 12345",
        "Device Name: sensor01",
        "Status Code: 200",
        "Device State: ACTIVE",
        "Status updated to: 404",
        "After status update:",
        "Device ID: 12345",
        "Device Name: sensor01",
        "Status Code: 404",
        "Device State: INACTIVE"
      ],
      "requirements": [
        "Use required function names: typedef_basics_init, typedef_basics_exit, print_device_details, update_device_status, check_device_state",
        "Use required variable names: my_device",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: typedef struct {, } Device;, extern Device my_device, Device my_device = {, module_param_named(device_id, my_device.device_id, int, 0644), module_param_named(status_code, my_device.status_code, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Typedef basics module loaded",
          "linkedFunction": "static int __init typedef_basics_init(void)",
          "exact": true
        },
        {
          "pattern": "Initial Device Information:",
          "linkedFunction": "static int __init typedef_basics_init(void)",
          "exact": true
        },
        {
          "pattern": "Device ID: 12345",
          "linkedFunction": "void print_device_details(void)",
          "exact": true
        },
        {
          "pattern": "Device Name: sensor01",
          "linkedFunction": "void print_device_details(void)",
          "exact": true
        },
        {
          "pattern": "Status Code: 200",
          "linkedFunction": "void print_device_details(void)",
          "exact": true
        },
        {
          "pattern": "Device State: ACTIVE",
          "linkedFunction": "void check_device_state(void)",
          "exact": true
        },
        {
          "pattern": "Status updated to: 404",
          "linkedFunction": "void update_device_status(int new_status)",
          "exact": true
        },
        {
          "pattern": "After status update:",
          "linkedFunction": "static int __init typedef_basics_init(void)",
          "exact": true
        },
        {
          "pattern": "Device ID: 12345",
          "linkedFunction": "void print_device_details(void)",
          "exact": true
        },
        {
          "pattern": "Device Name: sensor01",
          "linkedFunction": "void print_device_details(void)",
          "exact": true
        },
        {
          "pattern": "Status Code: 404",
          "linkedFunction": "void print_device_details(void)",
          "exact": true
        },
        {
          "pattern": "Device State: INACTIVE",
          "linkedFunction": "void check_device_state(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 19,
    "title": "Dynamic Memory - WHEN and WHY to Use kmalloc",
    "difficulty": 4,
    "xp": 40,
    "phase": "foundations",
    "description": "Master the decision-making process for dynamic vs static memory allocation in kernel development. Learn WHEN kmalloc is required (runtime-determined sizes, persistent memory, returning pointers) and WHY static allocation fails in these scenarios. Understand the kmalloc/kfree lifecycle pattern used throughout the Linux kernel.",
    "concepts": [
      "WHEN to use kmalloc vs static allocation (decision tree)",
      "WHY static allocation fails (runtime-determined sizes)",
      "Single-level array allocation with kmalloc",
      "kmalloc() function and GFP_KERNEL flags",
      "kfree() function and proper cleanup",
      "NULL pointer checking and error handling",
      "Memory lifecycle: allocate, check, use, free",
      "Use-after-free prevention",
      "Direct array indexing with allocated memory"
    ],
    "skills": [
      "Applying decision tree for static vs dynamic allocation",
      "Identifying scenarios requiring kmalloc (runtime sizes, persistent lifetime, returning pointers)",
      "Implementing single-level array allocation",
      "Using kmalloc(sizeof(Type) * count, GFP_KERNEL) for arrays",
      "Proper error handling for allocation failures",
      "Direct array indexing with allocated memory",
      "Setting pointers to NULL after freeing"
    ],
    "files": [
      {
        "name": "MEMORY_ALLOCATION_GUIDE.md",
        "content": "# Dynamic Memory Allocation - Visual Guide for Kernel Programming\n\n## Understanding the Core Concept\n\nThis guide uses **generic examples** to help you understand WHEN and WHY to use dynamic memory allocation (kmalloc) versus static allocation in kernel development.\n\n## The Fundamental Question: Static or Dynamic?\n\nBefore writing any memory allocation code, ask yourself:\n**\"Do I know the size at compile time, and will the memory lifetime work with the stack?\"**\n\n---\n\n## Part 1: The Decision Tree\n\n### WHEN Must You Use kmalloc?\n\nFollow this decision tree:\n\n```\n┌─────────────────────────────────────────────────┐\n│  Q1: Is the size known at COMPILE TIME?        │\n└─────────────────────────────────────────────────┘\n                    │\n        ┌───────────┴───────────┐\n       NO                      YES\n        │                        │\n        ▼                        ▼\n  ┌──────────┐         ┌─────────────────────────┐\n  │ USE      │         │ Q2: Does memory need to │\n  │ KMALLOC  │         │ outlive function scope? │\n  │ (MUST)   │         └─────────────────────────┘\n  └──────────┘                    │\n                      ┌───────────┴───────────┐\n                     YES                     NO\n                      │                       │\n                      ▼                       ▼\n                ┌──────────┐        ┌─────────────────────┐\n                │ USE      │        │ Q3: Returning       │\n                │ KMALLOC  │        │ pointer from func?  │\n                │ (MUST)   │        └─────────────────────┘\n                └──────────┘                  │\n                                  ┌───────────┴───────────┐\n                                 YES                     NO\n                                  │                       │\n                                  ▼                       ▼\n                            ┌──────────┐          ┌────────────┐\n                            │ USE      │          │ STATIC OK  │\n                            │ KMALLOC  │          │ (optional) │\n                            │ (MUST)   │          └────────────┘\n                            └──────────┘\n```\n\n---\n\n## Part 2: Stack vs Heap Memory\n\n### Understanding Where Memory Lives\n\n**Stack Memory (Static Allocation):**\n```\nFunction scope:\nvoid my_function() {\n    int local_var = 42;        ← Lives on STACK\n    Device dev = {1, 2, true}; ← Lives on STACK\n    \n    // Memory is AUTOMATICALLY freed when function returns\n}\n// After return: local_var and dev are GONE!\n```\n\n**Heap Memory (Dynamic Allocation):**\n```\nFunction scope:\nvoid my_function() {\n    Device *dev = kmalloc(sizeof(Device), GFP_KERNEL); ← Lives on HEAP\n    \n    // Memory persists even after function returns\n}\n// After return: Memory still exists! (Must manually free later)\n```\n\n**Memory Layout Visualization:**\n```\n┌─────────────────────────────────────┐ High Addresses\n│                                     │\n│  KERNEL SPACE (not accessible)      │\n│                                     │\n├─────────────────────────────────────┤\n│                                     │\n│  STACK (grows downward)             │ ← Static allocation lives here\n│  ┌───────────────────────┐          │\n│  │ Function call frames  │          │\n│  │ Local variables       │          │\n│  │ Function parameters   │          │\n│  └───────────────────────┘          │\n│         ↓                           │\n│                                     │\n│  (Free space)                       │\n│                                     │\n│         ↑                           │\n│  ┌───────────────────────┐          │\n│  │ Dynamically allocated │          │ ← kmalloc allocates here\n│  │ memory (heap)         │          │\n│  └───────────────────────┘          │\n│  HEAP (grows upward)                │\n│                                     │\n├─────────────────────────────────────┤\n│  BSS (uninitialized globals)        │\n│  DATA (initialized globals)         │\n│  TEXT (program code)                │\n└─────────────────────────────────────┘ Low Addresses\n```\n\n**Key Differences:**\n\n```\n┌──────────────┬─────────────────┬──────────────────┐\n│ Property     │ STACK (static)  │ HEAP (kmalloc)   │\n├──────────────┼─────────────────┼──────────────────┤\n│ Lifetime     │ Function scope  │ Until kfree()    │\n│ Size         │ Compile-time    │ Runtime          │\n│ Speed        │ FAST            │ Slower           │\n│ Cleanup      │ Automatic       │ Manual (kfree)   │\n│ Failure risk │ Stack overflow  │ Out of memory    │\n└──────────────┴─────────────────┴──────────────────┘\n```\n\n---\n\n## Part 2.5: Global/Static Storage - The Third Option\n\n### Understanding Module-Lifetime Memory\n\nBefore diving into when kmalloc is required, you need to understand the THIRD storage type: **Global/Static storage**.\n\n**Global Storage (outside functions):**\n```c\n/* Declared OUTSIDE any function - at file scope */\nDevice global_device = {1001, 200, true};\n\nstatic int __init my_init(void) {\n    global_device.device_id = 2000;  // Works fine!\n    return 0;\n}\n\nstatic void __exit my_exit(void) {\n    // global_device STILL EXISTS here!\n    printk(KERN_INFO \"Device ID: %d\\n\", global_device.device_id);\n}\n```\n\n**Complete Memory Layout with All Three Types:**\n```\n┌─────────────────────────────────────┐ High Addresses\n│                                     │\n│  KERNEL SPACE (not accessible)      │\n│                                     │\n├─────────────────────────────────────┤\n│                                     │\n│  STACK (grows downward)             │ ← Stack variables live here\n│  ┌───────────────────────┐          │   (function local variables)\n│  │ Function call frames  │          │   Lifetime: function scope\n│  │ Local variables       │          │   Cleanup: automatic\n│  └───────────────────────┘          │\n│         ↓                           │\n│                                     │\n│  (Free space)                       │\n│                                     │\n│         ↑                           │\n│  ┌───────────────────────┐          │\n│  │ Dynamically allocated │          │ ← kmalloc allocates here\n│  │ memory (heap)         │          │   Lifetime: until kfree()\n│  └───────────────────────┘          │   Cleanup: manual (kfree)\n│  HEAP (grows upward)                │\n│                                     │\n├─────────────────────────────────────┤\n│  BSS (uninitialized globals)        │ ← Global/static variables\n│  ┌───────────────────────┐          │   declared without initial value\n│  │ static int count;     │          │   Automatically zeroed\n│  └───────────────────────┘          │\n│                                     │\n│  DATA (initialized globals)         │ ← Global/static variables\n│  ┌───────────────────────┐          │   declared with initial value\n│  │ Device global_device  │          │   Lifetime: ENTIRE module\n│  │   = {1001, 200, true};│          │   Cleanup: automatic\n│  └───────────────────────┘          │\n│                                     │\n│  TEXT (program code)                │ ← Your functions live here\n└─────────────────────────────────────┘ Low Addresses\n```\n\n**Understanding the Segments:**\n\n```\nDATA segment (initialized globals):\n┌──────────────────────────────────┐\n│ Device global_device = {...};    │ ← Known value at compile time\n│ int config_value = 42;           │ ← Stored in binary\n└──────────────────────────────────┘\nLifetime: Entire module (insmod to rmmod)\nInitialization: Done when module loads\nCleanup: Automatic when module unloads\n\nBSS segment (uninitialized globals):\n┌──────────────────────────────────┐\n│ static int counter;              │ ← Automatically set to 0\n│ static Device devices[100];      │ ← All fields zeroed\n└──────────────────────────────────┘\nLifetime: Entire module (insmod to rmmod)\nInitialization: All zeros (automatic)\nCleanup: Automatic when module unloads\n```\n\n### When to Use Global Storage\n\n**Use GLOBAL when:**\n- Module configuration or state needs to persist across function calls\n- List heads for data structures (like in Problem 26)\n- Shared data accessed by multiple functions\n- Size is known at compile time AND lifetime is module-long\n- No kmalloc/kfree needed!\n\n**Examples of appropriate global usage:**\n\n**Example 1: Module configuration**\n```c\nstatic int debug_enabled = 0;  // Module-wide config\nmodule_param(debug_enabled, int, 0644);\n\nvoid function_a(void) {\n    if (debug_enabled) {\n        printk(KERN_INFO \"Debug: Function A\\n\");\n    }\n}\n\nvoid function_b(void) {\n    if (debug_enabled) {  // Same variable accessible here!\n        printk(KERN_INFO \"Debug: Function B\\n\");\n    }\n}\n```\n\n**Example 2: List heads (Problem 26 pattern)**\n```c\n/* Global list head - anchor for linked list */\nstruct list_head device_list;  // Lives entire module lifetime\n\nstatic int __init my_init(void) {\n    INIT_LIST_HEAD(&device_list);  // Initialize once\n    return 0;\n}\n\nvoid add_device(struct device_entry *dev) {\n    list_add(&dev->list, &device_list);  // Accessible anywhere\n}\n```\n\n**Example 3: Module state**\n```c\nstatic int total_requests = 0;  // Track across all function calls\n\nvoid handle_request(void) {\n    total_requests++;  // Persists between calls\n    printk(KERN_INFO \"Total requests: %d\\n\", total_requests);\n}\n```\n\n### Global vs Stack vs Heap Comparison\n\n**Complete comparison table:**\n```\n┌──────────────┬─────────────────┬─────────────────┬──────────────────┐\n│ Property     │ GLOBAL/STATIC   │ STACK (local)   │ HEAP (kmalloc)   │\n├──────────────┼─────────────────┼─────────────────┼──────────────────┤\n│ Lifetime     │ Module lifetime │ Function scope  │ Until kfree()    │\n│ Size         │ Compile-time    │ Compile-time    │ Runtime          │\n│ Speed        │ FASTEST         │ FAST            │ Slower           │\n│ Cleanup      │ Automatic       │ Automatic       │ Manual (kfree)   │\n│ Visibility   │ File/Module     │ Function only   │ Pointer-based    │\n│ Location     │ DATA/BSS        │ Stack           │ Heap             │\n│ Use case     │ Module state    │ Temporary work  │ Dynamic size     │\n│ Initialization│ At module load │ Each call       │ After kmalloc    │\n└──────────────┴─────────────────┴─────────────────┴──────────────────┘\n```\n\n### Visual Comparison: Same Data, Different Storage\n\n**Scenario: Store a single device**\n\n```\nGLOBAL storage:\n  Device global_dev = {1001, 200, true};  // At file scope\n  \n  Memory layout:\n  ┌─────────────────────────────────────┐\n  │ DATA segment                        │\n  │ ┌─────────────────────────┐         │\n  │ │ global_dev:             │         │ Lives: entire module\n  │ │   device_id = 1001      │         │ No kmalloc needed\n  │ │   status = 200          │         │ No kfree needed\n  │ │   is_active = true      │         │\n  │ └─────────────────────────┘         │\n  └─────────────────────────────────────┘\n\nSTACK storage:\n  void my_function(void) {\n      Device local_dev = {1001, 200, true};  // Local variable\n  }\n  \n  Memory layout DURING function:\n  ┌─────────────────────────────────────┐\n  │ Stack frame                         │\n  │ ┌─────────────────────────┐         │\n  │ │ local_dev:              │         │ Lives: function only\n  │ │   device_id = 1001      │         │ Destroyed on return!\n  │ │   status = 200          │         │\n  │ │   is_active = true      │         │\n  │ └─────────────────────────┘         │\n  └─────────────────────────────────────┘\n  \n  Memory layout AFTER function returns:\n  ┌─────────────────────────────────────┐\n  │ Stack frame                         │\n  │ ????????????????????????           │ GARBAGE! Don't access!\n  └─────────────────────────────────────┘\n\nHEAP storage:\n  Device *heap_dev = kmalloc(sizeof(Device), GFP_KERNEL);\n  heap_dev->device_id = 1001;\n  heap_dev->status = 200;\n  heap_dev->is_active = true;\n  \n  Memory layout:\n  ┌─────────────────────────────────────┐\n  │ Heap                                │\n  │ ┌─────────────────────────┐         │\n  │ │ Allocated memory:       │         │ Lives: until kfree()\n  │ │   device_id = 1001      │         │ Persists across functions\n  │ │   status = 200          │         │ MUST call kfree() later\n  │ │   is_active = true      │         │\n  │ └─────────────────────────┘         │\n  └─────────────────────────────────────┘\n  \n  Stack (just the pointer):\n  ┌─────────────────────────────────────┐\n  │ heap_dev ──────────┐                │\n  └────────────────────┼────────────────┘\n                       │\n                       └──→ Points to heap memory above\n```\n\n### Common Global Storage Mistakes\n\n**Mistake 1: Using global when heap is needed (runtime size)**\n```c\n/* WRONG: Size determined at runtime */\nint count = get_device_count();  // Runtime value\nDevice devices[count];  // ILLEGAL! VLA not allowed in kernel!\n\n/* CORRECT: Use heap for runtime sizes */\nint count = get_device_count();\nDevice *devices = kmalloc(sizeof(Device) * count, GFP_KERNEL);\n```\n\n**Mistake 2: Returning address of stack variable (should use global or heap)**\n```c\n/* WRONG: Returning stack address */\nDevice* bad_get_device(void) {\n    Device local = {1001, 200, true};  // Stack variable\n    return &local;  // DANGER! Dies when function returns\n}\n\n/* OPTION 1: Use global if single instance */\nDevice global_device = {1001, 200, true};\nDevice* good_get_device_global(void) {\n    return &global_device;  // SAFE: Global persists\n}\n\n/* OPTION 2: Use heap if multiple instances */\nDevice* good_get_device_heap(void) {\n    Device *dev = kmalloc(sizeof(Device), GFP_KERNEL);\n    if (!dev) return NULL;\n    dev->device_id = 1001;\n    dev->status = 200;\n    dev->is_active = true;\n    return dev;  // SAFE: Heap persists\n}\n```\n\n**Mistake 3: Over-using global (should use stack)**\n```c\n/* WRONG: Global for temporary work */\nstatic int temp_calculation;  // Unnecessarily global\n\nvoid calculate_something(void) {\n    temp_calculation = 5 + 10;  // This should be local!\n    return temp_calculation;\n}\n\n/* CORRECT: Use stack for temporary values */\nvoid calculate_something(void) {\n    int temp_calculation = 5 + 10;  // Local is sufficient\n    return temp_calculation;\n}\n```\n\n### Updated Decision Tree (Including Global)\n\n```\n┌─────────────────────────────────────────────────┐\n│  Q1: Is the size known at COMPILE TIME?        │\n└─────────────────────────────────────────────────┘\n                    │\n        ┌───────────┴───────────┐\n       NO                      YES\n        │                        │\n        ▼                        ▼\n  ┌──────────┐         ┌─────────────────────────┐\n  │ USE      │         │ Q2: Does memory need to │\n  │ KMALLOC  │         │ persist beyond function?│\n  │ (MUST)   │         └─────────────────────────┘\n  └──────────┘                    │\n                      ┌───────────┴───────────┐\n                     YES                     NO\n                      │                       │\n                      ▼                       ▼\n                ┌──────────────────┐    ┌─────────┐\n                │ Q3: Shared across│    │ USE     │\n                │ multiple funcs?  │    │ STACK   │\n                └──────────────────┘    │ (local) │\n                      │                 └─────────┘\n          ┌───────────┴───────────┐\n         YES                     NO\n          │                       │\n          ▼                       ▼\n    ┌──────────┐          ┌──────────┐\n    │ USE      │          │ USE      │\n    │ GLOBAL   │          │ KMALLOC  │\n    │ (static) │          │ (return) │\n    └──────────┘          └──────────┘\n```\n\n### Real-World Kernel Examples\n\n**Example: Global list heads in Problem 26**\n```c\n/* GLOBAL - List heads anchor the entire linked list structure */\nstruct list_head manual_device_list;   // Lives entire module lifetime\nstruct list_head kernel_device_list;   // Shared across all functions\n\n/* HEAP - Individual device nodes allocated dynamically */\nstruct device_entry *dev = kmalloc(sizeof(*dev), GFP_KERNEL);\n\n/* Why this mix? */\n/* - List heads are fixed size, known at compile time, module-lifetime */\n/* - Device entries are variable count, created/destroyed dynamically */\n```\n\n**Example: Module parameters (always global)**\n```c\nstatic int device_count = 3;  // Must be global for module_param\nmodule_param(device_count, int, 0644);\n\n/* Why global? */\n/* - module_param macro requires file scope variable */\n/* - Value persists across entire module lifetime */\n/* - Shared by all functions that need device count */\n```\n\n### Key Takeaways\n\n1. **Global = Module-lifetime data** - Use for configuration, state, list heads\n2. **Stack = Temporary work** - Use for calculations, short-lived values\n3. **Heap = Dynamic/persistent data** - Use for runtime sizes, returned pointers\n4. **No kmalloc/kfree for global** - Memory management is automatic\n5. **Global is NOT same as static local** - Different scope and lifetime\n6. **Know all three before choosing** - Each has specific use cases\n\n---\n\n## Part 3: Scenario 1 - Runtime-Determined Size\n\n### The Problem: Size Unknown at Compile Time\n\n**Example: Module parameter determines array size**\n\n```c\nint device_count = 5;  // Set at MODULE LOAD TIME via parameter\nmodule_param(device_count, int, 0644);\n```\n\n**WRONG - Static Allocation:**\n```c\nDevice devices[device_count];  // ILLEGAL!\n//             ^\n//             |\n//     Variable-Length Array (VLA)\n//     NOT ALLOWED in kernel code!\n```\n\n**Why this fails:**\n- `device_count` is only known when user runs `insmod module.ko device_count=10`\n- Compiler needs array size at compile time\n- VLAs are prohibited in kernel for safety (stack overflow risk)\n\n**CORRECT - Dynamic Allocation:**\n```c\nDevice *devices = kmalloc(sizeof(Device) * device_count, GFP_KERNEL);\n//      ^         ^        ^                 ^\n//      |         |        |                 |\n//   pointer   allocate  size per item    count of items\n```\n\n**Memory Layout:**\n```\nBEFORE kmalloc:\n  Stack:                 Heap:\n  ┌──────────┐          (empty)\n  │ devices  │ = NULL\n  └──────────┘\n\nAFTER kmalloc (device_count = 3):\n  Stack:                 Heap:\n  ┌──────────┐          ┌────────────────┐\n  │ devices  │────────→ │ Device 0       │\n  └──────────┘          │ Device 1       │\n                        │ Device 2       │\n                        └────────────────┘\n                        Single contiguous array!\n```\n\n**Accessing elements:**\n```c\ndevices[0].device_id = 1000;  // First device\ndevices[1].device_id = 1001;  // Second device\ndevices[2].device_id = 1002;  // Third device\n\n// Same as:\n(&devices[0])->device_id = 1000;\n(&devices[1])->device_id = 1001;\n(&devices[2])->device_id = 1002;\n```\n\n---\n\n## Part 4: Scenario 2 - Returning Pointers from Functions\n\n### The Problem: Returning Local Variables\n\n**DANGEROUS - Returning Stack Address:**\n```c\nDevice* create_device_wrong(int id) {\n    Device local = {id, 200, true};  // Lives on STACK\n    return &local;                    // DANGER!\n}\n//  Function returns\n//  Stack frame destroyed\n//  'local' no longer exists!\n```\n\n**What happens:**\n```\nDURING function:\n  Stack:                         \n  ┌────────────────────┐         \n  │ create_device_wrong│         \n  │ ┌────────────────┐ │         \n  │ │ local:         │ │ ← Address 0x1000\n  │ │   id = 1001    │ │         \n  │ │   status = 200 │ │         \n  │ │   active = true│ │         \n  │ └────────────────┘ │         \n  └────────────────────┘         \n\nAFTER function returns:\n  Stack:                         \n  ┌────────────────────┐         \n  │ (Frame popped)     │         \n  │ ????????????????   │ ← Address 0x1000 now GARBAGE!\n  └────────────────────┘         \n\n  Caller has pointer to 0x1000:\n  Device *dev = create_device_wrong(1001);\n  dev->device_id  ← Reading GARBAGE! (Undefined behavior)\n```\n\n**SAFE - Using kmalloc:**\n```c\nDevice* create_device_correct(int id) {\n    Device *dev = kmalloc(sizeof(Device), GFP_KERNEL);\n    if (!dev) {\n        return NULL;  // Allocation failed\n    }\n    \n    dev->device_id = id;\n    dev->status = 200;\n    dev->is_active = true;\n    \n    return dev;  // SAFE! Heap memory persists\n}\n```\n\n**Memory flow:**\n```\nDURING function:\n  Stack:                 Heap:\n  ┌────────────────┐    ┌────────────────┐\n  │ create_device  │    │ Device:        │ ← Address 0x5000\n  │ ┌────┐         │    │   id = 1001    │\n  │ │dev │─────────┼───→│   status = 200 │\n  │ └────┘         │    │   active = true│\n  └────────────────┘    └────────────────┘\n\nAFTER function returns:\n  Stack:                 Heap:\n  ┌────────────────┐    ┌────────────────┐\n  │ (Frame popped) │    │ Device:        │ ← Still at 0x5000!\n  └────────────────┘    │   id = 1001    │   MEMORY PERSISTS!\n                        │   status = 200 │\n  Caller:               │   active = true│\n  Device *dev ─────────→└────────────────┘\n  dev->device_id works!\n```\n\n---\n\n## Part 5: The kmalloc/kfree Lifecycle\n\n### The Four Essential Steps\n\n**Step 1: ALLOCATE**\n```c\nDevice *dev = kmalloc(sizeof(Device), GFP_KERNEL);\n//      ^     ^        ^               ^\n//      |     |        |               |\n//   pointer  alloc   size          flags (kernel memory, can sleep)\n```\n\n**Breaking down the syntax:**\n```\nkmalloc(size_t size, gfp_t flags)\n        ^            ^\n        |            |\n        |            Memory allocation flags:\n        |            - GFP_KERNEL: Normal allocation (can sleep)\n        |            - GFP_ATOMIC: Atomic (interrupt context)\n        |\n        Number of bytes to allocate\n\nsizeof(Device)\n  Returns size of Device structure in bytes\n  Example: If Device has:\n    int (4 bytes) + int (4 bytes) + bool (1 byte) + padding (3 bytes)\n    = 12 bytes total\n\nsizeof(Device) * count\n  For arrays: multiply by number of elements\n  Example: 5 devices × 12 bytes = 60 bytes\n```\n\n**Step 2: CHECK (CRITICAL!)**\n```c\nif (!dev) {\n    printk(KERN_ERR \"Allocation failed!\\n\");\n    return -ENOMEM;  // Error code for \"out of memory\"\n}\n```\n\n**Why checking is critical:**\n```\nkmalloc CAN FAIL when:\n- System is out of memory\n- Requested size is too large\n- Memory is fragmented\n\nIF you don't check:\ndev->device_id = 1001;  ← NULL pointer dereference!\n                        ← KERNEL PANIC! System crashes!\n```\n\n**Memory state after allocation:**\n```\nSUCCESS:\n  dev ────→  ┌────────────┐\n             │ ????????   │ ← Uninitialized!\n             │ ????????   │    Contains garbage!\n             │ ????????   │\n             └────────────┘\n\nFAILURE:\n  dev = NULL ──→ (nothing)\n```\n\n**Step 3: USE**\n```c\ndev->device_id = 1001;\ndev->status = 200;\ndev->is_active = true;\n```\n\n**Memory after initialization:**\n```\n  dev ────→  ┌────────────────┐\n             │ device_id: 1001│ ← Initialized\n             │ status: 200    │\n             │ is_active: true│\n             └────────────────┘\n```\n\n**Step 4: FREE**\n```c\nkfree(dev);\ndev = NULL;  // Important! Prevent use-after-free\n```\n\n**Memory after kfree:**\n```\nBEFORE kfree:\n  dev ────→  ┌────────────────┐\n             │ device_id: 1001│\n             │ status: 200    │\n             │ is_active: true│\n             └────────────────┘\n\nAFTER kfree(dev):\n  dev ────→  ┌────────────────┐\n             │ ????????       │ ← Memory freed!\n             │ ????????       │    Contents undefined!\n             │ ????????       │    DANGEROUS to access!\n             └────────────────┘\n\nAFTER dev = NULL:\n  dev = NULL ──→ (nothing)      ← Safe! Can't accidentally use\n```\n\n---\n\n## Part 6: Common Mistakes and How to Avoid Them\n\n### Mistake 1: Memory Leak (Forgetting kfree)\n\n**WRONG:**\n```c\nvoid process_device(void) {\n    Device *dev = kmalloc(sizeof(Device), GFP_KERNEL);\n    if (!dev) return;\n    \n    dev->device_id = 1001;\n    \n    // Function returns without freeing!\n    return;  // MEMORY LEAK!\n}\n```\n\n**What happens:**\n```\nCall 1:  Allocates 12 bytes  ────→ Lost forever!\nCall 2:  Allocates 12 bytes  ────→ Lost forever!\nCall 3:  Allocates 12 bytes  ────→ Lost forever!\n...\nCall 1000: System runs out of memory! \n```\n\n**CORRECT:**\n```c\nvoid process_device(void) {\n    Device *dev = kmalloc(sizeof(Device), GFP_KERNEL);\n    if (!dev) return;\n    \n    dev->device_id = 1001;\n    \n    kfree(dev);  // Always free!\n    dev = NULL;\n}\n```\n\n### Mistake 2: Use-After-Free\n\n**WRONG:**\n```c\nDevice *dev = kmalloc(sizeof(Device), GFP_KERNEL);\ndev->device_id = 1001;\n\nkfree(dev);\n\ndev->device_id = 1002;  // Use-after-free!\n```\n\n**What happens:**\n```\nAFTER kfree:\n  dev still points to freed memory\n  \n  dev ────→  ┌────────────────┐\n             │ ????????       │ ← May be reused by kernel!\n             │ ????????       │ ← Writing here corrupts memory!\n             │ ????????       │ ← UNDEFINED BEHAVIOR!\n             └────────────────┘\n\nCould cause:\n- Data corruption\n- Kernel panic\n- Security vulnerabilities\n```\n\n**CORRECT:**\n```c\nDevice *dev = kmalloc(sizeof(Device), GFP_KERNEL);\ndev->device_id = 1001;\n\nkfree(dev);\ndev = NULL;  // Prevent use-after-free\n\nif (dev) {   // This check now prevents the bug\n    dev->device_id = 1002;\n}\n```\n\n### Mistake 3: Double Free\n\n**WRONG:**\n```c\nDevice *dev = kmalloc(sizeof(Device), GFP_KERNEL);\nkfree(dev);\nkfree(dev);  // Double free!\n```\n\n**What happens:**\n```\nFirst kfree:\n  Memory returned to kernel allocator\n  Kernel marks it as \"free\"\n\nSecond kfree:\n  Kernel thinks memory is allocated\n  Tries to free already-free memory\n  CORRUPTS KERNEL ALLOCATOR DATA STRUCTURES!\n  KERNEL PANIC! \n```\n\n**CORRECT:**\n```c\nDevice *dev = kmalloc(sizeof(Device), GFP_KERNEL);\nkfree(dev);\ndev = NULL;  // Prevent double free\n\nif (dev) {   // This check prevents second free\n    kfree(dev);\n}\n```\n\n### Mistake 4: Forgetting NULL Check\n\n**WRONG:**\n```c\nDevice *dev = kmalloc(sizeof(Device), GFP_KERNEL);\ndev->device_id = 1001;  // What if kmalloc failed?\n```\n\n**What happens:**\n```\nIF kmalloc fails:\n  dev = NULL\n  \nNULL->device_id\n  Try to dereference address 0x00000000\n  KERNEL PANIC! \n```\n\n**CORRECT:**\n```c\nDevice *dev = kmalloc(sizeof(Device), GFP_KERNEL);\nif (!dev) {  // Always check!\n    printk(KERN_ERR \"Out of memory!\\n\");\n    return -ENOMEM;\n}\ndev->device_id = 1001;  // Safe now\n```\n\n---\n\n## Part 7: Single Array Allocation Pattern\n\n### Allocating an Array of Structures\n\n**Pattern:**\n```c\nint count = 5;\nDevice *devices = kmalloc(sizeof(Device) * count, GFP_KERNEL);\n//                       └────────┬─────────┘\n//                          Total bytes needed\n```\n\n**Memory layout:**\n```\nHeap (single contiguous allocation):\n┌────────────────────────────────────────────────┐\n│ devices[0]  devices[1]  devices[2] ...         │\n│ 12 bytes    12 bytes    12 bytes               │\n└────────────────────────────────────────────────┘\n ↑\n devices pointer\n\nTotal: 5 × 12 bytes = 60 bytes (contiguous)\n```\n\n**Accessing elements:**\n```c\n// Method 1: Array notation\ndevices[0].device_id = 1000;\ndevices[1].device_id = 1001;\ndevices[2].device_id = 1002;\n\n// Method 2: Pointer notation\n(&devices[0])->device_id = 1000;\n(&devices[1])->device_id = 1001;\n\n// Method 3: Pointer arithmetic\n(devices + 0)->device_id = 1000;\n(devices + 1)->device_id = 1001;\n\n// All three are equivalent!\n```\n\n**Cleanup (simple!):**\n```c\nkfree(devices);  // Single free for entire array!\ndevices = NULL;\n\n// NO LOOP NEEDED!\n// The entire contiguous block is freed at once.\n```\n\n**Visualization:**\n```\nALLOCATION:\n  Single kmalloc call\n      ↓\n  ┌─────┬─────┬─────┬─────┬─────┐\n  │ [0] │ [1] │ [2] │ [3] │ [4] │\n  └─────┴─────┴─────┴─────┴─────┘\n\nFREE:\n  Single kfree call\n      ↓\n  Entire array freed at once!\n```\n\n---\n\n## Part 8: GFP Flags - Memory Allocation Context\n\n### Understanding GFP_KERNEL\n\n**Common GFP flags:**\n```\n┌──────────────┬─────────────────┬──────────────────┐\n│ Flag         │ When to use     │ Can sleep?       │\n├──────────────┼─────────────────┼──────────────────┤\n│ GFP_KERNEL   │ Normal context  │ YES (can wait)   │\n│ GFP_ATOMIC   │ Interrupt/lock  │ NO (must succeed)│\n│ GFP_NOWAIT   │ No sleeping     │ NO               │\n│ GFP_DMA      │ DMA-capable     │ YES              │\n└──────────────┴─────────────────┴──────────────────┘\n```\n\n**GFP_KERNEL (most common):**\n```c\nDevice *dev = kmalloc(sizeof(Device), GFP_KERNEL);\n//                                    ^\n//                                    |\n//                    Allocation can SLEEP if needed\n//                    Waits for memory to become available\n```\n\n**Use GFP_KERNEL when:**\n- In normal process context\n- In module init/exit functions\n- Can afford to wait for memory\n- Most common case!\n\n**GFP_ATOMIC (special cases):**\n```c\nDevice *dev = kmalloc(sizeof(Device), GFP_ATOMIC);\n//                                    ^\n//                                    |\n//                    CANNOT sleep!\n//                    Returns immediately\n```\n\n**Use GFP_ATOMIC when:**\n- In interrupt handler\n- Holding a spinlock\n- Cannot sleep (atomic context)\n- Less likely to succeed!\n\n---\n\n## Part 9: Complete Example Walkthrough\n\n### Full Lifecycle Example\n\n```c\n/* Step 1: Allocate array */\nint count = 3;\nDevice *devices = kmalloc(sizeof(Device) * count, GFP_KERNEL);\n\n/* Step 2: Check for failure */\nif (!devices) {\n    printk(KERN_ERR \"Failed to allocate devices\\n\");\n    return -ENOMEM;\n}\n\n/* Step 3: Initialize all devices */\nfor (int i = 0; i < count; i++) {\n    devices[i].device_id = 1000 + i;\n    devices[i].status = 200;\n    devices[i].is_active = true;\n}\n\n/* Step 4: Use devices */\nfor (int i = 0; i < count; i++) {\n    printk(KERN_INFO \"Device %d: ID=%d, Status=%d\\n\",\n           i, devices[i].device_id, devices[i].status);\n}\n\n/* Step 5: Cleanup when done */\nkfree(devices);\ndevices = NULL;\n```\n\n**Memory state at each step:**\n```\nSTEP 1: After kmalloc\n  devices ──→  ┌─────┬─────┬─────┐\n               │  ?  │  ?  │  ?  │ Uninitialized\n               └─────┴─────┴─────┘\n\nSTEP 3: After initialization loop\n  devices ──→  ┌──────┬──────┬──────┐\n               │ 1000 │ 1001 │ 1002 │ device_id\n               │  200 │  200 │  200 │ status\n               │ true │ true │ true │ is_active\n               └──────┴──────┴──────┘\n\nSTEP 5: After kfree and NULL assignment\n  devices = NULL ──→ (nothing)\n  Memory returned to kernel\n```\n\n---\n\n## Part 10: Quick Reference\n\n### Decision Checklist\n\n**Use STATIC allocation when:**\n- Size known at compile time\n- Lifetime limited to function scope\n- Not returning pointer from function\n- Small size (< 1KB typically)\n\n**Use KMALLOC when:**\n- Size determined at runtime\n- Memory must persist beyond function\n- Returning pointer from function\n- Large data structures\n\n### Allocation Pattern Template\n\n```c\n/* Single structure */\nType *ptr = kmalloc(sizeof(Type), GFP_KERNEL);\nif (!ptr) {\n    return -ENOMEM;\n}\n// ... use ptr ...\nkfree(ptr);\nptr = NULL;\n\n/* Array of structures */\nType *array = kmalloc(sizeof(Type) * count, GFP_KERNEL);\nif (!array) {\n    return -ENOMEM;\n}\n// ... use array[0], array[1], etc ...\nkfree(array);\narray = NULL;\n```\n\n### Safety Checklist\n\n**After kmalloc:**\n- [ ] Check if pointer is NULL\n- [ ] Handle allocation failure\n\n**Before using:**\n- [ ] Initialize all fields\n- [ ] Don't use uninitialized memory\n\n**When done:**\n- [ ] Call kfree()\n- [ ] Set pointer to NULL\n- [ ] Don't use after free\n- [ ] Don't free twice\n\n---\n\n## Key Takeaways\n\n1. **Runtime sizes REQUIRE kmalloc** - No compile-time arrays with variable sizes\n2. **Returning pointers REQUIRES kmalloc** - Stack variables die when function returns\n3. **Always check kmalloc return** - NULL means out of memory\n4. **Single allocation = single free** - Arrays freed with one kfree call\n5. **Set to NULL after free** - Prevents use-after-free bugs\n6. **GFP_KERNEL for normal code** - Can sleep, most common case\n\nNow apply these patterns to your specific problem! The decision tree and lifecycle pattern are the same for any kernel code.\n",
        "readOnly": true,
        "language": "txt"
      },
      {
        "name": "dynamic_memory.h",
        "content": "#ifndef DYNAMIC_MEMORY_H\n#define DYNAMIC_MEMORY_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: WHEN to Use Static vs Dynamic Memory Allocation */\n/* ========================================================================== */\n/* This problem teaches the DECISION-MAKING PROCESS for choosing between\n * static allocation and dynamic allocation (kmalloc).\n *\n * CRITICAL LEARNING OBJECTIVE:\n * Understanding WHEN kmalloc is REQUIRED vs OPTIONAL is essential for\n * kernel development. Many students learn the syntax but not the criteria!\n *\n * DECISION TREE:\n * \n * Q1: Is the size known at compile time?\n *     NO  -> MUST use kmalloc (required)\n *     YES -> Continue to Q2\n *\n * Q2: Does memory need to outlive the function scope?\n *     YES -> MUST use kmalloc (required)\n *     NO  -> Continue to Q3\n *\n * Q3: Do you need to return a pointer from a function?\n *     YES -> MUST use kmalloc (required)\n *     NO  -> Static allocation is acceptable\n *\n * EXAMPLES OF WHEN KMALLOC IS REQUIRED:\n *\n * 1. RUNTIME-DETERMINED SIZE (Cannot use static allocation):\n *    int count = module_parameter;  // Unknown at compile time\n *    Device devices[count];  // ILLEGAL in C (VLA not allowed in kernel)\n *    Device *devices = kmalloc(sizeof(Device) * count, GFP_KERNEL);  // REQUIRED\n *\n * 2. RETURNING MEMORY FROM FUNCTION (Cannot use local variables):\n *    Device* bad_create(void) {\n *        Device local = {1, 2, true};  // Stack variable destroyed on return\n *        return &local;  // DANGER: Dangling pointer!\n *    }\n *    Device* good_create(void) {\n *        Device *dev = kmalloc(sizeof(Device), GFP_KERNEL);  // REQUIRED\n *        return dev;  // SAFE: Heap memory persists\n *    }\n *\n * 3. PERSISTENT LIFETIME (Beyond function scope):\n *    void init_device(void) {\n *        Device temp = {1, 2, true};  // Destroyed when function exits\n *    }\n *    Device *persistent_device = kmalloc(sizeof(Device), GFP_KERNEL);  // REQUIRED\n *\n * EXAMPLES OF WHEN STATIC IS ACCEPTABLE:\n *\n * 1. FIXED SIZE, KNOWN AT COMPILE TIME:\n *    Device single_device = {1001, 200, true};  // OK: Size known, lifetime OK\n *\n * 2. FIXED-SIZE ARRAY:\n *    Device devices[5] = {...};  // OK: Size known at compile time\n *\n * WHY THIS MATTERS IN KERNEL DEVELOPMENT:\n * - The Linux kernel uses kmalloc extensively for runtime-sized data structures\n * - Driver registration, device management, buffer allocation all use kmalloc\n * - Misunderstanding leads to stack corruption, memory leaks, crashes\n */\n\n/* ========================================================================== */\n/* MEMORY ALLOCATION PATTERN: The Lifecycle */\n/* ========================================================================== */\n/* KMALLOC/KFREE LIFECYCLE (4 Essential Steps):\n *\n * Step 1: ALLOCATE\n *   Device *dev = kmalloc(sizeof(Device), GFP_KERNEL);\n *   ^       ^      ^       ^               ^\n *   type    result function size           flags\n *\n * Step 2: CHECK (Critical - kmalloc can fail!)\n *   if (!dev) {\n *       printk(KERN_ERR \"Allocation failed!\\n\");\n *       return -ENOMEM;\n *   }\n *\n * Step 3: USE\n *   dev->device_id = 1001;\n *   dev->status = 200;\n *   dev->is_active = true;\n *\n * Step 4: FREE (When done)\n *   kfree(dev);\n *   dev = NULL;  // Prevent use-after-free bugs\n *\n * COMMON MISTAKES:\n * - Forgetting to check if kmalloc returned NULL\n * - Using memory after kfree (use-after-free bug)\n * - Forgetting to kfree (memory leak)\n * - Double-freeing the same pointer (double-free bug)\n */\n\n/* Device structure definition */\ntypedef struct {\n    int device_id;\n    int status;\n    bool is_active;\n} Device;\n\n/* Global device array pointer - dynamically allocated */\nextern Device *device_array;\nextern int device_count;\n\n/* ========================================================================== */\n/* SECTION 1: Function Declarations */\n/* ========================================================================== */\n/* TODO: Declare the following functions (declaration only, no implementation) */\n/* \n * REQUIRED FUNCTIONS:\n * 1. allocate_devices - Takes device count, returns 0 on success, -ENOMEM on failure\n * 2. initialize_device - Takes device pointer and ID, initializes device fields\n * 3. print_device_info - Takes device pointer, prints device information\n * 4. cleanup_devices - Takes no parameters, frees all allocated memory\n *\n * HINTS:\n * - allocate_devices should return int (for error code)\n * - initialize_device should take (Device *dev, int id) as parameters\n * - print_device_info should take (Device *dev) as parameter\n * - cleanup_devices should return void\n */\n\n#endif /* DYNAMIC_MEMORY_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "dynamic_memory.c",
        "content": "#include \"dynamic_memory.h\"\n\n/* Global device array pointer - starts as NULL */\nDevice *device_array = NULL;\nint device_count = 3;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses device_count to verify your dynamic allocation\n * works with RUNTIME-DETERMINED sizes (the key learning objective!).\n */\nmodule_param(device_count, int, 0644);\nMODULE_PARM_DESC(device_count, \"Number of devices to allocate (runtime-determined)\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: WHY Static Allocation Fails Here */\n/* ========================================================================== */\n/* PROBLEM: We need to allocate 'device_count' devices, but device_count\n * is determined at MODULE LOAD TIME (runtime), not compile time!\n *\n * STATIC ALLOCATION ATTEMPT (WILL NOT WORK):\n *   Device devices[device_count];  // ILLEGAL: VLA not allowed in kernel!\n *   \n * WHY THIS FAILS:\n * - device_count is only known when module loads (insmod dynamic_memory.ko device_count=5)\n * - C requires array sizes to be known at compile time\n * - Variable-Length Arrays (VLAs) are prohibited in kernel code for safety\n *\n * SOLUTION: MUST use kmalloc for runtime-determined sizes!\n *   Device *devices = kmalloc(sizeof(Device) * device_count, GFP_KERNEL);\n *   ^       ^         ^        ^                 ^\n *   type    result    function size calculation  flags\n *\n * This is a REQUIRED use case for dynamic memory allocation!\n *\n * MEMORY LAYOUT VISUALIZATION:\n *   Stack:                    Heap (Single Array):\n *   +-------------+          +----------+\n *   |device_array |--------->| Device 0 |\n *   +-------------+          | Device 1 |\n *                            | Device 2 |\n *                            +----------+\n *\n * CLEANUP IS SIMPLE (single kfree):\n *   kfree(device_array);\n */\n\n/* ========================================================================== */\n/* SECTION 1: Memory Allocation Function */\n/* ========================================================================== */\n/* TODO: Implement allocate_devices function\n *\n * REQUIREMENTS:\n * - Function signature: int allocate_devices(int count)\n * - Allocate single array of Device structures\n * - Check allocation for NULL (error handling!)\n * - Return 0 on success, -ENOMEM on failure\n * - Store result in global device_array variable\n *\n * ALGORITHM:\n * 1. Print message: \"Allocating %d devices...\" with count\n * 2. Allocate array: device_array = kmalloc(sizeof(Device) * count, GFP_KERNEL)\n * 3. Check if device_array is NULL (allocation failed)\n *    - If NULL: print error, return -ENOMEM\n * 4. Print success message: \"Successfully allocated %d devices\"\n * 5. Return 0\n *\n * CRITICAL ERROR HANDLING:\n * Always check if kmalloc returns NULL before using the memory!\n */\nint allocate_devices(int count)\n{\n    /* TODO: Implement single-level array allocation as described above */\n    return -ENOMEM;  /* Replace with actual implementation */\n}\n\n/* ========================================================================== */\n/* SECTION 2: Device Initialization Function */\n/* ========================================================================== */\n/* TODO: Implement initialize_device function\n *\n * REQUIREMENTS:\n * - Function signature: void initialize_device(Device *dev, int id)\n * - Check if dev pointer is NULL (safety check)\n * - Initialize device fields:\n *   - device_id = id\n *   - status = 200\n *   - is_active = true\n * - Print message: \"Device %d initialized\"\n *\n * ALGORITHM:\n * 1. Check if dev is NULL\n *    - If NULL: print error \"Cannot initialize NULL device\", return\n * 2. Set dev->device_id = id\n * 3. Set dev->status = 200\n * 4. Set dev->is_active = true\n * 5. Print success message with device ID\n */\nvoid initialize_device(Device *dev, int id)\n{\n    /* TODO: Implement device initialization as described above */\n}\n\n/* ========================================================================== */\n/* SECTION 3: Device Info Printing Function */\n/* ========================================================================== */\n/* TODO: Implement print_device_info function\n *\n * REQUIREMENTS:\n * - Function signature: void print_device_info(Device *dev)\n * - Check if dev pointer is NULL (safety check)\n * - Print device information:\n *   - \"=== Device Info ===\"\n *   - \"Device ID: %d\" (dev->device_id)\n *   - \"Status: %d\" (dev->status)\n *   - \"Active: YES\" or \"Active: NO\" (based on dev->is_active)\n *\n * ALGORITHM:\n * 1. Check if dev is NULL\n *    - If NULL: print error \"Cannot print info: device is NULL\", return\n * 2. Print header \"=== Device Info ===\"\n * 3. Print \"Device ID: %d\" with dev->device_id\n * 4. Print \"Status: %d\" with dev->status\n * 5. Print \"Active: YES\" if dev->is_active is true, else \"Active: NO\"\n */\nvoid print_device_info(Device *dev)\n{\n    /* TODO: Implement device info printing as described above */\n}\n\n/* ========================================================================== */\n/* SECTION 4: Memory Cleanup Function */\n/* ========================================================================== */\n/* TODO: Implement cleanup_devices function\n *\n * REQUIREMENTS:\n * - Function signature: void cleanup_devices(void)\n * - Free all allocated memory (single kfree!)\n * - Set pointer to NULL after freeing (prevent use-after-free)\n * - Use global variables: device_array, device_count\n *\n * ALGORITHM:\n * 1. Check if device_array is NULL\n *    - If NULL: print \"No devices to free\", return\n * 2. Print message: \"Freeing %d devices...\" with device_count\n * 3. Free device_array using kfree\n * 4. Set device_array = NULL\n * 5. Print success message: \"All devices freed\"\n *\n * CRITICAL: Single allocation requires single kfree!\n * No loop needed - the entire array is freed with one kfree call.\n */\nvoid cleanup_devices(void)\n{\n    /* TODO: Implement cleanup as described above */\n}\n\n/* ========================================================================== */\n/* MODULE INIT/EXIT */\n/* ========================================================================== */\nstatic int __init dynamic_memory_init(void)\n{\n    int ret;\n    int i;\n    int base_id = 1000;\n    \n    printk(KERN_INFO \"Dynamic memory module loaded\\n\");\n    printk(KERN_INFO \"Runtime device count: %d\\n\", device_count);\n    \n    /* Allocate devices dynamically */\n    ret = allocate_devices(device_count);\n    if (ret != 0) {\n        printk(KERN_ERR \"Failed to allocate devices\\n\");\n        return ret;\n    }\n    \n    /* Initialize all devices */\n    printk(KERN_INFO \"Initializing %d devices...\\n\", device_count);\n    for (i = 0; i < device_count; i++) {\n        /* NOTE: &device_array[i] gets the address of the i-th element\n         * device_array is a pointer to the first element\n         * device_array[i] is the actual struct (value)\n         * &device_array[i] is the address of that struct (pointer)\n         * We need the address because initialize_device expects Device *dev\n         */\n        initialize_device(&device_array[i], base_id + i);\n    }\n    \n    /* Print information for all devices */\n    printk(KERN_INFO \"Printing device information...\\n\");\n    for (i = 0; i < device_count; i++) {\n        printk(KERN_INFO \"Device %d:\\n\", i);\n        /* Same pattern: &device_array[i] passes address of i-th struct */\n        print_device_info(&device_array[i]);\n    }\n    \n    printk(KERN_INFO \"Dynamic allocation demonstration completed\\n\");\n    return 0;\n}\n\nstatic void __exit dynamic_memory_exit(void)\n{\n    printk(KERN_INFO \"Dynamic memory module unloading\\n\");\n    \n    /* Clean up all allocated memory */\n    cleanup_devices();\n    \n    printk(KERN_INFO \"Module unloaded cleanly\\n\");\n}\n\nmodule_init(dynamic_memory_init);\nmodule_exit(dynamic_memory_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Dynamic memory allocation with runtime-determined sizes\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Dynamic memory module Makefile\nobj-m += dynamic_memory.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "dynamic_memory.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "dynamic_memory_init",
          "dynamic_memory_exit",
          "allocate_devices",
          "initialize_device",
          "print_device_info",
          "cleanup_devices"
        ],
        "function_declarations": [
          {
            "name": "allocate_devices",
            "returnType": "int",
            "parameters": [
              "int count"
            ]
          },
          {
            "name": "initialize_device",
            "returnType": "void",
            "parameters": [
              "Device *dev",
              "int id"
            ]
          },
          {
            "name": "print_device_info",
            "returnType": "void",
            "parameters": [
              "Device *dev"
            ]
          },
          {
            "name": "cleanup_devices",
            "returnType": "void",
            "parameters": []
          }
        ],
        "variables_declarations": [
          {
            "name": "Device",
            "type": "typedef struct",
            "value": "{int device_id; int status; bool is_active;}",
            "storageClass": "none"
          },
          {
            "name": "device_array",
            "type": "Device *",
            "storageClass": "extern"
          },
          {
            "name": "device_count",
            "type": "int",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "device_array",
            "type": "Device *",
            "value": "NULL",
            "storageClass": "none"
          },
          {
            "name": "device_count",
            "type": "int",
            "value": "3",
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Dynamic memory module loaded",
          "Runtime device count: 3",
          "Allocating 3 devices...",
          "Successfully allocated 3 devices",
          "Initializing 3 devices...",
          "Device 1000 initialized",
          "Device 1001 initialized",
          "Device 1002 initialized",
          "Printing device information...",
          "Device 0:",
          "=== Device Info ===",
          "Device ID: 1000",
          "Status: 200",
          "Active: YES",
          "Device 1:",
          "Device ID: 1001",
          "Device 2:",
          "Device ID: 1002",
          "Dynamic allocation demonstration completed",
          "Dynamic memory module unloading",
          "Freeing 3 devices...",
          "All devices freed",
          "Module unloaded cleanly"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h",
          "linux/slab.h"
        ],
        "mustContain": [
          "kmalloc(sizeof(Device) * count, GFP_KERNEL)",
          "kfree(device_array)",
          "if (!device_array)",
          "device_array = NULL",
          "module_param(device_count, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int allocate_devices(int count)",
            "void initialize_device(Device *dev, int id)",
            "void print_device_info(Device *dev)",
            "void cleanup_devices(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int allocate_devices(int count)",
            "void initialize_device(Device *dev, int id)",
            "void print_device_info(Device *dev)",
            "void cleanup_devices(void)",
            "static int __init dynamic_memory_init(void)",
            "static void __exit dynamic_memory_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages with Function Linkage",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Dynamic memory module loaded",
              "exact": true,
              "linkedFunction": "static int __init dynamic_memory_init(void)"
            },
            {
              "pattern": "Runtime device count:",
              "exact": false,
              "linkedFunction": "static int __init dynamic_memory_init(void)"
            },
            {
              "pattern": "Allocating",
              "exact": false,
              "linkedFunction": "int allocate_devices(int count)"
            },
            {
              "pattern": "Successfully allocated",
              "exact": false,
              "linkedFunction": "int allocate_devices(int count)"
            },
            {
              "pattern": "Initializing",
              "exact": false,
              "linkedFunction": "static int __init dynamic_memory_init(void)"
            },
            {
              "pattern": "Device 1000 initialized",
              "exact": true,
              "linkedFunction": "void initialize_device(Device *dev, int id)"
            },
            {
              "pattern": "Printing device information...",
              "exact": true,
              "linkedFunction": "static int __init dynamic_memory_init(void)"
            },
            {
              "pattern": "Device 0:",
              "exact": true,
              "linkedFunction": "static int __init dynamic_memory_init(void)"
            },
            {
              "pattern": "=== Device Info ===",
              "exact": true,
              "linkedFunction": "void print_device_info(Device *dev)"
            },
            {
              "pattern": "Device ID: 1000",
              "exact": true,
              "linkedFunction": "void print_device_info(Device *dev)"
            },
            {
              "pattern": "Status: 200",
              "exact": true,
              "linkedFunction": "void print_device_info(Device *dev)"
            },
            {
              "pattern": "Active: YES",
              "exact": true,
              "linkedFunction": "void print_device_info(Device *dev)"
            },
            {
              "pattern": "Dynamic allocation demonstration completed",
              "exact": true,
              "linkedFunction": "static int __init dynamic_memory_init(void)"
            },
            {
              "pattern": "Dynamic memory module unloading",
              "exact": true,
              "linkedFunction": "static void __exit dynamic_memory_exit(void)"
            },
            {
              "pattern": "Freeing",
              "exact": false,
              "linkedFunction": "void cleanup_devices(void)"
            },
            {
              "pattern": "All devices freed",
              "exact": true,
              "linkedFunction": "void cleanup_devices(void)"
            },
            {
              "pattern": "Module unloaded cleanly",
              "exact": true,
              "linkedFunction": "static void __exit dynamic_memory_exit(void)"
            }
          ]
        },
        {
          "id": "advanced_dynamic_memory_validation",
          "name": "Advanced Dynamic Memory Implementation with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "memory_dynamic_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Runtime-Determined Size Allocation Test ===\\\\n\\\");\\n    \\n    srand(time(NULL));\\n    \\n    // Test different device counts (runtime-determined)\\n    int test_count1 = (rand() % 3) + 2;  // 2-4 devices\\n    int test_count2 = (rand() % 4) + 5;  // 5-8 devices\\n    \\n    printf(\\\"Test 1: Allocating %d devices (runtime size)\\\\n\\\", test_count1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/dynamic_memory.ko device_count=%d\\\", test_count1);\\n    system(\\\"rmmod dynamic_memory 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Allocating %d devices (runtime size)\\\\n\\\", test_count2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/dynamic_memory.ko device_count=%d\\\", test_count2);\\n    system(\\\"rmmod dynamic_memory\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Runtime-sized allocation test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced dynamic memory implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
              "echo '#define true 1' >> /tmp/linux/types.h",
              "echo '#define false 0' >> /tmp/linux/types.h",
              "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
              "echo '#define MAX_DEVICES 5' >> /tmp/linux/types.h",
              "echo '#define GFP_KERNEL 0' > /tmp/linux/slab.h",
              "echo '#define ENOMEM 12' >> /tmp/linux/slab.h",
              "echo 'void *kmalloc(size_t size, int flags);' >> /tmp/linux/slab.h",
              "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
              "echo 'Creating test file that includes dynamic memory header...'",
              "echo '#include \"/lib/modules/dynamic_memory.h\"' > /tmp/test.c",
              "echo 'int main() { allocate_devices(3); initialize_device(&device_array[0], 1000); print_device_info(&device_array[0]); cleanup_devices(); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
              "echo 'Phase 2: Runtime-Determined Size Allocation Testing'",
              "/bin/memory_dynamic_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Extract Runtime Device Counts'",
              "sleep 1",
              "echo 'Extracting runtime device counts from test output...'",
              "COUNT1=$(grep -o 'Test 1: Allocating [0-9]*' /tmp/test_output.log | cut -d' ' -f4)",
              "COUNT2=$(grep -o 'Test 2: Allocating [0-9]*' /tmp/test_output.log | cut -d' ' -f4)",
              "echo 'Extracted runtime counts: COUNT1='$COUNT1', COUNT2='$COUNT2",
              "if [ -z \"$COUNT1\" ] || [ -z \"$COUNT2\" ]; then echo 'FAIL: Could not extract runtime counts'; else echo 'PASS: Runtime device counts extracted successfully'; fi",
              "echo 'Phase 4: Single Array Allocation Validation'",
              "echo 'Validating single array allocation...'",
              "dmesg | grep -E '(Allocating|allocated)' && echo 'PASS: Array allocation initiated' || echo 'FAIL: Array allocation broken'",
              "dmesg | grep -E '(Successfully allocated|allocated)' && echo 'PASS: Array allocation successful' || echo 'FAIL: Array allocation broken'",
              "echo 'Phase 5: Runtime Device Count Validation'",
              "echo 'Validating with runtime count '$COUNT1' devices...'",
              "dmesg | grep \"Runtime device count: $COUNT1\" && echo 'PASS: Runtime count '$COUNT1' detected' || echo 'FAIL: Runtime count detection broken'",
              "dmesg | grep -E '(Allocating|allocated)' && echo 'PASS: Correct device count allocation' || echo 'FAIL: Wrong device count'",
              "dmesg | grep -E '(Successfully|allocated)' && echo 'PASS: All devices allocated' || echo 'FAIL: Allocation incomplete'",
              "echo 'Phase 6: Device Initialization Validation'",
              "dmesg | grep 'Device 1000 initialized' && echo 'PASS: Device initialization working' || echo 'FAIL: Device initialization broken'",
              "dmesg | grep 'Device ID: 1000' && echo 'PASS: First device data correct' || echo 'FAIL: First device data wrong'",
              "dmesg | grep 'Status: 200' && echo 'PASS: Device status field correct' || echo 'FAIL: Device status wrong'",
              "dmesg | grep 'Active: YES' && echo 'PASS: Device boolean field correct' || echo 'FAIL: Device boolean wrong'",
              "echo 'Phase 7: Cleanup Validation'",
              "dmesg | grep -E '(Freeing|free)' && echo 'PASS: Cleanup initiated' || echo 'FAIL: Cleanup not initiated'",
              "dmesg | grep 'All devices freed' && echo 'PASS: Cleanup successful' || echo 'FAIL: Cleanup broken'",
              "dmesg | grep 'Module unloaded cleanly' && echo 'PASS: Complete cleanup successful' || echo 'FAIL: Module unload broken'",
              "echo 'Phase 8: Final Validation Summary'",
              "echo 'PASS: All runtime-determined allocation validation successful'"
            ],
            "expected": {
              "dmesg": [
                "Dynamic memory module loaded",
                "Runtime device count: .*",
                "Allocat",
                "Initializing.*devices",
                "Device 1000 initialized",
                "Device ID: 1000",
                "Status: 200",
                "Active: YES",
                "Freeing",
                "All devices freed",
                "Module unloaded cleanly"
              ],
              "stdout": [
                "PASS: All function and variable declarations found in header file",
                "SUCCESS: Runtime-sized allocation test completed",
                "PASS: Runtime device counts extracted successfully",
                "PASS: Array allocation initiated",
                "PASS: Array allocation successful",
                "PASS: Runtime count.*detected",
                "PASS: Correct device count allocation",
                "PASS: All devices allocated",
                "PASS: Device initialization working",
                "PASS: First device data correct",
                "PASS: Device status field correct",
                "PASS: Device boolean field correct",
                "PASS: Cleanup initiated",
                "PASS: Cleanup successful",
                "PASS: Complete cleanup successful",
                "PASS: All runtime-determined allocation validation successful"
              ]
            },
            "timeout": 15
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Dynamic memory module loaded",
        "Runtime device count: 3",
        "Allocating 3 devices...",
        "Successfully allocated 3 devices",
        "Initializing 3 devices...",
        "Device 1000 initialized",
        "Device 1001 initialized",
        "Device 1002 initialized",
        "Printing device information...",
        "Device 0:",
        "=== Device Info ===",
        "Device ID: 1000",
        "Status: 200",
        "Active: YES",
        "Device 1:",
        "Device ID: 1001",
        "Device 2:",
        "Device ID: 1002",
        "Dynamic allocation demonstration completed",
        "Dynamic memory module unloading",
        "Freeing 3 devices...",
        "All devices freed",
        "Module unloaded cleanly"
      ],
      "requirements": [
        "Use required function names: dynamic_memory_init, dynamic_memory_exit, allocate_devices, initialize_device, print_device_info, cleanup_devices",
        "Use required variable names: device_array, device_count",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h, linux/slab.h",
        "Code must contain: kmalloc(sizeof(Device) * count, GFP_KERNEL), kfree(device_array), if (!device_array), device_array = NULL, module_param(device_count, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Dynamic memory module loaded",
          "linkedFunction": "static int __init dynamic_memory_init(void)",
          "exact": true
        },
        {
          "pattern": "Runtime device count:",
          "linkedFunction": "static int __init dynamic_memory_init(void)",
          "exact": false
        },
        {
          "pattern": "Allocating",
          "linkedFunction": "int allocate_devices(int count)",
          "exact": false
        },
        {
          "pattern": "Successfully allocated",
          "linkedFunction": "int allocate_devices(int count)",
          "exact": false
        },
        {
          "pattern": "Initializing",
          "linkedFunction": "static int __init dynamic_memory_init(void)",
          "exact": false
        },
        {
          "pattern": "Device 1000 initialized",
          "linkedFunction": "void initialize_device(Device *dev, int id)",
          "exact": true
        },
        {
          "pattern": "Printing device information...",
          "linkedFunction": "static int __init dynamic_memory_init(void)",
          "exact": true
        },
        {
          "pattern": "Device 0:",
          "linkedFunction": "static int __init dynamic_memory_init(void)",
          "exact": true
        },
        {
          "pattern": "=== Device Info ===",
          "linkedFunction": "void print_device_info(Device *dev)",
          "exact": true
        },
        {
          "pattern": "Device ID: 1000",
          "linkedFunction": "void print_device_info(Device *dev)",
          "exact": true
        },
        {
          "pattern": "Status: 200",
          "linkedFunction": "void print_device_info(Device *dev)",
          "exact": true
        },
        {
          "pattern": "Active: YES",
          "linkedFunction": "void print_device_info(Device *dev)",
          "exact": true
        },
        {
          "pattern": "Dynamic allocation demonstration completed",
          "linkedFunction": "static int __init dynamic_memory_init(void)",
          "exact": true
        },
        {
          "pattern": "Dynamic memory module unloading",
          "linkedFunction": "static void __exit dynamic_memory_exit(void)",
          "exact": true
        },
        {
          "pattern": "Freeing",
          "linkedFunction": "void cleanup_devices(void)",
          "exact": false
        },
        {
          "pattern": "All devices freed",
          "linkedFunction": "void cleanup_devices(void)",
          "exact": true
        },
        {
          "pattern": "Module unloaded cleanly",
          "linkedFunction": "static void __exit dynamic_memory_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 20,
    "title": "Pointer Casting - Multi-Level Type Conversion Mastery",
    "difficulty": 7,
    "xp": 60,
    "phase": "foundations",
    "description": "Master multi-level pointer casting chains: void* → generic_record* → sensor_record*. Learn the exact patterns used in production kernel parsers for safe type conversion and record processing.",
    "concepts": [
      "multi-level pointer casting",
      "void* generic pointers",
      "type-safe casting patterns",
      "polymorphic C structures",
      "record header patterns",
      "production parsing techniques"
    ],
    "skills": [
      "Casting void* to specific types safely",
      "Understanding pointer type conversion",
      "Implementing polymorphic C patterns",
      "Using casting chains like libstdf",
      "Professional kernel development practices",
      "Type safety validation"
    ],
    "files": [
      {
        "name": "pointer_casting.h",
        "content": "#ifndef POINTER_CASTING_H\n#define POINTER_CASTING_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n#define MAX_NAME_LEN 32\n\n/* Record type constants */\n#define SENSOR_RECORD 1\n#define DEVICE_RECORD 2\n\n/* Base record header (like rec_header) */\ntypedef struct {\n    uint8_t rec_type;\n    uint8_t rec_subtype;\n    uint16_t rec_length;\n} record_header;\n\n/* Generic record (like rec_unknown) */\ntypedef struct {\n    record_header header;\n    void* data;\n} generic_record;\n\n/* Specific record types (like rec_ptr, rec_mpr) */\ntypedef struct {\n    record_header header;\n    uint32_t sensor_id;\n    char sensor_name[MAX_NAME_LEN];\n    uint32_t measurement_value;\n} sensor_record;\n\ntypedef struct {\n    record_header header;\n    uint32_t device_id;\n    char device_status[MAX_NAME_LEN];\n    bool is_active;\n} device_record;\n\n/* Global record pointers for testing */\nextern generic_record *current_record;\nextern sensor_record *sensor_data;\nextern device_record *device_data;\n\n/* TODO: Declare your functions */\n/* void process_generic_record(void *raw_record); */\n/* void extract_sensor_data(generic_record *rec); */\n/* void extract_device_data(generic_record *rec); */\n/* void print_record_info(void); */\n\n#endif /* POINTER_CASTING_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "pointer_casting.c",
        "content": "#include \"pointer_casting.h\"\n\n/* Global record pointers initialized to NULL */\ngeneric_record *current_record = NULL;\nsensor_record *sensor_data = NULL;\ndevice_record *device_data = NULL;\n\nint test_record_type = SENSOR_RECORD;\nint test_sensor_id = 1001;\nint test_measurement = 257;\nint test_device_id = 2001;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your casting logic works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(test_record_type, int, 0644);\nMODULE_PARM_DESC(test_record_type, \"Record type for testing casting logic\");\nmodule_param(test_sensor_id, int, 0644);\nMODULE_PARM_DESC(test_sensor_id, \"Sensor ID for anti-hardcoding testing\");\nmodule_param(test_measurement, int, 0644);\nMODULE_PARM_DESC(test_measurement, \"Measurement value for anti-hardcoding testing\");\nmodule_param(test_device_id, int, 0644);\nMODULE_PARM_DESC(test_device_id, \"Device ID for anti-hardcoding testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: How multi-level pointer casting works in C */\n/* Basic pattern for casting pointers step by step:\n *\n * void* raw_ptr = get_generic_pointer();\n * generic_record* rec = (generic_record*)raw_ptr;  // Cast void* to generic type\n * sensor_record* sensor = (sensor_record*)rec;     // Cast generic to specific type\n *\n * This is like: void* → generic_record* → sensor_record*\n */\n\n/* WHAT EACH POINTER CONTAINS AND HOW TO USE IT: */\n\n/* 1. void* raw_ptr - Generic pointer (can point to ANY data type) */\n/*    Contains: Memory address, but no type information */\n/*    Usage: Cannot access fields directly - MUST cast first */\n/*    Example: raw_ptr points to memory, but raw_ptr->header won't work */\n\n/* 2. generic_record* rec - Pointer to generic record structure */\n/*    Contains: Same memory address, but now treats it as generic_record */\n/*    Usage: Can access generic fields: rec->header.rec_type, rec->data */\n/*    Example: rec->header.rec_type tells us if it's SENSOR or DEVICE */\n\n/* 3. sensor_record* sensor - Pointer to specific sensor record structure */\n/*    Contains: Same memory address, now treated as sensor_record */\n/*    Usage: Can access sensor fields: sensor->sensor_id, sensor->measurement_value */\n/*    Example: sensor->sensor_id gets the specific sensor ID number */\n\n/* HOW STRUCT-TO-STRUCT CASTING WORKS: */\n/* All structs start with same header layout: */\n/* generic_record: [header][data*]          <- Generic view */\n/* sensor_record:  [header][sensor_id][...] <- Specific view */\n/* device_record:  [header][device_id][...] <- Specific view */\n/* Same memory, different interpretation! */\n\n/* CASTING OPERATORS EXPLAINED: */\n/* (type_name*)pointer means \"treat this pointer as type_name*\" */\n/* Example: (sensor_record*)rec means \"treat rec as sensor_record*\" */\n/*          ↑ target type     ↑ source pointer */\n/* Why cast? To change how we interpret the memory structure */\n\n/* AMPERSAND OPERATOR (&) EXPLAINED IN DETAIL: */\n/* & is the \"address-of\" operator - it gets the memory address of a variable */\n\n/* WHAT & PRODUCES AND WHY WE NEED IT: */\n/* 1. &variable - Gets the memory address where variable is stored */\n/*    Contains: The actual memory address (like 0x7fff1234) */\n/*    Usage: Converts a variable into a pointer to that variable */\n/*    Example: &test_sensor_record gives the address where test_sensor_record lives */\n\n/* 2. variable (without &) - The actual data/contents of the variable */\n/*    Contains: The struct data itself (all the fields and values) */\n/*    Usage: Direct access to the variable's contents */\n/*    Example: test_sensor_record gives you the actual struct contents */\n\n/* WHY FUNCTIONS NEED POINTERS (ADDRESSES) NOT VALUES: */\n/* Function parameter: void process_record(void* raw_record) */\n/*                                          ↑ expects a POINTER (address) */\n/* */\n/* If we have: static generic_record test_sensor_record = {...}; */\n/* */\n/* CORRECT:   process_record((void*)&test_sensor_record); */\n/*            ↑ cast to void*  ↑ get address of the struct */\n/* */\n/* WRONG:     process_record((void*)test_sensor_record); */\n/*            ↑ tries to cast struct contents to pointer - INVALID! */\n\n/* MEMORY LAYOUT VISUALIZATION: */\n/* Memory Address: 0x1000                                    */\n/* ┌─────────────────────────────────────────────────────┐  */\n/* │ test_sensor_record struct data lives here           │  */\n/* │ [rec_type: 1][rec_subtype: 1][rec_length: 48][...] │  */\n/* └─────────────────────────────────────────────────────┘  */\n/*   ↑                                                       */\n/*   This address (0x1000) is what &test_sensor_record gives us */\n\n/* WHAT EACH EXPRESSION EVALUATES TO: */\n/* test_sensor_record      = The actual struct contents (can't fit in a pointer!) */\n/* &test_sensor_record     = 0x1000 (the address - this fits in a pointer!) */\n/* (void*)&test_sensor_record = 0x1000 cast as void* (what the function wants!) */\n\n/* THE & AND * RELATIONSHIP: */\n/* & = \"address of\" operator (gets address from variable) */\n/* * = \"dereference\" operator (gets value from address) */\n/* */\n/* If: generic_record* ptr = &test_sensor_record; */\n/* Then: *ptr gives you back the original test_sensor_record contents */\n/* And: ptr gives you the address (same as &test_sensor_record) */\n\n/* COMMON MISTAKES AND COMPILER ERRORS: */\n/* ERROR: test_record = (void*)test_sensor_record; */\n/* Compiler says: \"cannot convert 'generic_record' to 'void*'\" */\n/* Why? Because test_sensor_record is struct data, not an address */\n/* */\n/* CORRECT: test_record = (void*)&test_sensor_record; */\n/* Compiler happy: &test_sensor_record is an address, void* expects address */\n\n/* PRACTICAL EXAMPLES: */\n/* int x = 42; */\n/* int* ptr = &x;          // ptr now contains address of x */\n/* print(\"%p\", &x);       // Prints address like 0x7fff1234 */\n/* print(\"%d\", x);        // Prints value: 42 */\n/* print(\"%d\", *ptr);     // Prints value through pointer: 42 */\n\n/* IN OUR KERNEL CODE CONTEXT: */\n/* static generic_record test_sensor_record = {...}; // Struct variable */\n/* void* test_record = (void*)&test_sensor_record;   // Get its address */\n/* process_generic_record(test_record);              // Pass address to function */\n/* */\n/* Inside process_generic_record(void* raw_record): */\n/* generic_record* rec = (generic_record*)raw_record; // Cast address back to typed pointer */\n/* // Now rec points to our original test_sensor_record! */\n\n/* Predefined sensor record for testing */\nstatic sensor_record test_sensor = {\n    .header = { .rec_type = SENSOR_RECORD, .rec_subtype = 1, .rec_length = 48 },\n    .sensor_id = 1001,\n    .sensor_name = \"temperature_01\",\n    .measurement_value = 257\n};\n\n/* Predefined device record for testing */\nstatic device_record test_device = {\n    .header = { .rec_type = DEVICE_RECORD, .rec_subtype = 1, .rec_length = 52 },\n    .device_id = 2001,\n    .device_status = \"operational\",\n    .is_active = true\n};\n\n/* TODO: Implement multi-level casting function */\n/* Use the pattern above: void* → generic_record* → specific_record* */\nvoid process_generic_record(void *raw_record) {\n    /* WHY WE NEED THIS CASTING CHAIN: */\n    /* */\n    /* When we call this function from init: */\n    /* process_generic_record((void*)&test_sensor); */\n    /*                        ↑                    */\n    /*                        Cast sensor_record* to void* first */\n    /* */\n    /* STEP-BY-STEP EXPLANATION: */\n    /* 1. test_sensor is type: sensor_record */\n    /* 2. &test_sensor is type: sensor_record* (pointer to sensor_record) */\n    /* 3. (void*)&test_sensor is type: void* (generic pointer) */\n    /* 4. Function parameter raw_record receives: void* (generic pointer) */\n    /* */\n    /* INSIDE THIS FUNCTION - THE REVERSE JOURNEY: */\n    /* 5. raw_record is type: void* (we lost the original type information) */\n    /* 6. Cast to generic_record*: (generic_record*)raw_record */\n    /* 7. Now we can access header: rec->header.rec_type */\n    /* 8. Based on rec_type, cast to specific type: (sensor_record*)rec */\n    /* */\n    /* WHY THIS WORKS - MEMORY LAYOUT COMPATIBILITY: */\n    /* All record types start with the SAME header layout: */\n    /* sensor_record:  [header][sensor_id][measurement_value][sensor_name] */\n    /* device_record:  [header][device_id][device_status][is_active] */\n    /* generic_record: [header][data*] */\n    /*                  ↑ Same header in all types! */\n    /* */\n    /* So casting between them is safe for accessing the header portion */\n    \n    // TODO: Step 1: Cast void* raw_record to generic_record* (so we can access header)\n    // TODO: Step 2: Check header.rec_type to determine what kind of record this is\n    // TODO: Step 3: Route to extract_sensor_data() or extract_device_data() based on record type (use if or switch statement)\n    // Your implementation here\n}\n\n/* TODO: Implement sensor data extraction */\nvoid extract_sensor_data(generic_record *rec) {\n    // Cast generic_record* rec to sensor_record*\n    // Store sensor data and print information\n    // Your implementation here\n}\n\n/* TODO: Implement device data extraction */\nvoid extract_device_data(generic_record *rec) {\n    // Cast generic_record* rec to device_record*\n    // Store device data and print information\n    // Your implementation here\n}\n\nvoid print_record_info(void) {\n    if (!current_record) {\n        printk(KERN_ERR \"No current record available\\n\");\n        return;\n    }\n    \n    printk(KERN_INFO \"Current Record Info:\\n\");\n    \n    printk(KERN_INFO \"Record Subtype: %u\\n\", current_record->header.rec_subtype);\n    printk(KERN_INFO \"Record Type: %u\\n\", current_record->header.rec_type);\n    printk(KERN_INFO \"Record Length: %u\\n\", current_record->header.rec_length);\n}\n\n/* DETAILED EXPLANATION OF INIT FUNCTION - STEP BY STEP MEMORY ANALYSIS */\n/* This function demonstrates the complete casting chain with detailed memory explanations */\n\n/* UNDERSTANDING THE INIT FUNCTION CALLS: */\n/* test_sensor.sensor_id = test_sensor_id;        // Modify struct fields */\n/* test_sensor.measurement_value = test_measurement; */\n/* test_record = (void *)&test_sensor;           // Get address of entire struct */\n/* process_generic_record(test_record);          // Pass address to function */\n/* */\n/* WHAT &test_sensor GIVES YOU: */\n/* - &test_sensor = address of the ENTIRE struct (not just sensor_id) */\n/* - test_record = pointer to the whole struct */\n/* */\n/* MEMORY LAYOUT VISUALIZATION: */\n/* Memory Address: 0x1000 */\n/* ┌─────────────────────────────────────────┐ */\n/* │ test_sensor struct (entire thing)       │ */\n/* │ ┌─────────────────────────────────────┐ │  ← &test_sensor points HERE (to start) */\n/* │ │ header: {rec_type=1, subtype=1...} │ │ */\n/* │ ├─────────────────────────────────────┤ │ */\n/* │ │ sensor_id: 1001                     │ │ */\n/* │ ├─────────────────────────────────────┤ │ */\n/* │ │ sensor_name: \\\"temperature_01\\\"       │ │ */\n/* │ ├─────────────────────────────────────┤ │ */\n/* │ │ measurement_value: 257              │ │ */\n/* │ └─────────────────────────────────────┘ │ */\n/* └─────────────────────────────────────────┘ */\n/* */\n/* SO test_record POINTS TO: */\n/* - YES: The entire struct (including header, sensor_id, sensor_name, measurement_value) */\n/* - NO: NOT just sensor_id and measurement_value */\n/* */\n/* INSIDE process_generic_record(test_record): */\n/* void process_generic_record(void *raw_record) { */\n/*     // raw_record contains 0x1000 (address of entire test_sensor struct) */\n/*  */\n/*     generic_record *rec = (generic_record *)raw_record; */\n/*     // Now rec points to the same location, but treated as generic_record */\n/*  */\n/*     rec->header.rec_type;  // Accesses the header part */\n/*     // This works because both sensor_record and generic_record  */\n/*     // start with the same header layout! */\n/* } */\n/* */\n/* KEY POINT: */\n/* &test_sensor gives you the address of the WHOLE struct, not individual fields. */\n/* The function receives a pointer to the entire struct and can access any field within it. */\n/* */\n/* THE CASTING CHAIN: */\n/* 1. test_sensor = actual struct variable */\n/* 2. &test_sensor = pointer to entire struct */\n/* 3. (void *)&test_sensor = same pointer, but cast as generic void* */\n/* 4. Inside function: cast back to access fields */\n/* */\n/* So yes, test_record is a pointer, but it points to the ENTIRE struct, giving access to all fields! */\n\nstatic int __init pointer_casting_init(void)\n{\n    void *test_record;\n    \n    printk(KERN_INFO \"Pointer casting module loaded\\n\");\n    \n    /* Test both sensor and device records for comprehensive validation */\n    \n    /* First test: Sensor record with dynamic parameter values */\n    test_sensor.sensor_id = test_sensor_id;        /* Modify struct fields */\n    test_sensor.measurement_value = test_measurement;\n    test_record = (void *)&test_sensor;           /* Get address of entire struct */\n    process_generic_record(test_record);          /* Pass address to function */\n    print_record_info();\n    \n    /* Second test: Device record with dynamic parameter values */\n    test_device.device_id = test_device_id;       /* Modify struct fields */\n    test_record = (void *)&test_device;           /* Get address of entire struct */\n    process_generic_record(test_record);          /* Pass address to function */\n    print_record_info();\n    \n    return 0;\n}\n\nstatic void __exit pointer_casting_exit(void)\n{\n    printk(KERN_INFO \"Pointer casting module unloaded\\n\");\n    \n    /* Reset pointers */\n    current_record = NULL;\n    sensor_data = NULL;\n    device_data = NULL;\n}\n\nmodule_init(pointer_casting_init);\nmodule_exit(pointer_casting_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning multi-level pointer casting and type conversion\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Pointer casting module Makefile\nobj-m += pointer_casting.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "pointer_casting.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "pointer_casting_init",
          "pointer_casting_exit",
          "process_generic_record",
          "extract_sensor_data",
          "extract_device_data",
          "print_record_info"
        ],
        "function_declarations": [
          {
            "name": "process_generic_record",
            "returnType": "void",
            "parameters": [
              "void *raw_record"
            ]
          },
          {
            "name": "extract_sensor_data",
            "returnType": "void",
            "parameters": [
              "generic_record *rec"
            ]
          },
          {
            "name": "extract_device_data",
            "returnType": "void",
            "parameters": [
              "generic_record *rec"
            ]
          },
          {
            "name": "print_record_info",
            "returnType": "void",
            "parameters": []
          }
        ],
        "variables_declarations": [
          {
            "name": "record_header",
            "type": "typedef struct",
            "value": "{uint8_t rec_type; uint8_t rec_subtype; uint16_t rec_length;}",
            "storageClass": "none"
          },
          {
            "name": "generic_record",
            "type": "typedef struct",
            "value": "{record_header header; void* data;}",
            "storageClass": "none"
          },
          {
            "name": "sensor_record",
            "type": "typedef struct",
            "value": "{record_header header; uint32_t sensor_id; char sensor_name[MAX_NAME_LEN]; uint32_t measurement_value;}",
            "storageClass": "none"
          },
          {
            "name": "device_record",
            "type": "typedef struct",
            "value": "{record_header header; uint32_t device_id; char device_status[MAX_NAME_LEN]; bool is_active;}",
            "storageClass": "none"
          },
          {
            "name": "current_record",
            "type": "generic_record *",
            "storageClass": "extern"
          },
          {
            "name": "sensor_data",
            "type": "sensor_record *",
            "storageClass": "extern"
          },
          {
            "name": "device_data",
            "type": "device_record *",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "current_record",
            "type": "generic_record *",
            "value": "NULL",
            "storageClass": "none"
          },
          {
            "name": "sensor_data",
            "type": "sensor_record *",
            "value": "NULL",
            "storageClass": "none"
          },
          {
            "name": "device_data",
            "type": "device_record *",
            "value": "NULL",
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Pointer casting module loaded",
          "Sensor Record Extracted",
          "Sensor ID: 1001",
          "Sensor Name: temperature_01",
          "Measurement: 257",
          "Current Record Info:",
          "Record Type: 1",
          "Record Subtype: 1",
          "Record Length: 48",
          "Device Record Extracted",
          "Device ID: 2001",
          "Device Status: operational",
          "Active: true",
          "Current Record Info:",
          "Record Type: 2",
          "Record Subtype: 1",
          "Record Length: 52",
          "Pointer casting module unloaded"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "generic_record *rec = (generic_record *)raw_record",
          "sensor_record *sensor = (sensor_record *)rec",
          "device_record *device = (device_record *)rec",
          "current_record = rec",
          "sensor_data = sensor",
          "device_data = device",
          "if (rec->header.rec_type == SENSOR_RECORD)",
          "module_param(test_record_type, int, 0644)",
          "module_param(test_sensor_id, int, 0644)",
          "module_param(test_measurement, int, 0644)",
          "module_param(test_device_id, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void process_generic_record(void *raw_record)",
            "void extract_sensor_data(generic_record *rec)",
            "void extract_device_data(generic_record *rec)",
            "void print_record_info(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void process_generic_record(void *raw_record)",
            "void extract_sensor_data(generic_record *rec)",
            "void extract_device_data(generic_record *rec)",
            "void print_record_info(void)",
            "static int __init pointer_casting_init(void)",
            "static void __exit pointer_casting_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Pointer casting module loaded",
              "exact": true,
              "linkedFunction": "static int __init pointer_casting_init(void)"
            },
            {
              "pattern": "Sensor Record Extracted",
              "exact": true,
              "linkedFunction": "void extract_sensor_data(generic_record *rec)"
            },
            {
              "pattern": "Sensor ID: 1001",
              "exact": true,
              "linkedFunction": "void extract_sensor_data(generic_record *rec)"
            },
            {
              "pattern": "Sensor Name: temperature_01",
              "exact": true,
              "linkedFunction": "void extract_sensor_data(generic_record *rec)"
            },
            {
              "pattern": "Measurement: 257",
              "exact": true,
              "linkedFunction": "void extract_sensor_data(generic_record *rec)"
            },
            {
              "pattern": "Current Record Info:",
              "exact": true,
              "linkedFunction": "void print_record_info(void)"
            },
            {
              "pattern": "Record Type: 1",
              "exact": true,
              "linkedFunction": "void print_record_info(void)"
            },
            {
              "pattern": "Record Subtype: 1",
              "exact": true,
              "linkedFunction": "void print_record_info(void)"
            },
            {
              "pattern": "Record Length: 48",
              "exact": true,
              "linkedFunction": "void print_record_info(void)"
            },
            {
              "pattern": "Device Record Extracted",
              "exact": true,
              "linkedFunction": "void extract_device_data(generic_record *rec)"
            },
            {
              "pattern": "Device ID: 2001",
              "exact": true,
              "linkedFunction": "void extract_device_data(generic_record *rec)"
            },
            {
              "pattern": "Device Status: operational",
              "exact": true,
              "linkedFunction": "void extract_device_data(generic_record *rec)"
            },
            {
              "pattern": "Active: true",
              "exact": true,
              "linkedFunction": "void extract_device_data(generic_record *rec)"
            },
            {
              "pattern": "Current Record Info:",
              "exact": true,
              "linkedFunction": "void print_record_info(void)"
            },
            {
              "pattern": "Record Type: 2",
              "exact": true,
              "linkedFunction": "void print_record_info(void)"
            },
            {
              "pattern": "Record Subtype: 1",
              "exact": true,
              "linkedFunction": "void print_record_info(void)"
            },
            {
              "pattern": "Record Length: 52",
              "exact": true,
              "linkedFunction": "void print_record_info(void)"
            },
            {
              "pattern": "Pointer casting module unloaded",
              "exact": true,
              "linkedFunction": "static void __exit pointer_casting_exit(void)"
            }
          ]
        },
        {
          "id": "advanced_casting_validation",
          "name": "Advanced Multi-Level Casting Implementation with Anti-Hardcoding Protection",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "casting_dynamic_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Anti-Hardcoding Casting Test ===\\\\n\\\");\\n    \\n    // Seed random number generator with current time\\n    srand(time(NULL));\\n    \\n    // Generate unpredictable sensor test values\\n    int random_sensor_id = (rand() % 9000) + 1000;  // 1000-9999\\n    int random_measurement = (rand() % 500) + 100;   // 100-599\\n    \\n    // Generate unpredictable device test values\\n    int random_device_id = (rand() % 8000) + 2000;  // 2000-9999\\n    \\n    printf(\\\"Test 1: Random sensor casting (ID=%d, measurement=%d)\\\\n\\\", random_sensor_id, random_measurement);\\n    printf(\\\"Test 2: Random device casting (ID=%d)\\\\n\\\", random_device_id);\\n    \\n    // Test sensor record casting with random values\\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod pointer_casting 2>/dev/null\\\");\\n    \\n    char cmd1[512];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/pointer_casting.ko test_record_type=1 test_sensor_id=%d test_measurement=%d\\\", random_sensor_id, random_measurement);\\n    printf(\\\"DEBUG: Sensor command: %s\\\\n\\\", cmd1);\\n    system(cmd1);\\n    \\n    \\n    // Test device record casting with random values\\n    printf(\\\"DEBUG: Switching to device test...\\\\n\\\");\\n    system(\\\"rmmod pointer_casting\\\");\\n    \\n    char cmd2[512];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/pointer_casting.ko test_record_type=2 test_device_id=%d\\\", random_device_id);\\n    printf(\\\"DEBUG: Device command: %s\\\\n\\\", cmd2);\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Anti-hardcoding casting test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced multi-level casting implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo 'typedef unsigned char uint8_t;' >> /tmp/linux/types.h",
              "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
              "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
              "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
              "echo '#define true 1' >> /tmp/linux/types.h",
              "echo '#define false 0' >> /tmp/linux/types.h",
              "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
              "echo 'Creating test file that includes casting header...'",
              "echo '#include \"/lib/modules/pointer_casting.h\"' > /tmp/test.c",
              "echo 'int main() { current_record->header.rec_type = 1; process_generic_record((void*)0); extract_sensor_data((generic_record*)0); extract_device_data((generic_record*)0); print_record_info(); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
              "echo 'Phase 2: Anti-Hardcoding Dynamic Casting Test'",
              "/bin/casting_dynamic_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Random Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "SENSOR_ID=$(grep -o 'Random sensor casting (ID=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
              "SENSOR_MEASUREMENT=$(grep -o 'measurement=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
              "DEVICE_ID=$(grep -o 'Random device casting (ID=[0-9]*)' /tmp/test_output.log | cut -d'=' -f2 | cut -d')' -f1)",
              "echo 'Extracted values: SENSOR_ID='$SENSOR_ID', MEASUREMENT='$SENSOR_MEASUREMENT', DEVICE_ID='$DEVICE_ID",
              "if [ -z \"$SENSOR_ID\" ] || [ -z \"$SENSOR_MEASUREMENT\" ] || [ -z \"$DEVICE_ID\" ]; then echo 'FAIL: Could not extract random test values'; else echo 'PASS: Random values extracted successfully'; fi",
              "echo 'Phase 4: Anti-Hardcoding Validation with Random Values'",
              "echo 'Validating sensor casting with random ID '$SENSOR_ID",
              "dmesg | grep \"Sensor ID: $SENSOR_ID\" && echo 'PASS: Sensor casting with random ID working' || echo 'FAIL: Sensor casting with random ID broken'",
              "echo 'Validating sensor measurement with random value '$SENSOR_MEASUREMENT",
              "dmesg | grep \"Measurement: $SENSOR_MEASUREMENT\" && echo 'PASS: Sensor measurement with random value working' || echo 'FAIL: Sensor measurement with random value broken'",
              "echo 'Validating device casting with random ID '$DEVICE_ID",
              "dmesg | grep \"Device ID: $DEVICE_ID\" && echo 'PASS: Device casting with random ID working' || echo 'FAIL: Device casting with random ID broken'",
              "echo 'Phase 5: Static Field Validation (Non-Randomized Fields)'",
              "dmesg | grep 'Sensor Name: temperature_01' && echo 'PASS: Sensor name field access working' || echo 'FAIL: Sensor name field access broken'",
              "dmesg | grep 'Device Status: operational' && echo 'PASS: Device status field access working' || echo 'FAIL: Device status field access broken'",
              "echo 'Phase 6: Casting Logic and Record Type Validation'",
              "dmesg | grep 'Sensor Record Extracted' && echo 'PASS: Sensor extraction logic working' || echo 'FAIL: Sensor extraction logic broken'",
              "dmesg | grep 'Device Record Extracted' && echo 'PASS: Device extraction logic working' || echo 'FAIL: Device extraction logic broken'",
              "dmesg | grep 'Current Record Info:' && echo 'PASS: Record info display working' || echo 'FAIL: Record info display broken'",
              "echo 'Phase 7: Final Validation Summary'",
              "echo 'All phases completed successfully - anti-hardcoding protection verified'",
              "echo 'PASS: All anti-hardcoding casting validation successful'"
            ],
            "expected": {
              "dmesg": [
                "Pointer casting module loaded",
                "Sensor Record Extracted",
                "Sensor ID: .*",
                "Sensor Name: temperature_01",
                "Measurement: .*",
                "Device Record Extracted",
                "Device ID: .*",
                "Device Status: operational",
                "Current Record Info:",
                "Record Type: .*"
              ],
              "stdout": [
                "PASS: All function and variable declarations found in header file",
                "SUCCESS: Anti-hardcoding casting test completed",
                "PASS: Random values extracted successfully",
                "PASS: Sensor casting with random ID working",
                "PASS: Sensor measurement with random value working",
                "PASS: Device casting with random ID working",
                "PASS: Sensor name field access working",
                "PASS: Device status field access working",
                "PASS: Sensor extraction logic working",
                "PASS: Device extraction logic working",
                "PASS: Record info display working",
                "PASS: All anti-hardcoding casting validation successful"
              ]
            },
            "timeout": 15
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Pointer casting module loaded",
        "Sensor Record Extracted",
        "Sensor ID: 1001",
        "Sensor Name: temperature_01",
        "Measurement: 257",
        "Current Record Info:",
        "Record Type: 1",
        "Record Subtype: 1",
        "Record Length: 48",
        "Device Record Extracted",
        "Device ID: 2001",
        "Device Status: operational",
        "Active: true",
        "Current Record Info:",
        "Record Type: 2",
        "Record Subtype: 1",
        "Record Length: 52",
        "Pointer casting module unloaded"
      ],
      "requirements": [
        "Use required function names: pointer_casting_init, pointer_casting_exit, process_generic_record, extract_sensor_data, extract_device_data, print_record_info",
        "Use required variable names: current_record, sensor_data, device_data",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: generic_record *rec = (generic_record *)raw_record, sensor_record *sensor = (sensor_record *)rec, device_record *device = (device_record *)rec, current_record = rec, sensor_data = sensor, device_data = device, if (rec->header.rec_type == SENSOR_RECORD), module_param(test_record_type, int, 0644), module_param(test_sensor_id, int, 0644), module_param(test_measurement, int, 0644), module_param(test_device_id, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Pointer casting module loaded",
          "linkedFunction": "static int __init pointer_casting_init(void)",
          "exact": true
        },
        {
          "pattern": "Sensor Record Extracted",
          "linkedFunction": "void extract_sensor_data(generic_record *rec)",
          "exact": true
        },
        {
          "pattern": "Sensor ID: 1001",
          "linkedFunction": "void extract_sensor_data(generic_record *rec)",
          "exact": true
        },
        {
          "pattern": "Sensor Name: temperature_01",
          "linkedFunction": "void extract_sensor_data(generic_record *rec)",
          "exact": true
        },
        {
          "pattern": "Measurement: 257",
          "linkedFunction": "void extract_sensor_data(generic_record *rec)",
          "exact": true
        },
        {
          "pattern": "Current Record Info:",
          "linkedFunction": "void print_record_info(void)",
          "exact": true
        },
        {
          "pattern": "Record Type: 1",
          "linkedFunction": "void print_record_info(void)",
          "exact": true
        },
        {
          "pattern": "Record Subtype: 1",
          "linkedFunction": "void print_record_info(void)",
          "exact": true
        },
        {
          "pattern": "Record Length: 48",
          "linkedFunction": "void print_record_info(void)",
          "exact": true
        },
        {
          "pattern": "Device Record Extracted",
          "linkedFunction": "void extract_device_data(generic_record *rec)",
          "exact": true
        },
        {
          "pattern": "Device ID: 2001",
          "linkedFunction": "void extract_device_data(generic_record *rec)",
          "exact": true
        },
        {
          "pattern": "Device Status: operational",
          "linkedFunction": "void extract_device_data(generic_record *rec)",
          "exact": true
        },
        {
          "pattern": "Active: true",
          "linkedFunction": "void extract_device_data(generic_record *rec)",
          "exact": true
        },
        {
          "pattern": "Current Record Info:",
          "linkedFunction": "void print_record_info(void)",
          "exact": true
        },
        {
          "pattern": "Record Type: 2",
          "linkedFunction": "void print_record_info(void)",
          "exact": true
        },
        {
          "pattern": "Record Subtype: 1",
          "linkedFunction": "void print_record_info(void)",
          "exact": true
        },
        {
          "pattern": "Record Length: 52",
          "linkedFunction": "void print_record_info(void)",
          "exact": true
        },
        {
          "pattern": "Pointer casting module unloaded",
          "linkedFunction": "static void __exit pointer_casting_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 21,
    "title": "Function Pointers - Runtime-Unknown Type Dispatch",
    "difficulty": 6,
    "xp": 55,
    "phase": "foundations",
    "description": "Master function pointers by handling RUNTIME-UNKNOWN event types! Learn WHAT function pointers are, HOW they work, WHY they're necessary (not just convenient), and WHEN they're required vs overkill. Build an extensible callback system where handlers are registered dynamically from EXTERNAL MODULES - proving function pointers handle types that DON'T EXIST at compile time. Handler modules load dynamically, making if-else IMPOSSIBLE. This is the exact pattern Linux uses for interrupt handlers, filesystem operations, and driver registration.",
    "concepts": [
      "WHAT is a function pointer (variable storing function address)",
      "HOW function pointers work (memory layout and indirect calls)",
      "Function pointer syntax breakdown (step-by-step)",
      "Typedef for function pointers (making syntax cleaner)",
      "Function pointers in arrays (table-based dispatch)",
      "Function pointers in structs (OOP in C pattern)",
      "WHEN to use function pointers (decision tree)",
      "WHEN NOT to use (2-3 options use if-else instead)",
      "External module integration (THE key use case)",
      "Callback registration pattern (impossible without function pointers)",
      "Set once, use forever pattern (performance optimization)",
      "Extensible plugin systems",
      "Module dependencies and EXPORT_SYMBOL"
    ],
    "skills": [
      "Understanding function pointers as variables storing addresses",
      "Reading function pointer syntax (breaking down declarations)",
      "Using typedef to simplify function pointer declarations",
      "Assigning functions to function pointers",
      "Calling functions through pointers (indirect calls)",
      "Storing function pointers in arrays for dispatch tables",
      "Storing function pointers in structs for OOP patterns",
      "Applying decision tree for function pointer vs direct call choice",
      "Implementing callback registration systems (kernel pattern)",
      "Handling external module handlers",
      "Understanding 'set once, use forever' performance optimization",
      "Recognizing when function pointers add unnecessary complexity",
      "Building extensible event handling systems",
      "Using EXPORT_SYMBOL for cross-module functions"
    ],
    "files": [
      {
        "name": "function_dispatch.h",
        "content": "#ifndef FUNCTION_DISPATCH_H\n#define FUNCTION_DISPATCH_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n#define MAX_HANDLERS 8\n#define MAX_NAME_LEN 32\n#define MAX_HANDLER_TYPES 5\n\n/* Event handler function pointer type */\ntypedef void (*event_handler_t)(uint8_t event_type, void* event_data, uint32_t data_size);\n\n/* Event operations struct - demonstrates OOP in C pattern */\ntypedef struct {\n    event_handler_t handler;           /* Function pointer IN struct */\n    char event_name[MAX_NAME_LEN];   /* Event type name */\n    uint32_t event_count;             /* Number of times handled */\n} event_operations;\n\n/* Global event operations table */\nextern event_operations event_ops_table[MAX_HANDLERS];\nextern int registered_handler_count;\n\n/* TODO: Declare your callback registration function */\n/* void register_event_handler(uint8_t event_type, event_handler_t handler, const char* name); */\n\n/* TODO: Declare your dispatch function that uses the stored function pointer */\n/* void dispatch_event(uint8_t event_type, void* data, uint32_t size); */\n\n/* TODO: Declare your function to show all registered handlers */\n/* void show_registered_handlers(void); */\n\n#endif /* FUNCTION_DISPATCH_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "function_dispatch.c",
        "content": "#include \"function_dispatch.h\"\n#include <linux/string.h>\n\n/* Global event operations table - each entry has function pointer */\nevent_operations event_ops_table[MAX_HANDLERS];\nint registered_handler_count = 0;\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: Complete Beginner's Guide to Function Pointers */\n/* ========================================================================== */\n/* This problem teaches function pointers from FIRST PRINCIPLES!\n *\n * LEARNING PATH:\n * 1. WHAT is a function pointer? (basics)\n * 2. HOW does it work? (memory and syntax)\n * 3. WHY use it? (decision tree)\n * 4. WHEN to use it? (patterns)\n * 5. HOW to implement? (callback system)\n *\n * CRITICAL DIFFERENCE FROM TYPICAL PROBLEMS:\n * Handler functions are in SEPARATE MODULES!\n * You CANNOT use if-else - handlers don't exist in this module!\n * This PROVES function pointers handle runtime-unknown types!\n */\n\n/* ========================================================================== */\n/* PART 1: WHAT IS A FUNCTION POINTER? */\n/* ========================================================================== */\n/* A function pointer is a VARIABLE that stores the MEMORY ADDRESS of a function.\n *\n * COMPARISON TO DATA POINTERS (from Problem 15):\n *\n * Data Pointer (you already know this!):\n *   int number = 42;\n *   int *ptr = &number;  // ptr stores ADDRESS of variable\n *   *ptr = 99;           // Change value through pointer\n *\n * Function Pointer (new concept!):\n *   void my_function(int x) { ... }\n *   void (*ptr)(int) = my_function;  // ptr stores ADDRESS of function!\n *   ptr(42);                          // Call function through pointer\n *\n * KEY INSIGHT: Functions have addresses in memory, just like variables!\n */\n\n/* ========================================================================== */\n/* PART 2: HOW FUNCTION POINTERS WORK - MEMORY LAYOUT */\n/* ========================================================================== */\n/* MEMORY VISUALIZATION:\n *\n * Code Segment (where functions live):\n * Address      Content\n * 0x401000:    [sensor_handler code]   ← In handler_sensor.ko module!\n * 0x401200:    [motor_handler code]    ← In handler_motor.ko module!\n * 0x401400:    [status_handler code]   ← In handler_status.ko module!\n * 0x401600:    [network_handler code]  ← In handler_network.ko module!\n * 0x401800:    [storage_handler code]  ← In handler_storage.ko module!\n *\n * Data Segment (where function pointers live):\n * Address      Content\n * 0x500000:    handler_ptr = 0x401000  // Points to sensor_handler\n *\n * WHEN YOU CALL handler_ptr():\n * 1. CPU reads value at 0x500000 → gets 0x401000\n * 2. CPU jumps to address 0x401000 (in external module!)\n * 3. Executes sensor_handler code\n * 4. Returns back\n *\n * This is called INDIRECT CALL (go through pointer first)\n * Direct call: my_function() → CPU knows address at compile time\n * Indirect call: ptr() → CPU must read pointer value first\n */\n\n/* ========================================================================== */\n/* PART 3: FUNCTION POINTER SYNTAX EXPLAINED */\n/* ========================================================================== */\n/* Function pointer declarations look scary, but follow a pattern!\n *\n * STEP-BY-STEP BREAKDOWN:\n *\n * 1. Start with a function signature:\n *    void sensor_handler(uint8_t type, void* data, uint32_t size);\n *    ↑         ↑            ↑\n *    return    name         parameters\n *\n * 2. Replace function name with (*pointer_name):\n *    void (*handler_ptr)(uint8_t type, void* data, uint32_t size);\n *    ↑     ↑              ↑\n *    return pointer name   parameters\n *\n * 3. That's it! Now handler_ptr can point to any function with this signature.\n *\n * WHY THE PARENTHESES (*handler_ptr)?\n * Without: void *handler_ptr(...) means \"function returning void*\"\n * With: void (*handler_ptr)(...) means \"pointer to function returning void\"\n */\n\n/* ========================================================================== */\n/* PART 4: ASSIGNING AND CALLING FUNCTION POINTERS */\n/* ========================================================================== */\n/* ASSIGNMENT (storing function address):\n *\n * void sensor_handler(uint8_t type, void* data, uint32_t size) {\n *     printk(\"Sensor handler called\\n\");\n * }\n *\n * // Declare pointer\n * void (*handler_ptr)(uint8_t, void*, uint32_t);\n *\n * // Assign function address (function name IS the address!)\n * handler_ptr = sensor_handler;  // Option 1: Direct\n * handler_ptr = &sensor_handler; // Option 2: Explicit (same thing!)\n *\n * CALLING (using stored address):\n *\n * handler_ptr(1, NULL, 256);  // Option 1: Direct\n * (*handler_ptr)(1, NULL, 256); // Option 2: Explicit (same!)\n *\n * Both work identically! Modern C allows the simpler syntax.\n */\n\n/* ========================================================================== */\n/* PART 5: TYPEDEF FOR FUNCTION POINTERS (Making Life Easier) */\n/* ========================================================================== */\n/* Raw function pointer syntax is hard to read:\n *\n * BAD (UGLY):\n * void (*handler1)(uint8_t, void*, uint32_t);\n * void (*handler2)(uint8_t, void*, uint32_t);\n * void (*handler3)(uint8_t, void*, uint32_t);\n * // Repetitive and error-prone!\n *\n * GOOD (CLEAN): Use typedef to create a type name\n * typedef void (*event_handler_t)(uint8_t, void*, uint32_t);\n * event_handler_t handler1;\n * event_handler_t handler2;\n * event_handler_t handler3;\n * // Much clearer!\n *\n * TYPEDEF SYNTAX BREAKDOWN:\n * typedef void (*event_handler_t)(uint8_t type, void* data, uint32_t size);\n * ↑       ↑     ↑                 ↑\n * keyword return type name        parameters\n *\n * Now event_handler_t is a TYPE, like int or char*!\n * We use this in function_dispatch.h!\n */\n\n/* ========================================================================== */\n/* PART 6: FUNCTION POINTERS IN ARRAYS (The Power Move) */\n/* ========================================================================== */\n/* You can store function pointers in arrays for table-based dispatch!\n *\n * EXAMPLE: Interrupt handler table (like real Linux kernel)\n *\n * typedef void (*irq_handler_t)(int irq_num);\n * irq_handler_t irq_handlers[256];  // Array of function pointers!\n *\n * // Setup (registration):\n * irq_handlers[5] = keyboard_interrupt_handler;\n * irq_handlers[14] = disk_interrupt_handler;\n *\n * // Usage (dispatch):\n * void handle_interrupt(int irq_num) {\n *     if (irq_handlers[irq_num]) {\n *         irq_handlers[irq_num](irq_num);  // Call stored function!\n *     }\n * }\n *\n * This is O(1) lookup - much faster than if-else chain!\n * We use this pattern in this problem with event_ops_table[]!\n */\n\n/* ========================================================================== */\n/* PART 7: FUNCTION POINTERS IN STRUCTS (OOP in C) */\n/* ========================================================================== */\n/* This is how Linux kernel does object-oriented programming!\n *\n * STRUCT WITH FUNCTION POINTER:\n * struct file_operations {\n *     int (*open)(struct file *f);\n *     ssize_t (*read)(struct file *f, char *buf, size_t len);\n *     ssize_t (*write)(struct file *f, const char *buf, size_t len);\n * };\n *\n * DIFFERENT IMPLEMENTATIONS:\n * struct file_operations ext4_ops = {\n *     .open = ext4_open,\n *     .read = ext4_read,\n *     .write = ext4_write\n * };\n *\n * struct file_operations ntfs_ops = {\n *     .open = ntfs_open,\n *     .read = ntfs_read,\n *     .write = ntfs_write\n * };\n *\n * USAGE (automatic dispatch):\n * struct file {\n *     struct file_operations *ops;\n * };\n *\n * // Setup once:\n * ext4_file->ops = &ext4_ops;\n * ntfs_file->ops = &ntfs_ops;\n *\n * // Use many times (NO TYPE CHECKING!):\n * ext4_file->ops->read(...)  // Automatically calls ext4_read()\n * ntfs_file->ops->read(...)  // Automatically calls ntfs_read()\n *\n * We use a similar pattern with event_operations struct!\n */\n\n/* ========================================================================== */\n/* PART 8: WHEN to Use Function Pointers vs Direct Calls */\n/* ========================================================================== */\n/* Now that you know HOW function pointers work, learn WHEN to use them!\n *\n * DECISION TREE:\n * \n * Q1: Do you need to select different functions at RUNTIME based on data?\n *     NO  -> Direct function calls are simpler (STOP: don't use function pointers)\n *     YES -> Continue to Q2\n *\n * Q2: Do you have only 2-3 function options?\n *     YES -> Simple if-else is clearer and faster (STOP: don't use function pointers)\n *     NO  -> Continue to Q3\n *\n * Q3: Is this one of these scenarios?\n *     - Callbacks (must STORE function for later use)\n *     - 5+ functions requiring table-based dispatch\n *     - Plugin/extensible systems (functions unknown at compile time)\n *     - OOP in C (function pointers in struct for polymorphism)\n *     YES -> Function pointers REQUIRED\n *     NO  -> Reconsider if complexity is justified\n *\n * EXAMPLES OF WHEN FUNCTION POINTERS ARE REQUIRED:\n *\n * 1. EXTERNAL MODULES (CANNOT use if-else - functions don't exist!):\n *    // Handler functions are in SEPARATE .ko files!\n *    // sensor_event_handler is in handler_sensor.ko\n *    // motor_event_handler is in handler_motor.ko\n *    // You CANNOT call them directly - they're not compiled into this module!\n *    // If you try: if (type == 0) sensor_handler(...); → LINKER ERROR!\n *    // MUST use function pointers: event_ops_table[type].handler(...);\n *\n * 2. CALLBACK REGISTRATION (Cannot use if-else):\n *    void register_handler(event_handler_t handler) {\n *        handlers[event_type] = handler;  // MUST store for later!\n *    }\n *    // Later, when event occurs:\n *    handlers[event_type](data);  // Call stored function\n *    // WRONG: IMPOSSIBLE with if-else - you don't know which function user registered!\n *\n * 3. OOP IN C - Function Pointers in Struct (\"Set Once, Use Forever\"):\n *    struct file {\n *        struct file_operations *f_op;  // Points to function table\n *    };\n *    // Setup ONCE when file is opened:\n *    file->f_op = &ext4_file_operations;  // → Decision made once!\n *    // Then all operations are automatic (no type checking!):\n *    file->f_op->read();   // No if-else needed!\n *    file->f_op->write();  // No if-else needed!\n *    file->f_op->close();  // No if-else needed!\n *\n * EXAMPLES OF WHEN DIRECT CALLS ARE BETTER:\n *\n * 1. FUNCTION KNOWN AT COMPILE TIME (No runtime selection):\n *    BAD:  handler = my_function; handler(data);  // Unnecessary indirection!\n *    GOOD: my_function(data);  // Direct call is faster!\n *\n * 2. ONLY 2-3 FUNCTION OPTIONS (Simple if-else is clearer):\n *    BAD:  Setup entire function pointer infrastructure for 2 functions\n *    GOOD: if (type == A) func_a(); else func_b();  // Simpler!\n *\n * 3. PERFORMANCE-CRITICAL INNER LOOPS (Every cycle matters):\n *    Function pointers have costs:\n *    - Indirect call overhead (CPU pipeline stall)\n *    - Compiler cannot inline\n *    - Harder branch prediction\n *    Use direct calls in hot paths!\n */\n\n/* ========================================================================== */\n/* PART 9: THE \"SET ONCE, USE FOREVER\" PATTERN */\n/* ========================================================================== */\n/* This is the KEY insight that makes function pointers worthwhile!\n *\n * WITHOUT function pointers (check type repeatedly):\n *   void process(struct data *d) {\n *       if (d->type == A) func_a(d);  // Check EVERY time\n *       else func_b(d);\n *   }\n *   // If you process 10,000 items: 10,000 type checks!\n *\n * WITH function pointers (decide once, use forever):\n *   // Setup ONCE:\n *   d->handler = (d->type == A) ? func_a : func_b;  // Decide once\n *   // Use MANY times (no type checking!):\n *   d->handler(d);  // Just call it - 0 type checks!\n *   // If you process 10,000 items: 0 type checks!\n *\n * PERFORMANCE COMPARISON:\n * Setup phase: 1 assignment vs 1 if-else (same cost)\n * Process phase (1000 calls):\n * - If-else: 1000 type checks\n * - Function pointer: 0 type checks, just 1000 indirect calls\n * Winner: Function pointer (when processing many times)\n */\n\n/* ========================================================================== */\n/* PART 10: EXTERNAL MODULES - WHY IF-ELSE IS IMPOSSIBLE */\n/* ========================================================================== */\n/* This problem demonstrates WHY function pointers are NECESSARY!\n *\n * THE SCENARIO:\n * - Core module (function_dispatch.ko) provides registration system\n * - Handler modules (handler_*.ko) provide actual handlers\n * - Handlers are in SEPARATE .ko files\n * - You DON'T KNOW which handlers will be loaded!\n *\n * IN THIS PROBLEM:\n * - 5 handler modules available: sensor, motor, status, network, storage\n * - Test randomly loads 2-4 handler modules\n * - You DON'T KNOW which combination will be used!\n * - Testing system uses RANDOM combinations you've never seen!\n *\n * THIS IS EXACTLY LIKE:\n * - Linux filesystem registration (ext4.ko, ntfs.ko, btrfs.ko, ...)\n * - Driver registration (usb-storage.ko, ahci.ko, ...)\n * - Interrupt handlers (keyboard.ko, disk.ko, network.ko, ...)\n *\n * You CAN'T use if-else because:\n * 1. Handler functions don't exist in this module (linker error!)\n * 2. You don't know which modules will be loaded (runtime-unknown!)\n * Function pointers are REQUIRED, not just convenient!\n */\n\n/* ========================================================================== */\n/* NOW LET'S IMPLEMENT IT! */\n/* ========================================================================== */\n\n/* PATTERN SCAFFOLDING: Callback Registration Pattern */\n/* TODO: Implement callback registration function */\nvoid register_event_handler(uint8_t event_type, event_handler_t handler, const char* name) {\n    /* STEP 1: VALIDATE EVENT TYPE */\n    /* TODO: Check if event_type is within valid range (0 to MAX_HANDLERS-1) */\n    /* TODO: if (event_type >= MAX_HANDLERS) { */\n    /* TODO:     printk(KERN_ERR \"Invalid event type %d (max: %d)\\n\", event_type, MAX_HANDLERS-1); */\n    /* TODO:     return; */\n    /* TODO: } */\n    \n    /* STEP 2: STORE THE FUNCTION POINTER (The Key Step!) */\n    /* This is where the MAGIC happens - we store the function address! */\n    /* TODO: event_ops_table[event_type].handler = handler; */\n    /* What this does: Saves the address of external module's function in our table */\n    /* Later we can call: event_ops_table[event_type].handler(data) */\n    \n    /* STEP 3: STORE THE HANDLER NAME (for debugging/display) */\n    /* TODO: Copy the handler name to event_ops_table[event_type].event_name */\n    /* TODO: Use snprintf for safety: */\n    /* TODO: snprintf(event_ops_table[event_type].event_name, MAX_NAME_LEN, \"%s\", name); */\n    \n    /* STEP 4: INITIALIZE EVENT COUNT */\n    /* TODO: event_ops_table[event_type].event_count = 0; */\n    \n    /* STEP 5: TRACK TOTAL REGISTERED HANDLERS */\n    /* TODO: Increment registered_handler_count */\n    /* TODO: registered_handler_count++; */\n    \n    /* STEP 6: CONFIRMATION MESSAGE */\n    /* TODO: Print confirmation message */\n    /* TODO: printk(KERN_INFO \"Registered handler '%s' for event type %d\\n\", name, event_type); */\n}\n\n/* Export symbol so handler modules can call this function */\nEXPORT_SYMBOL(register_event_handler);\n\n/* TODO: Implement event dispatch function using stored function pointer */\nvoid dispatch_event(uint8_t event_type, void* data, uint32_t size) {\n    /* STEP 1: VALIDATE EVENT TYPE */\n    /* TODO: Check if event_type is within valid range */\n    /* TODO: if (event_type >= MAX_HANDLERS) { */\n    /* TODO:     printk(KERN_ERR \"Invalid event type %d\\n\", event_type); */\n    /* TODO:     return; */\n    /* TODO: } */\n    \n    /* STEP 2: CHECK IF HANDLER IS REGISTERED */\n    /* This is CRITICAL - must check before calling! */\n    /* TODO: if (event_ops_table[event_type].handler == NULL) { */\n    /* TODO:     printk(KERN_ERR \"No handler registered for event type %d\\n\", event_type); */\n    /* TODO:     return; */\n    /* TODO: } */\n    \n    /* STEP 3: INCREMENT EVENT COUNTER (statistics) */\n    /* TODO: event_ops_table[event_type].event_count++; */\n    \n    /* STEP 4: CALL THE STORED FUNCTION POINTER! */\n    /* THIS IS THE MAGIC - No if-else needed! */\n    /* TODO: event_ops_table[event_type].handler(event_type, data, size); */\n    /*\n     * WHAT JUST HAPPENED?\n     * 1. event_ops_table[event_type].handler  → Read function pointer from table\n     * 2. .handler(event_type, data, size)     → Call function through pointer\n     *\n     * If event_type == 0 and handler_sensor.ko is loaded:\n     *   - handler points to sensor_event_handler (in external module!)\n     *   - Calls sensor_event_handler(0, data, size)\n     *\n     * If event_type == 1 and handler_motor.ko is loaded:\n     *   - handler points to motor_event_handler (in external module!)\n     *   - Calls motor_event_handler(1, data, size)\n     *\n     * NO IF-ELSE! The function pointer was set during module load!\n     * We just dereference and call - automatic dispatch to external code!\n     */\n}\n\n/* TODO: Implement function to show all registered handlers */\nvoid show_registered_handlers(void) {\n    int i;\n    \n    /* STEP 1: PRINT HEADER */\n    /* TODO: Print header message */\n    /* TODO: printk(KERN_INFO \"\\n=== Registered Event Handlers ===\\n\"); */\n    \n    /* STEP 2: LOOP THROUGH ALL POSSIBLE EVENT TYPES */\n    /* TODO: Loop through all possible event types (0 to MAX_HANDLERS-1) */\n    /* TODO: for (i = 0; i < MAX_HANDLERS; i++) { */\n    \n        /* STEP 3: CHECK IF HANDLER IS REGISTERED AT THIS INDEX */\n        /* TODO: Check if handler is registered at this index */\n        /* TODO: if (event_ops_table[i].handler != NULL) { */\n        \n            /* STEP 4: PRINT HANDLER INFORMATION */\n            /* TODO: Print handler info: event type, name, call count */\n            /* TODO: printk(KERN_INFO \"Event Type %d: %s (called %u times)\\n\",  */\n            /*              i, event_ops_table[i].event_name, event_ops_table[i].event_count); */\n        \n        /* TODO: } */\n    /* TODO: } */\n    \n    /* STEP 5: PRINT FOOTER WITH TOTAL COUNT */\n    /* TODO: Print footer message */\n    /* TODO: printk(KERN_INFO \"Total registered handlers: %d\\n\", registered_handler_count); */\n}\n\nstatic int __init function_dispatch_init(void)\n{\n    int i;\n    \n    printk(KERN_INFO \"Function dispatch core module loaded\\n\");\n    printk(KERN_INFO \"Waiting for handler modules to register...\\n\");\n    \n    /* Initialize the event operations table */\n    for (i = 0; i < MAX_HANDLERS; i++) {\n        event_ops_table[i].handler = NULL;\n        event_ops_table[i].event_count = 0;\n        memset(event_ops_table[i].event_name, 0, MAX_NAME_LEN);\n    }\n    \n    printk(KERN_INFO \"Event dispatch system ready!\\n\");\n    \n    return 0;\n}\n\nstatic void __exit function_dispatch_exit(void)\n{\n    printk(KERN_INFO \"Function dispatch core module unloaded\\n\");\n    registered_handler_count = 0;\n}\n\nmodule_init(function_dispatch_init);\nmodule_exit(function_dispatch_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning WHY function pointers are required for external module integration\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "handler_sensor.c",
        "content": "#include \"function_dispatch.h\"\n\n/* Sensor event handler implementation */\nvoid sensor_event_handler(uint8_t type, void* data, uint32_t size) {\n    printk(KERN_INFO \"[Sensor Handler] Processing event type %d, data size: %u\\n\", type, size);\n}\n\nstatic int __init sensor_handler_init(void)\n{\n    printk(KERN_INFO \"Sensor handler module loaded\\n\");\n    register_event_handler(0, sensor_event_handler, \"Sensor\");\n    return 0;\n}\n\nstatic void __exit sensor_handler_exit(void)\n{\n    printk(KERN_INFO \"Sensor handler module unloaded\\n\");\n}\n\nmodule_init(sensor_handler_init);\nmodule_exit(sensor_handler_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"KernelQ\");\nMODULE_DESCRIPTION(\"Sensor event handler module\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": true,
        "language": "c"
      },
      {
        "name": "handler_motor.c",
        "content": "#include \"function_dispatch.h\"\n\n/* Motor event handler implementation */\nvoid motor_event_handler(uint8_t type, void* data, uint32_t size) {\n    printk(KERN_INFO \"[Motor Handler] Processing event type %d, data size: %u\\n\", type, size);\n}\n\nstatic int __init motor_handler_init(void)\n{\n    printk(KERN_INFO \"Motor handler module loaded\\n\");\n    register_event_handler(1, motor_event_handler, \"Motor\");\n    return 0;\n}\n\nstatic void __exit motor_handler_exit(void)\n{\n    printk(KERN_INFO \"Motor handler module unloaded\\n\");\n}\n\nmodule_init(motor_handler_init);\nmodule_exit(motor_handler_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"KernelQ\");\nMODULE_DESCRIPTION(\"Motor event handler module\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": true,
        "language": "c"
      },
      {
        "name": "handler_status.c",
        "content": "#include \"function_dispatch.h\"\n\n/* Status event handler implementation */\nvoid status_event_handler(uint8_t type, void* data, uint32_t size) {\n    printk(KERN_INFO \"[Status Handler] Processing event type %d, data size: %u\\n\", type, size);\n}\n\nstatic int __init status_handler_init(void)\n{\n    printk(KERN_INFO \"Status handler module loaded\\n\");\n    register_event_handler(2, status_event_handler, \"Status\");\n    return 0;\n}\n\nstatic void __exit status_handler_exit(void)\n{\n    printk(KERN_INFO \"Status handler module unloaded\\n\");\n}\n\nmodule_init(status_handler_init);\nmodule_exit(status_handler_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"KernelQ\");\nMODULE_DESCRIPTION(\"Status event handler module\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": true,
        "language": "c"
      },
      {
        "name": "handler_network.c",
        "content": "#include \"function_dispatch.h\"\n\n/* Network event handler implementation */\nvoid network_event_handler(uint8_t type, void* data, uint32_t size) {\n    printk(KERN_INFO \"[Network Handler] Processing event type %d, data size: %u\\n\", type, size);\n}\n\nstatic int __init network_handler_init(void)\n{\n    printk(KERN_INFO \"Network handler module loaded\\n\");\n    register_event_handler(3, network_event_handler, \"Network\");\n    return 0;\n}\n\nstatic void __exit network_handler_exit(void)\n{\n    printk(KERN_INFO \"Network handler module unloaded\\n\");\n}\n\nmodule_init(network_handler_init);\nmodule_exit(network_handler_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"KernelQ\");\nMODULE_DESCRIPTION(\"Network event handler module\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": true,
        "language": "c"
      },
      {
        "name": "handler_storage.c",
        "content": "#include \"function_dispatch.h\"\n\n/* Storage event handler implementation */\nvoid storage_event_handler(uint8_t type, void* data, uint32_t size) {\n    printk(KERN_INFO \"[Storage Handler] Processing event type %d, data size: %u\\n\", type, size);\n}\n\nstatic int __init storage_handler_init(void)\n{\n    printk(KERN_INFO \"Storage handler module loaded\\n\");\n    register_event_handler(4, storage_event_handler, \"Storage\");\n    return 0;\n}\n\nstatic void __exit storage_handler_exit(void)\n{\n    printk(KERN_INFO \"Storage handler module unloaded\\n\");\n}\n\nmodule_init(storage_handler_init);\nmodule_exit(storage_handler_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"KernelQ\");\nMODULE_DESCRIPTION(\"Storage event handler module\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": true,
        "language": "c"
      },
      {
        "name": "test_dispatch.c",
        "content": "#include \"function_dispatch.h\"\n\nint test_dispatch_types[MAX_HANDLERS] = {0, 1, 2, 3, 4, 0, 1, 2};\nint test_dispatch_count = 5;\n\nmodule_param_array(test_dispatch_types, int, &test_dispatch_count, 0644);\nMODULE_PARM_DESC(test_dispatch_types, \"Array of event types to dispatch (runtime-unknown)\");\n\nstatic int __init test_dispatch_init(void)\n{\n    int i;\n    \n    printk(KERN_INFO \"\\n=== Test Dispatch Module Loaded ===\\n\");\n    printk(KERN_INFO \"Will dispatch to %d different event types\\n\", test_dispatch_count);\n    \n    /* Show registered handlers */\n    show_registered_handlers();\n    \n    printk(KERN_INFO \"\\n=== Dispatching to Runtime-Unknown Types ===\\n\");\n    \n    /* Dispatch to MULTIPLE different types (proves table lookup works!) */\n    for (i = 0; i < test_dispatch_count && i < MAX_HANDLERS; i++) {\n        uint8_t dispatch_type = test_dispatch_types[i];\n        printk(KERN_INFO \"\\nDispatching to type %d:\\n\", dispatch_type);\n        dispatch_event(dispatch_type, NULL, 128 + (i * 64));\n    }\n    \n    /* Show final statistics */\n    printk(KERN_INFO \"\\n=== Final Handler Statistics ===\\n\");\n    show_registered_handlers();\n    \n    printk(KERN_INFO \"\\nFunction dispatch demonstration complete\\n\");\n    \n    return 0;\n}\n\nstatic void __exit test_dispatch_exit(void)\n{\n    printk(KERN_INFO \"Test dispatch module unloaded\\n\");\n}\n\nmodule_init(test_dispatch_init);\nmodule_exit(test_dispatch_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"KernelQ\");\nMODULE_DESCRIPTION(\"Test module for multi-type dispatch\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": true,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Function dispatch multi-module Makefile\nobj-m += function_dispatch.o\nobj-m += handler_sensor.o\nobj-m += handler_motor.o\nobj-m += handler_status.o\nobj-m += handler_network.o\nobj-m += handler_storage.o\nobj-m += test_dispatch.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "function_dispatch.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "function_dispatch_init",
          "function_dispatch_exit",
          "register_event_handler",
          "dispatch_event",
          "show_registered_handlers"
        ],
        "function_declarations": [
          {
            "name": "register_event_handler",
            "returnType": "void",
            "parameters": [
              "uint8_t event_type",
              "event_handler_t handler",
              "const char* name"
            ]
          },
          {
            "name": "dispatch_event",
            "returnType": "void",
            "parameters": [
              "uint8_t event_type",
              "void* data",
              "uint32_t size"
            ]
          },
          {
            "name": "show_registered_handlers",
            "returnType": "void",
            "parameters": []
          }
        ],
        "variables_declarations": [
          {
            "name": "event_handler_t",
            "type": "typedef",
            "value": "void (*)(uint8_t event_type, void* event_data, uint32_t data_size)",
            "storageClass": "none"
          },
          {
            "name": "event_operations",
            "type": "typedef struct",
            "value": "{event_handler_t handler; char event_name[MAX_NAME_LEN]; uint32_t event_count;}",
            "storageClass": "none"
          },
          {
            "name": "event_ops_table",
            "type": "event_operations",
            "value": "[MAX_HANDLERS]",
            "storageClass": "extern"
          },
          {
            "name": "registered_handler_count",
            "type": "int",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "event_ops_table",
            "type": "event_operations",
            "value": "[MAX_HANDLERS]",
            "storageClass": "none"
          },
          {
            "name": "registered_handler_count",
            "type": "int",
            "value": 0,
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Function dispatch core module loaded",
          "Waiting for handler modules to register",
          "Event dispatch system ready",
          "handler module loaded",
          "Registered handler",
          "Registered Event Handlers",
          "Total registered handlers:",
          "Dispatching to Runtime-Unknown Types",
          "Will dispatch to",
          "Dispatching to type",
          "Final Handler Statistics",
          "Function dispatch demonstration complete"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "event_ops_table[event_type].handler = handler",
          "event_ops_table[event_type].handler(event_type, data, size)",
          "if (event_ops_table[event_type].handler == NULL)",
          "event_ops_table[event_type].event_count++",
          "registered_handler_count++",
          "EXPORT_SYMBOL(register_event_handler)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void register_event_handler(uint8_t event_type, event_handler_t handler, const char* name)",
            "void dispatch_event(uint8_t event_type, void* data, uint32_t size)",
            "void show_registered_handlers(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void register_event_handler(uint8_t event_type, event_handler_t handler, const char* name)",
            "void dispatch_event(uint8_t event_type, void* data, uint32_t size)",
            "void show_registered_handlers(void)",
            "static int __init function_dispatch_init(void)",
            "static void __exit function_dispatch_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "callback_registration_implementation",
          "name": "Callback Registration Implementation",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "event_ops_table[event_type].handler = handler",
            "registered_handler_count++"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_pointer_dispatch",
          "name": "Function Pointer Dispatch (No If-Else)",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "event_ops_table[event_type].handler(event_type, data, size)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "export_symbol_check",
          "name": "EXPORT_SYMBOL for Cross-Module Access",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "EXPORT_SYMBOL(register_event_handler)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Function dispatch core module loaded",
              "exact": true,
              "linkedFunction": "static int __init function_dispatch_init(void)"
            },
            {
              "pattern": "Waiting for handler modules to register",
              "exact": true,
              "linkedFunction": "static int __init function_dispatch_init(void)"
            },
            {
              "pattern": "Event dispatch system ready",
              "exact": true,
              "linkedFunction": "static int __init function_dispatch_init(void)"
            },
            {
              "pattern": ".*handler module loaded",
              "exact": false,
              "linkedFunction": "Handler module init functions"
            },
            {
              "pattern": "Registered handler .* for event type [0-9]+",
              "exact": false,
              "linkedFunction": "void register_event_handler(uint8_t event_type, event_handler_t handler, const char* name)"
            },
            {
              "pattern": "Registered Event Handlers",
              "exact": true,
              "linkedFunction": "void show_registered_handlers(void)"
            },
            {
              "pattern": "Total registered handlers: [0-9]+",
              "exact": false,
              "linkedFunction": "void show_registered_handlers(void)"
            },
            {
              "pattern": "Dispatching to Runtime-Unknown Types",
              "exact": true,
              "linkedFunction": "test_dispatch module"
            },
            {
              "pattern": "Will dispatch to [0-9]+ different event types",
              "exact": false,
              "linkedFunction": "test_dispatch module"
            },
            {
              "pattern": "Dispatching to type [0-9]+",
              "exact": false,
              "linkedFunction": "test_dispatch module"
            },
            {
              "pattern": "\\[(Sensor|Motor|Status|Network|Storage) Handler\\] Processing event type [0-9]+, data size: [0-9]+",
              "exact": false,
              "linkedFunction": "void dispatch_event(uint8_t event_type, void* data, uint32_t size)"
            },
            {
              "pattern": "Final Handler Statistics",
              "exact": true,
              "linkedFunction": "test_dispatch module"
            },
            {
              "pattern": "Function dispatch demonstration complete",
              "exact": true,
              "linkedFunction": "test_dispatch module"
            }
          ]
        },
        {
          "id": "multi_module_dispatch_validation",
          "name": "Multi-Module Dynamic Dispatch (Proves External Module Integration)",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "multi_module_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\\\"=== Multi-Module Handler Integration Test ===\\\\n\\\");\\n    \\n    srand(time(NULL));\\n    \\n    /* Generate random handler module selection (2-4 modules) */\\n    const char *handlers[] = {\\\"handler_sensor\\\", \\\"handler_motor\\\", \\\"handler_status\\\", \\\"handler_network\\\", \\\"handler_storage\\\"};\\n    int num_handlers = (rand() % 3) + 2;\\n    int selected[5] = {0};\\n    \\n    printf(\\\"Step 1: Randomly selecting %d handler modules to load...\\\\n\\\", num_handlers);\\n    \\n    for(int i = 0; i < num_handlers; i++) {\\n        int idx;\\n        do { idx = rand() % 5; } while(selected[idx]);\\n        selected[idx] = 1;\\n        printf(\\\"  - Will load %s.ko\\\\n\\\", handlers[idx]);\\n    }\\n    \\n    /* Generate dispatch sequence */\\n    int dispatch_count = (rand() % 3) + 3;\\n    int dispatch_types[8];\\n    \\n    printf(\\\"\\\\nStep 2: Generating %d random dispatches...\\\\n\\\", dispatch_count);\\n    for(int i = 0; i < dispatch_count; i++) {\\n        int attempts = 0;\\n        do {\\n            dispatch_types[i] = rand() % 5;\\n            attempts++;\\n        } while (!selected[dispatch_types[i]] && attempts < 20);\\n        if (selected[dispatch_types[i]]) {\\n            printf(\\\"  - Dispatch %d: type %d\\\\n\\\", i+1, dispatch_types[i]);\\n        } else {\\n            dispatch_count = i;\\n            break;\\n        }\\n    }\\n    \\n    printf(\\\"\\\\nTest configuration: %d handlers, %d dispatches\\\\n\\\", num_handlers, dispatch_count);\\n    \\n    /* Build dispatch types string */\\n    char types_str[128] = \\\"\\\";\\n    for(int i = 0; i < dispatch_count; i++) {\\n        char buf[16];\\n        snprintf(buf, sizeof(buf), \\\"%s%d\\\", i > 0 ? \\\",\\\" : \\\"\\\", dispatch_types[i]);\\n        strcat(types_str, buf);\\n    }\\n    \\n    /* Unload any existing modules */\\n    system(\\\"rmmod test_dispatch 2>/dev/null\\\");\\n    system(\\\"rmmod handler_sensor handler_motor handler_status handler_network handler_storage 2>/dev/null\\\");\\n    system(\\\"rmmod function_dispatch 2>/dev/null\\\");\\n    \\n    /* Load core module */\\n    printf(\\\"\\\\nStep 3: Loading core module...\\\\n\\\");\\n    system(\\\"insmod /lib/modules/function_dispatch.ko\\\");\\n    \\n    /* Load selected handler modules */\\n    printf(\\\"Step 4: Loading selected handler modules...\\\\n\\\");\\n    for(int i = 0; i < 5; i++) {\\n        if (selected[i]) {\\n            char cmd[256];\\n            snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/%s.ko\\\", handlers[i]);\\n            printf(\\\"  - Loading %s.ko\\\\n\\\", handlers[i]);\\n            system(cmd);\\n        }\\n    }\\n    \\n    /* Load test dispatch module */\\n    printf(\\\"Step 5: Running dispatch test...\\\\n\\\");\\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/test_dispatch.ko test_dispatch_types=%s\\\", types_str);\\n    system(cmd);\\n    \\n    printf(\\\"\\\\nSUCCESS: Multi-module dispatch test completed!\\\\n\\\");\\n    printf(\\\"This PROVES function pointers handle external module functions!\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting multi-module external handler validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: TCC Header Validation'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define EXPORT_SYMBOL(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef unsigned char uint8_t;' > /tmp/linux/types.h",
              "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
              "echo 'void* memset(void* s, int c, unsigned long n);' > /tmp/linux/string.h",
              "echo '#include \"/lib/modules/function_dispatch.h\"' > /tmp/test.c",
              "echo 'int main() { register_event_handler(1, (event_handler_t)0, \"test\"); dispatch_event(1, (void*)0, 128); show_registered_handlers(); return 0; }' >> /tmp/test.c",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing'; cat /tmp/tcc_error.log; else echo 'PASS: All declarations found'; fi",
              "",
              "echo 'Phase 2: Multi-Module Integration Test'",
              "/bin/multi_module_tester > /tmp/test_output.log 2>&1",
              "cat /tmp/test_output.log",
              "sleep 1",
              "",
              "echo 'Phase 3: Verify Core Module Loaded'",
              "dmesg | grep 'Function dispatch core module loaded' && echo 'PASS: Core module loaded' || echo 'FAIL: Core module not loaded'",
              "dmesg | grep 'Event dispatch system ready' && echo 'PASS: System initialized' || echo 'FAIL: System not ready'",
              "",
              "echo 'Phase 4: Verify Handler Modules Registered'",
              "REGISTERED_COUNT=$(dmesg | grep -c 'Registered handler')",
              "echo 'Handler modules registered: '$REGISTERED_COUNT",
              "if [ \"$REGISTERED_COUNT\" -ge 2 ]; then echo 'PASS: Multiple handler modules registered'; else echo 'FAIL: Too few handlers'; fi",
              "",
              "echo 'Phase 5: Validate External Module Dispatch (THE CRITICAL TEST!)'",
              "SENSOR_CALLS=$(dmesg | grep -c '\\[Sensor Handler\\] Processing')",
              "MOTOR_CALLS=$(dmesg | grep -c '\\[Motor Handler\\] Processing')",
              "STATUS_CALLS=$(dmesg | grep -c '\\[Status Handler\\] Processing')",
              "NETWORK_CALLS=$(dmesg | grep -c '\\[Network Handler\\] Processing')",
              "STORAGE_CALLS=$(dmesg | grep -c '\\[Storage Handler\\] Processing')",
              "TOTAL_CALLS=$((SENSOR_CALLS + MOTOR_CALLS + STATUS_CALLS + NETWORK_CALLS + STORAGE_CALLS))",
              "echo 'External handler calls: Sensor='$SENSOR_CALLS', Motor='$MOTOR_CALLS', Status='$STATUS_CALLS', Network='$NETWORK_CALLS', Storage='$STORAGE_CALLS",
              "echo 'Total external calls: '$TOTAL_CALLS",
              "if [ \"$TOTAL_CALLS\" -ge 3 ]; then echo 'PASS: External module functions called via function pointers'; else echo 'FAIL: External handlers not called'; fi",
              "",
              "echo 'Phase 6: Verify Statistics Tracking'",
              "dmesg | grep 'Final Handler Statistics' && echo 'PASS: Statistics tracking working' || echo 'FAIL: Missing statistics'",
              "dmesg | grep 'called [1-9][0-9]* times' && echo 'PASS: Event counters updated' || echo 'PASS: Event counters initialized'",
              "",
              "echo 'Phase 7: Critical Validation - Proves If-Else Impossible'",
              "echo ''",
              "echo '========================================='",
              "echo 'CRITICAL SUCCESS: This test PROVES that:'",
              "echo '1. Handler functions in EXTERNAL .ko modules'",
              "echo '2. Core module CANNOT use if-else (linker error!)'",
              "echo '3. Function pointers are REQUIRED (not optional!)'",
              "echo '4. Dynamic module loading works like real kernel'",
              "echo '========================================='",
              "echo ''",
              "echo 'PASS: All multi-module external handler validation successful'"
            ],
            "expected": {
              "dmesg": [
                "Function dispatch core module loaded",
                "Waiting for handler modules to register",
                "Event dispatch system ready",
                ".* handler module loaded",
                "Registered handler .* for event type [0-9]*",
                "Dispatching to Runtime-Unknown Types",
                "Will dispatch to [0-9]+ different event types",
                "Dispatching to type [0-9]+",
                "\\[(Sensor|Motor|Status|Network|Storage) Handler\\] Processing event type [0-9]*",
                "Final Handler Statistics",
                "Function dispatch demonstration complete"
              ],
              "stdout": [
                "PASS: All declarations found",
                "SUCCESS: Multi-module dispatch test completed",
                "PASS: Core module loaded",
                "PASS: System initialized",
                "PASS: Multiple handler modules registered",
                "PASS: External module functions called via function pointers",
                "PASS: Statistics tracking working",
                "PASS: All multi-module external handler validation successful"
              ]
            },
            "timeout": 30
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Function dispatch core module loaded",
        "Waiting for handler modules to register",
        "Event dispatch system ready",
        "handler module loaded",
        "Registered handler",
        "Registered Event Handlers",
        "Total registered handlers:",
        "Dispatching to Runtime-Unknown Types",
        "Will dispatch to",
        "Dispatching to type",
        "Final Handler Statistics",
        "Function dispatch demonstration complete"
      ],
      "requirements": [
        "Use required function names: function_dispatch_init, function_dispatch_exit, register_event_handler, dispatch_event, show_registered_handlers",
        "Use required variable names: event_ops_table, registered_handler_count",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: event_ops_table[event_type].handler = handler, event_ops_table[event_type].handler(event_type, data, size), if (event_ops_table[event_type].handler == NULL), event_ops_table[event_type].event_count++, registered_handler_count++, EXPORT_SYMBOL(register_event_handler)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Function dispatch core module loaded",
          "linkedFunction": "static int __init function_dispatch_init(void)",
          "exact": true
        },
        {
          "pattern": "Waiting for handler modules to register",
          "linkedFunction": "static int __init function_dispatch_init(void)",
          "exact": true
        },
        {
          "pattern": "Event dispatch system ready",
          "linkedFunction": "static int __init function_dispatch_init(void)",
          "exact": true
        },
        {
          "pattern": ".*handler module loaded",
          "linkedFunction": "Handler module init functions",
          "exact": false
        },
        {
          "pattern": "Registered handler .* for event type [0-9]+",
          "linkedFunction": "void register_event_handler(uint8_t event_type, event_handler_t handler, const char* name)",
          "exact": false
        },
        {
          "pattern": "Registered Event Handlers",
          "linkedFunction": "void show_registered_handlers(void)",
          "exact": true
        },
        {
          "pattern": "Total registered handlers: [0-9]+",
          "linkedFunction": "void show_registered_handlers(void)",
          "exact": false
        },
        {
          "pattern": "Dispatching to Runtime-Unknown Types",
          "linkedFunction": "test_dispatch module",
          "exact": true
        },
        {
          "pattern": "Will dispatch to [0-9]+ different event types",
          "linkedFunction": "test_dispatch module",
          "exact": false
        },
        {
          "pattern": "Dispatching to type [0-9]+",
          "linkedFunction": "test_dispatch module",
          "exact": false
        },
        {
          "pattern": "\\[(Sensor|Motor|Status|Network|Storage) Handler\\] Processing event type [0-9]+, data size: [0-9]+",
          "linkedFunction": "void dispatch_event(uint8_t event_type, void* data, uint32_t size)",
          "exact": false
        },
        {
          "pattern": "Final Handler Statistics",
          "linkedFunction": "test_dispatch module",
          "exact": true
        },
        {
          "pattern": "Function dispatch demonstration complete",
          "linkedFunction": "test_dispatch module",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 22,
    "title": "Pointer Arithmetic - Buffer Navigation Fundamentals",
    "difficulty": 6,
    "xp": 50,
    "phase": "foundations",
    "description": "Master pointer arithmetic fundamentals and double pointer concepts. Learn to navigate through memory buffers, advance pointers sequentially, and understand the building blocks needed for binary data processing in Problem 22.",
    "concepts": [
      "pointer arithmetic fundamentals",
      "double pointer concepts",
      "buffer navigation",
      "memory traversal",
      "type casting basics",
      "sequential data access"
    ],
    "skills": [
      "Understanding double pointer modification",
      "Implementing pointer advancement functions",
      "Reading data types from memory buffers",
      "Traversing memory buffers safely",
      "Preparing for binary data parsing",
      "Foundation for Problem 22 concepts"
    ],
    "files": [
      {
        "name": "pointer_arithmetic.h",
        "content": "#ifndef POINTER_ARITHMETIC_H\n#define POINTER_ARITHMETIC_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n#define BUFFER_SIZE 16\n\n/* Global variables for testing */\nextern uint8_t test_buffer[BUFFER_SIZE];\nextern uint8_t *current_position;\nextern int total_bytes_read;\n\n/* TODO: Declare your pointer arithmetic functions */\n/* void advance_pointer(uint8_t **ptr, int bytes); */\n/* uint32_t read_uint32_and_advance(uint8_t **ptr); */\n/* uint16_t read_uint16_and_advance(uint8_t **ptr); */\n/* void traverse_buffer(uint8_t *buffer, size_t size); */\n/* void print_buffer_status(void); */\n\n#endif /* POINTER_ARITHMETIC_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "pointer_arithmetic.c",
        "content": "#include \"pointer_arithmetic.h\"\n\n/* Global variables */\nuint8_t test_buffer[BUFFER_SIZE] = {\n    0x01, 0x00, 0x00, 0x00,  /* uint32_t: 1 */\n    0xFF, 0x00,              /* uint16_t: 255 */\n    0x42, 0x00, 0x00, 0x00,  /* uint32_t: 66 */\n    0x7B, 0x00,              /* uint16_t: 123 */\n    0xAA, 0xBB, 0xCC, 0xDD   /* Extra bytes */\n};\n\nuint8_t *current_position = NULL;\nint total_bytes_read = 0;\n\nint test_advance_bytes = 4;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your pointer arithmetic logic works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(test_advance_bytes, int, 0644);\nMODULE_PARM_DESC(test_advance_bytes, \"Number of bytes to advance for testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: How pointer arithmetic works in C */\n/* This teaches the FOUNDATION for binary parsing:\n *\n * Memory Buffer:  [0x01][0x00][0x00][0x00][0xFF][0x00][0x42]...\n * Pointer:         ↑ ptr points here initially\n *                      ↑ ptr + 1 points here\n *                              ↑ ptr + 4 points here\n *\n * Step 1: Start with pointer at beginning of buffer\n * Step 2: Read data at current pointer location\n * Step 3: Advance pointer to next data location\n * Step 4: Repeat until buffer is fully processed\n */\n\n/* WHAT EACH POINTER OPERATION DOES AND HOW TO USE IT: */\n\n/* 1. void advance_pointer(uint8_t **ptr, int bytes) */\n/*    Purpose: Move a pointer forward by specified number of bytes */\n/*    Input: Double pointer (so we can modify caller's pointer) + byte count */\n/*    Output: None (modifies the pointer itself) */\n/*    Usage: advance_pointer(&my_ptr, 4);  // Moves my_ptr forward 4 bytes */\n\n/* 2. uint32_t read_uint32_and_advance(uint8_t **ptr) */\n/*    Purpose: Read 4 bytes as uint32_t AND move pointer forward */\n/*    Input: Double pointer to current buffer position */\n/*    Output: The 32-bit value that was read */\n/*    Side Effect: Advances pointer by 4 bytes automatically */\n/*    Usage: uint32_t value = read_uint32_and_advance(&buffer_pos); */\n\n/* 3. uint16_t read_uint16_and_advance(uint8_t **ptr) */\n/*    Purpose: Read 2 bytes as uint16_t AND move pointer forward */\n/*    Input: Double pointer to current buffer position */\n/*    Output: The 16-bit value that was read */\n/*    Side Effect: Advances pointer by 2 bytes automatically */\n/*    Usage: uint16_t value = read_uint16_and_advance(&buffer_pos); */\n\n/* POINTER ARITHMETIC BASICS EXPLAINED: */\n\n/* SINGLE POINTER ARITHMETIC: */\n/* uint8_t *ptr = buffer;       // ptr points to buffer[0] */\n/* ptr++;                       // ptr now points to buffer[1] */\n/* ptr += 4;                    // ptr now points to buffer[5] */\n/* uint8_t value = *ptr;        // Read the byte at current position */\n\n/* WHY WE NEED DOUBLE POINTERS (**): */\n/* Problem: Functions receive COPIES of pointer values */\n/* */\n/* void wrong_advance(uint8_t *ptr) { */\n/*     ptr += 4;  // Only changes the LOCAL copy! */\n/* } */\n/* // Caller's pointer stays unchanged - NOT what we want! */\n/* */\n/* Solution: Use double pointer to modify the original */\n/* void correct_advance(uint8_t **ptr) { */\n/*     *ptr += 4;  // Changes the ORIGINAL pointer! */\n/* } */\n/* // Caller's pointer gets advanced - EXACTLY what we want! */\n\n/* DOUBLE POINTER SYNTAX BREAKDOWN: */\n/* uint8_t **ptr means \"pointer to a pointer to uint8_t\" */\n/* */\n/* SIMPLE EXAMPLE TO UNDERSTAND DOUBLE POINTERS: */\n/* int a = 5; */\n/* int* ptr = &a;      // ptr points to a */\n/* int** ptr2 = &ptr;  // ptr2 points to ptr */\n/* */\n/* What Each Contains: */\n/* a = 5                    // The value */\n/* ptr = &a                 // Address of a (like 0x1000) */\n/* ptr2 = &ptr              // Address of ptr variable (like 0x2000) */\n/* */\n/* The Dereferencing Chain: */\n/* ptr2        // Address of ptr variable (0x2000) */\n/* *ptr2       // Contents of ptr variable (0x1000) - same as ptr */\n/* **ptr2      // Contents of a variable (5) - same as a */\n/* */\n/* CASTING AND DEREFERENCING EXAMPLE: */\n/* uint8_t buffer[] = {0x01, 0x00, 0x00, 0x00};  // 4 bytes representing uint32_t: 1 */\n/* uint8_t* current_position = buffer;            // Points to first byte */\n/* */\n/* When we call read_uint32_and_advance(&current_position) */\n/* Which is by declaration : read_uint32_and_advance(uint8_t **ptr) */\n/* ptr = &current_position                        // ptr points to current_position variable */\n/* *ptr = current_position                        // Gives us current_position (points to buffer[0]) */\n/* */\n/* Step-by-Step Breakdown of *(uint32_t*)(*ptr): */\n/* */\n/* *ptr                    // current_position (uint8_t* pointer to buffer[0]) */\n/* (uint32_t*)(*ptr)       // Cast to uint32_t* pointer (still points to buffer[0]) */\n/* *(uint32_t*)(*ptr)      // Dereference to get actual uint32_t VALUE (reads 4 bytes) */\n/* */\n/* What Each Expression Contains: */\n/* *ptr = 0x2000                    // Address of buffer[0] (pointer value) */\n/* (uint32_t*)(*ptr) = 0x2000       // Same address, but treated as uint32_t* */\n/* *(uint32_t*)(*ptr) = 1           // The 4-byte value: [0x01][0x00][0x00][0x00] = 1 */\n/* */\n/* Why We Need the Cast: */\n/* *ptr gives us uint8_t* (points to 1 byte) */\n/* (uint32_t*)(*ptr) changes interpretation to uint32_t* (points to 4 bytes) */\n/* *(uint32_t*)(*ptr) reads those 4 bytes as a single uint32_t value */\n/* */\n/* Memory Layout Visualization: */\n/* Buffer: [0x01][0x00][0x00][0x00][0xFF][0x00] */\n/* Address: 0x2000              0x2004        */\n/* */\n/* *ptr = 0x2000                    // Points to start of buffer */\n/* (uint32_t*)(*ptr) = 0x2000       // Same location, uint32_t* type */\n/* *(uint32_t*)(*ptr) = 1           // Reads bytes 0x2000-0x2003 as uint32_t */\n/* */\n/* APPLIED TO OUR BUFFER POINTERS: */\n/* If we have: uint8_t *buffer_pos = &buffer[0]; */\n/* And we call: advance_pointer(&buffer_pos, 4); */\n/* */\n/* Inside function: */\n/* ptr parameter contains: &buffer_pos (address of buffer_pos variable) */\n/* *ptr gives us: buffer_pos (the actual pointer value) */\n/* *ptr += 4 modifies: buffer_pos (moves it forward 4 bytes) */\n\n/* POINTER ARITHMETIC WITH TYPES: */\n/* uint8_t *ptr points to 1-byte values */\n/* ptr + 1 advances by 1 byte */\n/* ptr + 4 advances by 4 bytes */\n/* */\n/* uint32_t *ptr32 points to 4-byte values */\n/* ptr32 + 1 advances by 4 bytes (1 uint32_t) */\n/* ptr32 + 2 advances by 8 bytes (2 uint32_t values) */\n\n/* TYPE CASTING FOR DATA READING: */\n/* uint8_t *ptr = buffer; */\n/* uint32_t value = *(uint32_t*)ptr; */\n/*                   ↑       ↑     */\n/*                   |       └─ Dereference to read value */\n/*                   └─ Cast uint8_t* to uint32_t* */\n/* */\n/* This reads 4 bytes starting at ptr as a single uint32_t value */\n\n/* BUFFER TRAVERSAL PATTERN: */\n/* uint8_t *current = buffer;           // Start at beginning */\n/* while (current < buffer + size) {    // Check if within bounds */\n/*     process_byte(*current);          // Process current byte */\n/*     current++;                       // Move to next byte */\n/* } */\n\n/* MEMORY LAYOUT VISUALIZATION: */\n/* test_buffer:  [0x01][0x00][0x00][0x00][0xFF][0x00][0x42][0x00] */\n/* Addresses:     0x1000          0x1004  0x1006               */\n/* */\n/* uint8_t *ptr = test_buffer;     // ptr = 0x1000 */\n/* uint32_t val = *(uint32_t*)ptr; // Read bytes 0x1000-0x1003 = 1 */\n/* ptr += 4;                       // ptr = 0x1004 */\n/* uint16_t val2 = *(uint16_t*)ptr;// Read bytes 0x1004-0x1005 = 255 */\n\n/* COMMON MISTAKES AND SOLUTIONS: */\n/* MISTAKE 1: Forgetting to use double pointer for modification */\n/*   void bad_advance(uint8_t *ptr) { ptr += 4; }  // WRONG */\n/* SOLUTION: */\n/*   void good_advance(uint8_t **ptr) { *ptr += 4; }  // CORRECT */\n/* */\n/* MISTAKE 2: Confusing pointer and value dereferencing */\n/*   uint32_t val = (uint32_t)*ptr;    // WRONG - reads 1 byte, casts to uint32_t */\n/* SOLUTION: */\n/*   uint32_t val = *(uint32_t*)ptr;   // CORRECT - reads 4 bytes as uint32_t */\n/* */\n/* MISTAKE 3: Not checking buffer bounds */\n/*   ptr += 10;  // WRONG - might go past end of buffer */\n/* SOLUTION: */\n/*   if (ptr + 10 <= buffer + buffer_size) ptr += 10;  // CORRECT */\n\n/* PRACTICAL EXAMPLES FOR UNDERSTANDING: */\n/* Example 1: Reading consecutive integers from buffer */\n/* uint8_t buffer[] = {0x01, 0x00, 0x00, 0x00, 0xFF, 0x00}; */\n/* uint8_t *pos = buffer; */\n/* uint32_t first = read_uint32_and_advance(&pos);   // first = 1, pos += 4 */\n/* uint16_t second = read_uint16_and_advance(&pos);  // second = 255, pos += 2 */\n/* */\n/* Example 2: Manual buffer traversal */\n/* uint8_t *current = buffer; */\n/* for (int i = 0; i < buffer_size; i++) { */\n/*     printk(\"Byte %d: 0x%02x\\n\", i, *current); */\n/*     current++;  // Move to next byte */\n/* } */\n\n/* WHY THIS PREPARES YOU FOR PROBLEM 22: */\n/* Problem 22 (Binary Parsing) combines these concepts: */\n/* - Double pointers for buffer advancement (learned here) */\n/* - Type casting for data reading (learned here) */\n/* - Sequential data extraction (learned here) */\n/* + Dynamic memory allocation (from Problem 18) */\n/* + Structure parsing (from Problems 15-16) */\n/* = Complete binary parser capability! */\n\n/* TODO: Implement pointer advancement function */\nvoid advance_pointer(uint8_t **ptr, int bytes) {\n    /* TODO: Move the pointer forward by 'bytes' number of bytes */\n    /* TODO: Use *ptr += bytes to modify the caller's actual pointer */\n    /* TODO: This teaches the fundamental double pointer pattern */\n}\n\n/* TODO: Implement read and advance function */\nuint32_t read_uint32_and_advance(uint8_t **ptr) {\n    /* TODO: Read 4 bytes from current pointer position as uint32_t */\n    /* TODO: Cast *ptr to uint32_t* and dereference: *(uint32_t*)(*ptr) */\n    /* TODO: Advance the pointer by 4 bytes: *ptr += 4 */\n    /* TODO: Return the uint32_t value that was read */\n    return 0;\n}\n\n/* TODO: Implement read and advance function */\nuint16_t read_uint16_and_advance(uint8_t **ptr) {\n    /* TODO: Read 2 bytes from current pointer position as uint16_t */\n    /* TODO: Cast *ptr to uint16_t* and dereference: *(uint16_t*)(*ptr) */\n    /* TODO: Advance the pointer by 2 bytes: *ptr += 2 */\n    /* TODO: Return the uint16_t value that was read */\n    return 0;\n}\n\n/* TODO: Implement buffer traversal function */\nvoid traverse_buffer(uint8_t *buffer, size_t size) {\n    /* TODO: Create a pointer to traverse the buffer: uint8_t *buffer_ptr = buffer */\n    /* TODO: Loop through each byte: for (int i = 0; i < size; i++) */\n    /* TODO: Print each byte with its position: printk(\"Position %d: 0x%02x\\n\", i, *buffer_ptr) */\n    /* Format Specifier: %02x means: */\n    /* x = print as hexadecimal, 02 = pad with zeros to make it at least 2 digits */\n    /* TODO: Advance to next byte: buffer_ptr++ */\n}\n\nvoid print_buffer_status(void) {\n    if (!current_position) {\n        printk(KERN_INFO \"Buffer Status: No current position set\\n\");\n        return;\n    }\n    \n    printk(KERN_INFO \"Buffer Status:\\n\");\n    printk(KERN_INFO \"Buffer start: %p\\n\", test_buffer);\n    printk(KERN_INFO \"Current position: %p\\n\", current_position);\n    printk(KERN_INFO \"Bytes advanced: %ld\\n\", current_position - test_buffer);\n    printk(KERN_INFO \"Total bytes read: %d\\n\", total_bytes_read);\n}\n\nstatic int __init pointer_arithmetic_init(void)\n{\n    uint32_t value32;\n    uint16_t value16;\n    \n    printk(KERN_INFO \"Pointer arithmetic module loaded\\n\");\n    \n    /* Initialize current position to start of buffer */\n    current_position = test_buffer;\n    total_bytes_read = 0;\n    \n    printk(KERN_INFO \"Starting pointer arithmetic demonstration\\n\");\n    \n    /* Test 1: Read first uint32_t and advance */\n    printk(KERN_INFO \"Test 1: Reading uint32_t from buffer\\n\");\n    value32 = read_uint32_and_advance(&current_position);\n    total_bytes_read += 4;\n    printk(KERN_INFO \"Read uint32_t: %u\\n\", value32);\n    print_buffer_status();\n    \n    /* Test 2: Read uint16_t and advance */\n    printk(KERN_INFO \"Test 2: Reading uint16_t from buffer\\n\");\n    value16 = read_uint16_and_advance(&current_position);\n    total_bytes_read += 2;\n    printk(KERN_INFO \"Read uint16_t: %u\\n\", value16);\n    print_buffer_status();\n    \n    /* Test 3: Advance pointer by dynamic amount */\n    printk(KERN_INFO \"Test 3: Advancing pointer by %d bytes\\n\", test_advance_bytes);\n    advance_pointer(&current_position, test_advance_bytes);\n    total_bytes_read += test_advance_bytes;\n    print_buffer_status();\n    \n    /* Test 4: Traverse entire buffer */\n    printk(KERN_INFO \"Test 4: Traversing entire buffer\\n\");\n    traverse_buffer(test_buffer, BUFFER_SIZE);\n    \n    printk(KERN_INFO \"Pointer arithmetic demonstration completed\\n\");\n    \n    return 0;\n}\n\nstatic void __exit pointer_arithmetic_exit(void)\n{\n    printk(KERN_INFO \"Pointer arithmetic module unloaded\\n\");\n    \n    /* Reset global state */\n    current_position = NULL;\n    total_bytes_read = 0;\n}\n\nmodule_init(pointer_arithmetic_init);\nmodule_exit(pointer_arithmetic_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning pointer arithmetic fundamentals for buffer navigation\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Pointer arithmetic module Makefile\nobj-m += pointer_arithmetic.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "pointer_arithmetic.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "pointer_arithmetic_init",
          "pointer_arithmetic_exit",
          "advance_pointer",
          "read_uint32_and_advance",
          "read_uint16_and_advance",
          "traverse_buffer",
          "print_buffer_status"
        ],
        "function_declarations": [
          {
            "name": "advance_pointer",
            "returnType": "void",
            "parameters": [
              "uint8_t **ptr",
              "int bytes"
            ]
          },
          {
            "name": "read_uint32_and_advance",
            "returnType": "uint32_t",
            "parameters": [
              "uint8_t **ptr"
            ]
          },
          {
            "name": "read_uint16_and_advance",
            "returnType": "uint16_t",
            "parameters": [
              "uint8_t **ptr"
            ]
          },
          {
            "name": "traverse_buffer",
            "returnType": "void",
            "parameters": [
              "uint8_t *buffer",
              "size_t size"
            ]
          },
          {
            "name": "print_buffer_status",
            "returnType": "void",
            "parameters": []
          }
        ],
        "variables_declarations": [
          {
            "name": "test_buffer",
            "type": "uint8_t",
            "value": "[BUFFER_SIZE]",
            "storageClass": "extern"
          },
          {
            "name": "current_position",
            "type": "uint8_t *",
            "storageClass": "extern"
          },
          {
            "name": "total_bytes_read",
            "type": "int",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "current_position",
            "type": "uint8_t *",
            "value": "NULL",
            "storageClass": "none"
          },
          {
            "name": "total_bytes_read",
            "type": "int",
            "value": "0",
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Pointer arithmetic module loaded",
          "Starting pointer arithmetic demonstration",
          "Test 1: Reading uint32_t from buffer",
          "Read uint32_t: 1",
          "Test 2: Reading uint16_t from buffer",
          "Read uint16_t: 255",
          "Test 3: Advancing pointer by 4 bytes",
          "Test 4: Traversing entire buffer",
          "Position 0: 0x01",
          "Position 1: 0x00",
          "Pointer arithmetic demonstration completed",
          "Pointer arithmetic module unloaded"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "*ptr += bytes",
          "*(uint32_t*)(*ptr)",
          "*ptr += 4",
          "*(uint16_t*)(*ptr)",
          "*ptr += 2",
          "uint8_t *buffer_ptr = buffer",
          "buffer_ptr++",
          "read_uint32_and_advance(&current_position)",
          "read_uint16_and_advance(&current_position)",
          "advance_pointer(&current_position",
          "module_param(test_advance_bytes, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void advance_pointer(uint8_t **ptr, int bytes)",
            "uint32_t read_uint32_and_advance(uint8_t **ptr)",
            "uint16_t read_uint16_and_advance(uint8_t **ptr)",
            "void traverse_buffer(uint8_t *buffer, size_t size)",
            "void print_buffer_status(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void advance_pointer(uint8_t **ptr, int bytes)",
            "uint32_t read_uint32_and_advance(uint8_t **ptr)",
            "uint16_t read_uint16_and_advance(uint8_t **ptr)",
            "void traverse_buffer(uint8_t *buffer, size_t size)",
            "void print_buffer_status(void)",
            "static int __init pointer_arithmetic_init(void)",
            "static void __exit pointer_arithmetic_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Pointer arithmetic module loaded",
              "exact": true,
              "linkedFunction": "static int __init pointer_arithmetic_init(void)"
            },
            {
              "pattern": "Starting pointer arithmetic demonstration",
              "exact": true,
              "linkedFunction": "static int __init pointer_arithmetic_init(void)"
            },
            {
              "pattern": "Test 1: Reading uint32_t from buffer",
              "exact": true,
              "linkedFunction": "static int __init pointer_arithmetic_init(void)"
            },
            {
              "pattern": "Read uint32_t: 1",
              "exact": true,
              "linkedFunction": "uint32_t read_uint32_and_advance(uint8_t **ptr)"
            },
            {
              "pattern": "Test 2: Reading uint16_t from buffer",
              "exact": true,
              "linkedFunction": "static int __init pointer_arithmetic_init(void)"
            },
            {
              "pattern": "Read uint16_t: 255",
              "exact": true,
              "linkedFunction": "uint16_t read_uint16_and_advance(uint8_t **ptr)"
            },
            {
              "pattern": "Test 3: Advancing pointer by 4 bytes",
              "exact": true,
              "linkedFunction": "static int __init pointer_arithmetic_init(void)"
            },
            {
              "pattern": "Test 4: Traversing entire buffer",
              "exact": true,
              "linkedFunction": "static int __init pointer_arithmetic_init(void)"
            },
            {
              "pattern": "Position 0: 0x01",
              "exact": true,
              "linkedFunction": "void traverse_buffer(uint8_t *buffer, size_t size)"
            },
            {
              "pattern": "Position 1: 0x00",
              "exact": true,
              "linkedFunction": "void traverse_buffer(uint8_t *buffer, size_t size)"
            },
            {
              "pattern": "Pointer arithmetic demonstration completed",
              "exact": true,
              "linkedFunction": "static int __init pointer_arithmetic_init(void)"
            },
            {
              "pattern": "Pointer arithmetic module unloaded",
              "exact": true,
              "linkedFunction": "static void __exit pointer_arithmetic_exit(void)"
            }
          ]
        },
        {
          "id": "advanced_pointer_arithmetic_validation",
          "name": "Advanced Pointer Arithmetic with Anti-Hardcoding Protection",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "pointer_arithmetic_dynamic_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Anti-Hardcoding Pointer Arithmetic Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate unpredictable test values\\n    int random_advance_bytes = (rand() % 4) + 2;  // 2-5 bytes\\n    \\n    printf(\\\"Test 1: Random pointer advancement (bytes=%d)\\\\n\\\", random_advance_bytes);\\n    \\n    // Test with random values\\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod pointer_arithmetic 2>/dev/null\\\");\\n    \\n    char cmd[256];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/pointer_arithmetic.ko test_advance_bytes=%d\\\", random_advance_bytes);\\n    printf(\\\"DEBUG: Command: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Anti-hardcoding pointer arithmetic test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced pointer arithmetic implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef unsigned char uint8_t;' > /tmp/linux/types.h",
              "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
              "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
              "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
              "echo '#define BUFFER_SIZE 16' >> /tmp/linux/types.h",
              "echo 'Creating test file that includes pointer arithmetic header...'",
              "echo '#include \"/lib/modules/pointer_arithmetic.h\"' > /tmp/test.c",
              "echo 'int main() { uint8_t *ptr; current_position = (uint8_t*)0; advance_pointer(&ptr, 4); read_uint32_and_advance(&ptr); read_uint16_and_advance(&ptr); traverse_buffer((uint8_t*)0, 16); print_buffer_status(); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
              "echo 'Phase 2: Anti-Hardcoding Dynamic Pointer Arithmetic Test'",
              "/bin/pointer_arithmetic_dynamic_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Random Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "ADVANCE_BYTES=$(grep -o 'Random pointer advancement (bytes=[0-9]*)' /tmp/test_output.log | cut -d'=' -f2 | cut -d')' -f1)",
              "echo 'Extracted values: ADVANCE_BYTES='$ADVANCE_BYTES",
              "if [ -z \"$ADVANCE_BYTES\" ]; then echo 'FAIL: Could not extract random test values'; else echo 'PASS: Random values extracted successfully'; fi",
              "echo 'Phase 4: Anti-Hardcoding Validation with Random Values'",
              "echo 'Validating pointer advancement with random value '$ADVANCE_BYTES",
              "dmesg | grep \"Test 3: Advancing pointer by $ADVANCE_BYTES bytes\" && echo 'PASS: Pointer advancement with random value working' || echo 'FAIL: Pointer advancement with random value broken'",
              "echo 'Phase 5: Static Field Validation (Non-Randomized Fields)'",
              "dmesg | grep 'Read uint32_t: 1' && echo 'PASS: uint32_t reading working' || echo 'FAIL: uint32_t reading broken'",
              "dmesg | grep 'Read uint16_t: 255' && echo 'PASS: uint16_t reading working' || echo 'FAIL: uint16_t reading broken'",
              "dmesg | grep 'Position 0: 0x01' && echo 'PASS: Buffer traversal working' || echo 'FAIL: Buffer traversal broken'",
              "echo 'Phase 6: Pointer Arithmetic Logic Validation'",
              "dmesg | grep 'Starting pointer arithmetic demonstration' && echo 'PASS: Module demonstration working' || echo 'FAIL: Module demonstration broken'",
              "dmesg | grep 'Pointer arithmetic module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
              "dmesg | grep 'Pointer arithmetic module unloaded' && echo 'PASS: Module cleanup working' || echo 'FAIL: Module cleanup broken'",
              "echo 'Phase 7: Final Validation Summary'",
              "echo 'All phases completed successfully - anti-hardcoding pointer arithmetic protection verified'",
              "echo 'PASS: All anti-hardcoding pointer arithmetic validation successful'"
            ],
            "expected": {
              "dmesg": [
                "Pointer arithmetic module loaded",
                "Starting pointer arithmetic demonstration",
                "Test 1: Reading uint32_t from buffer",
                "Read uint32_t: 1",
                "Test 2: Reading uint16_t from buffer",
                "Read uint16_t: 255",
                "Test 3: Advancing pointer by .* bytes",
                "Test 4: Traversing entire buffer",
                "Position 0: 0x01",
                "Position 1: 0x00",
                "Pointer arithmetic demonstration completed",
                "Pointer arithmetic module unloaded"
              ],
              "stdout": [
                "PASS: All function and variable declarations found in header file",
                "SUCCESS: Anti-hardcoding pointer arithmetic test completed",
                "PASS: Random values extracted successfully",
                "PASS: Pointer advancement with random value working",
                "PASS: uint32_t reading working",
                "PASS: uint16_t reading working",
                "PASS: Buffer traversal working",
                "PASS: Module demonstration working",
                "PASS: Module initialization working",
                "PASS: Module cleanup working",
                "PASS: All anti-hardcoding pointer arithmetic validation successful"
              ]
            },
            "timeout": 15
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Pointer arithmetic module loaded",
        "Starting pointer arithmetic demonstration",
        "Test 1: Reading uint32_t from buffer",
        "Read uint32_t: 1",
        "Test 2: Reading uint16_t from buffer",
        "Read uint16_t: 255",
        "Test 3: Advancing pointer by 4 bytes",
        "Test 4: Traversing entire buffer",
        "Position 0: 0x01",
        "Position 1: 0x00",
        "Pointer arithmetic demonstration completed",
        "Pointer arithmetic module unloaded"
      ],
      "requirements": [
        "Use required function names: pointer_arithmetic_init, pointer_arithmetic_exit, advance_pointer, read_uint32_and_advance, read_uint16_and_advance, traverse_buffer, print_buffer_status",
        "Use required variable names: current_position, total_bytes_read",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: *ptr += bytes, *(uint32_t*)(*ptr), *ptr += 4, *(uint16_t*)(*ptr), *ptr += 2, uint8_t *buffer_ptr = buffer, buffer_ptr++, read_uint32_and_advance(&current_position), read_uint16_and_advance(&current_position), advance_pointer(&current_position, module_param(test_advance_bytes, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Pointer arithmetic module loaded",
          "linkedFunction": "static int __init pointer_arithmetic_init(void)",
          "exact": true
        },
        {
          "pattern": "Starting pointer arithmetic demonstration",
          "linkedFunction": "static int __init pointer_arithmetic_init(void)",
          "exact": true
        },
        {
          "pattern": "Test 1: Reading uint32_t from buffer",
          "linkedFunction": "static int __init pointer_arithmetic_init(void)",
          "exact": true
        },
        {
          "pattern": "Read uint32_t: 1",
          "linkedFunction": "uint32_t read_uint32_and_advance(uint8_t **ptr)",
          "exact": true
        },
        {
          "pattern": "Test 2: Reading uint16_t from buffer",
          "linkedFunction": "static int __init pointer_arithmetic_init(void)",
          "exact": true
        },
        {
          "pattern": "Read uint16_t: 255",
          "linkedFunction": "uint16_t read_uint16_and_advance(uint8_t **ptr)",
          "exact": true
        },
        {
          "pattern": "Test 3: Advancing pointer by 4 bytes",
          "linkedFunction": "static int __init pointer_arithmetic_init(void)",
          "exact": true
        },
        {
          "pattern": "Test 4: Traversing entire buffer",
          "linkedFunction": "static int __init pointer_arithmetic_init(void)",
          "exact": true
        },
        {
          "pattern": "Position 0: 0x01",
          "linkedFunction": "void traverse_buffer(uint8_t *buffer, size_t size)",
          "exact": true
        },
        {
          "pattern": "Position 1: 0x00",
          "linkedFunction": "void traverse_buffer(uint8_t *buffer, size_t size)",
          "exact": true
        },
        {
          "pattern": "Pointer arithmetic demonstration completed",
          "linkedFunction": "static int __init pointer_arithmetic_init(void)",
          "exact": true
        },
        {
          "pattern": "Pointer arithmetic module unloaded",
          "linkedFunction": "static void __exit pointer_arithmetic_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 23,
    "title": "STDF Binary Parser - Production Semiconductor Data Processing",
    "difficulty": 9,
    "xp": 75,
    "phase": "foundations",
    "description": "Master STDF (Standard Test Data Format) parsing using real production patterns. Learn header/data separation, record type dispatch, and multi-record processing exactly as used in semiconductor test systems and libstdf parsers.",
    "concepts": [
      "STDF header/data separation",
      "record type dispatch",
      "multi-record parsing",
      "production STDF patterns",
      "semiconductor data processing",
      "libstdf architecture"
    ],
    "skills": [
      "Parsing STDF headers with length/type/subtype",
      "Implementing record type dispatch",
      "Handling multiple record formats",
      "Using production STDF field names",
      "Understanding header/data separation",
      "Building real semiconductor parsers"
    ],
    "files": [
      {
        "name": "stdf_parser.h",
        "content": "#ifndef STDF_PARSER_H\n#define STDF_PARSER_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#define MAX_NAME_LEN 32\n#define MAX_RESULTS 8\n\n/* STDF Record Type Constants (like libstdf) */\n#define REC_PTR 0x15  /* Parametric Test Record */\n#define REC_MPR 0x16  /* Multiple-Result Parametric */\n\n/* STDF Header Structure (like libstdf rec_header) */\ntypedef struct {\n    uint16_t rec_length;  /* Number of bytes to follow */\n    uint8_t rec_type;     /* Record type identifier */\n    uint8_t rec_subtype;  /* Record subtype identifier */\n} stdf_header;\n\n/* Generic STDF Record (like libstdf rec_unknown) */\ntypedef struct {\n    stdf_header header;   /* Parsed header */\n    void *data;          /* Points to record payload */\n} stdf_record;\n\n/* PTR Record Structure (like libstdf rec_ptr) */\ntypedef struct {\n    uint32_t TEST_NUM;    /* Test number */\n    uint8_t HEAD_NUM;     /* Test head number */\n    uint8_t SITE_NUM;     /* Test site number */\n    uint8_t TEST_FLG;     /* Test flags */\n    uint8_t PARM_FLG;     /* Parameter flags */\n    uint32_t RESULT;      /* Test result (as integer) */\n    char TEST_TXT[MAX_NAME_LEN]; /* Test text */\n    char ALARM_ID[MAX_NAME_LEN]; /* Alarm identifier */\n} ptr_record;\n\n/* MPR Record Structure (like libstdf rec_mpr) */\ntypedef struct {\n    uint32_t TEST_NUM;    /* Test number */\n    uint8_t HEAD_NUM;     /* Test head number */\n    uint8_t SITE_NUM;     /* Test site number */\n    uint8_t TEST_FLG;     /* Test flags */\n    uint8_t PARM_FLG;     /* Parameter flags */\n    uint16_t RTN_ICNT;    /* Return result count */\n    uint32_t RTN_RSLT[MAX_RESULTS]; /* Return results array (as integers) */\n} mpr_record;\n\n/* Global variables for testing */\nextern stdf_record *parsed_record;\nextern uint8_t *test_buffer;\nextern size_t buffer_size;\n\n/* TODO: Declare your STDF parsing functions */\n/* stdf_header* parse_stdf_header(uint8_t **buffer_ptr); */\n/* uint8_t read_uint8_from_buffer(uint8_t **buffer_ptr); */\n/* uint32_t read_uint32_from_buffer(uint8_t **buffer_ptr); */\n/* uint16_t read_uint16_from_buffer(uint8_t **buffer_ptr); */\n/* char* read_string_from_buffer(uint8_t **buffer_ptr, uint8_t *out_length); */\n/* ptr_record* parse_ptr_record(uint8_t *data, uint16_t length); */\n/* mpr_record* parse_mpr_record(uint8_t *data, uint16_t length); */\n/* stdf_record* parse_stdf_record_from_buffer(uint8_t *raw_buffer); */\n/* int parse_stdf_file_buffer(uint8_t *buffer, size_t total_size); */\n/* void print_stdf_record(stdf_record *record); */\n\n#endif /* STDF_PARSER_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "stdf_parser.c",
        "content": "#include \"stdf_parser.h\"\n\n/* Global variables */\nstdf_record *parsed_record = NULL;\nuint8_t *test_buffer = NULL;\nsize_t buffer_size = 0;\n\nint test_record_type = REC_PTR;\nint test_num = 1001;\nint test_result = 255;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your STDF parsing logic works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(test_record_type, int, 0644);\nMODULE_PARM_DESC(test_record_type, \"STDF record type for testing\");\nmodule_param(test_num, int, 0644);\nMODULE_PARM_DESC(test_num, \"Test number for anti-hardcoding testing\");\nmodule_param(test_result, int, 0644);\nMODULE_PARM_DESC(test_result, \"Test result for anti-hardcoding testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: How STDF parsing works in production systems */\n/* This is the EXACT technique used in libstdf and semiconductor test systems:\n *\n * STDF File Structure:\n * ┌─────────────┬─────────────┬─────────────┬─────────────────────────────────────┐\n * │ rec_length  │ rec_type    │ rec_subtype │        RECORD PAYLOAD DATA          │\n * │ (2 bytes)   │ (1 byte)    │ (1 byte)    │     (rec_length bytes)              │\n * └─────────────┴─────────────┴─────────────┴─────────────────────────────────────┘\n *               ↑ header (4 bytes total)    ↑ data points here\n *\n * Step 1: Parse 4-byte header (length, type, subtype)\n * Step 2: Point data to payload after header\n * Step 3: Dispatch based on record type (PTR vs MPR)\n * Step 4: Parse fields based on specific record format\n */\n\n/* STDF HEADER/DATA SEPARATION EXPLAINED: */\n/* This is the KEY pattern that makes STDF parsing work:\n *\n * 1. Header contains metadata (length, type)\n * 2. Data points to payload (actual record fields)\n * 3. Length tells us how many payload bytes to read\n * 4. Type tells us how to interpret the payload\n *\n * Example PTR Record:\n * Header: [0x20, 0x00, 0x15, 0x10] = length=32, type=0x15, subtype=0x10\n * Data:   [TEST_NUM][HEAD_NUM][SITE_NUM][TEST_FLG][RESULT][TEST_TXT...]\n */\n\n/* RECORD TYPE DISPATCH PATTERN: */\n/* Production STDF parsers use switch-based dispatch:\n *\n * switch (header->rec_type) {\n *     case REC_PTR: return parse_ptr_record(data, length);\n *     case REC_MPR: return parse_mpr_record(data, length);\n *     default: return parse_unknown_record(data, length);\n * }\n *\n * This allows one parser to handle 30+ different record types!\n */\n\n/* STDF DATA TYPES (like libstdf): */\n/* U1 = uint8_t   (1 byte unsigned) */\n/* U2 = uint16_t  (2 byte unsigned) */\n/* U4 = uint32_t  (4 byte unsigned) */\n/* R4 = uint32_t  (4 byte data, stored as integer for kernel compatibility) */\n/* Cn = string    (1 byte length + n bytes data) */\n\n/* TODO: Implement STDF header parsing */\nstdf_header* parse_stdf_header(uint8_t **buffer_ptr) {\n    /* TODO: What do you need to store the parsed header data? */\n    /* TODO: How do you allocate memory in kernel space? */\n    /* TODO: STDF headers have 3 fields - what order should you read them? */\n    /* TODO: Look at the STDF specification - what's the first 2-byte field? */\n    /* TODO: What comes after rec_length in the header? */\n    /* TODO: Don't forget to return your populated structure */\n    return NULL;\n}\n\n/* TODO: Implement single byte reading */\nuint8_t read_uint8_from_buffer(uint8_t **buffer_ptr) {\n    /* TODO: Read 1 byte from buffer as uint8_t */\n    /* TODO: Cast *buffer_ptr to uint8_t* and dereference: *(*buffer_ptr) */\n    /* TODO: Advance *buffer_ptr by 1 byte: *buffer_ptr += 1 */\n    /* TODO: Return the uint8_t value */\n    return 0;\n}\n\n/* TODO: Implement 4-byte reading */\nuint32_t read_uint32_from_buffer(uint8_t **buffer_ptr) {\n    /* TODO: Read 4 bytes from buffer as uint32_t */\n    /* TODO: Cast *buffer_ptr to uint32_t* and dereference: *(uint32_t*)(*buffer_ptr) */\n    /* TODO: Advance *buffer_ptr by 4 bytes: *buffer_ptr += 4 */\n    /* TODO: Return the uint32_t value */\n    return 0;\n}\n\n/* TODO: Implement 2-byte reading */\nuint16_t read_uint16_from_buffer(uint8_t **buffer_ptr) {\n    /* TODO: Read 2 bytes from buffer as uint16_t */\n    /* TODO: Cast *buffer_ptr to uint16_t* and dereference: *(uint16_t*)(*buffer_ptr) */\n    /* TODO: Advance *buffer_ptr by 2 bytes: *buffer_ptr += 2 */\n    /* TODO: Return the uint16_t value */\n    return 0;\n}\n\n/* TODO: Implement STDF string reading (Cn type) */\nchar* read_string_from_buffer(uint8_t **buffer_ptr, uint8_t *out_length) {\n    /* TODO: Read first byte as string length using read_uint8_from_buffer */\n    /* TODO: Allocate memory for string using kmalloc(length + 1, GFP_KERNEL) */\n    /* TODO: Copy string data from buffer to allocated memory using memcpy */\n    /* TODO: Add null terminator to string */\n    /* TODO: Advance *buffer_ptr by length bytes: *buffer_ptr += length */\n    /* TODO: Store length in *out_length */\n    /* TODO: Return pointer to allocated string */\n    return NULL;\n}\n\n/* TODO: Implement PTR record parsing */\nptr_record* parse_ptr_record(uint8_t *data, uint16_t length) {\n    /* TODO: Allocate memory for ptr_record using kmalloc */\n    /* TODO: Create buffer position pointer: uint8_t *buffer_pos = data */\n    /* TODO: Parse TEST_NUM using read_uint32_from_buffer */\n    /* TODO: Parse HEAD_NUM using read_uint8_from_buffer */\n    /* TODO: Parse SITE_NUM using read_uint8_from_buffer */\n    /* TODO: Parse TEST_FLG using read_uint8_from_buffer */\n    /* TODO: Parse PARM_FLG using read_uint8_from_buffer */\n    /* TODO: Parse RESULT using read_uint32_from_buffer */\n    /* TODO: Parse TEST_TXT using read_string_from_buffer */\n    /* TODO: Copy string to record->TEST_TXT (max MAX_NAME_LEN-1 chars) */\n    /* TODO: Free temporary string */\n    /* TODO: Parse ALARM_ID using read_string_from_buffer */\n    /* TODO: Copy string to record->ALARM_ID (max MAX_NAME_LEN-1 chars) */\n    /* TODO: Free temporary string */\n    /* TODO: Return populated ptr_record */\n    return NULL;\n}\n\n/* TODO: Implement MPR record parsing */\nmpr_record* parse_mpr_record(uint8_t *data, uint16_t length) {\n    /* TODO: Allocate memory for mpr_record using kmalloc */\n    /* TODO: Create buffer position pointer: uint8_t *buffer_pos = data */\n    /* TODO: Parse TEST_NUM using read_uint32_from_buffer */\n    /* TODO: Parse HEAD_NUM using read_uint8_from_buffer */\n    /* TODO: Parse SITE_NUM using read_uint8_from_buffer */\n    /* TODO: Parse TEST_FLG using read_uint8_from_buffer */\n    /* TODO: Parse PARM_FLG using read_uint8_from_buffer */\n    /* TODO: Parse RTN_ICNT using read_uint16_from_buffer */\n    /* TODO: Loop through RTN_ICNT results, parsing each with read_uint32_from_buffer */\n    /* TODO: Store results in RTN_RSLT array (max MAX_RESULTS) */\n    /* TODO: Return populated mpr_record */\n    return NULL;\n}\n\n/* TODO: Implement main STDF record parser with dispatch */\nstdf_record* parse_stdf_record_from_buffer(uint8_t *raw_buffer) {\n    /* TODO: Allocate memory for stdf_record using kmalloc */\n    /* TODO: Create buffer position pointer: uint8_t *buffer_pos = raw_buffer */\n    /* TODO: Parse header using parse_stdf_header(&buffer_pos) */\n    /* TODO: Copy header to record->header */\n    /* TODO: Set record->data to point to buffer_pos (payload after header) */\n    /* TODO: Dispatch based on record type using switch statement: */\n    /* TODO:   case REC_PTR: parse PTR record from record->data */\n    /* TODO:   case REC_MPR: parse MPR record from record->data */\n    /* TODO:   default: handle unknown record type */\n    /* TODO: Return populated stdf_record */\n    return NULL;\n}\n\nvoid print_stdf_record(stdf_record *record) {\n    if (!record) {\n        printk(KERN_ERR \"No STDF record to print\\n\");\n        return;\n    }\n    \n    printk(KERN_INFO \"STDF Record Header:\\n\");\n    printk(KERN_INFO \"Record Length: %u\\n\", record->header.rec_length);\n    printk(KERN_INFO \"Record Type: 0x%02x\\n\", record->header.rec_type);\n    printk(KERN_INFO \"Record Subtype: 0x%02x\\n\", record->header.rec_subtype);\n    \n    switch (record->header.rec_type) {\n        case REC_PTR: {\n            ptr_record *ptr = (ptr_record*)record->data;\n            if (ptr) {\n                printk(KERN_INFO \"PTR Record Fields:\\n\");\n                printk(KERN_INFO \"TEST_NUM: %u\\n\", ptr->TEST_NUM);\n                printk(KERN_INFO \"HEAD_NUM: %u\\n\", ptr->HEAD_NUM);\n                printk(KERN_INFO \"SITE_NUM: %u\\n\", ptr->SITE_NUM);\n                printk(KERN_INFO \"TEST_FLG: 0x%02x\\n\", ptr->TEST_FLG);\n                printk(KERN_INFO \"RESULT: %u\\n\", ptr->RESULT);\n                printk(KERN_INFO \"TEST_TXT: %s\\n\", ptr->TEST_TXT);\n            }\n            break;\n        }\n        case REC_MPR: {\n            mpr_record *mpr = (mpr_record*)record->data;\n            if (mpr) {\n                printk(KERN_INFO \"MPR Record Fields:\\n\");\n                printk(KERN_INFO \"TEST_NUM: %u\\n\", mpr->TEST_NUM);\n                printk(KERN_INFO \"HEAD_NUM: %u\\n\", mpr->HEAD_NUM);\n                printk(KERN_INFO \"SITE_NUM: %u\\n\", mpr->SITE_NUM);\n                printk(KERN_INFO \"RTN_ICNT: %u\\n\", mpr->RTN_ICNT);\n                for (int i = 0; i < mpr->RTN_ICNT && i < MAX_RESULTS; i++) {\n                    printk(KERN_INFO \"RTN_RSLT[%d]: %u\\n\", i, mpr->RTN_RSLT[i]);\n                }\n            }\n            break;\n        }\n        default:\n            printk(KERN_INFO \"Unknown record type: 0x%02x\\n\", record->header.rec_type);\n            break;\n    }\n}\n\n/* REAL STDF FILE BUFFER: Authentic multi-record STDF data like production .stdf files */\n/* This is EXACTLY what you'd find in a real semiconductor test file! */\n/* Students must parse multiple records sequentially like libstdf does */\n\n/* \n * PRODUCTION STDF FILE STRUCTURE:\n * Real STDF files contain multiple consecutive records that must be parsed sequentially.\n * This buffer simulates a section of a real .stdf file with multiple record types.\n * \n * Layout: [PTR Record][MPR Record][PTR Record] = 89 bytes total\n * This teaches the EXACT pattern used in production semiconductor test systems!\n */\nstatic uint8_t real_stdf_file_buffer[] = {\n    /* ============ RECORD 1: PTR (Parametric Test Record) - 30 bytes ============ */\n    /* STDF Header (4 bytes) */\n    0x1A, 0x00,           /* REC_LEN = 26 bytes payload (little-endian) */\n    0x15,                 /* REC_TYP = 21 (PTR record type) */\n    0x10,                 /* REC_SUB = 16 (PTR subtype) */\n\n    /* PTR Record Payload (26 bytes) - Real STDF field layout */\n    0xE9, 0x03, 0x00, 0x00,  /* TEST_NUM = 1001 (U4, little-endian) */\n    0x01,                     /* HEAD_NUM = 1 (U1) */\n    0x01,                     /* SITE_NUM = 1 (U1) */\n    0x00,                     /* TEST_FLG = 0 (B1) - No test flags set */\n    0x00,                     /* PARM_FLG = 0 (B1) - No optional parameters */\n    0xFF, 0x00, 0x00, 0x00,  /* RESULT = 255 (U4, stored as integer for kernel) */\n\n    /* TEST_TXT field (Cn = length + string) - Real STDF Cn format */\n    0x0C,                     /* String length = 12 */\n    'V', 'o', 'l', 't', 'a', 'g', 'e', '_', 'T', 'e', 's', 't',  /* \"Voltage_Test\" */\n\n    /* ALARM_ID field (Cn format) - Empty in this test */\n    0x00,                     /* String length = 0 (no alarm) */\n\n    /* ============ RECORD 2: MPR (Multiple-Result Parametric) - 26 bytes ============ */\n    /* STDF Header (4 bytes) */\n    0x16, 0x00,           /* REC_LEN = 22 bytes payload (little-endian) */\n    0x16,                 /* REC_TYP = 22 (MPR record type) */\n    0x10,                 /* REC_SUB = 16 (MPR subtype) */\n\n    /* MPR Record Payload (22 bytes) - Real STDF field layout */\n    0xEA, 0x03, 0x00, 0x00,  /* TEST_NUM = 1002 (U4, little-endian) */\n    0x01,                     /* HEAD_NUM = 1 (U1) */\n    0x01,                     /* SITE_NUM = 1 (U1) */\n    0x00,                     /* TEST_FLG = 0 (B1) */\n    0x00,                     /* PARM_FLG = 0 (B1) */\n    0x03, 0x00,              /* RTN_ICNT = 3 (U2, little-endian) - 3 results */\n\n    /* RTN_RSLT array (3 results, each U4) */\n    0x64, 0x00, 0x00, 0x00,  /* RTN_RSLT[0] = 100 (U4) */\n    0x65, 0x00, 0x00, 0x00,  /* RTN_RSLT[1] = 101 (U4) */\n    0x66, 0x00, 0x00, 0x00,  /* RTN_RSLT[2] = 102 (U4) */\n\n    /* ============ RECORD 3: Another PTR (Parametric Test Record) - 31 bytes ============ */\n    /* STDF Header (4 bytes) */\n    0x1B, 0x00,           /* REC_LEN = 27 bytes payload (little-endian) */\n    0x15,                 /* REC_TYP = 21 (PTR record type) */\n    0x10,                 /* REC_SUB = 16 (PTR subtype) */\n\n    /* PTR Record Payload (27 bytes) - Real STDF field layout */\n    0xEB, 0x03, 0x00, 0x00,  /* TEST_NUM = 1003 (U4, little-endian) */\n    0x01,                     /* HEAD_NUM = 1 (U1) */\n    0x01,                     /* SITE_NUM = 1 (U1) */\n    0x00,                     /* TEST_FLG = 0 (B1) - No test flags set */\n    0x00,                     /* PARM_FLG = 0 (B1) - No optional parameters */\n    0x00, 0x01, 0x00, 0x00,  /* RESULT = 256 (U4, stored as integer for kernel) */\n\n    /* TEST_TXT field (Cn = length + string) - Real STDF Cn format */\n    0x0D,                     /* String length = 13 */\n    'C', 'u', 'r', 'r', 'e', 'n', 't', '_', 'T', 'e', 's', 't', '2',  /* \"Current_Test2\" */\n\n    /* ALARM_ID field (Cn format) - Empty in this test */\n    0x00,                     /* String length = 0 (no alarm) */\n\n    /* End of multi-record STDF buffer - total 89 bytes (30+26+31) */\n    /* This simulates real .stdf file content that needs sequential processing! */\n};\n\n/* TODO: Implement PRODUCTION STDF multi-record parser */\n/* This is the CORE function that students must implement - it teaches the */\n/* EXACT same pattern used in real libstdf and semiconductor test systems! */\nint parse_stdf_file_buffer(uint8_t *buffer, size_t total_size) {\n    /* TODO: What variables do you need to track your position in the buffer? */\n    /* TODO: How do you know when you've reached the end of the buffer? */\n    /* TODO: What counter should you keep for the number of records processed? */\n    \n    /* TODO: How would you loop through multiple records in a buffer? */\n    /* TODO: What condition should your loop check? */\n    /* TODO: How do you parse a single record at the current position? */\n    /* TODO: What should you do if parsing fails? */\n    /* TODO: How do you display the parsed record? */\n    /* TODO: CRITICAL: How do you move to the next record? (Think: header + payload) */\n    /* TODO: Don't forget to count each record and clean up memory! */\n    \n    /* TODO: What should this function return to indicate success? */\n    return 0;\n}\n\n/* Helper function to create real STDF multi-record buffer for testing */\nstatic uint8_t* get_real_stdf_file_buffer(uint32_t test_num, uint32_t result) {\n    uint8_t *pos;\n    \n    /* Use the complete multi-record STDF buffer */\n    buffer_size = sizeof(real_stdf_file_buffer);\n    test_buffer = kmalloc(buffer_size, GFP_KERNEL);\n    if (!test_buffer) {\n        return NULL;\n    }\n    \n    /* Copy the entire multi-record STDF file buffer */\n    memcpy(test_buffer, real_stdf_file_buffer, buffer_size);\n    \n    /* Update dynamic test values in FIRST PTR record (for validation) */\n    pos = test_buffer + 4;  /* Skip header to first PTR payload */\n    *(uint32_t*)pos = test_num;     /* Update TEST_NUM field */\n    pos += 4 + 1 + 1 + 1 + 1;      /* Skip to RESULT field */\n    *(uint32_t*)pos = result;       /* Update RESULT field */\n    \n    return test_buffer;\n}\n\nstatic int __init stdf_parser_init(void)\n{\n    int record_count;\n    \n    printk(KERN_INFO \"STDF parser module loaded\\n\");\n    \n    /* Get real STDF multi-record buffer with dynamic parameter values */\n    if (!get_real_stdf_file_buffer(test_num, (uint32_t)test_result)) {\n        printk(KERN_ERR \"Failed to create STDF test buffer\\n\");\n        return -ENOMEM;\n    }\n    \n    printk(KERN_INFO \"Created STDF buffer: type=0x%02x, test_num=%d, result=%d\\n\", \n           test_record_type, test_num, test_result);\n    \n    /* PRODUCTION LIBSTDF PATTERN: Parse multiple records sequentially */\n    /* This is EXACTLY how real semiconductor test systems process STDF files! */\n    record_count = parse_stdf_file_buffer(test_buffer, buffer_size);\n    \n    printk(KERN_INFO \"STDF file processing complete: %d records parsed\\n\", record_count);\n    \n    return 0;\n}\n\nstatic void __exit stdf_parser_exit(void)\n{\n    printk(KERN_INFO \"STDF parser module unloaded\\n\");\n    \n    /* Clean up allocated memory */\n    if (parsed_record) {\n        if (parsed_record->data) {\n            kfree(parsed_record->data);\n        }\n        kfree(parsed_record);\n        parsed_record = NULL;\n    }\n    \n    if (test_buffer) {\n        kfree(test_buffer);\n        test_buffer = NULL;\n    }\n}\n\nmodule_init(stdf_parser_init);\nmodule_exit(stdf_parser_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning STDF parsing with production header/data separation and record dispatch\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# STDF parser module Makefile\nobj-m += stdf_parser.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "stdf_parser.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "stdf_parser_init",
          "stdf_parser_exit",
          "parse_stdf_header",
          "read_uint8_from_buffer",
          "read_uint32_from_buffer",
          "read_uint16_from_buffer",
          "read_string_from_buffer",
          "parse_ptr_record",
          "parse_mpr_record",
          "parse_stdf_record_from_buffer",
          "parse_stdf_file_buffer",
          "print_stdf_record"
        ],
        "function_declarations": [
          {
            "name": "parse_stdf_header",
            "returnType": "stdf_header*",
            "parameters": [
              "uint8_t **buffer_ptr"
            ]
          },
          {
            "name": "read_uint8_from_buffer",
            "returnType": "uint8_t",
            "parameters": [
              "uint8_t **buffer_ptr"
            ]
          },
          {
            "name": "read_uint32_from_buffer",
            "returnType": "uint32_t",
            "parameters": [
              "uint8_t **buffer_ptr"
            ]
          },
          {
            "name": "read_uint16_from_buffer",
            "returnType": "uint16_t",
            "parameters": [
              "uint8_t **buffer_ptr"
            ]
          },
          {
            "name": "read_string_from_buffer",
            "returnType": "char*",
            "parameters": [
              "uint8_t **buffer_ptr",
              "uint8_t *out_length"
            ]
          },
          {
            "name": "parse_ptr_record",
            "returnType": "ptr_record*",
            "parameters": [
              "uint8_t *data",
              "uint16_t length"
            ]
          },
          {
            "name": "parse_mpr_record",
            "returnType": "mpr_record*",
            "parameters": [
              "uint8_t *data",
              "uint16_t length"
            ]
          },
          {
            "name": "parse_stdf_record_from_buffer",
            "returnType": "stdf_record*",
            "parameters": [
              "uint8_t *raw_buffer"
            ]
          },
          {
            "name": "parse_stdf_file_buffer",
            "returnType": "int",
            "parameters": [
              "uint8_t *buffer",
              "size_t total_size"
            ]
          },
          {
            "name": "print_stdf_record",
            "returnType": "void",
            "parameters": [
              "stdf_record *record"
            ]
          }
        ],
        "variables_declarations": [
          {
            "name": "stdf_header",
            "type": "typedef struct",
            "value": "{uint16_t rec_length; uint8_t rec_type; uint8_t rec_subtype;}",
            "storageClass": "none"
          },
          {
            "name": "stdf_record",
            "type": "typedef struct",
            "value": "{stdf_header header; void *data;}",
            "storageClass": "none"
          },
          {
            "name": "ptr_record",
            "type": "typedef struct",
            "value": "{uint32_t TEST_NUM; uint8_t HEAD_NUM; uint8_t SITE_NUM; uint8_t TEST_FLG; uint8_t PARM_FLG; uint32_t RESULT; char TEST_TXT[MAX_NAME_LEN]; char ALARM_ID[MAX_NAME_LEN];}",
            "storageClass": "none"
          },
          {
            "name": "mpr_record",
            "type": "typedef struct",
            "value": "{uint32_t TEST_NUM; uint8_t HEAD_NUM; uint8_t SITE_NUM; uint8_t TEST_FLG; uint8_t PARM_FLG; uint16_t RTN_ICNT; uint32_t RTN_RSLT[MAX_RESULTS];}",
            "storageClass": "none"
          },
          {
            "name": "parsed_record",
            "type": "stdf_record *",
            "storageClass": "extern"
          },
          {
            "name": "test_buffer",
            "type": "uint8_t *",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "parsed_record",
            "type": "stdf_record *",
            "value": "NULL",
            "storageClass": "none"
          },
          {
            "name": "test_buffer",
            "type": "uint8_t *",
            "value": "NULL",
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "STDF parser module loaded",
          "Created STDF buffer: type=0x15, test_num=1001, result=255",
          "STDF Record Header:",
          "Record Length: 26",
          "Record Type: 0x15",
          "Record Subtype: 0x10",
          "PTR Record Fields:",
          "TEST_NUM: 1001",
          "HEAD_NUM: 1",
          "SITE_NUM: 1",
          "TEST_FLG: 0x00",
          "RESULT: 255",
          "TEST_TXT: Voltage_Test",
          "STDF Record Header:",
          "Record Length: 22",
          "Record Type: 0x16",
          "Record Subtype: 0x10",
          "MPR Record Fields:",
          "TEST_NUM: 1002",
          "HEAD_NUM: 1",
          "SITE_NUM: 1",
          "RTN_ICNT: 3",
          "RTN_RSLT[0]: 100",
          "RTN_RSLT[1]: 101",
          "RTN_RSLT[2]: 102",
          "STDF Record Header:",
          "Record Length: 27",
          "Record Type: 0x15",
          "Record Subtype: 0x10",
          "PTR Record Fields:",
          "TEST_NUM: 1003",
          "HEAD_NUM: 1",
          "SITE_NUM: 1",
          "TEST_FLG: 0x00",
          "RESULT: 256",
          "TEST_TXT: Current_Test2",
          "STDF file processing complete: 3 records parsed",
          "STDF parser module unloaded"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h",
          "linux/slab.h",
          "linux/string.h"
        ],
        "mustContain": [
          "parse_stdf_header(&buffer_pos)",
          "read_uint8_from_buffer(&buffer_pos)",
          "*(uint32_t*)(*buffer_ptr)",
          "*buffer_ptr += 4",
          "*(uint16_t*)(*buffer_ptr)",
          "*buffer_ptr += 2",
          "switch (record->header.rec_type)",
          "case REC_PTR:",
          "case REC_MPR:",
          "record->data",
          "kmalloc",
          "kfree",
          "while (current_pos < buffer_end)",
          "current_pos += 4 + record->header.rec_length",
          "parse_stdf_file_buffer(test_buffer, buffer_size)",
          "module_param(test_record_type, int, 0644)",
          "module_param(test_num, int, 0644)",
          "module_param(test_result, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "stdf_header* parse_stdf_header(uint8_t **buffer_ptr)",
            "uint8_t read_uint8_from_buffer(uint8_t **buffer_ptr)",
            "uint32_t read_uint32_from_buffer(uint8_t **buffer_ptr)",
            "uint16_t read_uint16_from_buffer(uint8_t **buffer_ptr)",
            "char* read_string_from_buffer(uint8_t **buffer_ptr, uint8_t *out_length)",
            "ptr_record* parse_ptr_record(uint8_t *data, uint16_t length)",
            "mpr_record* parse_mpr_record(uint8_t *data, uint16_t length)",
            "stdf_record* parse_stdf_record_from_buffer(uint8_t *raw_buffer)",
            "int parse_stdf_file_buffer(uint8_t *buffer, size_t total_size)",
            "void print_stdf_record(stdf_record *record)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "stdf_header* parse_stdf_header(uint8_t **buffer_ptr)",
            "uint8_t read_uint8_from_buffer(uint8_t **buffer_ptr)",
            "uint32_t read_uint32_from_buffer(uint8_t **buffer_ptr)",
            "uint16_t read_uint16_from_buffer(uint8_t **buffer_ptr)",
            "char* read_string_from_buffer(uint8_t **buffer_ptr, uint8_t *out_length)",
            "ptr_record* parse_ptr_record(uint8_t *data, uint16_t length)",
            "mpr_record* parse_mpr_record(uint8_t *data, uint16_t length)",
            "stdf_record* parse_stdf_record_from_buffer(uint8_t *raw_buffer)",
            "int parse_stdf_file_buffer(uint8_t *buffer, size_t total_size)",
            "void print_stdf_record(stdf_record *record)",
            "static int __init stdf_parser_init(void)",
            "static void __exit stdf_parser_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "STDF parser module loaded",
              "exact": true,
              "linkedFunction": "static int __init stdf_parser_init(void)"
            },
            {
              "pattern": "Created STDF buffer: type=0x15, test_num=1001, result=255",
              "exact": true,
              "linkedFunction": "static int __init stdf_parser_init(void)"
            },
            {
              "pattern": "STDF Record Header:",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "Record Length: 26",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "Record Type: 0x15",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "Record Subtype: 0x10",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "PTR Record Fields:",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "TEST_NUM: 1001",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "HEAD_NUM: 1",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "SITE_NUM: 1",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "TEST_FLG: 0x00",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "RESULT: 255",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "TEST_TXT: Voltage_Test",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "STDF Record Header:",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "Record Length: 22",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "Record Type: 0x16",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "Record Subtype: 0x10",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "MPR Record Fields:",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "TEST_NUM: 1002",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "HEAD_NUM: 1",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "SITE_NUM: 1",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "RTN_ICNT: 3",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "RTN_RSLT[0]: 100",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "RTN_RSLT[1]: 101",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "RTN_RSLT[2]: 102",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "STDF Record Header:",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "Record Length: 27",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "Record Type: 0x15",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "Record Subtype: 0x10",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "PTR Record Fields:",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "TEST_NUM: 1003",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "HEAD_NUM: 1",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "SITE_NUM: 1",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "TEST_FLG: 0x00",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "RESULT: 256",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "TEST_TXT: Current_Test2",
              "exact": true,
              "linkedFunction": "void print_stdf_record(stdf_record *record)"
            },
            {
              "pattern": "STDF file processing complete: 3 records parsed",
              "exact": true,
              "linkedFunction": "static int __init stdf_parser_init(void)"
            },
            {
              "pattern": "STDF parser module unloaded",
              "exact": true,
              "linkedFunction": "static void __exit stdf_parser_exit(void)"
            }
          ]
        },
        {
          "id": "advanced_stdf_parsing_validation",
          "name": "Advanced STDF Parsing with Anti-Hardcoding Protection",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "stdf_parsing_dynamic_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Anti-Hardcoding STDF Parsing Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate unpredictable test values\\n    int random_record_type = (rand() % 2) ? 0x15 : 0x16;  // PTR or MPR\\n    int random_test_num = (rand() % 9000) + 1000;         // 1000-9999\\n    int random_result = (rand() % 500) + 100;             // 100-599\\n    \\n    printf(\\\"Test 1: Random STDF parsing (type=0x%02x, test_num=%d, result=%d)\\\\n\\\", random_record_type, random_test_num, random_result);\\n    \\n    // Test with random values\\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod stdf_parser 2>/dev/null\\\");\\n    \\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/stdf_parser.ko test_record_type=%d test_num=%d test_result=%d\\\", random_record_type, random_test_num, random_result);\\n    printf(\\\"DEBUG: Command: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Anti-hardcoding STDF parsing test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced STDF parsing implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef unsigned char uint8_t;' > /tmp/linux/types.h",
              "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
              "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
              "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
              "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
              "echo '#define MAX_RESULTS 8' >> /tmp/linux/types.h",
              "echo '#define REC_PTR 0x15' >> /tmp/linux/types.h",
              "echo '#define REC_MPR 0x16' >> /tmp/linux/types.h",
              "echo 'void* kmalloc(size_t size, int flags);' > /tmp/linux/slab.h",
              "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
              "echo '#define GFP_KERNEL 0' >> /tmp/linux/slab.h",
              "echo 'void* memcpy(void *dest, const void *src, size_t n);' >> /tmp/linux/slab.h",
              "echo 'size_t strlen(const char *s);' >> /tmp/linux/slab.h",
              "echo 'void* memcpy(void *dest, const void *src, size_t n);' > /tmp/linux/string.h",
              "echo 'size_t strlen(const char *s);' >> /tmp/linux/string.h",
              "echo 'char* strcpy(char *dest, const char *src);' >> /tmp/linux/string.h",
              "echo 'Creating test file that includes STDF parsing header...'",
              "echo '#include \"/lib/modules/stdf_parser.h\"' > /tmp/test.c",
              "echo 'int main() { uint8_t *buf; uint8_t len; size_t size = 89; parsed_record = (stdf_record*)0; parse_stdf_header(&buf); read_uint8_from_buffer(&buf); read_uint32_from_buffer(&buf); read_uint16_from_buffer(&buf); read_string_from_buffer(&buf, &len); parse_ptr_record(buf, 26); parse_mpr_record(buf, 22); parse_stdf_record_from_buffer(buf); parse_stdf_file_buffer(buf, size); print_stdf_record((stdf_record*)0); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
              "echo 'Phase 2: Anti-Hardcoding Dynamic STDF Parsing Test'",
              "/bin/stdf_parsing_dynamic_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Random Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "RECORD_TYPE=$(grep -o 'Random STDF parsing (type=0x[0-9a-f]*' /tmp/test_output.log | cut -d'=' -f2)",
              "TEST_NUM=$(grep -o 'test_num=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
              "RESULT=$(grep -o 'result=[0-9]*)' /tmp/test_output.log | cut -d'=' -f2 | cut -d')' -f1)",
              "echo 'Extracted values: RECORD_TYPE='$RECORD_TYPE', TEST_NUM='$TEST_NUM', RESULT='$RESULT",
              "if [ -z \"$RECORD_TYPE\" ] || [ -z \"$TEST_NUM\" ] || [ -z \"$RESULT\" ]; then echo 'FAIL: Could not extract random test values'; else echo 'PASS: Random values extracted successfully'; fi",
              "echo 'Phase 4: Anti-Hardcoding Validation with Random Values'",
              "echo 'Validating STDF record type parsing with random value '$RECORD_TYPE",
              "dmesg | grep \"Record Type: $RECORD_TYPE\" && echo 'PASS: STDF record type parsing with random value working' || echo 'FAIL: STDF record type parsing with random value broken'",
              "echo 'Validating TEST_NUM parsing with random value '$TEST_NUM",
              "dmesg | grep \"TEST_NUM: $TEST_NUM\" && echo 'PASS: TEST_NUM parsing with random value working' || echo 'FAIL: TEST_NUM parsing with random value broken'",
              "echo 'Validating RESULT parsing with random value '$RESULT",
              "dmesg | grep \"RESULT: $RESULT\" && echo 'PASS: RESULT parsing with random value working' || echo 'FAIL: RESULT parsing with random value broken'",
              "echo 'Phase 5: Static Field Validation (Non-Randomized Fields)'",
              "dmesg | grep 'STDF Record Header:' && echo 'PASS: STDF header parsing working' || echo 'FAIL: STDF header parsing broken'",
              "dmesg | grep 'HEAD_NUM: 1' && echo 'PASS: HEAD_NUM parsing working' || echo 'FAIL: HEAD_NUM parsing broken'",
              "dmesg | grep 'SITE_NUM: 1' && echo 'PASS: SITE_NUM parsing working' || echo 'FAIL: SITE_NUM parsing broken'",
              "echo 'Phase 6: STDF Architecture Validation'",
              "dmesg | grep 'PTR Record Fields:' && echo 'PASS: PTR record dispatch working' || echo 'FAIL: PTR record dispatch broken'",
              "dmesg | grep 'MPR Record Fields:' && echo 'PASS: MPR record dispatch working' || echo 'FAIL: MPR record dispatch broken'",
              "dmesg | grep 'RTN_ICNT: 3' && echo 'PASS: MPR array count parsing working' || echo 'FAIL: MPR array count parsing broken'",
              "dmesg | grep 'RTN_RSLT\\[0\\]: 100' && echo 'PASS: MPR array element parsing working' || echo 'FAIL: MPR array element parsing broken'",
              "dmesg | grep 'STDF file processing complete: 3 records parsed' && echo 'PASS: Multi-record processing working' || echo 'FAIL: Multi-record processing broken'",
              "dmesg | grep 'STDF parser module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
              "dmesg | grep 'STDF parser module unloaded' && echo 'PASS: Module cleanup working' || echo 'FAIL: Module cleanup broken'",
              "echo 'Phase 7: Final Validation Summary'",
              "echo 'All phases completed successfully - anti-hardcoding STDF parsing protection verified'",
              "echo 'PASS: All anti-hardcoding STDF parsing validation successful'"
            ],
            "expected": {
              "dmesg": [
                "STDF parser module loaded",
                "Created STDF buffer: type=.*, test_num=.*, result=.*",
                "STDF Record Header:",
                "Record Length: .*",
                "Record Type: .*",
                "Record Subtype: .*",
                "PTR Record Fields:",
                "TEST_NUM: .*",
                "HEAD_NUM: .*",
                "SITE_NUM: .*",
                "TEST_FLG: .*",
                "RESULT: .*",
                "TEST_TXT: .*",
                "MPR Record Fields:",
                "RTN_ICNT: .*",
                "RTN_RSLT\\[.*\\]: .*",
                "STDF file processing complete: .* records parsed",
                "STDF parser module unloaded"
              ],
              "stdout": [
                "PASS: All function and variable declarations found in header file",
                "SUCCESS: Anti-hardcoding STDF parsing test completed",
                "PASS: Random values extracted successfully",
                "PASS: STDF record type parsing with random value working",
                "PASS: TEST_NUM parsing with random value working",
                "PASS: RESULT parsing with random value working",
                "PASS: STDF header parsing working",
                "PASS: HEAD_NUM parsing working",
                "PASS: SITE_NUM parsing working",
                "PASS: PTR record dispatch working",
                "PASS: MPR record dispatch working",
                "PASS: MPR array count parsing working",
                "PASS: MPR array element parsing working",
                "PASS: Multi-record processing working",
                "PASS: Module initialization working",
                "PASS: Module cleanup working",
                "PASS: All anti-hardcoding STDF parsing validation successful"
              ]
            },
            "timeout": 15
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "STDF parser module loaded",
        "Created STDF buffer: type=0x15, test_num=1001, result=255",
        "STDF Record Header:",
        "Record Length: 26",
        "Record Type: 0x15",
        "Record Subtype: 0x10",
        "PTR Record Fields:",
        "TEST_NUM: 1001",
        "HEAD_NUM: 1",
        "SITE_NUM: 1",
        "TEST_FLG: 0x00",
        "RESULT: 255",
        "TEST_TXT: Voltage_Test",
        "STDF Record Header:",
        "Record Length: 22",
        "Record Type: 0x16",
        "Record Subtype: 0x10",
        "MPR Record Fields:",
        "TEST_NUM: 1002",
        "HEAD_NUM: 1",
        "SITE_NUM: 1",
        "RTN_ICNT: 3",
        "RTN_RSLT[0]: 100",
        "RTN_RSLT[1]: 101",
        "RTN_RSLT[2]: 102",
        "STDF Record Header:",
        "Record Length: 27",
        "Record Type: 0x15",
        "Record Subtype: 0x10",
        "PTR Record Fields:",
        "TEST_NUM: 1003",
        "HEAD_NUM: 1",
        "SITE_NUM: 1",
        "TEST_FLG: 0x00",
        "RESULT: 256",
        "TEST_TXT: Current_Test2",
        "STDF file processing complete: 3 records parsed",
        "STDF parser module unloaded"
      ],
      "requirements": [
        "Use required function names: stdf_parser_init, stdf_parser_exit, parse_stdf_header, read_uint8_from_buffer, read_uint32_from_buffer, read_uint16_from_buffer, read_string_from_buffer, parse_ptr_record, parse_mpr_record, parse_stdf_record_from_buffer, parse_stdf_file_buffer, print_stdf_record",
        "Use required variable names: parsed_record, test_buffer",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h, linux/slab.h, linux/string.h",
        "Code must contain: parse_stdf_header(&buffer_pos), read_uint8_from_buffer(&buffer_pos), *(uint32_t*)(*buffer_ptr), *buffer_ptr += 4, *(uint16_t*)(*buffer_ptr), *buffer_ptr += 2, switch (record->header.rec_type), case REC_PTR:, case REC_MPR:, record->data, kmalloc, kfree, while (current_pos < buffer_end), current_pos += 4 + record->header.rec_length, parse_stdf_file_buffer(test_buffer, buffer_size), module_param(test_record_type, int, 0644), module_param(test_num, int, 0644), module_param(test_result, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "STDF parser module loaded",
          "linkedFunction": "static int __init stdf_parser_init(void)",
          "exact": true
        },
        {
          "pattern": "Created STDF buffer: type=0x15, test_num=1001, result=255",
          "linkedFunction": "static int __init stdf_parser_init(void)",
          "exact": true
        },
        {
          "pattern": "STDF Record Header:",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "Record Length: 26",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "Record Type: 0x15",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "Record Subtype: 0x10",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "PTR Record Fields:",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "TEST_NUM: 1001",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "HEAD_NUM: 1",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "SITE_NUM: 1",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "TEST_FLG: 0x00",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "RESULT: 255",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "TEST_TXT: Voltage_Test",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "STDF Record Header:",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "Record Length: 22",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "Record Type: 0x16",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "Record Subtype: 0x10",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "MPR Record Fields:",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "TEST_NUM: 1002",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "HEAD_NUM: 1",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "SITE_NUM: 1",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "RTN_ICNT: 3",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "RTN_RSLT[0]: 100",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "RTN_RSLT[1]: 101",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "RTN_RSLT[2]: 102",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "STDF Record Header:",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "Record Length: 27",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "Record Type: 0x15",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "Record Subtype: 0x10",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "PTR Record Fields:",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "TEST_NUM: 1003",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "HEAD_NUM: 1",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "SITE_NUM: 1",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "TEST_FLG: 0x00",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "RESULT: 256",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "TEST_TXT: Current_Test2",
          "linkedFunction": "void print_stdf_record(stdf_record *record)",
          "exact": true
        },
        {
          "pattern": "STDF file processing complete: 3 records parsed",
          "linkedFunction": "static int __init stdf_parser_init(void)",
          "exact": true
        },
        {
          "pattern": "STDF parser module unloaded",
          "linkedFunction": "static void __exit stdf_parser_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 24,
    "title": "Preprocessor Macros - Kernel-Style Code Generation",
    "difficulty": 5,
    "xp": 55,
    "phase": "foundations",
    "description": "Master essential preprocessor macros for kernel development. Learn #define constants, bit flag macros, function-like macros, and conditional compilation patterns used throughout Linux kernel code.",
    "concepts": [
      "preprocessor directives",
      "simple constant macros",
      "bit manipulation macros",
      "function-like macros",
      "conditional compilation",
      "kernel macro conventions"
    ],
    "skills": [
      "Defining constant macros for magic numbers",
      "Creating bit flag macros for status registers",
      "Writing function-like macros",
      "Using conditional compilation for debug code",
      "Understanding macro parameter safety",
      "Applying kernel-style macro patterns"
    ],
    "files": [
      {
        "name": "macro_processor.h",
        "content": "#ifndef MACRO_PROCESSOR_H\n#define MACRO_PROCESSOR_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* TODO: Define device type constants */\n/* Define DEVICE_TYPE_SENSOR with value 1 */\n/* Define DEVICE_TYPE_MOTOR with value 2 */\n\n/* TODO: Define status flag constants using bit shifts */\n/* Define STATUS_ONLINE using (1 << 0) */\n/* Define STATUS_READY using (1 << 1) */\n\n/* TODO: Define configuration constants */\n/* Define MAX_DEVICE_NAME with value 32 */\n\n/* TODO: Define function-like macros */\n/* Create macro MAKE_VERSION(major, minor) that combines major and minor into single value */\n/* IMPORTANT: Wrap parameters in parentheses for safety! */\n/* Formula: (((major) << 16) | (minor)) */\n/* This prevents issues when called with expressions like MAKE_VERSION(1+1, 2+2) */\n\n/* TODO: Define conditional compilation macros */\n/* Create macro DEBUG_PRINT(fmt, ...) that prints debug messages */\n/* When DEBUG_MODE is defined: printk(KERN_DEBUG fmt, ##__VA_ARGS__) */\n/* When DEBUG_MODE is not defined: empty (no operation) */\n\n/* Device structure for testing */\ntypedef struct {\n    uint8_t device_type;\n    uint8_t status_flags;\n    uint32_t version;\n    char name[MAX_DEVICE_NAME];\n} device_info;\n\n/* Global test device */\nextern device_info test_device;\n\n/* TODO: Declare your macro testing functions */\n/* void test_macro_constants(void); */\n/* void test_version_and_flags(void); */\n/* void test_conditional_compilation(void); */\n/* void print_device_info(device_info *device); */\n\n#endif /* MACRO_PROCESSOR_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "macro_processor.c",
        "content": "#include \"macro_processor.h\"\n\n/* Enable debug mode for conditional compilation testing */\n#define DEBUG_MODE\n\n/* Global test device */\ndevice_info test_device = {\n    .device_type = DEVICE_TYPE_SENSOR,\n    .status_flags = 0,\n    .version = 0,\n    .name = \"Temperature Sensor\"\n};\n\nint test_device_type = DEVICE_TYPE_SENSOR;\nint test_major_version = 2;\nint test_minor_version = 4;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your macro logic works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(test_device_type, int, 0644);\nMODULE_PARM_DESC(test_device_type, \"Device type for testing macro validation\");\nmodule_param(test_major_version, int, 0644);\nMODULE_PARM_DESC(test_major_version, \"Major version for testing version macros\");\nmodule_param(test_minor_version, int, 0644);\nMODULE_PARM_DESC(test_minor_version, \"Minor version for testing version macros\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: How preprocessor macros work in kernel development */\n/* This teaches the FOUNDATION for kernel programming:\n *\n * Macro Types in Kernel Development:\n * 1. Simple Constants: #define MAX_SIZE 64\n * 2. Bit Flag Constants: #define FLAG_READY (1 << 0)\n * 3. Function-like Macros: #define MAX(a,b) ((a) > (b) ? (a) : (b))\n * 4. Conditional Compilation: #ifdef DEBUG ... #endif\n *\n * Why Macros are Essential in Kernel:\n * - Hardware register definitions use bit manipulation macros\n * - Kernel APIs heavily use function-like macros for efficiency\n * - Conditional compilation for different kernel configurations\n * - Version and feature detection macros\n */\n\n/* MACRO SAFETY PATTERNS: */\n\n/* Always wrap parameters in parentheses: */\n/* #define SQUARE(x) ((x) * (x))  // CORRECT */\n/* #define SQUARE(x) x * x        // WRONG - fails with SQUARE(a+b) */\n\n/* Always wrap entire macro in parentheses for complex expressions: */\n/* #define ADD(a,b) ((a) + (b))   // CORRECT */\n/* #define ADD(a,b) (a) + (b)     // WRONG - fails in expressions like 2 * ADD(3,4) */\n\n/* BAD EXAMPLE - What happens WITHOUT parentheses: */\n/* #define BAD_VERSION(maj, min) ((maj << 16) | min)  // UNSAFE! */\n/* BAD_VERSION(1+1, 2+2) expands to: ((1+1 << 16) | 2+2) */\n/* Due to operator precedence: ((1 + (1 << 16)) | 2) + 2 = WRONG RESULT! */\n/* Shift (<<) has higher precedence than addition (+) */\n\n/* GOOD EXAMPLE - With proper parentheses: */\n/* #define MAKE_VERSION(maj, min) (((maj) << 16) | (min))  // SAFE! */\n/* MAKE_VERSION(1+1, 2+2) expands to: (((1+1) << 16) | (2+2)) */\n/* Result: (((2) << 16) | (4)) = 0x00020004 = CORRECT! */\n\n/* Real kernel examples where this matters: */\n/* - PCI_DEVFN(slot, func) for device addressing */\n/* - KERNEL_VERSION(a,b,c) for version checking */\n/* - DIV_ROUND_UP(n,d) for size calculations */\n\n/* KERNEL MACRO EXAMPLES: */\n\n/* Module parameter declaration: */\n/* module_param(variable, type, permissions) */\n\n/* Kernel logging with levels: */\n/* printk(KERN_INFO \"message\") */\n\n/* Bit manipulation for hardware registers: */\n/* #define REG_ENABLE  (1 << 0) */\n/* #define REG_RESET   (1 << 1) */\n/* writel(REG_ENABLE | REG_RESET, device->base + CONTROL_REG) */\n\n/* TODO: Implement macro constants testing */\nvoid test_macro_constants(void) {\n    /* TODO: Test device type constants */\n    /* TODO: Print \"Testing macro constants:\" */\n    /* TODO: Print \"DEVICE_TYPE_SENSOR = %d\" with DEVICE_TYPE_SENSOR value */\n    /* TODO: Print \"DEVICE_TYPE_MOTOR = %d\" with DEVICE_TYPE_MOTOR value */\n    /* TODO: Print \"MAX_DEVICE_NAME = %d\" with MAX_DEVICE_NAME value */\n}\n\n/* TODO: Implement version and flags testing */\nvoid test_version_and_flags(void) {\n    /* TODO: Test bit flags */\n    /* TODO: Print \"Testing bit flags and version:\" */\n    /* TODO: Print \"STATUS_ONLINE = 0x%02x\" with STATUS_ONLINE value */\n    /* TODO: Print \"STATUS_READY = 0x%02x\" with STATUS_READY value */\n    \n    /* TODO: Test version macro */\n    /* TODO: Create version using MAKE_VERSION macro with test_major_version and test_minor_version */\n    /* TODO: Store result in variable: uint32_t version = MAKE_VERSION(test_major_version, test_minor_version) */\n    /* TODO: Print \"Created version: 0x%08x\" with version */\n    \n    /* TODO: Test combined flags */\n    /* TODO: Create variable combined_flags = STATUS_ONLINE | STATUS_READY */\n    /* TODO: Print \"Combined flags: 0x%02x\" with combined_flags */\n}\n\n/* TODO: Implement conditional compilation testing */\nvoid test_conditional_compilation(void) {\n    /* TODO: Test conditional compilation macros */\n    /* TODO: Print \"Testing conditional compilation:\" */\n    \n    /* TODO: Use DEBUG_PRINT macro to print \"Debug message: device type %d\" and test_device_type */\n    \n    /* TODO: Test preprocessor conditions */\n    /* TODO: Use #ifdef DEBUG_MODE to conditionally print \"Debug mode is enabled\" */\n    /* TODO: Use #else to print \"Debug mode is disabled\" */\n    /* TODO: Close with #endif */\n}\n\nvoid print_device_info(device_info *device) {\n    if (!device) {\n        printk(KERN_ERR \"No device information available\\n\");\n        return;\n    }\n    \n    printk(KERN_INFO \"Device: %s (Type: %d, Version: 0x%08x)\\n\", \n           device->name, device->device_type, device->version);\n}\n\nstatic int __init macro_processor_init(void)\n{\n    printk(KERN_INFO \"Macro processor module loaded\\n\");\n    \n    /* Update test device with dynamic parameter values */\n    test_device.device_type = test_device_type;\n    test_device.version = MAKE_VERSION(test_major_version, test_minor_version);\n    test_device.status_flags = STATUS_ONLINE | STATUS_READY;\n    \n    /* Test all macro categories */\n    test_macro_constants();\n    test_version_and_flags();\n    test_conditional_compilation();\n    \n    /* Display device information */\n    print_device_info(&test_device);\n    \n    printk(KERN_INFO \"Macro demonstration completed\\n\");\n    \n    return 0;\n}\n\nstatic void __exit macro_processor_exit(void)\n{\n    printk(KERN_INFO \"Macro processor module unloaded\\n\");\n}\n\nmodule_init(macro_processor_init);\nmodule_exit(macro_processor_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning essential preprocessor macros for kernel development\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Macro processor module Makefile\nobj-m += macro_processor.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "macro_processor.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "macro_processor_init",
          "macro_processor_exit",
          "test_macro_constants",
          "test_version_and_flags",
          "test_conditional_compilation",
          "print_device_info"
        ],
        "macro_declarations": [
          {
            "name": "DEVICE_TYPE_SENSOR",
            "type": "constant",
            "value": "1",
            "description": "Device type constant for sensors"
          },
          {
            "name": "DEVICE_TYPE_MOTOR",
            "type": "constant",
            "value": "2",
            "description": "Device type constant for motors"
          },
          {
            "name": "STATUS_ONLINE",
            "type": "constant",
            "value": "(1 << 0)",
            "description": "Status bit flag for online state"
          },
          {
            "name": "STATUS_READY",
            "type": "constant",
            "value": "(1 << 1)",
            "description": "Status bit flag for ready state"
          },
          {
            "name": "MAX_DEVICE_NAME",
            "type": "constant",
            "value": "32",
            "description": "Maximum device name length"
          },
          {
            "name": "MAKE_VERSION",
            "type": "function-like",
            "parameters": [
              "major",
              "minor"
            ],
            "value": "(((major) << 16) | (minor))",
            "description": "Combine major and minor version into single value"
          },
          {
            "name": "DEBUG_MODE",
            "preprocessor": "#ifdef",
            "type": "constant",
            "value": "\n#define DEBUG_PRINT(fmt, ...) printk(KERN_DEBUG fmt, ##__VA_ARGS__)\n#else\n#define DEBUG_PRINT(fmt, ...)\n#endif",
            "description": "Conditional debug printing macro"
          }
        ],
        "macro_definitions": [
          {
            "name": "DEBUG_MODE",
            "type": "constant",
            "description": "Enable debug compilation mode"
          }
        ],
        "function_declarations": [
          {
            "name": "test_macro_constants",
            "returnType": "void",
            "parameters": [
              "void"
            ]
          },
          {
            "name": "test_version_and_flags",
            "returnType": "void",
            "parameters": [
              "void"
            ]
          },
          {
            "name": "test_conditional_compilation",
            "returnType": "void",
            "parameters": [
              "void"
            ]
          },
          {
            "name": "print_device_info",
            "returnType": "void",
            "parameters": [
              "device_info *device"
            ]
          }
        ],
        "variables_declarations": [
          {
            "name": "test_device",
            "type": "device_info",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "test_device",
            "type": "device_info",
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Macro processor module loaded",
          "Testing macro constants:",
          "DEVICE_TYPE_SENSOR = 1",
          "DEVICE_TYPE_MOTOR = 2",
          "MAX_DEVICE_NAME = 32",
          "Testing bit flags and version:",
          "STATUS_ONLINE = 0x01",
          "STATUS_READY = 0x02",
          "Created version:",
          "Combined flags: 0x03",
          "Testing conditional compilation:",
          "Debug mode is enabled",
          "Device: Temperature Sensor",
          "Macro demonstration completed",
          "Macro processor module unloaded"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "#define DEVICE_TYPE_SENSOR 1",
          "#define DEVICE_TYPE_MOTOR 2",
          "#define STATUS_ONLINE (1 << 0)",
          "#define STATUS_READY (1 << 1)",
          "#define MAX_DEVICE_NAME 32",
          "#define MAKE_VERSION(major, minor) (((major) << 16) | (minor))",
          "#ifdef DEBUG_MODE",
          "#define DEBUG_PRINT(fmt, ...) printk(KERN_DEBUG fmt, ##__VA_ARGS__)",
          "#else",
          "#define DEBUG_PRINT(fmt, ...)",
          "#endif",
          "MAKE_VERSION(test_major_version, test_minor_version)",
          "DEBUG_PRINT(",
          "STATUS_ONLINE | STATUS_READY",
          "module_param(test_device_type, int, 0644)",
          "module_param(test_major_version, int, 0644)",
          "module_param(test_minor_version, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void test_macro_constants(void)",
            "void test_version_and_flags(void)",
            "void test_conditional_compilation(void)",
            "void print_device_info(device_info *device)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "macro_definitions",
          "name": "Macro Definitions in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "#define DEVICE_TYPE_SENSOR 1",
            "#define DEVICE_TYPE_MOTOR 2",
            "#define STATUS_ONLINE (1 << 0)",
            "#define STATUS_READY (1 << 1)",
            "#define MAX_DEVICE_NAME 32",
            "#define MAKE_VERSION",
            "#define DEBUG_PRINT"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void test_macro_constants(void)",
            "void test_version_and_flags(void)",
            "void test_conditional_compilation(void)",
            "void print_device_info(device_info *device)",
            "static int __init macro_processor_init(void)",
            "static void __exit macro_processor_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Macro processor module loaded",
              "exact": true,
              "linkedFunction": "static int __init macro_processor_init(void)"
            },
            {
              "pattern": "Testing macro constants:",
              "exact": true,
              "linkedFunction": "void test_macro_constants(void)"
            },
            {
              "pattern": "DEVICE_TYPE_SENSOR = 1",
              "exact": true,
              "linkedFunction": "void test_macro_constants(void)"
            },
            {
              "pattern": "DEVICE_TYPE_MOTOR = 2",
              "exact": true,
              "linkedFunction": "void test_macro_constants(void)"
            },
            {
              "pattern": "MAX_DEVICE_NAME = 32",
              "exact": true,
              "linkedFunction": "void test_macro_constants(void)"
            },
            {
              "pattern": "Testing bit flags and version:",
              "exact": true,
              "linkedFunction": "void test_version_and_flags(void)"
            },
            {
              "pattern": "STATUS_ONLINE = 0x01",
              "exact": true,
              "linkedFunction": "void test_version_and_flags(void)"
            },
            {
              "pattern": "STATUS_READY = 0x02",
              "exact": true,
              "linkedFunction": "void test_version_and_flags(void)"
            },
            {
              "pattern": "Combined flags: 0x03",
              "exact": true,
              "linkedFunction": "void test_version_and_flags(void)"
            },
            {
              "pattern": "Testing conditional compilation:",
              "exact": true,
              "linkedFunction": "void test_conditional_compilation(void)"
            },
            {
              "pattern": "Debug mode is enabled",
              "exact": true,
              "linkedFunction": "void test_conditional_compilation(void)"
            },
            {
              "pattern": "Device: Temperature Sensor",
              "exact": true,
              "linkedFunction": "void print_device_info(device_info *device)"
            },
            {
              "pattern": "Macro demonstration completed",
              "exact": true,
              "linkedFunction": "static int __init macro_processor_init(void)"
            },
            {
              "pattern": "Macro processor module unloaded",
              "exact": true,
              "linkedFunction": "static void __exit macro_processor_exit(void)"
            }
          ]
        },
        {
          "id": "simplified_macro_validation",
          "name": "Simplified Macro Processing with Anti-Hardcoding Protection",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "macro_dynamic_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Macro Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate test values\\n    int random_device_type = ((rand() % 2) + 1);  // 1 or 2\\n    int random_major = (rand() % 5) + 1;          // 1-5\\n    int random_minor = (rand() % 10) + 1;         // 1-10\\n    \\n    printf(\\\"Random macro test (device=%d, ver=%d.%d)\\\\n\\\", random_device_type, random_major, random_minor);\\n    \\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod macro_processor 2>/dev/null\\\");\\n    \\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/macro_processor.ko test_device_type=%d test_major_version=%d test_minor_version=%d\\\", random_device_type, random_major, random_minor);\\n    printf(\\\"DEBUG: Command: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Macro test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting simplified macro validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: TCC Header Validation'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_DEBUG' >> /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef unsigned char uint8_t;' > /tmp/linux/types.h",
              "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
              "echo '#include \"/lib/modules/macro_processor.h\"' > /tmp/test.c",
              "echo 'int main() { device_info dev; test_macro_constants(); test_version_and_flags(); test_conditional_compilation(); print_device_info(&dev); return 0; }' >> /tmp/test.c",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or macro definition missing'; cat /tmp/tcc_error.log; else echo 'PASS: All declarations found in header'; fi",
              "echo 'Phase 2: Dynamic Macro Test'",
              "/bin/macro_dynamic_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Macro Validation'",
              "sleep 1",
              "dmesg | grep 'DEVICE_TYPE_SENSOR = 1' && echo 'PASS: Device constants working' || echo 'FAIL: Device constants broken'",
              "dmesg | grep 'STATUS_ONLINE = 0x01' && echo 'PASS: Bit flags working' || echo 'FAIL: Bit flags broken'",
              "dmesg | grep 'Combined flags: 0x03' && echo 'PASS: Flag combination working' || echo 'FAIL: Flag combination broken'",
              "dmesg | grep 'Debug mode is enabled' && echo 'PASS: Conditional compilation working' || echo 'FAIL: Conditional compilation broken'",
              "dmesg | grep 'Testing macro constants:' && echo 'PASS: Constant testing working' || echo 'FAIL: Constant testing broken'",
              "dmesg | grep 'Testing bit flags and version:' && echo 'PASS: Version testing working' || echo 'FAIL: Version testing broken'",
              "dmesg | grep 'Macro processor module loaded' && echo 'PASS: Module loading working' || echo 'FAIL: Module loading broken'",
              "echo 'PASS: All macro validation successful'"
            ],
            "expected": {
              "dmesg": [
                "Macro processor module loaded",
                "Testing macro constants:",
                "DEVICE_TYPE_SENSOR = 1",
                "DEVICE_TYPE_MOTOR = 2",
                "MAX_DEVICE_NAME = 32",
                "Testing bit flags and version:",
                "STATUS_ONLINE = 0x01",
                "STATUS_READY = 0x02",
                "Created version: .*",
                "Combined flags: 0x03",
                "Testing conditional compilation:",
                "Debug mode is enabled",
                "Device: Temperature Sensor",
                "Macro demonstration completed",
                "Macro processor module unloaded"
              ],
              "stdout": [
                "PASS: All declarations found in header",
                "SUCCESS: Macro test completed",
                "PASS: Device constants working",
                "PASS: Bit flags working",
                "PASS: Flag combination working",
                "PASS: Conditional compilation working",
                "PASS: Constant testing working",
                "PASS: Version testing working",
                "PASS: Module loading working",
                "PASS: All macro validation successful"
              ]
            },
            "timeout": 15
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Macro processor module loaded",
        "Testing macro constants:",
        "DEVICE_TYPE_SENSOR = 1",
        "DEVICE_TYPE_MOTOR = 2",
        "MAX_DEVICE_NAME = 32",
        "Testing bit flags and version:",
        "STATUS_ONLINE = 0x01",
        "STATUS_READY = 0x02",
        "Created version:",
        "Combined flags: 0x03",
        "Testing conditional compilation:",
        "Debug mode is enabled",
        "Device: Temperature Sensor",
        "Macro demonstration completed",
        "Macro processor module unloaded"
      ],
      "requirements": [
        "Use required function names: macro_processor_init, macro_processor_exit, test_macro_constants, test_version_and_flags, test_conditional_compilation, print_device_info",
        "Use required variable names: test_device",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: #define DEVICE_TYPE_SENSOR 1, #define DEVICE_TYPE_MOTOR 2, #define STATUS_ONLINE (1 << 0), #define STATUS_READY (1 << 1), #define MAX_DEVICE_NAME 32, #define MAKE_VERSION(major, minor) (((major) << 16) | (minor)), #ifdef DEBUG_MODE, #define DEBUG_PRINT(fmt, ...) printk(KERN_DEBUG fmt, ##__VA_ARGS__), #else, #define DEBUG_PRINT(fmt, ...), #endif, MAKE_VERSION(test_major_version, test_minor_version), DEBUG_PRINT(, STATUS_ONLINE | STATUS_READY, module_param(test_device_type, int, 0644), module_param(test_major_version, int, 0644), module_param(test_minor_version, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Macro processor module loaded",
          "linkedFunction": "static int __init macro_processor_init(void)",
          "exact": true
        },
        {
          "pattern": "Testing macro constants:",
          "linkedFunction": "void test_macro_constants(void)",
          "exact": true
        },
        {
          "pattern": "DEVICE_TYPE_SENSOR = 1",
          "linkedFunction": "void test_macro_constants(void)",
          "exact": true
        },
        {
          "pattern": "DEVICE_TYPE_MOTOR = 2",
          "linkedFunction": "void test_macro_constants(void)",
          "exact": true
        },
        {
          "pattern": "MAX_DEVICE_NAME = 32",
          "linkedFunction": "void test_macro_constants(void)",
          "exact": true
        },
        {
          "pattern": "Testing bit flags and version:",
          "linkedFunction": "void test_version_and_flags(void)",
          "exact": true
        },
        {
          "pattern": "STATUS_ONLINE = 0x01",
          "linkedFunction": "void test_version_and_flags(void)",
          "exact": true
        },
        {
          "pattern": "STATUS_READY = 0x02",
          "linkedFunction": "void test_version_and_flags(void)",
          "exact": true
        },
        {
          "pattern": "Combined flags: 0x03",
          "linkedFunction": "void test_version_and_flags(void)",
          "exact": true
        },
        {
          "pattern": "Testing conditional compilation:",
          "linkedFunction": "void test_conditional_compilation(void)",
          "exact": true
        },
        {
          "pattern": "Debug mode is enabled",
          "linkedFunction": "void test_conditional_compilation(void)",
          "exact": true
        },
        {
          "pattern": "Device: Temperature Sensor",
          "linkedFunction": "void print_device_info(device_info *device)",
          "exact": true
        },
        {
          "pattern": "Macro demonstration completed",
          "linkedFunction": "static int __init macro_processor_init(void)",
          "exact": true
        },
        {
          "pattern": "Macro processor module unloaded",
          "linkedFunction": "static void __exit macro_processor_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 25,
    "title": "Enums and X-Macros - Managing Related Constants",
    "difficulty": 6,
    "xp": 65,
    "phase": "foundations",
    "description": "Master enums for grouped constants and X-macros for sophisticated code generation. Learn to define data once and generate multiple related structures automatically - a powerful pattern used throughout Linux kernel development.",
    "concepts": [
      "enum fundamentals",
      "grouped constants",
      "automatic enumeration",
      "custom enum values",
      "X-macro patterns",
      "code generation",
      "define once use everywhere",
      "data synchronization"
    ],
    "skills": [
      "Defining enums for related constants",
      "Using enums instead of #define constants",
      "Understanding automatic vs custom enum values",
      "Creating X-macro tables",
      "Generating code with X-macros",
      "Maintaining synchronized data structures",
      "Applying kernel-style code generation patterns"
    ],
    "files": [
      {
        "name": "enum_processor.h",
        "content": "#ifndef ENUM_PROCESSOR_H\n#define ENUM_PROCESSOR_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* LEARNING PROGRESSION: From Basic Constants to Code Generation */\n/* This problem teaches the evolution from basic #define to sophisticated X-macros */\n\n/* STEP 1: Introduction to Enums */\n/* Enums are a way to group related constants together with automatic numbering */\n/* Instead of: #define STATE_IDLE 0, #define STATE_ACTIVE 1, #define STATE_ERROR 2 */\n/* You can write: enum { STATE_IDLE, STATE_ACTIVE, STATE_ERROR }; */\n\n/* TODO: Define basic device state enum */\n/* Create enum device_state with values: DEVICE_OFFLINE, DEVICE_ONLINE, DEVICE_ERROR */\n/* Enums automatically assign 0, 1, 2... unless you specify otherwise */\n\n/* TODO: Define priority enum with custom values */\n/* Create enum priority with values: PRIORITY_LOW = 1, PRIORITY_MEDIUM = 5, PRIORITY_HIGH = 10 */\n\n/* STEP 2: The Manual Maintenance Problem */\n/* When you have related data (enum + strings + IDs), keeping them synchronized is tedious */\n\n/* TODO: Define device type enum manually */\n/* Create enum device_type with values: TYPE_SENSOR, TYPE_MOTOR, TYPE_LED */\n\n/* Manual approach - you have to update multiple places when adding new types! */\nextern const char* device_type_names[];\nextern const uint16_t device_type_ids[];\n\n/* STEP 3: X-Macro Solution - Define Once, Use Everywhere */\n/* X-macros solve the synchronization problem by defining data once */\n/* and generating multiple related structures automatically */\n\n/* TODO: Define the X-macro table */\n/* Create macro DEVICE_TABLE(X) that calls X for each device: */\n/* X(SENSOR, \"Temperature Sensor\", 0x2001) */\n/* X(MOTOR, \"Stepper Motor\", 0x2002) */\n/* X(LED, \"Status LED\", 0x2003) */\n/* X(DISPLAY, \"LCD Display\", 0x2004) */\n\n/* TODO: Generate enum using X-macro */\n/* Create enum xmacro_device_type using the DEVICE_TABLE */\n/* Pattern: #define MAKE_ENUM(name, desc, id) XDEV_##name, */\n/*          enum xmacro_device_type { DEVICE_TABLE(MAKE_ENUM) }; */\n/*          #undef MAKE_ENUM */\n\n/* Configuration structure for testing */\ntypedef struct {\n    enum device_state state;\n    enum priority priority;\n    enum device_type manual_type;\n    // enum xmacro_device_type auto_type;  // TODO: Add this after creating X-macro enum\n    uint16_t device_id;\n    char device_name[64];\n} device_config;\n\n/* Global test configuration */\nextern device_config test_config;\n\n/* TODO: Declare your testing functions */\n/* void test_basic_enums(void); */\n/* void test_manual_approach(void); */\n/* void test_xmacro_generation(void); */\n/* void demonstrate_synchronization(void); */\n/* void print_device_config(device_config *config); */\n\n#endif /* ENUM_PROCESSOR_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "enum_processor.c",
        "content": "#include \"enum_processor.h\"\n\n/* Global test configuration */\ndevice_config test_config = {\n    .state = DEVICE_OFFLINE,\n    .priority = PRIORITY_LOW,\n    .manual_type = TYPE_SENSOR,\n    // .auto_type = XDEV_SENSOR,  // TODO: Enable after creating X-macro enum\n    .device_id = 0,\n    .device_name = \"Test Device\"\n};\n\nint test_device_type = TYPE_SENSOR;\nint test_priority = PRIORITY_MEDIUM;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n */\nmodule_param(test_device_type, int, 0644);\nMODULE_PARM_DESC(test_device_type, \"Device type for testing enum values\");\nmodule_param(test_priority, int, 0644);\nMODULE_PARM_DESC(test_priority, \"Priority level for testing enum functionality\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: Evolution from Constants to Code Generation */\n/* This teaches the PROGRESSION in kernel programming:\n *\n * Stage 1: Basic Constants\n * #define STATE_IDLE 0\n * #define STATE_ACTIVE 1\n * Problem: No grouping, easy to make mistakes\n *\n * Stage 2: Enums (Grouped Constants)\n * enum state { STATE_IDLE, STATE_ACTIVE, STATE_ERROR };\n * Benefits: Automatic numbering, type safety, logical grouping\n *\n * Stage 3: Manual Related Data\n * enum device_type { TYPE_A, TYPE_B };\n * const char* names[] = { \"Device A\", \"Device B\" };\n * Problem: Must update multiple places, easy to get out of sync\n *\n * Stage 4: X-Macros (Code Generation)\n * #define DEVICE_TABLE(X) X(A, \"Device A\", 0x100) X(B, \"Device B\", 0x200)\n * Benefits: Define once, generate enum + strings + IDs automatically\n *\n * Why X-Macros are Essential in Kernel:\n * - System call tables: NR_syscalls generated from syscall definitions\n * - Error codes: Both enum and string arrays from single definition\n * - Driver registration: Device tables with IDs, names, and handlers\n * - Trace points: Event definitions generate both code and documentation\n */\n\n/* STEP 1: Manual arrays for device types (before X-macros) */\n/* TODO: Implement manual device type arrays */\nconst char* device_type_names[] = {\n    /* TODO: Add string names that match the enum device_type order */\n    /* \"Temperature Sensor\", \"Stepper Motor\", \"Status LED\" */\n};\n\nconst uint16_t device_type_ids[] = {\n    /* TODO: Add IDs that match the enum device_type order */\n    /* 0x1001, 0x1002, 0x1003 */\n};\n\n/* STEP 2: X-Macro generated arrays (after X-macros) */\n/* TODO: Implement X-macro generated arrays */\n/* Generate string array using X-macro pattern: */\n/* const char* xmacro_device_names[] = { */\n/* #define MAKE_STRING(name, desc, id) desc, */\n/*     DEVICE_TABLE(MAKE_STRING) */\n/* #undef MAKE_STRING */\n/* }; */\n\n/* Generate ID array using X-macro pattern: */\n/* const uint16_t xmacro_device_ids[] = { */\n/* #define MAKE_ID(name, desc, id) id, */\n/*     DEVICE_TABLE(MAKE_ID) */\n/* #undef MAKE_ID */\n/* }; */\n\n/* TODO: Implement basic enum testing */\nvoid test_basic_enums(void) {\n    /* TODO: Test basic enum functionality */\n    /* TODO: Print \"Testing basic enums:\" */\n    /* TODO: Print \"DEVICE_OFFLINE = %d\" with DEVICE_OFFLINE value */\n    /* TODO: Print \"DEVICE_ONLINE = %d\" with DEVICE_ONLINE value */\n    /* TODO: Print \"DEVICE_ERROR = %d\" with DEVICE_ERROR value */\n    \n    /* TODO: Test priority enum with custom values */\n    /* TODO: Print \"PRIORITY_LOW = %d\" with PRIORITY_LOW value */\n    /* TODO: Print \"PRIORITY_MEDIUM = %d\" with PRIORITY_MEDIUM value */\n    /* TODO: Print \"PRIORITY_HIGH = %d\" with PRIORITY_HIGH value */\n}\n\n/* TODO: Implement manual approach testing */\nvoid test_manual_approach(void) {\n    /* TODO: Test manual enum and array coordination */\n    /* TODO: Print \"Testing manual approach:\" */\n    \n    /* TODO: Test that enum values match array indices */\n    /* TODO: Print \"TYPE_SENSOR name: %s\" with device_type_names[TYPE_SENSOR] */\n    /* TODO: Print \"TYPE_MOTOR name: %s\" with device_type_names[TYPE_MOTOR] */\n    /* TODO: Print \"TYPE_LED name: %s\" with device_type_names[TYPE_LED] */\n    \n    /* TODO: Test ID lookup */\n    /* TODO: Print \"TYPE_SENSOR ID: 0x%04x\" with device_type_ids[TYPE_SENSOR] */\n    /* TODO: Print \"TYPE_MOTOR ID: 0x%04x\" with device_type_ids[TYPE_MOTOR] */\n}\n\n/* TODO: Implement X-macro generation testing */\nvoid test_xmacro_generation(void) {\n    /* TODO: Test X-macro generated structures */\n    /* TODO: Print \"Testing X-macro generation:\" */\n    \n    /* TODO: Test X-macro generated enum */\n    /* TODO: Print \"XDEV_SENSOR = %d\" with XDEV_SENSOR value */\n    /* TODO: Print \"XDEV_MOTOR = %d\" with XDEV_MOTOR value */\n    /* TODO: Print \"XDEV_LED = %d\" with XDEV_LED value */\n    /* TODO: Print \"XDEV_DISPLAY = %d\" with XDEV_DISPLAY value */\n    \n    /* TODO: Test X-macro generated arrays */\n    /* TODO: Print \"XDEV_SENSOR name: %s\" with xmacro_device_names[XDEV_SENSOR] */\n    /* TODO: Print \"XDEV_DISPLAY name: %s\" with xmacro_device_names[XDEV_DISPLAY] */\n    /* TODO: Print \"XDEV_SENSOR ID: 0x%04x\" with xmacro_device_ids[XDEV_SENSOR] */\n    /* TODO: Print \"XDEV_DISPLAY ID: 0x%04x\" with xmacro_device_ids[XDEV_DISPLAY] */\n}\n\n/* TODO: Implement synchronization demonstration */\nvoid demonstrate_synchronization(void) {\n    /* TODO: Show the power of X-macro synchronization */\n    /* TODO: Print \"Demonstrating automatic synchronization:\" */\n    \n    /* TODO: Show that adding new devices to DEVICE_TABLE automatically updates everything */\n    /* TODO: Create variable: int device_count = sizeof(xmacro_device_names) / sizeof(xmacro_device_names[0]) */\n    /* TODO: Print \"Total devices in X-macro table: %d\" with device_count */\n    \n    /* TODO: Demonstrate dynamic access */\n    /* TODO: Use test_device_type parameter to look up device info */\n    /* TODO: Print \"Selected device type %d\" with test_device_type */\n    /* TODO: Print \"Device name: %s\" with xmacro_device_names[test_device_type] */\n    /* TODO: Print \"Device ID: 0x%04x\" with xmacro_device_ids[test_device_type] */\n}\n\nvoid print_device_config(device_config *config) {\n    if (!config) {\n        printk(KERN_ERR \"No device configuration available\\n\");\n        return;\n    }\n    \n    printk(KERN_INFO \"Device Configuration:\\n\");\n    printk(KERN_INFO \"  Name: %s\\n\", config->device_name);\n    printk(KERN_INFO \"  State: %d\\n\", config->state);\n    printk(KERN_INFO \"  Priority: %d\\n\", config->priority);\n    printk(KERN_INFO \"  Manual Type: %d\\n\", config->manual_type);\n    printk(KERN_INFO \"  Device ID: 0x%04x\\n\", config->device_id);\n}\n\nstatic int __init enum_processor_init(void)\n{\n    printk(KERN_INFO \"Enum processor module loaded\\n\");\n    \n    /* Update test configuration with dynamic parameter values */\n    test_config.manual_type = test_device_type;\n    test_config.priority = test_priority;\n    test_config.device_id = device_type_ids[test_device_type];\n    \n    printk(KERN_INFO \"Testing enum and X-macro concepts\\n\");\n    \n    /* Test all enum and X-macro concepts */\n    test_basic_enums();\n    test_manual_approach();\n    test_xmacro_generation();\n    demonstrate_synchronization();\n    \n    /* Display final configuration */\n    print_device_config(&test_config);\n    \n    printk(KERN_INFO \"Enum and X-macro demonstration completed\\n\");\n    \n    return 0;\n}\n\nstatic void __exit enum_processor_exit(void)\n{\n    printk(KERN_INFO \"Enum processor module unloaded\\n\");\n}\n\nmodule_init(enum_processor_init);\nmodule_exit(enum_processor_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning enums and X-macros for managing related constants\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Enum processor module Makefile\nobj-m += enum_processor.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "enum_processor.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "enum_processor_init",
          "enum_processor_exit",
          "test_basic_enums",
          "test_manual_approach",
          "test_xmacro_generation",
          "demonstrate_synchronization",
          "print_device_config"
        ],
        "macro_declarations": [
          {
            "name": "DEVICE_TABLE",
            "type": "constant",
            "value": "(X) \\\nX(SENSOR, \"Temperature Sensor\", 0x2001) \\\nX(MOTOR, \"Stepper Motor\", 0x2002) \\\nX(LED, \"Status LED\", 0x2003) \\\nX(DISPLAY, \"LCD Display\", 0x2004)",
            "description": "X-macro table defining all devices with name, description, and ID"
          },
          {
            "name": "MAKE_ENUM",
            "type": "constant",
            "value": "(name, desc, id) XDEV_##name,\nenum xmacro_device_type { DEVICE_TABLE(MAKE_ENUM) };\n#undef MAKE_ENUM",
            "description": "X-macro helper to generate enum values"
          },
          {
            "name": "MAKE_STRING",
            "type": "function-like",
            "parameters": [
              "name",
              "desc",
              "id"
            ],
            "value": "desc,",
            "description": "X-macro helper to generate string array entries"
          },
          {
            "name": "MAKE_ID",
            "type": "function-like",
            "parameters": [
              "name",
              "desc",
              "id"
            ],
            "value": "id,",
            "description": "X-macro helper to generate ID array entries"
          }
        ],
        "macro_definitions": [],
        "function_declarations": [
          {
            "name": "test_basic_enums",
            "returnType": "void",
            "parameters": [
              "void"
            ]
          },
          {
            "name": "test_manual_approach",
            "returnType": "void",
            "parameters": [
              "void"
            ]
          },
          {
            "name": "test_xmacro_generation",
            "returnType": "void",
            "parameters": [
              "void"
            ]
          },
          {
            "name": "demonstrate_synchronization",
            "returnType": "void",
            "parameters": [
              "void"
            ]
          },
          {
            "name": "print_device_config",
            "returnType": "void",
            "parameters": [
              "device_config *config"
            ]
          }
        ],
        "variables_declarations": [
          {
            "name": "device_state",
            "type": "enum",
            "value": "{DEVICE_OFFLINE, DEVICE_ONLINE, DEVICE_ERROR}",
            "storageClass": "none"
          },
          {
            "name": "priority",
            "type": "enum",
            "value": "{PRIORITY_LOW = 1, PRIORITY_MEDIUM = 5, PRIORITY_HIGH = 10}",
            "storageClass": "none"
          },
          {
            "name": "device_type",
            "type": "enum",
            "value": "{TYPE_SENSOR, TYPE_MOTOR, TYPE_LED}",
            "storageClass": "none"
          },
          {
            "name": "xmacro_device_type",
            "type": "enum",
            "value": "{XDEV_SENSOR, XDEV_MOTOR, XDEV_LED, XDEV_DISPLAY}",
            "storageClass": "none"
          },
          {
            "name": "device_config",
            "type": "typedef struct",
            "value": "{enum device_state state; enum priority priority; enum device_type manual_type; uint16_t device_id; char device_name[64];}",
            "storageClass": "none"
          },
          {
            "name": "device_type_names",
            "type": "const char*",
            "value": "[]",
            "storageClass": "extern"
          },
          {
            "name": "device_type_ids",
            "type": "const uint16_t",
            "value": "[]",
            "storageClass": "extern"
          },
          {
            "name": "test_config",
            "type": "device_config",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "test_config",
            "type": "device_config",
            "storageClass": "none"
          },
          {
            "name": "device_type_names",
            "type": "const char*",
            "value": "[]",
            "storageClass": "none"
          },
          {
            "name": "device_type_ids",
            "type": "const uint16_t",
            "value": "[]",
            "storageClass": "none"
          },
          {
            "name": "xmacro_device_names",
            "type": "const char*",
            "value": "[]",
            "storageClass": "none"
          },
          {
            "name": "xmacro_device_ids",
            "type": "const uint16_t",
            "value": "[]",
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Enum processor module loaded",
          "Testing enum and X-macro concepts",
          "Testing basic enums:",
          "DEVICE_OFFLINE = 0",
          "DEVICE_ONLINE = 1",
          "DEVICE_ERROR = 2",
          "PRIORITY_LOW = 1",
          "PRIORITY_MEDIUM = 5",
          "PRIORITY_HIGH = 10",
          "Testing manual approach:",
          "TYPE_SENSOR name:",
          "TYPE_MOTOR name:",
          "TYPE_LED name:",
          "TYPE_SENSOR ID:",
          "TYPE_MOTOR ID:",
          "Testing X-macro generation:",
          "XDEV_SENSOR = 0",
          "XDEV_MOTOR = 1",
          "XDEV_LED = 2",
          "XDEV_DISPLAY = 3",
          "XDEV_SENSOR name:",
          "XDEV_DISPLAY name:",
          "XDEV_SENSOR ID:",
          "XDEV_DISPLAY ID:",
          "Demonstrating automatic synchronization:",
          "Total devices in X-macro table:",
          "Selected device type",
          "Device name:",
          "Device ID:",
          "Device Configuration:",
          "Enum and X-macro demonstration completed",
          "Enum processor module unloaded"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "enum device_state",
          "DEVICE_OFFLINE",
          "DEVICE_ONLINE",
          "DEVICE_ERROR",
          "enum priority",
          "PRIORITY_LOW = 1",
          "PRIORITY_MEDIUM = 5",
          "PRIORITY_HIGH = 10",
          "enum device_type",
          "TYPE_SENSOR",
          "TYPE_MOTOR",
          "TYPE_LED",
          "#define DEVICE_TABLE(X)",
          "X(SENSOR,",
          "X(MOTOR,",
          "X(LED,",
          "X(DISPLAY,",
          "enum xmacro_device_type",
          "#define MAKE_ENUM(name, desc, id) XDEV_##name,",
          "DEVICE_TABLE(MAKE_ENUM)",
          "#undef MAKE_ENUM",
          "xmacro_device_names",
          "#define MAKE_STRING(name, desc, id) desc,",
          "DEVICE_TABLE(MAKE_STRING)",
          "#undef MAKE_STRING",
          "xmacro_device_ids",
          "#define MAKE_ID(name, desc, id) id,",
          "DEVICE_TABLE(MAKE_ID)",
          "#undef MAKE_ID",
          "device_type_names[TYPE_SENSOR]",
          "device_type_ids[TYPE_SENSOR]",
          "xmacro_device_names[XDEV_SENSOR]",
          "xmacro_device_ids[XDEV_SENSOR]",
          "sizeof(xmacro_device_names)",
          "module_param(test_device_type, int, 0644)",
          "module_param(test_priority, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void test_basic_enums(void)",
            "void test_manual_approach(void)",
            "void test_xmacro_generation(void)",
            "void demonstrate_synchronization(void)",
            "void print_device_config(device_config *config)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "enum_definitions",
          "name": "Enum Definitions in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "enum device_state",
            "enum priority",
            "enum device_type",
            "enum xmacro_device_type",
            "DEVICE_OFFLINE",
            "DEVICE_ONLINE",
            "DEVICE_ERROR",
            "PRIORITY_LOW",
            "PRIORITY_MEDIUM",
            "PRIORITY_HIGH",
            "TYPE_SENSOR",
            "TYPE_MOTOR",
            "TYPE_LED",
            "XDEV_SENSOR",
            "XDEV_MOTOR",
            "XDEV_LED",
            "XDEV_DISPLAY"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "xmacro_patterns",
          "name": "X-Macro Pattern Implementation",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "#define DEVICE_TABLE(X)",
            "#define MAKE_ENUM",
            "DEVICE_TABLE(MAKE_ENUM)",
            "#undef MAKE_ENUM",
            "#define MAKE_STRING",
            "DEVICE_TABLE(MAKE_STRING)",
            "#undef MAKE_STRING",
            "#define MAKE_ID",
            "DEVICE_TABLE(MAKE_ID)",
            "#undef MAKE_ID"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void test_basic_enums(void)",
            "void test_manual_approach(void)",
            "void test_xmacro_generation(void)",
            "void demonstrate_synchronization(void)",
            "void print_device_config(device_config *config)",
            "static int __init enum_processor_init(void)",
            "static void __exit enum_processor_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Enum processor module loaded",
              "exact": true,
              "linkedFunction": "static int __init enum_processor_init(void)"
            },
            {
              "pattern": "Testing enum and X-macro concepts",
              "exact": true,
              "linkedFunction": "static int __init enum_processor_init(void)"
            },
            {
              "pattern": "Testing basic enums:",
              "exact": true,
              "linkedFunction": "void test_basic_enums(void)"
            },
            {
              "pattern": "DEVICE_OFFLINE = 0",
              "exact": true,
              "linkedFunction": "void test_basic_enums(void)"
            },
            {
              "pattern": "DEVICE_ONLINE = 1",
              "exact": true,
              "linkedFunction": "void test_basic_enums(void)"
            },
            {
              "pattern": "DEVICE_ERROR = 2",
              "exact": true,
              "linkedFunction": "void test_basic_enums(void)"
            },
            {
              "pattern": "PRIORITY_LOW = 1",
              "exact": true,
              "linkedFunction": "void test_basic_enums(void)"
            },
            {
              "pattern": "PRIORITY_MEDIUM = 5",
              "exact": true,
              "linkedFunction": "void test_basic_enums(void)"
            },
            {
              "pattern": "PRIORITY_HIGH = 10",
              "exact": true,
              "linkedFunction": "void test_basic_enums(void)"
            },
            {
              "pattern": "Testing manual approach:",
              "exact": true,
              "linkedFunction": "void test_manual_approach(void)"
            },
            {
              "pattern": "Testing X-macro generation:",
              "exact": true,
              "linkedFunction": "void test_xmacro_generation(void)"
            },
            {
              "pattern": "XDEV_SENSOR = 0",
              "exact": true,
              "linkedFunction": "void test_xmacro_generation(void)"
            },
            {
              "pattern": "XDEV_MOTOR = 1",
              "exact": true,
              "linkedFunction": "void test_xmacro_generation(void)"
            },
            {
              "pattern": "XDEV_LED = 2",
              "exact": true,
              "linkedFunction": "void test_xmacro_generation(void)"
            },
            {
              "pattern": "XDEV_DISPLAY = 3",
              "exact": true,
              "linkedFunction": "void test_xmacro_generation(void)"
            },
            {
              "pattern": "Demonstrating automatic synchronization:",
              "exact": true,
              "linkedFunction": "void demonstrate_synchronization(void)"
            },
            {
              "pattern": "Device Configuration:",
              "exact": true,
              "linkedFunction": "void print_device_config(device_config *config)"
            },
            {
              "pattern": "Enum and X-macro demonstration completed",
              "exact": true,
              "linkedFunction": "static int __init enum_processor_init(void)"
            },
            {
              "pattern": "Enum processor module unloaded",
              "exact": true,
              "linkedFunction": "static void __exit enum_processor_exit(void)"
            }
          ]
        },
        {
          "id": "enum_xmacro_validation",
          "name": "Enum and X-Macro Dynamic Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "enum_dynamic_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Enum and X-Macro Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate test values\\n    int random_device_type = (rand() % 3);     // 0, 1, or 2 (TYPE_SENSOR, TYPE_MOTOR, TYPE_LED)\\n    int random_priority = ((rand() % 3) == 0) ? 1 : ((rand() % 3) == 1) ? 5 : 10;  // 1, 5, or 10\\n    \\n    printf(\\\"Random enum test (device=%d, priority=%d)\\\\n\\\", random_device_type, random_priority);\\n    \\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod enum_processor 2>/dev/null\\\");\\n    \\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/enum_processor.ko test_device_type=%d test_priority=%d\\\", random_device_type, random_priority);\\n    printf(\\\"DEBUG: Command: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Enum test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting enum and X-macro validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: TCC Header Validation'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef unsigned char uint8_t;' > /tmp/linux/types.h",
              "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
              "echo '#include \"/lib/modules/enum_processor.h\"' > /tmp/test.c",
              "echo 'int main() { device_config config; test_basic_enums(); test_manual_approach(); test_xmacro_generation(); demonstrate_synchronization(); print_device_config(&config); return 0; }' >> /tmp/test.c",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or enum definition missing'; cat /tmp/tcc_error.log; else echo 'PASS: All declarations found in header'; fi",
              "echo 'Phase 2: Dynamic Enum Test'",
              "/bin/enum_dynamic_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Enum and X-Macro Validation'",
              "sleep 1",
              "dmesg | grep 'DEVICE_OFFLINE = 0' && echo 'PASS: Basic enum values working' || echo 'FAIL: Basic enum values broken'",
              "dmesg | grep 'PRIORITY_LOW = 1' && echo 'PASS: Custom enum values working' || echo 'FAIL: Custom enum values broken'",
              "dmesg | grep 'PRIORITY_MEDIUM = 5' && echo 'PASS: Custom enum values working' || echo 'FAIL: Custom enum values broken'",
              "dmesg | grep 'PRIORITY_HIGH = 10' && echo 'PASS: Custom enum values working' || echo 'FAIL: Custom enum values broken'",
              "dmesg | grep 'XDEV_SENSOR = 0' && echo 'PASS: X-macro enum generation working' || echo 'FAIL: X-macro enum generation broken'",
              "dmesg | grep 'XDEV_DISPLAY = 3' && echo 'PASS: X-macro enum generation working' || echo 'FAIL: X-macro enum generation broken'",
              "dmesg | grep 'Total devices in X-macro table:' && echo 'PASS: X-macro synchronization working' || echo 'FAIL: X-macro synchronization broken'",
              "dmesg | grep 'Testing basic enums:' && echo 'PASS: Basic enum testing working' || echo 'FAIL: Basic enum testing broken'",
              "dmesg | grep 'Testing manual approach:' && echo 'PASS: Manual approach testing working' || echo 'FAIL: Manual approach testing broken'",
              "dmesg | grep 'Testing X-macro generation:' && echo 'PASS: X-macro generation testing working' || echo 'FAIL: X-macro generation testing broken'",
              "dmesg | grep 'Enum processor module loaded' && echo 'PASS: Module loading working' || echo 'FAIL: Module loading broken'",
              "echo 'PASS: All enum and X-macro validation successful'"
            ],
            "expected": {
              "dmesg": [
                "Enum processor module loaded",
                "Testing enum and X-macro concepts",
                "Testing basic enums:",
                "DEVICE_OFFLINE = 0",
                "DEVICE_ONLINE = 1",
                "DEVICE_ERROR = 2",
                "PRIORITY_LOW = 1",
                "PRIORITY_MEDIUM = 5",
                "PRIORITY_HIGH = 10",
                "Testing manual approach:",
                "TYPE_SENSOR name: .*",
                "TYPE_MOTOR name: .*",
                "TYPE_LED name: .*",
                "TYPE_SENSOR ID: .*",
                "TYPE_MOTOR ID: .*",
                "Testing X-macro generation:",
                "XDEV_SENSOR = 0",
                "XDEV_MOTOR = 1",
                "XDEV_LED = 2",
                "XDEV_DISPLAY = 3",
                "XDEV_SENSOR name: .*",
                "XDEV_DISPLAY name: .*",
                "XDEV_SENSOR ID: .*",
                "XDEV_DISPLAY ID: .*",
                "Demonstrating automatic synchronization:",
                "Total devices in X-macro table: .*",
                "Selected device type .*",
                "Device name: .*",
                "Device ID: .*",
                "Device Configuration:",
                "Enum and X-macro demonstration completed",
                "Enum processor module unloaded"
              ],
              "stdout": [
                "PASS: All declarations found in header",
                "SUCCESS: Enum test completed",
                "PASS: Basic enum values working",
                "PASS: Custom enum values working",
                "PASS: X-macro enum generation working",
                "PASS: X-macro synchronization working",
                "PASS: Basic enum testing working",
                "PASS: Manual approach testing working",
                "PASS: X-macro generation testing working",
                "PASS: Module loading working",
                "PASS: All enum and X-macro validation successful"
              ]
            },
            "timeout": 30
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Enum processor module loaded",
        "Testing enum and X-macro concepts",
        "Testing basic enums:",
        "DEVICE_OFFLINE = 0",
        "DEVICE_ONLINE = 1",
        "DEVICE_ERROR = 2",
        "PRIORITY_LOW = 1",
        "PRIORITY_MEDIUM = 5",
        "PRIORITY_HIGH = 10",
        "Testing manual approach:",
        "TYPE_SENSOR name:",
        "TYPE_MOTOR name:",
        "TYPE_LED name:",
        "TYPE_SENSOR ID:",
        "TYPE_MOTOR ID:",
        "Testing X-macro generation:",
        "XDEV_SENSOR = 0",
        "XDEV_MOTOR = 1",
        "XDEV_LED = 2",
        "XDEV_DISPLAY = 3",
        "XDEV_SENSOR name:",
        "XDEV_DISPLAY name:",
        "XDEV_SENSOR ID:",
        "XDEV_DISPLAY ID:",
        "Demonstrating automatic synchronization:",
        "Total devices in X-macro table:",
        "Selected device type",
        "Device name:",
        "Device ID:",
        "Device Configuration:",
        "Enum and X-macro demonstration completed",
        "Enum processor module unloaded"
      ],
      "requirements": [
        "Use required function names: enum_processor_init, enum_processor_exit, test_basic_enums, test_manual_approach, test_xmacro_generation, demonstrate_synchronization, print_device_config",
        "Use required variable names: test_config, device_type_names, device_type_ids, xmacro_device_names, xmacro_device_ids",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: enum device_state, DEVICE_OFFLINE, DEVICE_ONLINE, DEVICE_ERROR, enum priority, PRIORITY_LOW = 1, PRIORITY_MEDIUM = 5, PRIORITY_HIGH = 10, enum device_type, TYPE_SENSOR, TYPE_MOTOR, TYPE_LED, #define DEVICE_TABLE(X), X(SENSOR,, X(MOTOR,, X(LED,, X(DISPLAY,, enum xmacro_device_type, #define MAKE_ENUM(name, desc, id) XDEV_##name,, DEVICE_TABLE(MAKE_ENUM), #undef MAKE_ENUM, xmacro_device_names, #define MAKE_STRING(name, desc, id) desc,, DEVICE_TABLE(MAKE_STRING), #undef MAKE_STRING, xmacro_device_ids, #define MAKE_ID(name, desc, id) id,, DEVICE_TABLE(MAKE_ID), #undef MAKE_ID, device_type_names[TYPE_SENSOR], device_type_ids[TYPE_SENSOR], xmacro_device_names[XDEV_SENSOR], xmacro_device_ids[XDEV_SENSOR], sizeof(xmacro_device_names), module_param(test_device_type, int, 0644), module_param(test_priority, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Enum processor module loaded",
          "linkedFunction": "static int __init enum_processor_init(void)",
          "exact": true
        },
        {
          "pattern": "Testing enum and X-macro concepts",
          "linkedFunction": "static int __init enum_processor_init(void)",
          "exact": true
        },
        {
          "pattern": "Testing basic enums:",
          "linkedFunction": "void test_basic_enums(void)",
          "exact": true
        },
        {
          "pattern": "DEVICE_OFFLINE = 0",
          "linkedFunction": "void test_basic_enums(void)",
          "exact": true
        },
        {
          "pattern": "DEVICE_ONLINE = 1",
          "linkedFunction": "void test_basic_enums(void)",
          "exact": true
        },
        {
          "pattern": "DEVICE_ERROR = 2",
          "linkedFunction": "void test_basic_enums(void)",
          "exact": true
        },
        {
          "pattern": "PRIORITY_LOW = 1",
          "linkedFunction": "void test_basic_enums(void)",
          "exact": true
        },
        {
          "pattern": "PRIORITY_MEDIUM = 5",
          "linkedFunction": "void test_basic_enums(void)",
          "exact": true
        },
        {
          "pattern": "PRIORITY_HIGH = 10",
          "linkedFunction": "void test_basic_enums(void)",
          "exact": true
        },
        {
          "pattern": "Testing manual approach:",
          "linkedFunction": "void test_manual_approach(void)",
          "exact": true
        },
        {
          "pattern": "Testing X-macro generation:",
          "linkedFunction": "void test_xmacro_generation(void)",
          "exact": true
        },
        {
          "pattern": "XDEV_SENSOR = 0",
          "linkedFunction": "void test_xmacro_generation(void)",
          "exact": true
        },
        {
          "pattern": "XDEV_MOTOR = 1",
          "linkedFunction": "void test_xmacro_generation(void)",
          "exact": true
        },
        {
          "pattern": "XDEV_LED = 2",
          "linkedFunction": "void test_xmacro_generation(void)",
          "exact": true
        },
        {
          "pattern": "XDEV_DISPLAY = 3",
          "linkedFunction": "void test_xmacro_generation(void)",
          "exact": true
        },
        {
          "pattern": "Demonstrating automatic synchronization:",
          "linkedFunction": "void demonstrate_synchronization(void)",
          "exact": true
        },
        {
          "pattern": "Device Configuration:",
          "linkedFunction": "void print_device_config(device_config *config)",
          "exact": true
        },
        {
          "pattern": "Enum and X-macro demonstration completed",
          "linkedFunction": "static int __init enum_processor_init(void)",
          "exact": true
        },
        {
          "pattern": "Enum processor module unloaded",
          "linkedFunction": "static void __exit enum_processor_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 26,
    "title": "Linked Lists - Kernel List Patterns",
    "difficulty": 4,
    "xp": 45,
    "phase": "foundations",
    "description": "Master linked lists through two approaches: implement basic operations manually to understand fundamentals, then use real Linux kernel list macros. Learn the essential data structure pattern used throughout kernel development.",
    "concepts": [
      "linked list fundamentals",
      "embedded list nodes",
      "kernel list patterns",
      "circular doubly-linked lists",
      "manual vs macro operations",
      "list traversal patterns",
      "memory management with lists",
      "head anchor concept",
      "double pointer operations",
      "pointer update ordering"
    ],
    "skills": [
      "Implementing basic linked list operations",
      "Using kernel list macros",
      "Understanding embedded list node pattern",
      "Distinguishing between head and nodes",
      "Managing list node pointers",
      "Traversing lists safely",
      "Searching and counting list elements",
      "Cleaning up dynamic list structures",
      "Working with container_of macro",
      "Understanding double pointer dereference"
    ],
    "files": [
      {
        "name": "linked_lists.h",
        "content": "#ifndef LINKED_LISTS_H\n#define LINKED_LISTS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n\n#define MAX_DEVICE_NAME 16\n\n/* Basic list node structure (like kernel's list_head) */\nstruct list_head {\n    struct list_head *next, *prev;\n};\n\n/* Device entry structure with embedded list node */\nstruct device_entry {\n    int device_id;\n    char name[MAX_DEVICE_NAME];\n    int status;\n    struct list_head list;  /* Embedded list node - kernel pattern! */\n};\n\n/* Global list heads for testing */\nextern struct list_head manual_device_list;\nextern struct list_head kernel_device_list;\n\n/* TODO: Declare your manual list functions */\n/* void manual_init_list(struct list_head *head); */\n/* void manual_add_device(struct device_entry *dev, struct list_head *head); */\n/* void manual_remove_device(struct device_entry *dev); */\n/* int manual_is_empty(struct list_head *head); */\n/* void manual_traverse_list(struct list_head *head); */\n\n/* TODO: Declare your kernel macro functions */\n/* void kernel_add_device(struct device_entry *dev); */\n/* void kernel_traverse_list(void); */\n/* struct device_entry* find_device_by_id(int device_id); */\n/* int count_total_devices(void); */\n/* void cleanup_all_devices(void); */\n\n#endif /* LINKED_LISTS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "linked_lists.c",
        "content": "#include \"linked_lists.h\"\n\n/* Global list heads */\nstruct list_head manual_device_list;\nstruct list_head kernel_device_list;\n\nint test_device_id = 1001;\nint test_device_count = 3;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n */\nmodule_param(test_device_id, int, 0644);\nMODULE_PARM_DESC(test_device_id, \"Device ID for testing list operations\");\nmodule_param(test_device_count, int, 0644);\nMODULE_PARM_DESC(test_device_count, \"Number of devices for testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: How linked lists work in kernel development */\n/* This teaches the FOUNDATION for kernel data structures:\n *\n * Traditional Linked List (textbook approach):\n * struct node {\n *     int data;\n *     struct node *next;\n * };\n * Problem: Each data type needs its own list implementation\n *\n * Kernel Linked List (embedded approach):\n * struct list_head {\n *     struct list_head *next, *prev;\n * };\n * struct my_data {\n *     int value;\n *     struct list_head list;  // Embedded list node\n * };\n * Benefits: Generic operations, memory efficient, type flexible\n *\n * Why Kernel Pattern is Superior:\n * 1. Any struct can contain list nodes\n * 2. Same struct can be in multiple lists\n * 3. Generic list operations work on any type\n * 4. No separate memory allocation for list nodes\n * 5. Used everywhere: processes, devices, memory pages, files\n */\n\n/* MEMORY LAYOUT VISUALIZATION: */\n/* Traditional approach:\n * [data1|next] -> [data2|next] -> [data3|next] -> NULL\n * Each node allocated separately\n *\n * Kernel approach:\n * device_entry1: [device_id|name|status|list_node]\n * device_entry2: [device_id|name|status|list_node]\n * device_entry3: [device_id|name|status|list_node]\n * List nodes embedded in actual data structures\n */\n\n/* DOUBLE POINTER REVIEW FROM PREVIOUS PROBLEMS: */\n/* head->next points to first node\n * head->prev points to last node\n * node->next points to next node\n * node->prev points to previous node\n * Circular: last->next points back to head\n */\n\n/* TODO: Implement manual list initialization */\nvoid manual_init_list(struct list_head *head) {\n    /* TODO: Initialize head to point to itself (empty circular list) */\n    /* TODO: Set head->next = head */\n    /* TODO: Set head->prev = head */\n}\n\n/* TODO: Implement manual add to list */\nvoid manual_add_device(struct device_entry *dev, struct list_head *head) {\n    /* TODO: Initialize the device's list node */\n    /* TODO: Add device at the beginning of list (after head) */\n    /* TODO: Step 1: Set dev->list.next = head->next */\n    /* TODO: Step 2: Set dev->list.prev = head */\n    /* TODO: Step 3: Set head->next->prev = &dev->list */\n    /* TODO: Step 4: Set head->next = &dev->list */\n    /* TODO: Print \"Manually added device: %s (ID: %d)\" */\n}\n\n/* TODO: Implement manual remove from list */\nvoid manual_remove_device(struct device_entry *dev) {\n    /* TODO: Remove device from list by fixing pointers */\n    /* TODO: Step 1: Set dev->list.prev->next = dev->list.next */\n    /* TODO: Step 2: Set dev->list.next->prev = dev->list.prev */\n    /* TODO: Step 3: Set dev->list.next = &dev->list (reinitialize) */\n    /* TODO: Step 4: Set dev->list.prev = &dev->list (reinitialize) */\n    /* TODO: Print \"Manually removed device: %s (ID: %d)\" */\n}\n\n/* TODO: Implement manual empty check */\nint manual_is_empty(struct list_head *head) {\n    /* TODO: Return 1 if empty (head->next == head), 0 if not empty */\n    return 0;\n}\n\n/* TODO: Implement manual list traversal */\nvoid manual_traverse_list(struct list_head *head) {\n    /* TODO: Traverse list using manual pointer manipulation */\n    /* TODO: Create struct list_head *pos */\n    /* TODO: Loop: for (pos = head->next; pos != head; pos = pos->next) */\n    /* TODO: Inside loop: get device using container_of or list_entry */\n    /* TODO: Print \"Manual traversal - Device: %s (ID: %d, Status: %d)\" */\n    /* TODO: If empty list, print \"Manual list is empty\" */\n}\n\n/* TODO: Implement kernel macro add */\nvoid kernel_add_device(struct device_entry *dev) {\n    /* TODO: Use kernel macro to add device to kernel_device_list */\n    /* TODO: Use list_add(&dev->list, &kernel_device_list) */\n    /* TODO: Print \"Kernel added device: %s (ID: %d)\" */\n}\n\n/* TODO: Implement kernel macro traversal */\nvoid kernel_traverse_list(void) {\n    /* TODO: Use list_for_each_entry macro to traverse */\n    /* TODO: list_for_each_entry(entry, &kernel_device_list, list) */\n    /* TODO: Print \"Kernel traversal - Device: %s (ID: %d, Status: %d)\" */\n    /* TODO: If empty, print \"Kernel list is empty\" */\n}\n\n/* TODO: Implement device search */\nstruct device_entry* find_device_by_id(int device_id) {\n    /* TODO: Use list_for_each_entry to search for device_id */\n    /* TODO: Return pointer to device if found, NULL if not found */\n    return NULL;\n}\n\n/* TODO: Implement device counting */\nint count_total_devices(void) {\n    /* TODO: Use list_for_each_entry to count devices in kernel_device_list */\n    /* TODO: Return total count */\n    return 0;\n}\n\n/* TODO: Implement cleanup function */\nvoid cleanup_all_devices(void) {\n    /* TODO: Use list_for_each_entry_safe to safely remove and free all devices */\n    /* TODO: Use list_del to remove from list */\n    /* TODO: Use kfree to free memory */\n    /* TODO: Print \"Cleaned up device: %s\" for each device */\n}\n\n/* Helper function to create test devices */\nstatic struct device_entry* create_test_device(int id, const char* name, int status) {\n    struct device_entry *dev = kmalloc(sizeof(*dev), GFP_KERNEL);\n    if (!dev) {\n        return NULL;\n    }\n    \n    dev->device_id = id;\n    dev->status = status;\n    snprintf(dev->name, MAX_DEVICE_NAME, \"%s\", name);\n    INIT_LIST_HEAD(&dev->list);\n    \n    return dev;\n}\n\nstatic int __init linked_lists_init(void)\n{\n    struct device_entry *dev1, *dev2, *dev3;\n    struct device_entry *found_dev;\n    int total_devices;\n    \n    printk(KERN_INFO \"Linked lists module loaded\\n\");\n    \n    /* Initialize list heads */\n    manual_init_list(&manual_device_list);\n    INIT_LIST_HEAD(&kernel_device_list);\n    \n    printk(KERN_INFO \"Testing manual list operations\\n\");\n    \n    /* Test manual list operations */\n    dev1 = create_test_device(test_device_id, \"TempSensor\", 1);\n    dev2 = create_test_device(test_device_id + 1, \"MotorCtrl\", 1);\n    dev3 = create_test_device(test_device_id + 2, \"LEDStrip\", 0);\n    \n    if (!dev1 || !dev2 || !dev3) {\n        printk(KERN_ERR \"Failed to create test devices\\n\");\n        return -ENOMEM;\n    }\n    \n    /* Test manual operations */\n    manual_add_device(dev1, &manual_device_list);\n    manual_add_device(dev2, &manual_device_list);\n    manual_add_device(dev3, &manual_device_list);\n    \n    printk(KERN_INFO \"Manual list empty: %d\\n\", manual_is_empty(&manual_device_list));\n    manual_traverse_list(&manual_device_list);\n    \n    /* Remove one device manually */\n    manual_remove_device(dev2);\n    manual_traverse_list(&manual_device_list);\n    \n    printk(KERN_INFO \"Testing kernel macro operations\\n\");\n    \n    /* Test kernel macro operations */\n    kernel_add_device(dev1);\n    kernel_add_device(dev2);\n    kernel_add_device(dev3);\n    \n    kernel_traverse_list();\n    \n    /* Test search functionality */\n    found_dev = find_device_by_id(test_device_id);\n    if (found_dev) {\n        printk(KERN_INFO \"Found device: %s (ID: %d)\\n\", found_dev->name, found_dev->device_id);\n    } else {\n        printk(KERN_INFO \"Device ID %d not found\\n\", test_device_id);\n    }\n    \n    /* Test counting */\n    total_devices = count_total_devices();\n    printk(KERN_INFO \"Total devices in kernel list: %d\\n\", total_devices);\n    \n    printk(KERN_INFO \"Linked list demonstration completed\\n\");\n    \n    return 0;\n}\n\nstatic void __exit linked_lists_exit(void)\n{\n    printk(KERN_INFO \"Linked lists module unloading\\n\");\n    \n    /* Clean up all devices */\n    cleanup_all_devices();\n    \n    printk(KERN_INFO \"Linked lists module unloaded\\n\");\n}\n\nmodule_init(linked_lists_init);\nmodule_exit(linked_lists_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning linked list patterns for kernel development\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "VISUAL_GUIDE.md",
        "content": "# Circular Doubly-Linked List - Visual Guide\n\n## Understanding the Pattern\n\nThis guide uses **generic examples** (not the specific problem solution) to help you understand circular doubly-linked list operations step-by-step.\n\n---\n\n## CRITICAL CONCEPTS: Head vs Nodes\n\nBefore diving into operations, you MUST understand these fundamental concepts, as they're the source of most confusion:\n\n### What is a \"Node\"?\n\nA **node** is the ENTIRE data structure, not just the list pointers:\n\n```c\nstruct device_entry {\n    int device_id;              // Data\n    char name[32];              // Data\n    int status;                 // Data\n    struct list_head list;      // ← The list pointers (embedded)\n};\n\n// When you create a device, that's a NODE:\nstruct device_entry alice = {25, \"TempSensor\", 1, ...};\n//                    ^^^^^ \n//                    THIS IS NODE 1 (complete structure)\n```\n\n**Key Point:** The node = complete struct (data + embedded list_head)\n\n### What is \"head\"?\n\nThe **head** is a STANDALONE list_head with NO data attached:\n\n```c\nstruct list_head head;  // ← Just pointers, NO data!\n```\n\n**head is the entry/exit point** for your entire list:\n- You start traversing at `head->next` (first real node)\n- You stop when you circle back to `head`\n- It's the anchor that holds the structure together\n\n### Memory Layout: What's Actually in Memory?\n\n```\nhead (standalone list_head)\n├─ next → pointer to first node's list member\n└─ prev → pointer to last node's list member\n\nnode1 (alice struct in memory)\n├─ device_id: 25\n├─ name: \"TempSensor\"\n├─ status: 1\n└─ list (the list_head inside alice)\n   ├─ next → node2.list\n   └─ prev → head\n\nnode2 (bob struct in memory)\n├─ device_id: 30\n├─ name: \"MotorCtrl\"\n├─ status: 1\n└─ list (the list_head inside bob)\n   ├─ next → head (circular!)\n   └─ prev → node1.list\n```\n\n### The Embedded List Pattern Explained\n\nTraditional (wasteful):\n```\n[data1|next] → [data2|next] → [data3|next] → NULL\nEach list node separate from data\n```\n\nKernel Pattern (efficient):\n```\nnode1: [device_id|name|status|list_head]\nnode2: [device_id|name|status|list_head]\nnode3: [device_id|name|status|list_head]\n\nList pointers are INSIDE the data structures!\n```\n\n**Benefits of embedded pattern:**\n- Generic: same `list_head` works for ANY struct\n- Efficient: no separate memory for list nodes\n- Flexible: one struct can be in multiple lists\n\n---\n\n## UNDERSTANDING DOUBLE POINTERS: `node->list.prev->next`\n\nThis confuses many students. Let's break it down:\n\n### Single Pointer: `dev->list.prev`\n\n```c\ndev->list.prev\n├─ dev: the device struct you're operating on\n├─ list: the list_head MEMBER inside dev\n└─ prev: the POINTER that points to the previous node's list_head\n```\n\n**Result:** `dev->list.prev` gives you the address of the previous node's list_head\n\n### Double Pointer: `dev->list.prev->next`\n\n```c\ndev->list.prev->next\n├─ dev->list.prev: the PREVIOUS node's list_head\n└─ ->next: the next POINTER OF the previous node\n```\n\n**Result:** `dev->list.prev->next` gives you access to the previous node's `.next` pointer\n\n### Visual Example: Why We Use It\n\nWhen removing bob:\n\n```\nBEFORE:\nhead → bob → alice → head\n\nWe want to CHANGE: head.next (currently points to bob)\nWe want to CHANGE IT TO: alice\n\nStep: head->next->prev = dev->list.next;\n      ^^^^^^^^^^^^^^ this is head's next pointer\n                       ↓\nBetter way to write it: dev->list.prev->next = dev->list.next;\n                        ^^^^^^^^^^^^^^^^^ still the same thing!\n                        (dev.prev = head, so head.next = what we're changing)\n```\n\n**The pattern:** When removing a node, you DON'T change the node's own pointers. You change the NEIGHBORS' pointers to skip over it!\n\n---\n\n## Core Concept: Embedded List Pattern\n\nInstead of the traditional approach where list nodes contain data:\n```\nTraditional: [prev|data|next] -> [prev|data|next] -> NULL\n```\n\nKernel pattern embeds the list node INSIDE your data structure:\n```\nKernel: Your data structure contains a list_head member\nstruct person {\n    int age;\n    char name[32];\n    struct list_head list;  // <-- Just the links!\n};\n```\n\n---\n\n## Operation 1: Initialize Empty List\n\n**Goal:** Create an empty circular list where head points to itself.\n\n**Visual:**\n\n```\nBEFORE (uninitialized):\n         head\n    ┌──────────┐\n    │ next  = ???\n    │ prev  = ???\n    └──────────┘\n\nAFTER initialization:\n         ┌─────────┐\n         ↓         │\n        head       │\n    ┌──────────┐   │\n    │ next  ───┼───┘\n    │ prev  ───┼───┐\n    └──────────┘   │\n         ↑         │\n         └─────────┘\n\n(Circular: points to itself = empty list)\n```\n\n**Pattern to learn:**\n- Set `head->next = head`\n- Set `head->prev = head`\n- Result: head is both the \"next\" and \"prev\" of itself\n\n**Why self-referential?** An empty list where head points to itself is elegant because:\n- Empty check: `if (head->next == head)` → list is empty\n- Traversal: `for (p = head->next; p != head; p = p->next)` → loop never runs\n- No special NULL cases to handle\n\n---\n\n## Operation 2: Add First Item to List\n\n**Goal:** Insert the first item right after head.\n\nLet's add a person named \"Alice\" (age 25):\n\n**Initial state (empty list):**\n```\n         ┌─────┐\n         ↓     │\n        head   │\n        ═══════┘  (points to itself)\n\nalice (not yet linked)\n    ┌──────────────────┐\n    │ age: 25          │\n    │ name: \"Alice\"    │\n    │ ┌────────────┐   │\n    │ │ next = ??? │   │\n    │ │ prev = ??? │   │\n    │ └────────────┘   │\n    └──────────────────┘\n```\n\n**Step 1: alice->list.next = head->next;**\n```\nalice now knows what comes \"next\" (currently head)\n\n        head\n    ┌──────────┐\n    │ next  ───┼────┐\n    └──────────┘    │\n                    │\n    alice           │\n    ┌──────────────────┐\n    │ age: 25       │  │\n    │ ┌──────────┐  │  │\n    │ │ next  ───┼──┘  │\n    │ │ prev  = ???    │\n    │ └──────────┘     │\n    └──────────────────┘\n    Points to head\n```\n\n**Step 2: alice->list.prev = head;**\n```\nalice now knows what comes \"before\" (head)\n\n        head\n    ┌──────────┐\n         ↑\n         │\n    alice│\n    ┌────┼─────────────┐\n    │ age: 25          │\n    │ ┌──┼───────┐     │\n    │ │ next  → head   │\n    │ │ prev  → head   │\n    │ └──────────┘     │\n    └──────────────────┘\n    Points to head\n```\n\n**Step 3: head->next->prev = &alice->list;**\n```\nTell the old first node (currently head) that alice comes before it\n\n        head\n    ┌──────────┐\n    │ next  ───┼──→ (still points to head, will update next)\n    │ prev  ───┼──→ alice  ← CHANGED!\n    └──────────┘\n\nWHY THIS ORDER?\nIf you did Step 4 BEFORE Step 3, you'd lose the reference to head!\nAlways update the neighbors BEFORE updating the pointer that helps you find them.\n```\n\n**Step 4: head->next = &alice->list;**\n```\nUpdate head to point forward to alice\n\nFINAL STATE:\n        head ←─────────────────────┐\n    ┌──────────┐                   │\n    │ next  ───┼──┐                │\n    │ prev  ───┼──┼────────┐       │\n    └──────────┘  │        │       │\n                  │        │       │\n              alice ───────┘       │\n         ┌──────────────────────┐  │\n         │ age: 25              │  │\n         │ name: \"Alice\"        │  │\n         │ ┌──────────┐         │  │\n         └─│ next  ───┼─────────┴──┤\n           │ prev  ───┼────────────┘\n           └──────────┘\n\nList: head ↔ alice ↔ head (circular)\n```\n\n**Critical Rule:** When adding a node:\n1. Set new node's pointers FIRST (knows where it fits)\n2. Update neighbors' pointers SECOND (they point to new node)\n3. Update head LAST (head now points to new node)\n\nThis order ensures you never lose references!\n\n---\n\n## Operation 3: Add Second Item\n\n**Goal:** Add \"Bob\" (age 30) to the list.\n\n**Current state:**\n```\nhead ↔ alice ↔ head\n```\n\n**After adding Bob using same 4-step pattern:**\n```\nhead ↔ bob ↔ alice ↔ head\n\n        head ←─────────────────────────────────┐\n    ┌──────────┐                               │\n    │ next  ───┼──┐                            │\n    │ prev  ───┼──┼────────┐                   │\n    └──────────┘  │        │                   │\n                  │        │                   │\n               bob│        │                   │\n         ┌────────────────┐│                   │\n         │ age: 30        ││                   │\n         │ name: \"Bob\"    ││                   │\n         └─┌──────────┐───┘│                   │\n           │ next  ───┼───┐│                   │\n           │ prev  ───┼───┼┼───────────────────┤\n           └──────────┘   ││                   │\n                  │       ││                   │\n              alice ──────┼┘                   │\n         ┌────────────────┼─────┐              │\n         │ age: 25        │     │              │\n         │ name: \"Alice\"  │     │              │\n         │ ┌──────────┐   │     │              │\n         └─│ next  ───┼───┼─────┴──────────────┘\n           │ prev  ───┼───┘\n           └──────────┘\n```\n\n**Pattern:** Adding at head always inserts at the FRONT of the list.\n\n---\n\n## Operation 4: Remove Item from List\n\n**Goal:** Remove Bob from the middle of the list.\n\n**Current state:**\n```\nhead ↔ bob ↔ alice ↔ head\n```\n\n**Complete pointer view BEFORE removal:**\n```\nhead struct:\n    ├─ next → bob.list      (points to bob's list_head)\n    └─ prev → alice.list    (points to alice's list_head)\n\nbob struct:\n    └─ list\n       ├─ next → alice.list  (points to alice's list_head)\n       └─ prev → head        (points to head)\n\nalice struct:\n    └─ list\n       ├─ next → head        (points to head)\n       └─ prev → bob.list    (points to bob's list_head)\n```\n\n**Step 1: bob->list.prev->next = bob->list.next;**\n\nBreaking it down:\n```\nbob->list.prev              = head (bob's previous node)\nbob->list.prev->next        = head.next (the pointer we're changing)\nbob->list.next              = alice.list (what we want head.next to point to)\n\nResult: head.next = alice.list (skip bob!)\n```\n\n```\nVisual - Tell Bob's previous node (head) to skip Bob and point to Bob's next (alice)\n\n         head                     bob                       alice\n    ┌──────────┐         ┌──────────────────┐        ┌────────────┐\n    │ next  ───┼────────────────────────────────────→│ list       │\n    │ prev     │         │                  │        │            │\n    └──────────┘         └──────────────────┘        └────────────┘\n    \n    Before: head.next → bob.list\n    After:  head.next → alice.list (CHANGED!)\n```\n\n**Step 2: bob->list.next->prev = bob->list.prev;**\n\nBreaking it down:\n```\nbob->list.next              = alice.list (bob's next node)\nbob->list.next->prev        = alice.list.prev (the pointer we're changing)\nbob->list.prev              = head (what we want alice.prev to point to)\n\nResult: alice.prev = head (alice now points back to head)\n```\n\n```\nVisual - Tell Bob's next node (alice) to point back to Bob's previous (head)\n\n         head                     bob                       alice\n    ┌──────────┐         ┌──────────────────┐        ┌────────────┐\n    │ next  ───┼────────────────────────────────────→│ list       │\n    │          │         │                  │        │            │\n    │ prev  ←──┼─────────────────────────────────────┼─ prev      │\n    └──────────┘         └──────────────────┘        └────────────┘\n    \n    Before: alice.prev → bob.list\n    After:  alice.prev → head (CHANGED!)\n```\n\n**Now Bob is unlinked!**\n```\nList becomes: head ↔ alice ↔ head\nBob is floating, not pointed to by anyone.\n```\n\n**Step 3 & 4: Reinitialize Bob's pointers (safety)**\n```\nbob->list.next = &bob->list;\nbob->list.prev = &bob->list;\n\nBob is now isolated (points to itself):\n          ┌──────────────┐\n          ↓              │\n         bob             │\n    ┌──────────────────┐ │\n    │ age: 30          │ │\n    │ name: \"Bob\"      │ │\n    │ ┌──────────┐     │ │\n    │ │ next  ───┼─────┼─┘\n    │ │ prev  ───┼─────┼─┐\n    │ └──────────┘     │ │\n    └──────────────────┘ │\n          ↑              │\n          └──────────────┘\n```\n\n**Why reinitialize?** Makes the node safe to delete or re-add later without dangling pointers.\n\n---\n\n## Operation 5: Check if List is Empty\n\n**Pattern:** A list is empty when `head->next == head`\n\n**Empty list:**\n```\n          ┌──────────┐\n          ↓          │\n         head        │\n    ┌──────────┐     │\n    │ next  ───┼─────┘\n    │ prev  ───┼─────┐\n    └──────────┘     │\n          ↑          │\n          └──────────┘\n\nPoints to itself\nhead->next == head  → TRUE → List is EMPTY\n```\n\n**Non-empty list:**\n```\nhead ↔ alice ↔ head\n\n         head              alice\n    ┌──────────┐     ┌──────────────┐\n    │ next  ───┼──→  │ list member  │\n    │ prev     │     │              │\n    └──────────┘     └──────────────┘\n\nhead->next == head  → FALSE (points to alice) → List is NOT EMPTY\n```\n\n---\n\n## Operation 6: Traverse the List\n\n**Goal:** Visit every item in the list and access their data.\n\n**The Challenge:** When you traverse, you get pointers to `list_head`, but you need the full structure (device_entry)!\n\n**Pattern:**\n```c\nstruct list_head *pos;\nstruct device_entry *dev;\n\nfor (pos = head->next; pos != head; pos = pos->next) {\n    // pos points to the 'list' member inside a device_entry struct\n    // Use container_of to get the device_entry struct!\n    dev = container_of(pos, struct device_entry, list);\n    //  ^             ^    ^                      ^\n    //  |             |    |                      |\n    //  result     pointer type                member name\n    \n    // Now you can access dev->device_id, dev->name, etc.\n}\n```\n\n**Visual explanation:**\n```\nList: head ↔ alice ↔ bob ↔ head\n\nITERATION 1:\n    pos = head->next  →  pos points to alice's list member\n\n         head              alice              bob\n    ┌──────────┐     ┌──────────────────┐\n    │ next  ───┼──→  │ device_id: 25    │\n    └──────────┘     │ name: \"Alice\"    │\n                     │ status: 1        │\n                     │ ┌──────────┐     │\n                     │ │  list    │ ←─── pos points HERE\n                     │ └──────────┘     │\n                     └──────────────────┘\n                              ↑\n                              │\n                container_of calculates THIS\n                (start of device_entry struct from list member)\n\n    dev = container_of(pos, struct device_entry, list);\n    // Now dev points to the start of alice struct\n    // Can access: dev->device_id (25), dev->name (\"Alice\")\n\nITERATION 2:\n    pos = pos->next  →  pos points to bob's list member\n\n    dev = container_of(pos, struct device_entry, list);\n    // Now dev points to start of bob struct\n    // Can access: dev->device_id (30), dev->name (\"Bob\")\n\nLOOP EXIT:\n    pos = pos->next  →  pos points back to head\n    Check: pos != head?  → FALSE\n    Loop exits!\n```\n\n**How container_of works (the math):**\n```\nMemory layout of struct device_entry:\n    ┌──────────────┐ ← Start of struct (e.g., address 0x1000)\n    │ device_id    │\n    ├──────────────┤\n    │ name[16]     │\n    ├──────────────┤\n    │ status       │\n    ├──────────────┤ ← offset of 'list' member (e.g., 0x1028)\n    │ list.next    │ ← pos points HERE (0x1028)\n    │ list.prev    │\n    └──────────────┘\n\ncontainer_of formula:\nstruct_address = pos - offset_of(list in device_entry)\n0x1000 = 0x1028 - 0x28\n\nGives you the start of the device_entry struct!\n```\n\n---\n\n## Operation 7: Count Items\n\n**Pattern:** Traverse the list and increment a counter.\n\n```c\nint count = 0;\nstruct list_head *pos;\n\nfor (pos = head->next; pos != head; pos = pos->next) {\n    count++;\n}\n\nreturn count;\n```\n\n**Visual:**\n```\nList: head ↔ alice ↔ bob ↔ charlie ↔ head\n\ncount = 0\n\nVisit alice   → count = 1\nVisit bob     → count = 2\nVisit charlie → count = 3\n\nReturn 3\n```\n\n---\n\n## Operation 8: Search for Specific Item\n\n**Pattern:** Traverse and compare each item's data.\n\n**Example: Find device with device_id 30**\n```c\nstruct list_head *pos;\nstruct device_entry *dev;\n\nfor (pos = head->next; pos != head; pos = pos->next) {\n    dev = container_of(pos, struct device_entry, list);\n    if (dev->device_id == 30) {\n        return dev;  // Found Bob!\n    }\n}\n\nreturn NULL;  // Not found\n```\n\n**Visual:**\n```\nSearching for device_id == 30:\n\nList: head ↔ alice(25) ↔ bob(30) ↔ charlie(35) ↔ head\n\nITERATION 1: Visit alice\n    dev->device_id == 30?  → NO (25 != 30)\n    Continue...\n\nITERATION 2: Visit bob\n    dev->device_id == 30?  → YES! ✓\n    return bob;\n\nCaller receives pointer to bob struct:\n    ┌──────────────────┐\n    │ device_id: 30    │ ← Can access all fields\n    │ name: \"Bob\"      │\n    │ status: 1        │\n    │ list: {...}      │\n    └──────────────────┘\n```\n\n---\n\n## Operation 9: Safe Cleanup (Delete All)\n\n**The Problem:** You can't use regular traversal when deleting nodes!\n\n**Why?** After deleting a node, `pos->next` is invalid!\n\n**Solution:** Use \"safe\" traversal with TWO pointers:\n```c\nstruct device_entry *dev, *tmp;\n\nlist_for_each_entry_safe(dev, tmp, &head, list) {\n    //                   ^    ^     ^\n    //                   |    |     |\n    //              current saved  head\n    \n    list_del(&dev->list);  // Remove from list\n    kfree(dev);            // Free memory\n}\n```\n\n**Visual explanation:**\n```\nINITIAL:\nhead ↔ alice ↔ bob ↔ charlie ↔ head\n\nITERATION 1:\n    dev = alice\n    tmp = bob  (saved for next iteration!)\n    \n    list_del(&alice->list)  → Remove alice from list\n    kfree(alice)            → Free alice's memory\n    \n    Result: head ↔ bob ↔ charlie ↔ head\n    alice is DELETED (memory freed)\n\nITERATION 2:\n    dev = tmp (which is bob)\n    tmp = charlie  (saved!)\n    \n    list_del(&bob->list)\n    kfree(bob)\n    \n    Result: head ↔ charlie ↔ head\n    bob is DELETED\n\nITERATION 3:\n    dev = tmp (which is charlie)\n    tmp = head  (no more items)\n    \n    list_del(&charlie->list)\n    kfree(charlie)\n    \n    Result: head ↔ head (empty!)\n    charlie is DELETED\n\nFINAL STATE:\n          ┌──────────┐\n          ↓          │\n         head        │\n    ┌──────────┐     │\n    │ next  ───┼─────┘\n    │ prev  ───┼─────┐\n    └──────────┘     │\n          ↑          │\n          └──────────┘\n    \nAll items freed!\nAll memory cleaned up!\n```\n\n**Why two pointers?**\n- `tmp` saves the next node BEFORE we delete the current node\n- Without this, we'd lose track of where to go next!\n\n---\n\n## Summary: The Four Pointer Operations\n\nEvery linked list operation boils down to updating pointers correctly:\n\n**1. Initialize:**\n```\nhead->next = head;\nhead->prev = head;\n```\n\n**2. Add (4 steps - ORDER MATTERS!):**\n```\nnew->list.next = head->next;     // Step 1: new knows next\nnew->list.prev = head;            // Step 2: new knows prev\nhead->next->prev = &new->list;    // Step 3: old first knows new\nhead->next = &new->list;          // Step 4: head knows new\n```\n\n**3. Remove (4 steps):**\n```\nnode->list.prev->next = node->list.next;  // Step 1: skip forward\nnode->list.next->prev = node->list.prev;  // Step 2: skip backward\nnode->list.next = &node->list;            // Step 3: reinit (safety)\nnode->list.prev = &node->list;            // Step 4: reinit (safety)\n```\n\n**4. Traverse:**\n```\nfor (pos = head->next; pos != head; pos = pos->next) {\n    item = container_of(pos, struct type, list);\n    // Use item->data\n}\n```\n\n---\n\n## Key Insights\n\n1. **Circular means no NULL** - Last node points back to head, never breaks the chain\n2. **Doubly-linked means bidirectional** - Can traverse forward AND backward\n3. **Head is the anchor** - Entry/exit point for the entire list, not a data node\n4. **Nodes are complete structs** - Data + embedded list_head, not just pointers\n5. **Embedded pattern is generic** - Same list_head works for ANY struct type\n6. **Order matters when updating** - Update neighbors before losing references\n7. **Double pointers access neighbor pointers** - `node->list.prev->next` accesses previous node's next pointer\n8. **container_of is magic** - Gets you from list member back to full struct\n9. **Safe deletion needs two pointers** - Save next pointer before deleting current\n10. **Circular elegance** - Self-pointing empty list eliminates special cases\n\n---\n\nNow apply these patterns to your specific problem! The operations are the same, just adapt the struct name and field names.\n",
        "readOnly": true,
        "language": "txt"
      },
      {
        "name": "Makefile",
        "content": "# Linked lists module Makefile\nobj-m += linked_lists.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "linked_lists.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "linked_lists_init",
          "linked_lists_exit",
          "manual_init_list",
          "manual_add_device",
          "manual_remove_device",
          "manual_is_empty",
          "manual_traverse_list",
          "kernel_add_device",
          "kernel_traverse_list",
          "find_device_by_id",
          "count_total_devices",
          "cleanup_all_devices"
        ],
        "function_declarations": [
          {
            "name": "manual_init_list",
            "returnType": "void",
            "parameters": [
              "struct list_head *head"
            ]
          },
          {
            "name": "manual_add_device",
            "returnType": "void",
            "parameters": [
              "struct device_entry *dev",
              "struct list_head *head"
            ]
          },
          {
            "name": "manual_remove_device",
            "returnType": "void",
            "parameters": [
              "struct device_entry *dev"
            ]
          },
          {
            "name": "manual_is_empty",
            "returnType": "int",
            "parameters": [
              "struct list_head *head"
            ]
          },
          {
            "name": "manual_traverse_list",
            "returnType": "void",
            "parameters": [
              "struct list_head *head"
            ]
          },
          {
            "name": "kernel_add_device",
            "returnType": "void",
            "parameters": [
              "struct device_entry *dev"
            ]
          },
          {
            "name": "kernel_traverse_list",
            "returnType": "void",
            "parameters": []
          },
          {
            "name": "find_device_by_id",
            "returnType": "struct device_entry*",
            "parameters": [
              "int device_id"
            ]
          },
          {
            "name": "count_total_devices",
            "returnType": "int",
            "parameters": []
          },
          {
            "name": "cleanup_all_devices",
            "returnType": "void",
            "parameters": []
          }
        ],
        "variables_declarations": [
          {
            "name": "device_entry",
            "type": "struct",
            "value": "{int device_id; char name[MAX_DEVICE_NAME]; int status; struct list_head list;}",
            "storageClass": "none"
          },
          {
            "name": "manual_device_list",
            "type": "struct list_head",
            "storageClass": "extern"
          },
          {
            "name": "kernel_device_list",
            "type": "struct list_head",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "manual_device_list",
            "type": "struct list_head",
            "storageClass": "none"
          },
          {
            "name": "kernel_device_list",
            "type": "struct list_head",
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Linked lists module loaded",
          "Testing manual list operations",
          "Manually added device: TempSensor (ID: 1001)",
          "Manually added device: MotorCtrl (ID: 1002)",
          "Manually added device: LEDStrip (ID: 1003)",
          "Manual list empty: 0",
          "Manual traversal - Device: LEDStrip (ID: 1003, Status: 0)",
          "Manual traversal - Device: MotorCtrl (ID: 1002, Status: 1)",
          "Manual traversal - Device: TempSensor (ID: 1001, Status: 1)",
          "Manually removed device: MotorCtrl (ID: 1002)",
          "Testing kernel macro operations",
          "Kernel added device: TempSensor (ID: 1001)",
          "Kernel added device: MotorCtrl (ID: 1002)",
          "Kernel added device: LEDStrip (ID: 1003)",
          "Kernel traversal - Device: LEDStrip (ID: 1003, Status: 0)",
          "Kernel traversal - Device: MotorCtrl (ID: 1002, Status: 1)",
          "Kernel traversal - Device: TempSensor (ID: 1001, Status: 1)",
          "Found device: TempSensor (ID: 1001)",
          "Total devices in kernel list: 3",
          "Linked list demonstration completed",
          "Linked lists module unloading",
          "Cleaned up device: LEDStrip",
          "Cleaned up device: MotorCtrl",
          "Cleaned up device: TempSensor",
          "Linked lists module unloaded"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h",
          "linux/slab.h",
          "linux/list.h"
        ],
        "mustContain": [
          "head->next = head",
          "head->prev = head",
          "dev->list.next = head->next",
          "dev->list.prev = head",
          "head->next->prev = &dev->list",
          "head->next = &dev->list",
          "dev->list.prev->next = dev->list.next",
          "dev->list.next->prev = dev->list.prev",
          "head->next == head",
          "pos = head->next; pos != head; pos = pos->next",
          "list_add(&dev->list, &kernel_device_list)",
          "list_for_each_entry(",
          "list_for_each_entry_safe(",
          "list_del(",
          "kfree(",
          "INIT_LIST_HEAD(",
          "module_param(test_device_id, int, 0644)",
          "module_param(test_device_count, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void manual_init_list(struct list_head *head)",
            "void manual_add_device(struct device_entry *dev, struct list_head *head)",
            "void manual_remove_device(struct device_entry *dev)",
            "int manual_is_empty(struct list_head *head)",
            "void manual_traverse_list(struct list_head *head)",
            "void kernel_add_device(struct device_entry *dev)",
            "void kernel_traverse_list(void)",
            "struct device_entry* find_device_by_id(int device_id)",
            "int count_total_devices(void)",
            "void cleanup_all_devices(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void manual_init_list(struct list_head *head)",
            "void manual_add_device(struct device_entry *dev, struct list_head *head)",
            "void manual_remove_device(struct device_entry *dev)",
            "int manual_is_empty(struct list_head *head)",
            "void manual_traverse_list(struct list_head *head)",
            "void kernel_add_device(struct device_entry *dev)",
            "void kernel_traverse_list(void)",
            "struct device_entry* find_device_by_id(int device_id)",
            "int count_total_devices(void)",
            "void cleanup_all_devices(void)",
            "static int __init linked_lists_init(void)",
            "static void __exit linked_lists_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Linked lists module loaded",
              "exact": true,
              "linkedFunction": "static int __init linked_lists_init(void)"
            },
            {
              "pattern": "Testing manual list operations",
              "exact": true,
              "linkedFunction": "static int __init linked_lists_init(void)"
            },
            {
              "pattern": "Manually added device: TempSensor (ID: 1001)",
              "exact": true,
              "linkedFunction": "void manual_add_device(struct device_entry *dev, struct list_head *head)"
            },
            {
              "pattern": "Manually added device: MotorCtrl (ID: 1002)",
              "exact": true,
              "linkedFunction": "void manual_add_device(struct device_entry *dev, struct list_head *head)"
            },
            {
              "pattern": "Manually added device: LEDStrip (ID: 1003)",
              "exact": true,
              "linkedFunction": "void manual_add_device(struct device_entry *dev, struct list_head *head)"
            },
            {
              "pattern": "Manual list empty: 0",
              "exact": true,
              "linkedFunction": "static int __init linked_lists_init(void)"
            },
            {
              "pattern": "Manual traversal - Device: LEDStrip (ID: 1003, Status: 0)",
              "exact": true,
              "linkedFunction": "void manual_traverse_list(struct list_head *head)"
            },
            {
              "pattern": "Manual traversal - Device: MotorCtrl (ID: 1002, Status: 1)",
              "exact": true,
              "linkedFunction": "void manual_traverse_list(struct list_head *head)"
            },
            {
              "pattern": "Manual traversal - Device: TempSensor (ID: 1001, Status: 1)",
              "exact": true,
              "linkedFunction": "void manual_traverse_list(struct list_head *head)"
            },
            {
              "pattern": "Manually removed device: MotorCtrl (ID: 1002)",
              "exact": true,
              "linkedFunction": "void manual_remove_device(struct device_entry *dev)"
            },
            {
              "pattern": "Testing kernel macro operations",
              "exact": true,
              "linkedFunction": "static int __init linked_lists_init(void)"
            },
            {
              "pattern": "Kernel added device: TempSensor (ID: 1001)",
              "exact": true,
              "linkedFunction": "void kernel_add_device(struct device_entry *dev)"
            },
            {
              "pattern": "Kernel added device: MotorCtrl (ID: 1002)",
              "exact": true,
              "linkedFunction": "void kernel_add_device(struct device_entry *dev)"
            },
            {
              "pattern": "Kernel added device: LEDStrip (ID: 1003)",
              "exact": true,
              "linkedFunction": "void kernel_add_device(struct device_entry *dev)"
            },
            {
              "pattern": "Kernel traversal - Device: LEDStrip (ID: 1003, Status: 0)",
              "exact": true,
              "linkedFunction": "void kernel_traverse_list(void)"
            },
            {
              "pattern": "Kernel traversal - Device: MotorCtrl (ID: 1002, Status: 1)",
              "exact": true,
              "linkedFunction": "void kernel_traverse_list(void)"
            },
            {
              "pattern": "Kernel traversal - Device: TempSensor (ID: 1001, Status: 1)",
              "exact": true,
              "linkedFunction": "void kernel_traverse_list(void)"
            },
            {
              "pattern": "Found device: TempSensor (ID: 1001)",
              "exact": true,
              "linkedFunction": "static int __init linked_lists_init(void)"
            },
            {
              "pattern": "Total devices in kernel list: 3",
              "exact": true,
              "linkedFunction": "static int __init linked_lists_init(void)"
            },
            {
              "pattern": "Linked list demonstration completed",
              "exact": true,
              "linkedFunction": "static int __init linked_lists_init(void)"
            },
            {
              "pattern": "Linked lists module unloading",
              "exact": true,
              "linkedFunction": "static void __exit linked_lists_exit(void)"
            },
            {
              "pattern": "Cleaned up device: LEDStrip",
              "exact": true,
              "linkedFunction": "void cleanup_all_devices(void)"
            },
            {
              "pattern": "Cleaned up device: MotorCtrl",
              "exact": true,
              "linkedFunction": "void cleanup_all_devices(void)"
            },
            {
              "pattern": "Cleaned up device: TempSensor",
              "exact": true,
              "linkedFunction": "void cleanup_all_devices(void)"
            },
            {
              "pattern": "Linked lists module unloaded",
              "exact": true,
              "linkedFunction": "static void __exit linked_lists_exit(void)"
            }
          ]
        },
        {
          "id": "advanced_linked_list_validation",
          "name": "Advanced Linked List Implementation with Anti-Hardcoding Protection",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "linked_list_dynamic_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Anti-Hardcoding Linked List Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate unpredictable test values\\n    int random_device_id = (rand() % 9000) + 1000;  // 1000-9999\\n    int random_device_count = (rand() % 3) + 2;     // 2-4 devices\\n    \\n    printf(\\\"Test 1: Random linked list operations (device_id=%d, count=%d)\\\\n\\\", random_device_id, random_device_count);\\n    \\n    // Test with random values\\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod linked_lists 2>/dev/null\\\");\\n    \\n    char cmd[256];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/linked_lists.ko test_device_id=%d test_device_count=%d\\\", random_device_id, random_device_count);\\n    printf(\\\"DEBUG: Command: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Anti-hardcoding linked list test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced linked list implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef unsigned char uint8_t;' > /tmp/linux/types.h",
              "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
              "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
              "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
              "echo '#define MAX_DEVICE_NAME 16' >> /tmp/linux/types.h",
              "echo 'void* kmalloc(size_t size, int flags);' > /tmp/linux/slab.h",
              "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
              "echo '#define GFP_KERNEL 0' >> /tmp/linux/slab.h",
              "echo 'struct list_head { struct list_head *next, *prev; };' > /tmp/linux/list.h",
              "echo '#define INIT_LIST_HEAD(ptr) do { (ptr)->next = (ptr); (ptr)->prev = (ptr); } while (0)' >> /tmp/linux/list.h",
              "echo '#define list_add(new, head) do { (new)->next = (head)->next; (new)->prev = (head); (head)->next->prev = (new); (head)->next = (new); } while (0)' >> /tmp/linux/list.h",
              "echo '#define list_for_each_entry(pos, head, member) for (pos = container_of((head)->next, typeof(*pos), member); &pos->member != (head); pos = container_of(pos->member.next, typeof(*pos), member))' >> /tmp/linux/list.h",
              "echo '#define list_for_each_entry_safe(pos, n, head, member) for (pos = container_of((head)->next, typeof(*pos), member), n = container_of(pos->member.next, typeof(*pos), member); &pos->member != (head); pos = n, n = container_of(n->member.next, typeof(*n), member))' >> /tmp/linux/list.h",
              "echo '#define list_del(entry) do { (entry)->next->prev = (entry)->prev; (entry)->prev->next = (entry)->next; } while (0)' >> /tmp/linux/list.h",
              "echo '#define container_of(ptr, type, member) ((type *)((char *)(ptr) - offsetof(type, member)))' >> /tmp/linux/list.h",
              "echo '#define offsetof(type, member) ((size_t) &((type *)0)->member)' >> /tmp/linux/list.h",
              "echo 'Creating test file that includes linked lists header...'",
              "echo '#include \"/lib/modules/linked_lists.h\"' > /tmp/test.c",
              "echo 'int main() { struct list_head head; struct device_entry *dev; manual_init_list(&head); manual_add_device(dev, &head); manual_remove_device(dev); manual_is_empty(&head); manual_traverse_list(&head); kernel_add_device(dev); kernel_traverse_list(); find_device_by_id(1001); count_total_devices(); cleanup_all_devices(); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
              "echo 'Phase 2: Anti-Hardcoding Dynamic Linked List Test'",
              "/bin/linked_list_dynamic_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Random Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "DEVICE_ID=$(grep -o 'Random linked list operations (device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
              "DEVICE_COUNT=$(grep -o 'count=[0-9]*)' /tmp/test_output.log | cut -d'=' -f2 | cut -d')' -f1)",
              "echo 'Extracted values: DEVICE_ID='$DEVICE_ID', DEVICE_COUNT='$DEVICE_COUNT",
              "if [ -z \"$DEVICE_ID\" ] || [ -z \"$DEVICE_COUNT\" ]; then echo 'FAIL: Could not extract random test values'; else echo 'PASS: Random values extracted successfully'; fi",
              "echo 'Phase 4: Anti-Hardcoding Validation with Random Values'",
              "echo 'Validating linked list operations with random device ID '$DEVICE_ID",
              "dmesg | grep \"TempSensor (ID: $DEVICE_ID)\" && echo 'PASS: Linked list operations with random device ID working' || echo 'FAIL: Linked list operations with random device ID broken'",
              "echo 'Phase 5: Linked List Implementation Validation'",
              "dmesg | grep 'Manually added device:' && echo 'PASS: Manual add operations working' || echo 'FAIL: Manual add operations broken'",
              "dmesg | grep 'Manual traversal - Device:' && echo 'PASS: Manual traversal working' || echo 'FAIL: Manual traversal broken'",
              "dmesg | grep 'Manually removed device:' && echo 'PASS: Manual remove operations working' || echo 'FAIL: Manual remove operations broken'",
              "dmesg | grep 'Kernel added device:' && echo 'PASS: Kernel macro operations working' || echo 'FAIL: Kernel macro operations broken'",
              "dmesg | grep 'Kernel traversal - Device:' && echo 'PASS: Kernel traversal working' || echo 'FAIL: Kernel traversal broken'",
              "echo 'Phase 6: Advanced List Operations Validation'",
              "dmesg | grep 'Found device:' && echo 'PASS: Device search working' || echo 'FAIL: Device search broken'",
              "dmesg | grep 'Total devices in kernel list: 3' && echo 'PASS: Device counting working' || echo 'FAIL: Device counting broken'",
              "dmesg | grep 'Cleaned up device:' && echo 'PASS: Device cleanup working' || echo 'FAIL: Device cleanup broken'",
              "echo 'Phase 7: Module Operations Validation'",
              "dmesg | grep 'Linked lists module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
              "dmesg | grep 'Linked lists module unloaded' && echo 'PASS: Module cleanup working' || echo 'FAIL: Module cleanup broken'",
              "echo 'All linked list implementation validations completed'"
            ],
            "expected": {
              "dmesg": [
                "Linked lists module loaded",
                "Testing manual list operations",
                "Manually added device: .*",
                "Manual list empty: 0",
                "Manual traversal - Device: .*",
                "Manually removed device: .*",
                "Testing kernel macro operations",
                "Kernel added device: .*",
                "Kernel traversal - Device: .*",
                "Found device: .*",
                "Total devices in kernel list: .*",
                "Linked list demonstration completed",
                "Linked lists module unloading",
                "Cleaned up device: .*",
                "Linked lists module unloaded"
              ],
              "stdout": [
                "PASS: All function and variable declarations found in header file",
                "SUCCESS: Anti-hardcoding linked list test completed",
                "PASS: Random values extracted successfully",
                "PASS: Linked list operations with random device ID working",
                "PASS: Manual add operations working",
                "PASS: Manual traversal working",
                "PASS: Manual remove operations working",
                "PASS: Kernel macro operations working",
                "PASS: Kernel traversal working",
                "PASS: Device search working",
                "PASS: Device counting working",
                "PASS: Device cleanup working",
                "PASS: Module initialization working",
                "PASS: Module cleanup working"
              ]
            },
            "timeout": 15
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Linked lists module loaded",
        "Testing manual list operations",
        "Manually added device: TempSensor (ID: 1001)",
        "Manually added device: MotorCtrl (ID: 1002)",
        "Manually added device: LEDStrip (ID: 1003)",
        "Manual list empty: 0",
        "Manual traversal - Device: LEDStrip (ID: 1003, Status: 0)",
        "Manual traversal - Device: MotorCtrl (ID: 1002, Status: 1)",
        "Manual traversal - Device: TempSensor (ID: 1001, Status: 1)",
        "Manually removed device: MotorCtrl (ID: 1002)",
        "Testing kernel macro operations",
        "Kernel added device: TempSensor (ID: 1001)",
        "Kernel added device: MotorCtrl (ID: 1002)",
        "Kernel added device: LEDStrip (ID: 1003)",
        "Kernel traversal - Device: LEDStrip (ID: 1003, Status: 0)",
        "Kernel traversal - Device: MotorCtrl (ID: 1002, Status: 1)",
        "Kernel traversal - Device: TempSensor (ID: 1001, Status: 1)",
        "Found device: TempSensor (ID: 1001)",
        "Total devices in kernel list: 3",
        "Linked list demonstration completed",
        "Linked lists module unloading",
        "Cleaned up device: LEDStrip",
        "Cleaned up device: MotorCtrl",
        "Cleaned up device: TempSensor",
        "Linked lists module unloaded"
      ],
      "requirements": [
        "Use required function names: linked_lists_init, linked_lists_exit, manual_init_list, manual_add_device, manual_remove_device, manual_is_empty, manual_traverse_list, kernel_add_device, kernel_traverse_list, find_device_by_id, count_total_devices, cleanup_all_devices",
        "Use required variable names: manual_device_list, kernel_device_list",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h, linux/slab.h, linux/list.h",
        "Code must contain: head->next = head, head->prev = head, dev->list.next = head->next, dev->list.prev = head, head->next->prev = &dev->list, head->next = &dev->list, dev->list.prev->next = dev->list.next, dev->list.next->prev = dev->list.prev, head->next == head, pos = head->next; pos != head; pos = pos->next, list_add(&dev->list, &kernel_device_list), list_for_each_entry(, list_for_each_entry_safe(, list_del(, kfree(, INIT_LIST_HEAD(, module_param(test_device_id, int, 0644), module_param(test_device_count, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Linked lists module loaded",
          "linkedFunction": "static int __init linked_lists_init(void)",
          "exact": true
        },
        {
          "pattern": "Testing manual list operations",
          "linkedFunction": "static int __init linked_lists_init(void)",
          "exact": true
        },
        {
          "pattern": "Manually added device: TempSensor (ID: 1001)",
          "linkedFunction": "void manual_add_device(struct device_entry *dev, struct list_head *head)",
          "exact": true
        },
        {
          "pattern": "Manually added device: MotorCtrl (ID: 1002)",
          "linkedFunction": "void manual_add_device(struct device_entry *dev, struct list_head *head)",
          "exact": true
        },
        {
          "pattern": "Manually added device: LEDStrip (ID: 1003)",
          "linkedFunction": "void manual_add_device(struct device_entry *dev, struct list_head *head)",
          "exact": true
        },
        {
          "pattern": "Manual list empty: 0",
          "linkedFunction": "static int __init linked_lists_init(void)",
          "exact": true
        },
        {
          "pattern": "Manual traversal - Device: LEDStrip (ID: 1003, Status: 0)",
          "linkedFunction": "void manual_traverse_list(struct list_head *head)",
          "exact": true
        },
        {
          "pattern": "Manual traversal - Device: MotorCtrl (ID: 1002, Status: 1)",
          "linkedFunction": "void manual_traverse_list(struct list_head *head)",
          "exact": true
        },
        {
          "pattern": "Manual traversal - Device: TempSensor (ID: 1001, Status: 1)",
          "linkedFunction": "void manual_traverse_list(struct list_head *head)",
          "exact": true
        },
        {
          "pattern": "Manually removed device: MotorCtrl (ID: 1002)",
          "linkedFunction": "void manual_remove_device(struct device_entry *dev)",
          "exact": true
        },
        {
          "pattern": "Testing kernel macro operations",
          "linkedFunction": "static int __init linked_lists_init(void)",
          "exact": true
        },
        {
          "pattern": "Kernel added device: TempSensor (ID: 1001)",
          "linkedFunction": "void kernel_add_device(struct device_entry *dev)",
          "exact": true
        },
        {
          "pattern": "Kernel added device: MotorCtrl (ID: 1002)",
          "linkedFunction": "void kernel_add_device(struct device_entry *dev)",
          "exact": true
        },
        {
          "pattern": "Kernel added device: LEDStrip (ID: 1003)",
          "linkedFunction": "void kernel_add_device(struct device_entry *dev)",
          "exact": true
        },
        {
          "pattern": "Kernel traversal - Device: LEDStrip (ID: 1003, Status: 0)",
          "linkedFunction": "void kernel_traverse_list(void)",
          "exact": true
        },
        {
          "pattern": "Kernel traversal - Device: MotorCtrl (ID: 1002, Status: 1)",
          "linkedFunction": "void kernel_traverse_list(void)",
          "exact": true
        },
        {
          "pattern": "Kernel traversal - Device: TempSensor (ID: 1001, Status: 1)",
          "linkedFunction": "void kernel_traverse_list(void)",
          "exact": true
        },
        {
          "pattern": "Found device: TempSensor (ID: 1001)",
          "linkedFunction": "static int __init linked_lists_init(void)",
          "exact": true
        },
        {
          "pattern": "Total devices in kernel list: 3",
          "linkedFunction": "static int __init linked_lists_init(void)",
          "exact": true
        },
        {
          "pattern": "Linked list demonstration completed",
          "linkedFunction": "static int __init linked_lists_init(void)",
          "exact": true
        },
        {
          "pattern": "Linked lists module unloading",
          "linkedFunction": "static void __exit linked_lists_exit(void)",
          "exact": true
        },
        {
          "pattern": "Cleaned up device: LEDStrip",
          "linkedFunction": "void cleanup_all_devices(void)",
          "exact": true
        },
        {
          "pattern": "Cleaned up device: MotorCtrl",
          "linkedFunction": "void cleanup_all_devices(void)",
          "exact": true
        },
        {
          "pattern": "Cleaned up device: TempSensor",
          "linkedFunction": "void cleanup_all_devices(void)",
          "exact": true
        },
        {
          "pattern": "Linked lists module unloaded",
          "linkedFunction": "static void __exit linked_lists_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 27,
    "title": "Error Handling - Kernel Resilience Patterns",
    "difficulty": 5,
    "xp": 50,
    "phase": "foundations",
    "description": "Master essential error handling patterns for robust kernel programming. Learn standard error codes, proper cleanup patterns, and defensive programming techniques that prevent crashes and memory leaks.",
    "concepts": [
      "standard error codes",
      "parameter validation",
      "memory allocation errors",
      "resource cleanup",
      "error propagation",
      "defensive programming"
    ],
    "skills": [
      "Using standard Linux error codes",
      "Implementing proper error checking",
      "Managing memory allocation failures",
      "Writing defensive kernel code",
      "Propagating errors correctly",
      "Cleaning up resources safely"
    ],
    "files": [
      {
        "name": "error_handler.h",
        "content": "#ifndef ERROR_HANDLER_H\n#define ERROR_HANDLER_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\n#define MAX_BUFFER_SIZE 1024\n\n/* Simple device structure for error handling demonstration */\nstruct test_device {\n    int device_id;\n    char *buffer;\n    size_t buffer_size;\n    int is_initialized;\n};\n\n/* Global test device */\nextern struct test_device global_device;\n\n/* TODO: Declare your error handling functions */\n/* int validate_device_id(int device_id); */\n/* int allocate_device_buffer(struct test_device *dev, size_t size); */\n/* int initialize_device(struct test_device *dev, int device_id, size_t buffer_size); */\n/* void cleanup_device(struct test_device *dev); */\n/* const char* get_error_message(int error_code); */\n/* int process_device_operation(int device_id, size_t buffer_size); */\n\n#endif /* ERROR_HANDLER_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "error_handler.c",
        "content": "#include \"error_handler.h\"\n\n/* Global test device */\nstruct test_device global_device = {0};\n\nint test_device_id = 100;\nint test_buffer_size = 512;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n */\nmodule_param(test_device_id, int, 0644);\nMODULE_PARM_DESC(test_device_id, \"Device ID for testing error handling\");\nmodule_param(test_buffer_size, int, 0644);\nMODULE_PARM_DESC(test_buffer_size, \"Buffer size for testing error handling\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: Essential Error Handling in Linux Kernel */\n/* This teaches the CORE patterns for robust kernel programming:\n *\n * 1. STANDARD ERROR CODES:\n * -EINVAL  = Invalid argument (22)\n * -ENOMEM  = Out of memory (12)\n * -EBUSY   = Device or resource busy (16)\n * -ENODEV  = No such device (19)\n *\n * 2. ERROR CHECKING PATTERN:\n * if (bad_condition) {\n *     printk(KERN_ERR \"Error description\\n\");\n *     return -ERROR_CODE;\n * }\n *\n * 3. RESOURCE CLEANUP PATTERN:\n * ptr = kmalloc(size, GFP_KERNEL);\n * if (!ptr) {\n *     return -ENOMEM;\n * }\n * // Use ptr...\n * kfree(ptr);  // Always clean up!\n *\n * 4. ERROR PROPAGATION:\n * ret = some_function();\n * if (ret < 0) {\n *     return ret;  // Pass error up\n * }\n */\n\n/* TODO: Implement device ID validation */\nint validate_device_id(int device_id) {\n    /* TODO: Check if device_id is negative */\n    /* TODO: If negative, print error message and return -EINVAL */\n    /* TODO: Check if device_id is greater than 1000 */\n    /* TODO: If too large, print error message and return -EINVAL */\n    /* TODO: Print \"Device ID %d is valid\" */\n    /* TODO: Return 0 for success */\n    return -ENOSYS;\n}\n\n/* TODO: Implement safe buffer allocation */\nint allocate_device_buffer(struct test_device *dev, size_t size) {\n    /* TODO: Check if dev is NULL */\n    /* TODO: If NULL, return -EINVAL */\n    /* TODO: Check if size is 0 or greater than MAX_BUFFER_SIZE */\n    /* TODO: If invalid size, return -EINVAL */\n    /* TODO: Check if buffer is already allocated (dev->buffer != NULL) */\n    /* TODO: If already allocated, return -EBUSY */\n    /* TODO: Allocate memory using kmalloc(size, GFP_KERNEL) */\n    /* TODO: If allocation fails, return -ENOMEM */\n    /* TODO: Set dev->buffer and dev->buffer_size */\n    /* TODO: Print \"Allocated buffer of size %zu\" */\n    /* TODO: Return 0 for success */\n    return -ENOSYS;\n}\n\n/* TODO: Implement device initialization with error handling */\nint initialize_device(struct test_device *dev, int device_id, size_t buffer_size) {\n    /* TODO: Check if dev is NULL */\n    /* TODO: If NULL, return -EINVAL */\n    \n    /* TODO: Validate device ID using validate_device_id() */\n    /* TODO: If validation fails, return the error code */\n    \n    /* TODO: Allocate buffer using allocate_device_buffer() */\n    /* TODO: If allocation fails, return the error code */\n    \n    /* TODO: Set dev->device_id = device_id */\n    /* TODO: Set dev->is_initialized = 1 */\n    /* TODO: Print \"Device %d initialized successfully\" */\n    /* TODO: Return 0 for success */\n    return -ENOSYS;\n}\n\n/* TODO: Implement safe cleanup */\nvoid cleanup_device(struct test_device *dev) {\n    /* TODO: Check if dev is NULL */\n    /* TODO: If NULL, return early */\n    /* TODO: If dev->buffer is not NULL, free it using kfree() */\n    /* TODO: Set dev->buffer = NULL */\n    /* TODO: Set dev->buffer_size = 0 */\n    /* TODO: Set dev->is_initialized = 0 */\n    /* TODO: Print \"Device cleaned up\" */\n}\n\n/* TODO: Implement error message conversion */\nconst char* get_error_message(int error_code) {\n    /* TODO: Use switch statement to convert error codes to messages */\n    /* TODO: Case -EINVAL: return \"Invalid argument\" */\n    /* TODO: Case -ENOMEM: return \"Out of memory\" */\n    /* TODO: Case -EBUSY: return \"Device busy\" */\n    /* TODO: Case -ENODEV: return \"No such device\" */\n    /* TODO: Case 0: return \"Success\" */\n    /* TODO: Default: return \"Unknown error\" */\n    return \"Not implemented\";\n}\n\n/* TODO: Implement complete device operation with error handling */\nint process_device_operation(int device_id, size_t buffer_size) {\n    /* TODO: Initialize device using initialize_device() */\n    /* TODO: If initialization fails, print error and return error code */\n    /* TODO: Print \"Device operation completed successfully\" */\n    /* TODO: Return 0 for success */\n    return -ENOSYS;\n}\n\nstatic int __init error_handler_init(void)\n{\n    int ret;\n    \n    printk(KERN_INFO \"Error handler module loaded\\n\");\n    \n    /* Test error handling with module parameters */\n    printk(KERN_INFO \"Testing error handling with device_id=%d, buffer_size=%d\\n\", \n           test_device_id, test_buffer_size);\n    \n    /* Process device operation */\n    ret = process_device_operation(test_device_id, test_buffer_size);\n    if (ret < 0) {\n        printk(KERN_ERR \"Device operation failed: %s\\n\", get_error_message(ret));\n    } else {\n        printk(KERN_INFO \"All operations completed successfully\\n\");\n    }\n    \n    return 0;\n}\n\nstatic void __exit error_handler_exit(void)\n{\n    printk(KERN_INFO \"Error handler module unloading\\n\");\n    \n    /* Clean up the device */\n    cleanup_device(&global_device);\n    \n    printk(KERN_INFO \"Error handler module unloaded\\n\");\n}\n\nmodule_init(error_handler_init);\nmodule_exit(error_handler_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning essential error handling patterns for kernel development\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Error handling module Makefile\nobj-m += error_handler.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "error_handler.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "error_handler_init",
          "error_handler_exit",
          "validate_device_id",
          "allocate_device_buffer",
          "initialize_device",
          "cleanup_device",
          "get_error_message",
          "process_device_operation"
        ],
        "function_declarations": [
          {
            "name": "validate_device_id",
            "returnType": "int",
            "parameters": [
              "int device_id"
            ]
          },
          {
            "name": "allocate_device_buffer",
            "returnType": "int",
            "parameters": [
              "struct test_device *dev",
              "size_t size"
            ]
          },
          {
            "name": "initialize_device",
            "returnType": "int",
            "parameters": [
              "struct test_device *dev",
              "int device_id",
              "size_t buffer_size"
            ]
          },
          {
            "name": "cleanup_device",
            "returnType": "void",
            "parameters": [
              "struct test_device *dev"
            ]
          },
          {
            "name": "get_error_message",
            "returnType": "const char*",
            "parameters": [
              "int error_code"
            ]
          },
          {
            "name": "process_device_operation",
            "returnType": "int",
            "parameters": [
              "int device_id",
              "size_t buffer_size"
            ]
          }
        ],
        "variables_declarations": [
          {
            "name": "test_device",
            "type": "struct",
            "value": "{int device_id; char *buffer; size_t buffer_size; int is_initialized;}",
            "storageClass": "none"
          },
          {
            "name": "global_device",
            "type": "struct test_device",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "global_device",
            "type": "struct test_device",
            "storageClass": "none"
          },
          {
            "name": "test_device_id",
            "type": "int",
            "value": "100",
            "storageClass": "none"
          },
          {
            "name": "test_buffer_size",
            "type": "int",
            "value": "512",
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Error handler module loaded",
          "Testing error handling with device_id=100, buffer_size=512",
          "Device ID 100 is valid",
          "Allocated buffer of size 512",
          "Device 100 initialized successfully",
          "Device operation completed successfully",
          "All operations completed successfully",
          "Error handler module unloading",
          "Device cleaned up",
          "Error handler module unloaded"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h",
          "linux/slab.h",
          "linux/errno.h"
        ],
        "mustContain": [
          "kmalloc",
          "kfree",
          "-EINVAL",
          "-ENOMEM",
          "-EBUSY",
          "-ENODEV",
          "module_param(test_device_id, int, 0644)",
          "module_param(test_buffer_size, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int validate_device_id(int device_id)",
            "int allocate_device_buffer(struct test_device *dev, size_t size)",
            "int initialize_device(struct test_device *dev, int device_id, size_t buffer_size)",
            "void cleanup_device(struct test_device *dev)",
            "const char* get_error_message(int error_code)",
            "int process_device_operation(int device_id, size_t buffer_size)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int validate_device_id(int device_id)",
            "int allocate_device_buffer(struct test_device *dev, size_t size)",
            "int initialize_device(struct test_device *dev, int device_id, size_t buffer_size)",
            "void cleanup_device(struct test_device *dev)",
            "const char* get_error_message(int error_code)",
            "int process_device_operation(int device_id, size_t buffer_size)",
            "static int __init error_handler_init(void)",
            "static void __exit error_handler_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Error handler module loaded",
              "exact": true,
              "linkedFunction": "static int __init error_handler_init(void)"
            },
            {
              "pattern": "Testing error handling with device_id=100, buffer_size=512",
              "exact": true,
              "linkedFunction": "static int __init error_handler_init(void)"
            },
            {
              "pattern": "Device ID 100 is valid",
              "exact": true,
              "linkedFunction": "int validate_device_id(int device_id)"
            },
            {
              "pattern": "Allocated buffer of size 512",
              "exact": true,
              "linkedFunction": "int allocate_device_buffer(struct test_device *dev, size_t size)"
            },
            {
              "pattern": "Device 100 initialized successfully",
              "exact": true,
              "linkedFunction": "int initialize_device(struct test_device *dev, int device_id, size_t buffer_size)"
            },
            {
              "pattern": "Device operation completed successfully",
              "exact": true,
              "linkedFunction": "int process_device_operation(int device_id, size_t buffer_size)"
            },
            {
              "pattern": "All operations completed successfully",
              "exact": true,
              "linkedFunction": "static int __init error_handler_init(void)"
            },
            {
              "pattern": "Error handler module unloading",
              "exact": true,
              "linkedFunction": "static void __exit error_handler_exit(void)"
            },
            {
              "pattern": "Device cleaned up",
              "exact": true,
              "linkedFunction": "void cleanup_device(struct test_device *dev)"
            },
            {
              "pattern": "Error handler module unloaded",
              "exact": true,
              "linkedFunction": "static void __exit error_handler_exit(void)"
            }
          ]
        },
        {
          "id": "simple_error_handling_validation",
          "name": "Simple Error Handling Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "error_handling_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Error Handling Test ===\\\\n\\\");\\n    \\n    srand(time(NULL));\\n    \\n    int random_device_id = (rand() % 500) + 50;   // 50-549\\n    int random_buffer_size = (rand() % 700) + 300; // 300-999\\n    \\n    printf(\\\"Test: device_id=%d, buffer_size=%d\\\\n\\\", random_device_id, random_buffer_size);\\n    \\n    system(\\\"rmmod error_handler 2>/dev/null\\\");\\n    \\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/error_handler.ko test_device_id=%d test_buffer_size=%d\\\", random_device_id, random_buffer_size);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Error handling test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting simple error handling validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: TCC Header Validation'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef unsigned long size_t;' > /tmp/linux/types.h",
              "echo '#define MAX_BUFFER_SIZE 1024' >> /tmp/linux/types.h",
              "echo 'void* kmalloc(size_t size, int flags);' > /tmp/linux/slab.h",
              "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
              "echo '#define GFP_KERNEL 0' >> /tmp/linux/slab.h",
              "echo '#define EINVAL 22' > /tmp/linux/errno.h",
              "echo '#define ENOMEM 12' >> /tmp/linux/errno.h",
              "echo '#define EBUSY 16' >> /tmp/linux/errno.h",
              "echo '#define ENODEV 19' >> /tmp/linux/errno.h",
              "echo '#define ENOSYS 38' >> /tmp/linux/errno.h",
              "echo '#include \"/lib/modules/error_handler.h\"' > /tmp/test.c",
              "echo 'int main() { struct test_device dev; validate_device_id(100); allocate_device_buffer(&dev, 512); initialize_device(&dev, 100, 512); cleanup_device(&dev); get_error_message(-22); process_device_operation(100, 512); return 0; }' >> /tmp/test.c",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing'; cat /tmp/tcc_error.log; else echo 'PASS: All declarations found'; fi",
              "echo 'Phase 2: Dynamic Error Handling Test'",
              "/bin/error_handling_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Error Handling Validation'",
              "sleep 1",
              "dmesg | grep 'Error handler module loaded' && echo 'PASS: Module loading' || echo 'FAIL: Module loading'",
              "dmesg | grep 'Device ID .* is valid' && echo 'PASS: Device validation' || echo 'FAIL: Device validation'",
              "dmesg | grep 'Allocated buffer of size' && echo 'PASS: Buffer allocation' || echo 'FAIL: Buffer allocation'",
              "dmesg | grep 'Device .* initialized successfully' && echo 'PASS: Device initialization' || echo 'FAIL: Device initialization'",
              "dmesg | grep 'Device operation completed successfully' && echo 'PASS: Operation completion' || echo 'FAIL: Operation completion'",
              "dmesg | grep 'All operations completed successfully' && echo 'PASS: All operations' || echo 'FAIL: All operations'",
              "dmesg | grep 'Device cleaned up' && echo 'PASS: Cleanup' || echo 'FAIL: Cleanup'",
              "dmesg | grep 'Error handler module unloaded' && echo 'PASS: Module unloading' || echo 'FAIL: Module unloading'",
              "echo 'PASS: All error handling validation successful'"
            ],
            "expected": {
              "dmesg": [
                "Error handler module loaded",
                "Testing error handling with device_id=.*, buffer_size=.*",
                "Device ID .* is valid",
                "Allocated buffer of size .*",
                "Device .* initialized successfully",
                "Device operation completed successfully",
                "All operations completed successfully",
                "Error handler module unloading",
                "Device cleaned up",
                "Error handler module unloaded"
              ],
              "stdout": [
                "PASS: All declarations found",
                "SUCCESS: Error handling test completed",
                "PASS: Module loading",
                "PASS: Device validation",
                "PASS: Buffer allocation",
                "PASS: Device initialization",
                "PASS: Operation completion",
                "PASS: All operations",
                "PASS: Cleanup",
                "PASS: Module unloading",
                "PASS: All error handling validation successful"
              ]
            },
            "timeout": 30
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Error handler module loaded",
        "Testing error handling with device_id=100, buffer_size=512",
        "Device ID 100 is valid",
        "Allocated buffer of size 512",
        "Device 100 initialized successfully",
        "Device operation completed successfully",
        "All operations completed successfully",
        "Error handler module unloading",
        "Device cleaned up",
        "Error handler module unloaded"
      ],
      "requirements": [
        "Use required function names: error_handler_init, error_handler_exit, validate_device_id, allocate_device_buffer, initialize_device, cleanup_device, get_error_message, process_device_operation",
        "Use required variable names: global_device, test_device_id, test_buffer_size",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h, linux/slab.h, linux/errno.h",
        "Code must contain: kmalloc, kfree, -EINVAL, -ENOMEM, -EBUSY, -ENODEV, module_param(test_device_id, int, 0644), module_param(test_buffer_size, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Error handler module loaded",
          "linkedFunction": "static int __init error_handler_init(void)",
          "exact": true
        },
        {
          "pattern": "Testing error handling with device_id=100, buffer_size=512",
          "linkedFunction": "static int __init error_handler_init(void)",
          "exact": true
        },
        {
          "pattern": "Device ID 100 is valid",
          "linkedFunction": "int validate_device_id(int device_id)",
          "exact": true
        },
        {
          "pattern": "Allocated buffer of size 512",
          "linkedFunction": "int allocate_device_buffer(struct test_device *dev, size_t size)",
          "exact": true
        },
        {
          "pattern": "Device 100 initialized successfully",
          "linkedFunction": "int initialize_device(struct test_device *dev, int device_id, size_t buffer_size)",
          "exact": true
        },
        {
          "pattern": "Device operation completed successfully",
          "linkedFunction": "int process_device_operation(int device_id, size_t buffer_size)",
          "exact": true
        },
        {
          "pattern": "All operations completed successfully",
          "linkedFunction": "static int __init error_handler_init(void)",
          "exact": true
        },
        {
          "pattern": "Error handler module unloading",
          "linkedFunction": "static void __exit error_handler_exit(void)",
          "exact": true
        },
        {
          "pattern": "Device cleaned up",
          "linkedFunction": "void cleanup_device(struct test_device *dev)",
          "exact": true
        },
        {
          "pattern": "Error handler module unloaded",
          "linkedFunction": "static void __exit error_handler_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 28,
    "title": "Advanced X-Macros - Multi-Target Code Generation",
    "difficulty": 8,
    "xp": 80,
    "phase": "foundations",
    "description": "Master advanced X-macro patterns for sophisticated code generation. Learn to create single-source tables that auto-generate multiple related structures: enums, function stubs, switch statements, if-else chains, struct arrays, and function pointer tables. This powerful kernel programming technique is used extensively in driver registration, system call tables (SYSCALL_DEFINEx), tracepoint generation (TRACE_EVENT), and device management - eliminating repetitive code and preventing synchronization errors.",
    "concepts": [
      "advanced X-macros",
      "multi-parameter macros",
      "code generation patterns",
      "function stub generation",
      "switch statement generation",
      "if-else chain generation",
      "struct array generation",
      "function pointer tables",
      "driver registration systems",
      "define-once-use-everywhere",
      "DRY principle in kernel development"
    ],
    "skills": [
      "Creating 5-parameter X-macro tables",
      "Auto-generating function stubs from tables",
      "Generating enums from X-macros",
      "Generating switch statements from X-macros",
      "Generating if-else chains from X-macros",
      "Creating struct arrays with X-macros",
      "Building function pointer tables",
      "Implementing kernel driver registration patterns",
      "Understanding multi-target code generation",
      "Embedding table data in generated functions"
    ],
    "files": [
      {
        "name": "driver_registry.h",
        "content": "#ifndef DRIVER_REGISTRY_H\n#define DRIVER_REGISTRY_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: Advanced X-Macros - Header File Edition */\n/* ========================================================================== */\n/* This header teaches PRODUCTION X-MACRO PATTERNS used in real Linux kernel!\n *\n * LEARNING PROGRESSION: From Simple X-Macros to Multi-Target Generation\n * Problem 25: Basic X-macros with 3 parameters (name, id, description)\n * Problem 28: Advanced X-macros with 5 parameters for complete driver system\n *\n * WHAT YOU'LL LEARN IN THIS HEADER:\n * 1. How to create a master X-macro table (DRIVER_TABLE)\n * 2. Token pasting operator (##) for identifier generation\n * 3. Variadic macros (...) for flexible parameter handling\n * 4. Auto-generating enums from X-macro tables\n * 5. Auto-generating function declarations from X-macro tables\n * 6. Understanding macro expansion order and cleanup (#undef)\n */\n\n/* ========================================================================== */\n/* REAL LINUX KERNEL EXAMPLES OF X-MACRO PATTERNS: */\n/* ========================================================================== */\n/* 1. PCI Device Registration (drivers/pci/pci-driver.c):\n *    #define PCI_DEVICE(vend, dev) \\\n *        .vendor = (vend), .device = (dev)\n *    Single macro generates entire pci_device_id struct entries!\n *\n * 2. System Call Tables (arch/x86/entry/syscalls/syscall_64.tbl):\n *    SYSCALL_DEFINEx() generates BOTH function prototypes AND table entries\n *    One definition creates function signature + syscall table entry!\n *\n * 3. Tracepoint System (include/trace/events/sched.h):\n *    TRACE_EVENT(sched_switch, ...) AUTO-GENERATES trace_sched_switch() function!\n *    One macro creates registration, formatting, and runtime functions!\n *\n * 4. Error Code Management (include/uapi/asm-generic/errno-base.h):\n *    Single errno list generates error numbers AND error string arrays\n *    No manual synchronization needed!\n *\n * THIS IS THE POWER YOU'RE LEARNING! */\n\n/* Driver capability flags (used in DRIVER_TABLE) */\n#define DRV_HOTPLUG  (1 << 0)  /* Supports hot-plug/unplug */\n#define DRV_IRQ      (1 << 1)  /* Uses interrupts */\n#define DRV_DMA      (1 << 2)  /* Supports DMA */\n#define DRV_POWER    (1 << 3)  /* Power management capable */\n#define DRV_STATIC   0          /* Static device, no special flags */\n\n/* Forward declarations */\nstruct driver_info;\nstruct driver_ops;\n\n/* ========================================================================== */\n/* SECTION 1: MASTER X-MACRO TABLE DEFINITION */\n/* ========================================================================== */\n\n/* X-MACRO FUNDAMENTALS EXPLAINED: */\n/* An X-macro is a table that takes another macro as a parameter and applies\n * it to each entry. This allows ONE definition to generate MULTIPLE outputs!\n *\n * BASIC X-MACRO PATTERN:\n *   #define MY_TABLE(X) \\\n *       X(entry1_data) \\\n *       X(entry2_data) \\\n *       X(entry3_data)\n *\n * How it works:\n *   When you call MY_TABLE(SOME_MACRO), it expands to:\n *   SOME_MACRO(entry1_data) SOME_MACRO(entry2_data) SOME_MACRO(entry3_data)\n *\n * By defining different SOME_MACRO versions, ONE table generates MANY outputs!\n */\n\n/* MULTI-PARAMETER X-MACRO PATTERN (What we're using): */\n/* Each X() call can pass multiple parameters:\n *   #define DRIVER_TABLE(X) \\\n *       X(name1, param2, param3, param4, param5) \\\n *       X(name2, param2, param3, param4, param5)\n *\n * This gives us rich data per entry that can be used in different ways!\n */\n\n/* MULTI-LINE MACRO SYNTAX REVIEW: */\n/* Use backslash (\\) at end of each line to continue macro definition:\n *   #define MULTI_LINE \\\n *       first line \\\n *       second line\n *\n * CRITICAL RULES:\n * - NO \\ on the last line!\n * - \\ must be LAST character on line (no spaces after it!)\n * - Each line ending with \\ will be joined into one logical line\n *\n * Example with 3 entries:\n *   #define TABLE(X) \\\n *       X(A, 1) \\\n *       X(B, 2) \\\n *       X(C, 3)\n * Notice: No \\ after X(C, 3) because it's the last line!\n */\n\n/* ========================================================================== */\n/* TODO: Define DRIVER_TABLE X-macro */\n/* ========================================================================== */\n/* This is the master table that drives ALL code generation in this problem.\n * It should take a macro X as parameter and call it for each driver entry.\n *\n * UNDERSTANDING THE 5 PARAMETERS:\n * Each driver entry needs 5 pieces of information:\n *   1. name:         Driver identifier (SERIAL_USB, GPIO_PIN, etc.)\n *   2. type_code:    Unique 16-bit type identifier (0x0100, 0x0200, etc.)\n *   3. init_func:    Init function name (init_usb_serial, init_gpio_pin, etc.)\n *   4. cleanup_func: Cleanup function name (cleanup_usb_serial, cleanup_gpio_pin, etc.)\n *   5. flags:        Capability flags (DRV_HOTPLUG | DRV_IRQ, DRV_STATIC, etc.)\n *\n * REQUIRED DRIVER ENTRIES (5 total):\n *\n *   1. SERIAL_USB:  \n *      type_code=0x0100\n *      init=init_usb_serial\n *      cleanup=cleanup_usb_serial\n *      flags=DRV_HOTPLUG|DRV_IRQ (which is 0x03)\n *\n *   2. SERIAL_UART:\n *      type_code=0x0101\n *      init=init_uart_serial\n *      cleanup=cleanup_uart_serial\n *      flags=DRV_STATIC (which is 0x00)\n *\n *   3. GPIO_PIN:\n *      type_code=0x0200\n *      init=init_gpio_pin\n *      cleanup=cleanup_gpio_pin\n *      flags=DRV_STATIC (which is 0x00)\n *\n *   4. GPIO_LED:\n *      type_code=0x0201\n *      init=init_gpio_led\n *      cleanup=cleanup_gpio_led\n *      flags=DRV_STATIC (which is 0x00)\n *\n *   5. SPI_FLASH:\n *      type_code=0x0300\n *      init=init_spi_flash\n *      cleanup=cleanup_spi_flash\n *      flags=DRV_HOTPLUG (which is 0x01)\n *\n * PATTERN TO IMPLEMENT:\n *   #define DRIVER_TABLE(X) \\\n *       X(SERIAL_USB, 0x0100, init_usb_serial, cleanup_usb_serial, DRV_HOTPLUG | DRV_IRQ) \\\n *       X(SERIAL_UART, 0x0101, init_uart_serial, cleanup_uart_serial, DRV_STATIC) \\\n *       X(GPIO_PIN, 0x0200, init_gpio_pin, cleanup_gpio_pin, DRV_STATIC) \\\n *       X(GPIO_LED, 0x0201, init_gpio_led, cleanup_gpio_led, DRV_STATIC) \\\n *       X(SPI_FLASH, 0x0300, init_spi_flash, cleanup_spi_flash, DRV_HOTPLUG)\n *\n * WHAT THIS TABLE WILL GENERATE:\n * This single table will be used to auto-generate:\n * - enum driver_type (5 enum values)\n * - 5 init function declarations\n * - 5 cleanup function declarations\n * - 10 function implementations (in .c file)\n * - switch statement cases (in .c file)\n * - if-else detection chain (in .c file)\n * - struct arrays with metadata (in .c file)\n * Total: 30+ lines of code from ONE 5-line table!\n *\n * COMMON MISTAKES:\n * MISTAKE 1: Forgetting backslash on continuation lines\n *   #define DRIVER_TABLE(X)        // WRONG\n *   X(SERIAL_USB, ...) \n * SOLUTION:\n *   #define DRIVER_TABLE(X) \\      // CORRECT - note the backslash!\n *       X(SERIAL_USB, ...) \\\n *\n * MISTAKE 2: Adding backslash on last line\n *   X(SPI_FLASH, ...) \\           // WRONG - no \\ on last line!\n * SOLUTION:\n *   X(SPI_FLASH, ...)             // CORRECT - no backslash at end\n *\n * MISTAKE 3: Spaces after backslash\n *   X(GPIO_PIN, ...) \\ [space]    // WRONG - compiler error!\n * SOLUTION:\n *   X(GPIO_PIN, ...) \\            // CORRECT - backslash is last char\n *\n * MISTAKE 4: Missing parameters\n *   X(SERIAL_USB, 0x0100)         // WRONG - only 2 parameters!\n * SOLUTION:\n *   X(SERIAL_USB, 0x0100, init_usb_serial, cleanup_usb_serial, DRV_HOTPLUG | DRV_IRQ)\n *   // CORRECT - all 5 parameters present\n */\n#define DRIVER_TABLE(X) /* YOUR CODE HERE */\n\n/* ========================================================================== */\n/* SECTION 2: ENUM GENERATION FROM X-MACRO TABLE */\n/* ========================================================================== */\n\n/* TOKEN PASTING OPERATOR (##) EXPLAINED: */\n/* The ## operator glues two tokens together to create a new identifier.\n *\n * BASIC EXAMPLES:\n * #define CONCAT(a, b) a##b\n * CONCAT(hello, world) → helloworld\n * CONCAT(DRV_, USB) → DRV_USB\n *\n * PRACTICAL USE:\n * #define MAKE_ENUM_NAME(x) DRV_##x\n * MAKE_ENUM_NAME(SERIAL_USB) → DRV_SERIAL_USB\n * MAKE_ENUM_NAME(GPIO_PIN) → DRV_GPIO_PIN\n *\n * WHY WE USE IT:\n * We want to convert driver names (SERIAL_USB) into enum values (DRV_SERIAL_USB)\n * Without ##: We'd have to manually prefix every enum value\n * With ##: Automatic prefix generation from table data!\n */\n\n/* VARIADIC MACROS (...) EXPLAINED: */\n/* The ... syntax means \"accept any number of additional parameters\"\n *\n * BASIC EXAMPLE:\n * #define TAKE_FIRST(first, ...) first\n * TAKE_FIRST(A, B, C, D, E) → A (ignores B, C, D, E)\n *\n * WHY WE USE IT:\n * DRIVER_TABLE passes 5 parameters: (name, code, init, cleanup, flags)\n * For enum generation, we only need 'name'\n * The ... allows us to ignore the other 4 parameters!\n *\n * PRACTICAL USE:\n * #define MAKE_ENUM(name, ...) DRV_##name,\n * Called with: MAKE_ENUM(SERIAL_USB, 0x0100, init_usb_serial, cleanup_usb_serial, 0x03)\n * Expands to: DRV_SERIAL_USB,\n * The ... silently discards 0x0100, init_usb_serial, cleanup_usb_serial, 0x03\n */\n\n/* HOW ENUM GENERATION WORKS (Step-by-Step): */\n/* Step 1: Define helper macro that generates one enum value\n *   #define MAKE_ENUM(name, ...) DRV_##name,\n *\n * Step 2: Apply it to the table\n *   enum driver_type {\n *       DRIVER_TABLE(MAKE_ENUM)\n *       DRV_UNKNOWN\n *   };\n *\n * Step 3: Preprocessor expands DRIVER_TABLE(MAKE_ENUM)\n *   DRIVER_TABLE(MAKE_ENUM) expands to:\n *   MAKE_ENUM(SERIAL_USB, 0x0100, init_usb_serial, cleanup_usb_serial, DRV_HOTPLUG | DRV_IRQ)\n *   MAKE_ENUM(SERIAL_UART, 0x0101, init_uart_serial, cleanup_uart_serial, DRV_STATIC)\n *   MAKE_ENUM(GPIO_PIN, 0x0200, init_gpio_pin, cleanup_gpio_pin, DRV_STATIC)\n *   MAKE_ENUM(GPIO_LED, 0x0201, init_gpio_led, cleanup_gpio_led, DRV_STATIC)\n *   MAKE_ENUM(SPI_FLASH, 0x0300, init_spi_flash, cleanup_spi_flash, DRV_HOTPLUG)\n *\n * Step 4: Each MAKE_ENUM expands\n *   MAKE_ENUM(SERIAL_USB, ...) → DRV_SERIAL_USB,\n *   MAKE_ENUM(SERIAL_UART, ...) → DRV_SERIAL_UART,\n *   MAKE_ENUM(GPIO_PIN, ...) → DRV_GPIO_PIN,\n *   MAKE_ENUM(GPIO_LED, ...) → DRV_GPIO_LED,\n *   MAKE_ENUM(SPI_FLASH, ...) → DRV_SPI_FLASH,\n *\n * Step 5: Final enum after all expansion\n *   enum driver_type {\n *       DRV_SERIAL_USB,\n *       DRV_SERIAL_UART,\n *       DRV_GPIO_PIN,\n *       DRV_GPIO_LED,\n *       DRV_SPI_FLASH,\n *       DRV_UNKNOWN\n *   };\n *\n * RESULT: 5 enum values auto-generated from ONE table!\n * If we add a 6th driver to DRIVER_TABLE, enum automatically gets 6th value!\n */\n\n/* WHY #undef AFTER USE: */\n/* After generating the enum, we don't need MAKE_ENUM anymore.\n * We'll create different helper macros for other targets.\n * #undef MAKE_ENUM allows us to redefine it later if needed.\n *\n * Pattern:\n * #define MAKE_ENUM(...) // First use\n * ... use it ...\n * #undef MAKE_ENUM\n * #define MAKE_ENUM(...) // Can redefine with different behavior\n *\n * Without #undef: \"macro redefinition\" compiler error!\n */\n\n/* ========================================================================== */\n/* TODO: Define MAKE_ENUM helper macro */\n/* ========================================================================== */\n/* TASK: Create a macro that generates enum values with DRV_ prefix\n *\n * Requirements:\n * - Takes parameters: name, code, init, cleanup, flags\n * - Only uses 'name' parameter\n * - Ignores other 4 parameters using variadic ... syntax\n * - Generates: DRV_<name>, (with trailing comma)\n * - Uses token pasting (##) to create DRV_ prefix\n *\n * STEP-BY-STEP GUIDE:\n * 1. Start with: #define MAKE_ENUM(name, ...)\n *    - 'name' is the parameter we need\n *    - '...' captures and ignores the remaining 4 parameters\n *\n * 2. Use token pasting to create DRV_<name>:\n *    DRV_##name\n *    - When name=SERIAL_USB: DRV_##SERIAL_USB → DRV_SERIAL_USB\n *\n * 3. Add trailing comma:\n *    DRV_##name,\n *    - The comma allows multiple enum values to be listed\n *\n * Expected macro definition:\n *   #define MAKE_ENUM(name, ...) DRV_##name,\n *\n * Test your understanding:\n *   MAKE_ENUM(SERIAL_USB, 0x0100, init_usb_serial, cleanup_usb_serial, 0x03)\n *   Should expand to: DRV_SERIAL_USB,\n *\n *   MAKE_ENUM(GPIO_PIN, 0x0200, init_gpio_pin, cleanup_gpio_pin, 0x00)\n *   Should expand to: DRV_GPIO_PIN,\n */\n#define MAKE_ENUM(name, ...) /* YOUR CODE HERE */\n\n/* ========================================================================== */\n/* TODO: Generate enum driver_type using DRIVER_TABLE(MAKE_ENUM) */\n/* ========================================================================== */\n/* TASK: Use the X-macro table to auto-generate enum values\n *\n * Pattern to implement:\n *   enum driver_type {\n *       DRIVER_TABLE(MAKE_ENUM)\n *       DRV_UNKNOWN\n *   };\n *\n * How this works:\n * 1. DRIVER_TABLE(MAKE_ENUM) expands to 5 MAKE_ENUM() calls\n * 2. Each MAKE_ENUM() call generates one enum value\n * 3. DRV_UNKNOWN is added manually as the last value\n *\n * Expected result after preprocessor expansion:\n *   enum driver_type {\n *       DRV_SERIAL_USB,\n *       DRV_SERIAL_UART,\n *       DRV_GPIO_PIN,\n *       DRV_GPIO_LED,\n *       DRV_SPI_FLASH,\n *       DRV_UNKNOWN\n *   };\n */\nenum driver_type {\n    /* YOUR CODE HERE: Insert DRIVER_TABLE(MAKE_ENUM) on the line below */\n    \n    DRV_UNKNOWN\n};\n\n/* Clean up MAKE_ENUM macro (allows redefinition later if needed) */\n#undef MAKE_ENUM\n\n/* Driver metadata structure */\nstruct driver_info {\n    enum driver_type type;\n    uint16_t type_code;\n    const char *name;\n    uint32_t flags;\n};\n\n/* Driver operation function pointers */\ntypedef int (*init_func_t)(void);\ntypedef void (*cleanup_func_t)(void);\n\nstruct driver_ops {\n    init_func_t init;\n    cleanup_func_t cleanup;\n};\n\n/* Global driver tables */\nextern struct driver_info driver_table[];\nextern struct driver_ops ops_table[];\nextern const int driver_count;\n\n/* ========================================================================== */\n/* SECTION 3: AUTO-GENERATING FUNCTION DECLARATIONS */\n/* ========================================================================== */\n\n/* WHY AUTO-GENERATE FUNCTION DECLARATIONS: */\n/* Traditional approach (TEDIOUS and ERROR-PRONE):\n *   int init_usb_serial(void);\n *   int init_uart_serial(void);\n *   int init_gpio_pin(void);\n *   int init_gpio_led(void);\n *   int init_spi_flash(void);\n *   // If we add a 6th driver, we must remember to add declaration here!\n *   // If we rename a function, we must update in multiple places!\n *\n * X-macro approach (AUTOMATIC and ERROR-FREE):\n *   #define MAKE_INIT_DECL(name, code, init, cleanup, flags) int init(void);\n *   DRIVER_TABLE(MAKE_INIT_DECL)\n *   // Adding a 6th driver? It's automatically declared!\n *   // Rename a function in table? Declaration updates automatically!\n */\n\n/* HOW FUNCTION DECLARATION GENERATION WORKS: */\n/* Step 1: Define macro that generates one function declaration\n *   For init functions: #define MAKE_INIT_DECL(name, code, init, cleanup, flags) int init(void);\n *   For cleanup functions: #define MAKE_CLEANUP_DECL(name, code, init, cleanup, flags) void cleanup(void);\n *\n * Step 2: Apply to table\n *   DRIVER_TABLE(MAKE_INIT_DECL)\n *\n * Step 3: Expansion\n *   MAKE_INIT_DECL(SERIAL_USB, 0x0100, init_usb_serial, cleanup_usb_serial, 0x03)\n *   → int init_usb_serial(void);\n *\n *   MAKE_INIT_DECL(GPIO_PIN, 0x0200, init_gpio_pin, cleanup_gpio_pin, 0x00)\n *   → int init_gpio_pin(void);\n *\n * Result: All 5 init function declarations auto-generated!\n */\n\n/* UNDERSTANDING WHICH PARAMETER TO USE: */\n/* Each DRIVER_TABLE entry has 5 parameters:\n *   X(name, code, init, cleanup, flags)\n *\n * For init function declarations:\n *   We need the 'init' parameter (3rd parameter)\n *   Example: init_usb_serial, init_gpio_pin, etc.\n *\n * For cleanup function declarations:\n *   We need the 'cleanup' parameter (4th parameter)\n *   Example: cleanup_usb_serial, cleanup_gpio_pin, etc.\n *\n * The macro receives all 5 but only uses what it needs!\n */\n\n/* ========================================================================== */\n/* TODO: Auto-generate init function declarations */\n/* ========================================================================== */\n/* TASK: Create a macro that generates init function declarations\n *\n * Requirements:\n * - Define MAKE_INIT_DECL macro that takes 5 parameters\n * - Use the 'init' parameter (3rd parameter)\n * - Generate function declaration: int <init_name>(void);\n *\n * Expected macro:\n *   #define MAKE_INIT_DECL(name, code, init, cleanup, flags) int init(void);\n *\n * Then use it:\n *   DRIVER_TABLE(MAKE_INIT_DECL)\n *\n * This will auto-generate all 5 init function declarations:\n *   int init_usb_serial(void);\n *   int init_uart_serial(void);\n *   int init_gpio_pin(void);\n *   int init_gpio_led(void);\n *   int init_spi_flash(void);\n *\n * Test your understanding:\n *   MAKE_INIT_DECL(SERIAL_USB, 0x0100, init_usb_serial, cleanup_usb_serial, 0x03)\n *   Should expand to: int init_usb_serial(void);\n */\n#define MAKE_INIT_DECL(name, code, init, cleanup, flags) /* YOUR CODE HERE */\n\n/* YOUR CODE HERE: Use DRIVER_TABLE(MAKE_INIT_DECL) to generate all init declarations */\n\n/* Clean up macro */\n#undef MAKE_INIT_DECL\n\n/* ========================================================================== */\n/* TODO: Auto-generate cleanup function declarations */\n/* ========================================================================== */\n/* TASK: Create a macro that generates cleanup function declarations\n *\n * Requirements:\n * - Define MAKE_CLEANUP_DECL macro that takes 5 parameters\n * - Use the 'cleanup' parameter (4th parameter)\n * - Generate function declaration: void <cleanup_name>(void);\n *\n * Expected macro:\n *   #define MAKE_CLEANUP_DECL(name, code, init, cleanup, flags) void cleanup(void);\n *\n * Then use it:\n *   DRIVER_TABLE(MAKE_CLEANUP_DECL)\n *\n * This will auto-generate all 5 cleanup function declarations:\n *   void cleanup_usb_serial(void);\n *   void cleanup_uart_serial(void);\n *   void cleanup_gpio_pin(void);\n *   void cleanup_gpio_led(void);\n *   void cleanup_spi_flash(void);\n *\n * Test your understanding:\n *   MAKE_CLEANUP_DECL(SERIAL_USB, 0x0100, init_usb_serial, cleanup_usb_serial, 0x03)\n *   Should expand to: void cleanup_usb_serial(void);\n */\n#define MAKE_CLEANUP_DECL(name, code, init, cleanup, flags) /* YOUR CODE HERE */\n\n/* YOUR CODE HERE: Use DRIVER_TABLE(MAKE_CLEANUP_DECL) to generate all cleanup declarations */\n\n/* Clean up macro */\n#undef MAKE_CLEANUP_DECL\n\n/* ========================================================================== */\n/* SECTION 4: MULTI-TARGET GENERATION FUNCTION DECLARATIONS */\n/* ========================================================================== */\n/* These functions will be implemented in the .c file using more X-macro magic!\n * They demonstrate how the generated data structures are used at runtime. */\n\nint initialize_driver(enum driver_type type);\nvoid cleanup_driver(enum driver_type type);\nenum driver_type detect_driver_by_code(uint16_t type_code);\nint count_drivers_by_flag(uint32_t flag);\nvoid print_driver_table(void);\nconst char* get_driver_name(enum driver_type type);\n\n/* ========================================================================== */\n/* SUMMARY: What This Header Accomplished */\n/* ========================================================================== */\n/* From ONE master table (DRIVER_TABLE), this header auto-generated:\n *\n * 1. enum driver_type with 5 values (DRV_SERIAL_USB, DRV_SERIAL_UART, etc.)\n * 2. 5 init function declarations (int init_usb_serial(void), etc.)\n * 3. 5 cleanup function declarations (void cleanup_usb_serial(void), etc.)\n *\n * Total: 11 lines of code auto-generated from ONE 5-line table!\n *\n * The .c file will use the same table to generate:\n * - 10 complete function implementations\n * - 2 struct arrays with 5 entries each\n * - Switch statement with 5 cases\n * - If-else chain with 5 conditions\n *\n * Grand total: 50+ lines of code from ONE table definition!\n * This is the power of X-macros in production kernel development!\n */\n\n#endif /* DRIVER_REGISTRY_H */\n",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "driver_registry.c",
        "content": "#include \"driver_registry.h\"\n\nint test_driver_type = 0;  /* DRV_SERIAL_USB */\nint test_type_code = 0x0100;\nint test_flag = DRV_HOTPLUG;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n */\nmodule_param(test_driver_type, int, 0644);\nMODULE_PARM_DESC(test_driver_type, \"Driver type for testing dispatch logic\");\nmodule_param(test_type_code, int, 0644);\nMODULE_PARM_DESC(test_type_code, \"Type code for testing detection logic\");\nmodule_param(test_flag, int, 0644);\nMODULE_PARM_DESC(test_flag, \"Flag for testing count logic\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: Advanced X-Macro Multi-Target Code Generation */\n/* This teaches PRODUCTION-LEVEL patterns from real Linux kernel development:\n *\n * EVOLUTION OF CODE GENERATION:\n * Problem 25 (Basic X-Macros):\n *   - 3 parameters per entry (name, id, description)\n *   - Generates 3 targets: enum + string array + ID array\n *   - Single purpose: data synchronization\n *\n * Problem 28 (Advanced X-Macros):\n *   - 5 parameters per entry (name, type_code, init_func, cleanup_func, flags)\n *   - Generates 7+ targets: enum + function stubs + switches + if-chain + struct arrays\n *   - Multiple purposes: complete driver registration system\n *\n * REAL LINUX KERNEL EXAMPLES:\n * 1. PCI Device Registration:\n *    PCI_DEVICE(vendor, device) macro generates pci_device_id structs\n *\n * 2. System Call Tables:\n *    SYSCALL_DEFINEx() generates BOTH function prototypes AND syscall table entries\n *\n * 3. Tracepoint System:\n *    TRACE_EVENT(sched_switch, ...) AUTO-GENERATES trace_sched_switch() function!\n *\n * 4. Error Code Management:\n *    Single errno.h generates error numbers AND error string arrays\n */\n\n/* ========================================================================== */\n/* TARGET 0: Auto-Generate Function Implementations (ADVANCED PATTERN!) */\n/* ========================================================================== */\n/* WHAT THIS TARGET TEACHES: Generating entire FUNCTION BODIES from X-macros */\n\n/* UNDERSTANDING THE PROBLEM: */\n/* We need to create 5 init functions:\n *   int init_usb_serial(void) { ... }\n *   int init_uart_serial(void) { ... }\n *   int init_gpio_pin(void) { ... }\n *   int init_gpio_led(void) { ... }\n *   int init_spi_flash(void) { ... }\n *\n * Each function needs different data embedded (name, code, flags)\n * Writing them manually = 50+ lines of repetitive code\n * Using X-macro = 5-line macro + 1-line invocation!\n */\n\n/* HOW X-MACRO FUNCTION GENERATION WORKS: */\n/* Step 1: DRIVER_TABLE calls our macro for each driver */\n/*   DRIVER_TABLE(MAKE_INIT_FUNC) expands to: */\n/*   MAKE_INIT_FUNC(SERIAL_USB, 0x0100, init_usb_serial, cleanup_usb_serial, 0x03) */\n/*   MAKE_INIT_FUNC(SERIAL_UART, 0x0101, init_uart_serial, cleanup_uart_serial, 0x00) */\n/*   ... */\n/*\n * Step 2: Each MAKE_INIT_FUNC invocation generates a complete function */\n/*   For SERIAL_USB: */\n/*     name=SERIAL_USB, code=0x0100, init=init_usb_serial, cleanup=cleanup_usb_serial, flags=0x03 */\n/*     Macro expands to: */\n/*     int init_usb_serial(void) { */\n/*         printk(KERN_INFO \"Initializing SERIAL_USB driver\\n\"); */\n/*         printk(KERN_INFO \"  Type code: 0x0100\\n\"); */\n/*         printk(KERN_INFO \"  Flags: 0x03\\n\"); */\n/*         return 0; */\n/*     } */\n\n/* WHAT EACH PARAMETER CONTAINS AND HOW TO USE IT: */\n/* 1. name parameter (e.g., SERIAL_USB) */\n/*    Contains: Plain identifier token */\n/*    Use #name to convert to string: \"SERIAL_USB\" */\n/*    Example: printk(\"Initializing \" #name \" driver\\n\"); */\n/*\n * 2. code parameter (e.g., 0x0100) */\n/*    Contains: Numeric value */\n/*    Use code directly in expressions: printk(\"Type: 0x%04x\\n\", code); */\n/*\n * 3. init parameter (e.g., init_usb_serial) */\n/*    Contains: Function name identifier */\n/*    Use init as function name: int init(void) { ... } */\n/*\n * 4. flags parameter (e.g., DRV_HOTPLUG | DRV_IRQ which is 0x03) */\n/*    Contains: Numeric expression */\n/*    Use flags directly: printk(\"Flags: 0x%02x\\n\", flags); */\n\n/* STRINGIFICATION OPERATOR (#) EXPLAINED: */\n/* #parameter converts macro parameter to string literal */\n/* Example: */\n/*   #define MAKE_STRING(x) #x */\n/*   MAKE_STRING(SERIAL_USB) expands to \"SERIAL_USB\" */\n/*   MAKE_STRING(hello world) expands to \"hello world\" */\n/*\n * In our case: */\n/*   When name=SERIAL_USB: */\n/*   #name → \"SERIAL_USB\" */\n/*   \"Initializing \" #name \" driver\" → \"Initializing SERIAL_USB driver\" */\n\n/* PARAMETER EMBEDDING IN FUNCTION BODY: */\n/* Macro parameters can be used anywhere in the macro expansion */\n/* Example: */\n/*   #define MAKE_FUNC(fname, val) \\ */\n/*   int fname(void) { \\ */\n/*       return val; \\ */\n/*   } */\n/*\n * MAKE_FUNC(get_magic, 42) expands to: */\n/*   int get_magic(void) { */\n/*       return 42; */\n/*   } */\n\n/* MULTI-LINE MACRO SYNTAX: */\n/* Use \\ at end of each line to continue macro definition */\n/* Example: */\n/*   #define MULTI_LINE \\ */\n/*   first line \\ */\n/*   second line */\n/*\n * IMPORTANT: */\n/*   - NO \\ on the last line! */\n/*   - \\ must be LAST character on line (no spaces after it!) */\n\n/* COMMON MISTAKES AND SOLUTIONS: */\n/* MISTAKE 1: Using macro parameter as string without # */\n/*   printk(\"Initializing name driver\");  // WRONG - prints literal \"name\" */\n/* SOLUTION: */\n/*   printk(\"Initializing \" #name \" driver\");  // CORRECT - stringifies parameter */\n/*\n * MISTAKE 2: Not using backslashes on multi-line macros */\n/*   #define MY_MACRO(x)     // WRONG */\n/*   int x(void) { */\n/*   return 0; */\n/*   } */\n/* SOLUTION: */\n/*   #define MY_MACRO(x) \\    // CORRECT */\n/*   int x(void) { \\          // CORRECT */\n/*       return 0; \\          // CORRECT */\n/*   }                       // NO \\ on last line */\n/*\n * MISTAKE 3: Extra spaces after backslash */\n/*   #define MACRO \\ [space]  // WRONG - compiler error */\n/* SOLUTION: */\n/*   #define MACRO \\          // CORRECT - \\ is last character */\n\n/* TODO: Define MAKE_INIT_FUNC macro that generates complete init functions\n *\n * Requirements:\n * - Function signature: int <init_name>(void)\n * - Print driver name (use stringification #name)\n * - Print type code in hex format (0x%04x)\n * - Print flags in hex format (0x%02x)\n * - Return 0 for success\n *\n * Remember:\n * - Use backslash \\ at end of each line except last\n * - Double backslash \\\\n in strings for macro expansion\n * - Embed code and flags parameters directly in printk\n *\n * Expected output for SERIAL_USB:\n *   \"Initializing SERIAL_USB driver\"\n *   \"  Type code: 0x0100\"\n *   \"  Flags: 0x03\"\n */\n#define MAKE_INIT_FUNC(name, code, init, cleanup, flags) /* YOUR CODE HERE */\n\n/* TODO: Use DRIVER_TABLE to generate all 5 init functions */\n\n#undef MAKE_INIT_FUNC\n\n/* TODO: Define MAKE_CLEANUP_FUNC macro that generates cleanup functions\n *\n * Requirements:\n * - Function signature: void <cleanup_name>(void)\n * - Print driver name (use stringification #name)\n * - Print type code in hex format (0x%04x)\n * - No return value needed (void function)\n *\n * Expected output for SERIAL_USB:\n *   \"Cleaning up SERIAL_USB driver\"\n *   \"  Type code: 0x0100\"\n */\n#define MAKE_CLEANUP_FUNC(name, code, init, cleanup, flags) /* YOUR CODE HERE */\n\n/* TODO: Use DRIVER_TABLE to generate all 5 cleanup functions */\n\n#undef MAKE_CLEANUP_FUNC\n\n/* ========================================================================== */\n/* TARGET 1 & 2: Struct Array Generation */\n/* ========================================================================== */\n/* WHAT THIS TARGET TEACHES: Generating struct array initializers */\n\n/* HOW STRUCT ARRAY GENERATION WORKS: */\n/* Given struct driver_info definition from .h file: */\n/*   struct driver_info { */\n/*       enum driver_type type; */\n/*       uint16_t type_code; */\n/*       const char *name; */\n/*       uint32_t flags; */\n/*   }; */\n/*\n * We want to generate: */\n/*   struct driver_info driver_table[] = { */\n/*       { DRV_SERIAL_USB, 0x0100, \"SERIAL_USB\", 0x03 }, */\n/*       { DRV_SERIAL_UART, 0x0101, \"SERIAL_UART\", 0x00 }, */\n/*       { DRV_GPIO_PIN, 0x0200, \"GPIO_PIN\", 0x00 }, */\n/*       { DRV_GPIO_LED, 0x0201, \"GPIO_LED\", 0x00 }, */\n/*       { DRV_SPI_FLASH, 0x0300, \"SPI_FLASH\", 0x01 } */\n/*   }; */\n\n/* STRUCT INITIALIZER SYNTAX: */\n/* C designated initializers: { .field1 = value1, .field2 = value2 } */\n/* C positional initializers: { value1, value2, value3 } */\n/*\n * For driver_info: */\n/*   { DRV_SERIAL_USB, 0x0100, \"SERIAL_USB\", 0x03 } */\n/*    ↑               ↑       ↑             ↑        */\n/*    type            code    name          flags    */\n\n/* TOKEN PASTING REVIEW (##): */\n/* DRV_##name creates DRV_SERIAL_USB from name=SERIAL_USB */\n/* Example: */\n/*   #define MAKE_ENUM_VAL(x) DRV_##x */\n/*   MAKE_ENUM_VAL(SERIAL_USB) → DRV_SERIAL_USB */\n\n/* COMBINING TOKEN PASTING AND STRINGIFICATION: */\n/* For SERIAL_USB entry: */\n/*   DRV_##name → DRV_SERIAL_USB (enum value) */\n/*   #name → \"SERIAL_USB\" (string literal) */\n\n/* TODO: Define MAKE_INFO macro that generates struct initializers\n *\n * Requirements:\n * - Generate positional struct initializer for driver_info\n * - Field order: type (enum), type_code, name (string), flags\n * - Use token pasting (DRV_##name) for enum value\n * - Use stringification (#name) for name field\n * - Include trailing comma\n *\n * Expected result for SERIAL_USB:\n *   { DRV_SERIAL_USB, 0x0100, \"SERIAL_USB\", 0x03 },\n */\n#define MAKE_INFO(name, code, init, cleanup, flags) /* YOUR CODE HERE */\n\nstruct driver_info driver_table[] = {\n    /* YOUR CODE HERE: Use DRIVER_TABLE(MAKE_INFO) to populate array */\n};\n\n#undef MAKE_INFO\n\n/* TODO: Calculate driver_count\n * Hint: Total array size divided by size of one element\n */\nconst int driver_count = /* YOUR CODE HERE */;\n\n/* TODO: Define MAKE_OPS macro that generates function pointer table entries\n *\n * Requirements:\n * - Generate positional struct initializer for driver_ops\n * - Field order: init (function pointer), cleanup (function pointer)\n * - Use the init and cleanup parameters directly (they're already function names)\n * - Include trailing comma\n *\n * Expected result for SERIAL_USB:\n *   { init_usb_serial, cleanup_usb_serial },\n */\n#define MAKE_OPS(name, code, init, cleanup, flags) /* YOUR CODE HERE */\n\nstruct driver_ops ops_table[] = {\n    /* YOUR CODE HERE: Use DRIVER_TABLE(MAKE_OPS) */\n};\n\n#undef MAKE_OPS\n\n/* ========================================================================== */\n/* TARGET 3 & 4: Switch Statement Generation */\n/* ========================================================================== */\n/* WHAT THIS TARGET TEACHES: Generating switch-case statements */\n\n/* HOW SWITCH GENERATION WORKS: */\n/* We want to generate: */\n/*   switch(type) { */\n/*       case DRV_SERIAL_USB: return init_usb_serial(); */\n/*       case DRV_SERIAL_UART: return init_uart_serial(); */\n/*       case DRV_GPIO_PIN: return init_gpio_pin(); */\n/*       case DRV_GPIO_LED: return init_gpio_led(); */\n/*       case DRV_SPI_FLASH: return init_spi_flash(); */\n/*       default: return -ENODEV; */\n/*   } */\n\n/* SWITCH CASE SYNTAX: */\n/* case CONSTANT: statement; */\n/* For our case: case DRV_##name: return init(); */\n/*\n * Breaking it down: */\n/*   case DRV_##name:  // Match this enum value */\n/*   return init();    // Call the init function */\n\n/* TODO: Implement initialize_driver() with X-macro generated switch cases\n *\n * Requirements:\n * - Create switch statement on type parameter\n * - Define MAKE_INIT_CASE macro that generates: case DRV_##name: return init();\n * - Use DRIVER_TABLE(MAKE_INIT_CASE) inside switch to generate all cases\n * - Add default case returning -ENODEV for unknown types\n * - Remember to #undef MAKE_INIT_CASE after use\n *\n * Expected behavior:\n * - DRV_SERIAL_USB calls init_usb_serial() and returns result\n * - DRV_SERIAL_UART calls init_uart_serial() and returns result\n * - And so on for all 5 drivers\n */\nint initialize_driver(enum driver_type type)\n{\n    /* YOUR CODE HERE */\n}\n\n/* TODO: Implement cleanup_driver() with X-macro generated switch cases\n *\n * Requirements:\n * - Create switch statement on type parameter\n * - Define MAKE_CLEANUP_CASE macro that generates: case DRV_##name: cleanup(); break;\n * - Use DRIVER_TABLE(MAKE_CLEANUP_CASE) inside switch\n * - Add default case (can be empty break)\n * - Remember to #undef MAKE_CLEANUP_CASE after use\n *\n * Note: Use break (not return) since function returns void\n */\nvoid cleanup_driver(enum driver_type type)\n{\n    /* YOUR CODE HERE */\n}\n\n/* ========================================================================== */\n/* TARGET 5: If-Else Chain Generation */\n/* ========================================================================== */\n/* WHAT THIS TARGET TEACHES: Generating sequential if statements */\n\n/* HOW IF-CHAIN GENERATION WORKS: */\n/* We want to generate: */\n/*   if (type_code == 0x0100) return DRV_SERIAL_USB; */\n/*   if (type_code == 0x0101) return DRV_SERIAL_UART; */\n/*   if (type_code == 0x0200) return DRV_GPIO_PIN; */\n/*   if (type_code == 0x0201) return DRV_GPIO_LED; */\n/*   if (type_code == 0x0300) return DRV_SPI_FLASH; */\n/*   return DRV_UNKNOWN; */\n\n/* WHY CHAIN OF IFS (NOT IF-ELSE-IF): */\n/* Each if statement contains a return, so execution stops on match */\n/* This is simpler than if-else-if and works identically */\n\n/* TODO: Implement detect_driver_by_code() with X-macro generated if-chain\n *\n * Requirements:\n * - Define MAKE_DETECT macro that generates: if (type_code == code) return DRV_##name;\n * - Use DRIVER_TABLE(MAKE_DETECT) to generate all if statements\n * - Remember to #undef MAKE_DETECT after use\n * - Return DRV_UNKNOWN if no match found\n *\n * Expected behavior:\n * - type_code 0x0100 returns DRV_SERIAL_USB\n * - type_code 0x0101 returns DRV_SERIAL_UART\n * - Unknown codes return DRV_UNKNOWN\n */\nenum driver_type detect_driver_by_code(uint16_t type_code)\n{\n    /* YOUR CODE HERE */\n    return DRV_UNKNOWN;\n}\n\n/* ========================================================================== */\n/* TARGET 6: Table Iteration Functions */\n/* ========================================================================== */\n/* WHAT THIS TARGET TEACHES: Using the generated tables dynamically */\n\n/* TODO: Implement count_drivers_by_flag()\n *\n * Requirements:\n * - Count how many drivers in driver_table have matching flags\n * - Use bitwise AND (&) to check flag matches\n * - Loop through all driver_count entries\n *\n * Example:\n * - Flag DRV_HOTPLUG (0x01) should match SERIAL_USB and SPI_FLASH\n * - Returns 2\n */\nint count_drivers_by_flag(uint32_t flag)\n{\n    /* YOUR CODE HERE */\n}\n\n/* TODO: Implement print_driver_table()\n *\n * Requirements:\n * - Print all entries in driver_table\n * - Format: \"Driver: <name> (Type: 0x%04x, Flags: 0x%02x)\"\n * - Loop through all driver_count entries\n *\n * Expected output for first entry:\n *   \"Driver: SERIAL_USB (Type: 0x0100, Flags: 0x03)\"\n */\nvoid print_driver_table(void)\n{\n    /* YOUR CODE HERE */\n}\n\n/* TODO: Implement get_driver_name()\n *\n * Requirements:\n * - Return driver name string from driver_table for given enum value\n * - Validate that type is within valid range (0 to driver_count-1)\n * - Return \"Unknown\" for invalid types\n *\n * Example:\n * - get_driver_name(DRV_SERIAL_USB) returns \"SERIAL_USB\"\n * - get_driver_name(999) returns \"Unknown\"\n */\nconst char* get_driver_name(enum driver_type type)\n{\n    /* YOUR CODE HERE */\n}\n\n/* ========================================================================== */\n/* Module Init/Exit */\n/* ========================================================================== */\nstatic int __init driver_registry_init(void)\n{\n    int ret;\n    int count;\n    enum driver_type detected;\n    \n    printk(KERN_INFO \"Driver registry module loaded\\n\");\n    \n    /* Test TARGET 1 & 2: Driver table generation */\n    printk(KERN_INFO \"Total drivers registered: %d\\n\", driver_count);\n    print_driver_table();\n    \n    /* Test TARGET 3: Switch-based initialization */\n    printk(KERN_INFO \"Testing driver initialization with type %d\\n\", test_driver_type);\n    ret = initialize_driver(test_driver_type);\n    if (ret == 0) {\n        printk(KERN_INFO \"Driver initialization succeeded\\n\");\n    } else {\n        printk(KERN_ERR \"Driver initialization failed: %d\\n\", ret);\n    }\n    \n    /* Test TARGET 5: Type code detection */\n    printk(KERN_INFO \"Testing type detection with code 0x%04x\\n\", test_type_code);\n    detected = detect_driver_by_code(test_type_code);\n    printk(KERN_INFO \"Detected driver: %s\\n\", get_driver_name(detected));\n    \n    /* Test TARGET 6: Flag-based counting */\n    printk(KERN_INFO \"Testing flag counting with flag 0x%02x\\n\", test_flag);\n    count = count_drivers_by_flag(test_flag);\n    printk(KERN_INFO \"Drivers with flag 0x%02x: %d\\n\", test_flag, count);\n    \n    /* Test TARGET 4: Cleanup dispatch */\n    cleanup_driver(test_driver_type);\n    \n    printk(KERN_INFO \"Driver registry demonstration completed\\n\");\n    \n    return 0;\n}\n\nstatic void __exit driver_registry_exit(void)\n{\n    printk(KERN_INFO \"Driver registry module unloaded\\n\");\n}\n\nmodule_init(driver_registry_init);\nmodule_exit(driver_registry_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning advanced X-macros for multi-target code generation\");\nMODULE_VERSION(\"1.0\");\n",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Driver registry module Makefile\nobj-m += driver_registry.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help\n",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "driver_registry.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "driver_registry_init",
          "driver_registry_exit",
          "initialize_driver",
          "cleanup_driver",
          "detect_driver_by_code",
          "count_drivers_by_flag",
          "print_driver_table",
          "get_driver_name"
        ],
        "macro_declarations": [
          {
            "name": "DRIVER_TABLE",
            "type": "function-like",
            "parameters": [
              "X"
            ]
          },
          {
            "name": "MAKE_ENUM",
            "type": "function-like",
            "parameters": [
              "name",
              "..."
            ]
          },
          {
            "name": "MAKE_INIT_DECL",
            "type": "function-like",
            "parameters": [
              "name",
              "code",
              "init",
              "cleanup",
              "flags"
            ]
          },
          {
            "name": "MAKE_CLEANUP_DECL",
            "type": "function-like",
            "parameters": [
              "name",
              "code",
              "init",
              "cleanup",
              "flags"
            ]
          }
        ],
        "macro_definitions": [
          {
            "name": "MAKE_INIT_FUNC",
            "type": "function-like",
            "parameters": [
              "name",
              "code",
              "init",
              "cleanup",
              "flags"
            ]
          },
          {
            "name": "MAKE_CLEANUP_FUNC",
            "type": "function-like",
            "parameters": [
              "name",
              "code",
              "init",
              "cleanup",
              "flags"
            ]
          },
          {
            "name": "MAKE_INFO",
            "type": "function-like",
            "parameters": [
              "name",
              "code",
              "init",
              "cleanup",
              "flags"
            ]
          },
          {
            "name": "MAKE_OPS",
            "type": "function-like",
            "parameters": [
              "name",
              "code",
              "init",
              "cleanup",
              "flags"
            ]
          },
          {
            "name": "MAKE_INIT_CASE",
            "type": "function-like",
            "parameters": [
              "name",
              "code",
              "init",
              "cleanup",
              "flags"
            ]
          },
          {
            "name": "MAKE_CLEANUP_CASE",
            "type": "function-like",
            "parameters": [
              "name",
              "code",
              "init",
              "cleanup",
              "flags"
            ]
          },
          {
            "name": "MAKE_DETECT",
            "type": "function-like",
            "parameters": [
              "name",
              "code",
              "init",
              "cleanup",
              "flags"
            ]
          }
        ],
        "variables_declarations": [
          {
            "name": "driver_type",
            "type": "enum",
            "value": "{\n    DRIVER_TABLE(MAKE_ENUM)\n    DRV_UNKNOWN\n}",
            "storageClass": "none"
          },
          {
            "name": "driver_info",
            "type": "struct",
            "value": "{enum driver_type type; uint16_t type_code; const char *name; uint32_t flags;}",
            "storageClass": "none"
          },
          {
            "name": "driver_ops",
            "type": "struct",
            "value": "{init_func_t init; cleanup_func_t cleanup;}",
            "storageClass": "none"
          },
          {
            "name": "driver_table",
            "type": "struct driver_info",
            "value": "[]",
            "storageClass": "extern"
          },
          {
            "name": "ops_table",
            "type": "struct driver_ops",
            "value": "[]",
            "storageClass": "extern"
          },
          {
            "name": "driver_count",
            "type": "const int",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "driver_table[]",
            "type": "struct driver_info",
            "value": "{\n    DRIVER_TABLE(MAKE_INFO)\n}",
            "storageClass": "none"
          },
          {
            "name": "ops_table[]",
            "type": "struct driver_ops",
            "value": "{\n    DRIVER_TABLE(MAKE_OPS)\n}",
            "storageClass": "none"
          },
          {
            "name": "driver_count",
            "type": "const int",
            "value": "sizeof(driver_table) / sizeof(driver_table[0])",
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Driver registry module loaded",
          "Total drivers registered: 5",
          "Driver: SERIAL_USB (Type: 0x0100, Flags: 0x03)",
          "Driver: SERIAL_UART (Type: 0x0101, Flags: 0x00)",
          "Driver: GPIO_PIN (Type: 0x0200, Flags: 0x00)",
          "Driver: GPIO_LED (Type: 0x0201, Flags: 0x00)",
          "Driver: SPI_FLASH (Type: 0x0300, Flags: 0x01)",
          "Testing driver initialization with type 0",
          "Initializing SERIAL_USB driver",
          "Type code: 0x0100",
          "Flags: 0x03",
          "Driver initialization succeeded",
          "Testing type detection with code 0x0100",
          "Detected driver: SERIAL_USB",
          "Testing flag counting with flag",
          "Drivers with flag",
          "Cleaning up SERIAL_USB driver",
          "Type code: 0x0100",
          "Driver registry demonstration completed",
          "Driver registry module unloaded"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h"
        ],
        "mustContain": [
          "#define DRIVER_TABLE(X)",
          "X(SERIAL_USB, 0x0100, init_usb_serial, cleanup_usb_serial, DRV_HOTPLUG | DRV_IRQ)",
          "X(SERIAL_UART, 0x0101, init_uart_serial, cleanup_uart_serial, DRV_STATIC)",
          "X(GPIO_PIN, 0x0200, init_gpio_pin, cleanup_gpio_pin, DRV_STATIC)",
          "X(GPIO_LED, 0x0201, init_gpio_led, cleanup_gpio_led, DRV_STATIC)",
          "X(SPI_FLASH, 0x0300, init_spi_flash, cleanup_spi_flash, DRV_HOTPLUG)",
          "#define MAKE_ENUM(name, ...) DRV_##name,",
          "enum driver_type",
          "DRIVER_TABLE(MAKE_ENUM)",
          "#undef MAKE_ENUM",
          "#define MAKE_INIT_DECL(name, code, init, cleanup, flags)",
          "int init(void);",
          "DRIVER_TABLE(MAKE_INIT_DECL)",
          "#undef MAKE_INIT_DECL",
          "#define MAKE_CLEANUP_DECL(name, code, init, cleanup, flags)",
          "void cleanup(void);",
          "DRIVER_TABLE(MAKE_CLEANUP_DECL)",
          "#undef MAKE_CLEANUP_DECL",
          "#define MAKE_INIT_FUNC(name, code, init, cleanup, flags)",
          "int init(void)",
          "printk.*#name",
          "Type code.*0x%04x.*code",
          "Flags.*0x%02x.*flags",
          "DRIVER_TABLE(MAKE_INIT_FUNC)",
          "#undef MAKE_INIT_FUNC",
          "#define MAKE_CLEANUP_FUNC(name, code, init, cleanup, flags)",
          "void cleanup(void)",
          "DRIVER_TABLE(MAKE_CLEANUP_FUNC)",
          "#undef MAKE_CLEANUP_FUNC",
          "#define MAKE_INFO",
          "DRIVER_TABLE(MAKE_INFO)",
          "#define MAKE_OPS",
          "DRIVER_TABLE(MAKE_OPS)",
          "#define MAKE_INIT_CASE",
          "case DRV_##name: return init();",
          "DRIVER_TABLE(MAKE_INIT_CASE)",
          "#define MAKE_CLEANUP_CASE",
          "case DRV_##name: cleanup(); break;",
          "DRIVER_TABLE(MAKE_CLEANUP_CASE)",
          "#define MAKE_DETECT",
          "if (type_code == code) return DRV_##name;",
          "DRIVER_TABLE(MAKE_DETECT)",
          "sizeof(driver_table) / sizeof(driver_table[0])",
          "driver_table[i].flags & flag",
          "module_param(test_driver_type, int, 0644)",
          "module_param(test_type_code, int, 0644)",
          "module_param(test_flag, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int initialize_driver(enum driver_type type)",
            "void cleanup_driver(enum driver_type type)",
            "enum driver_type detect_driver_by_code(uint16_t type_code)",
            "int count_drivers_by_flag(uint32_t flag)",
            "void print_driver_table(void)",
            "const char* get_driver_name(enum driver_type type)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "xmacro_table_definition",
          "name": "X-Macro Table with 5 Parameters",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "#define DRIVER_TABLE(X)",
            "X(SERIAL_USB,",
            "X(SERIAL_UART,",
            "X(GPIO_PIN,",
            "X(GPIO_LED,",
            "X(SPI_FLASH,"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "enum_generation",
          "name": "Enum Generation from X-Macro",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "#define MAKE_ENUM",
            "enum driver_type",
            "DRIVER_TABLE(MAKE_ENUM)",
            "#undef MAKE_ENUM"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "struct_array_generation",
          "name": "Struct Array Generation",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "#define MAKE_INFO",
            "struct driver_info driver_table",
            "DRIVER_TABLE(MAKE_INFO)",
            "#define MAKE_OPS",
            "struct driver_ops ops_table",
            "DRIVER_TABLE(MAKE_OPS)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "switch_generation",
          "name": "Switch Statement Generation",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "#define MAKE_INIT_CASE",
            "case DRV_",
            "DRIVER_TABLE(MAKE_INIT_CASE)",
            "#define MAKE_CLEANUP_CASE",
            "DRIVER_TABLE(MAKE_CLEANUP_CASE)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "ifelse_generation",
          "name": "If-Else Chain Generation",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "#define MAKE_DETECT",
            "if (type_code == code)",
            "DRIVER_TABLE(MAKE_DETECT)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_declaration_generation",
          "name": "Function Declaration Auto-Generation in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "#define MAKE_INIT_DECL(name, code, init, cleanup, flags)",
            "int init(void);",
            "DRIVER_TABLE(MAKE_INIT_DECL)",
            "#undef MAKE_INIT_DECL",
            "#define MAKE_CLEANUP_DECL(name, code, init, cleanup, flags)",
            "void cleanup(void);",
            "DRIVER_TABLE(MAKE_CLEANUP_DECL)",
            "#undef MAKE_CLEANUP_DECL"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_implementation_generation",
          "name": "Function Implementation Auto-Generation in Source",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "#define MAKE_INIT_FUNC(name, code, init, cleanup, flags)",
            "int init(void)",
            "#name",
            "0x%04x",
            "0x%02x",
            "DRIVER_TABLE(MAKE_INIT_FUNC)",
            "#undef MAKE_INIT_FUNC",
            "#define MAKE_CLEANUP_FUNC(name, code, init, cleanup, flags)",
            "void cleanup(void)",
            "DRIVER_TABLE(MAKE_CLEANUP_FUNC)",
            "#undef MAKE_CLEANUP_FUNC"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Implementations in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int initialize_driver(enum driver_type type)",
            "void cleanup_driver(enum driver_type type)",
            "enum driver_type detect_driver_by_code(uint16_t type_code)",
            "int count_drivers_by_flag(uint32_t flag)",
            "void print_driver_table(void)",
            "const char* get_driver_name(enum driver_type type)",
            "static int __init driver_registry_init(void)",
            "static void __exit driver_registry_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Driver registry module loaded",
              "exact": true,
              "linkedFunction": "static int __init driver_registry_init(void)"
            },
            {
              "pattern": "Total drivers registered: 5",
              "exact": true,
              "linkedFunction": "static int __init driver_registry_init(void)"
            },
            {
              "pattern": "Driver: SERIAL_USB (Type: 0x0100, Flags: 0x03)",
              "exact": true,
              "linkedFunction": "void print_driver_table(void)"
            },
            {
              "pattern": "Driver: SERIAL_UART (Type: 0x0101, Flags: 0x00)",
              "exact": true,
              "linkedFunction": "void print_driver_table(void)"
            },
            {
              "pattern": "Driver: GPIO_PIN (Type: 0x0200, Flags: 0x00)",
              "exact": true,
              "linkedFunction": "void print_driver_table(void)"
            },
            {
              "pattern": "Driver: GPIO_LED (Type: 0x0201, Flags: 0x00)",
              "exact": true,
              "linkedFunction": "void print_driver_table(void)"
            },
            {
              "pattern": "Driver: SPI_FLASH (Type: 0x0300, Flags: 0x01)",
              "exact": true,
              "linkedFunction": "void print_driver_table(void)"
            },
            {
              "pattern": "Testing driver initialization with type 0",
              "exact": true,
              "linkedFunction": "static int __init driver_registry_init(void)"
            },
            {
              "pattern": "Initializing SERIAL_USB driver",
              "exact": true,
              "linkedFunction": "int init_usb_serial(void)"
            },
            {
              "pattern": "Type code: 0x0100",
              "exact": true,
              "linkedFunction": "int init_usb_serial(void)"
            },
            {
              "pattern": "Flags: 0x03",
              "exact": true,
              "linkedFunction": "int init_usb_serial(void)"
            },
            {
              "pattern": "Driver initialization succeeded",
              "exact": true,
              "linkedFunction": "static int __init driver_registry_init(void)"
            },
            {
              "pattern": "Testing type detection with code 0x0100",
              "exact": true,
              "linkedFunction": "static int __init driver_registry_init(void)"
            },
            {
              "pattern": "Detected driver: SERIAL_USB",
              "exact": true,
              "linkedFunction": "static int __init driver_registry_init(void)"
            },
            {
              "pattern": "Cleaning up SERIAL_USB driver",
              "exact": true,
              "linkedFunction": "void cleanup_usb_serial(void)"
            },
            {
              "pattern": "Type code: 0x0100",
              "exact": true,
              "linkedFunction": "void cleanup_usb_serial(void)"
            },
            {
              "pattern": "Driver registry demonstration completed",
              "exact": true,
              "linkedFunction": "static int __init driver_registry_init(void)"
            },
            {
              "pattern": "Driver registry module unloaded",
              "exact": true,
              "linkedFunction": "static void __exit driver_registry_exit(void)"
            }
          ]
        },
        {
          "id": "advanced_xmacro_validation",
          "name": "Advanced X-Macro Multi-Target Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "xmacro_dynamic_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Advanced X-Macro Dynamic Test ===\\\\n\\\");\\n    \\n    srand(time(NULL));\\n    \\n    // Test different driver types\\n    int driver_types[] = {0, 1, 2, 3, 4};  // All 5 drivers\\n    int type_codes[] = {0x0100, 0x0101, 0x0200, 0x0201, 0x0300};\\n    int flags[] = {1, 0, 1};  // HOTPLUG=1, STATIC=0\\n    \\n    int random_driver = driver_types[rand() % 5];\\n    int random_code = type_codes[rand() % 5];\\n    int random_flag = flags[rand() % 3];\\n    \\n    printf(\\\"Test: driver_type=%d, type_code=0x%04x, flag=%d\\\\n\\\", random_driver, random_code, random_flag);\\n    \\n    system(\\\"rmmod driver_registry 2>/dev/null\\\");\\n    \\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/driver_registry.ko test_driver_type=%d test_type_code=%d test_flag=%d\\\", random_driver, random_code, random_flag);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: X-macro test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced X-macro validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: TCC Header Validation'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef unsigned short uint16_t;' > /tmp/linux/types.h",
              "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
              "echo '#include \"/lib/modules/driver_registry.h\"' > /tmp/test.c",
              "echo 'int main() { struct driver_info info; struct driver_ops ops; initialize_driver(DRV_SERIAL_USB); cleanup_driver(DRV_SERIAL_USB); detect_driver_by_code(0x0100); count_drivers_by_flag(1); print_driver_table(); get_driver_name(DRV_SERIAL_USB); return 0; }' >> /tmp/test.c",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing'; cat /tmp/tcc_error.log; else echo 'PASS: All declarations found'; fi",
              "echo 'Phase 2: Dynamic X-Macro Test'",
              "/bin/xmacro_dynamic_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: X-Macro Function Generation Validation (CRITICAL)'",
              "sleep 1",
              "echo 'Extracting test driver type from output...'",
              "TEST_DRIVER=$(grep -o 'driver_type=[0-9]*' /tmp/test_output.log | head -1 | cut -d'=' -f2)",
              "echo 'Testing with driver type '$TEST_DRIVER",
              "echo 'Validating macro-generated function output (must include type code and flags)...'",
              "dmesg | grep 'Type code: 0x' && echo 'PASS: Functions include type code (proves macro generation)' || echo 'FAIL: Missing type code (manual implementation detected)'",
              "dmesg | grep 'Flags: 0x' && echo 'PASS: Functions include flags (proves macro generation)' || echo 'FAIL: Missing flags (manual implementation detected)'",
              "echo 'Validating flag values match DRIVER_TABLE entries...'",
              "case $TEST_DRIVER in",
              "  0) dmesg | grep 'Flags: 0x03' && echo 'PASS: USB Serial flags correct (DRV_HOTPLUG|DRV_IRQ=0x03)' || echo 'FAIL: USB Serial flags wrong' ;;",
              "  1) dmesg | grep 'Flags: 0x00' && echo 'PASS: UART Serial flags correct (DRV_STATIC=0x00)' || echo 'FAIL: UART Serial flags wrong' ;;",
              "  2) dmesg | grep 'Flags: 0x00' && echo 'PASS: GPIO PIN flags correct (DRV_STATIC=0x00)' || echo 'FAIL: GPIO PIN flags wrong' ;;",
              "  3) dmesg | grep 'Flags: 0x00' && echo 'PASS: GPIO LED flags correct (DRV_STATIC=0x00)' || echo 'FAIL: GPIO LED flags wrong' ;;",
              "  4) dmesg | grep 'Flags: 0x01' && echo 'PASS: SPI Flash flags correct (DRV_HOTPLUG=0x01)' || echo 'FAIL: SPI Flash flags wrong' ;;",
              "esac",
              "echo 'Phase 4: Multi-Target Generation Validation'",
              "dmesg | grep 'Driver registry module loaded' && echo 'PASS: Module loading' || echo 'FAIL: Module loading'",
              "dmesg | grep 'Total drivers registered: 5' && echo 'PASS: Driver count correct' || echo 'FAIL: Driver count wrong'",
              "dmesg | grep 'Driver: SERIAL_USB' && echo 'PASS: Struct array generation' || echo 'FAIL: Struct array generation'",
              "dmesg | grep 'Driver: GPIO_PIN' && echo 'PASS: X-macro expansion' || echo 'FAIL: X-macro expansion'",
              "dmesg | grep 'Initializing.*driver' && echo 'PASS: Switch dispatch working' || echo 'FAIL: Switch dispatch broken'",
              "dmesg | grep 'Driver initialization succeeded' && echo 'PASS: Function pointer table' || echo 'FAIL: Function pointer table'",
              "dmesg | grep 'Detected driver:' && echo 'PASS: If-else chain generation' || echo 'FAIL: If-else chain generation'",
              "dmesg | grep 'Drivers with flag' && echo 'PASS: Flag counting logic' || echo 'FAIL: Flag counting logic'",
              "dmesg | grep 'Cleaning up.*driver' && echo 'PASS: Cleanup dispatch' || echo 'FAIL: Cleanup dispatch'",
              "dmesg | grep 'Driver registry demonstration completed' && echo 'PASS: All targets validated' || echo 'FAIL: Some targets missing'",
              "echo 'PASS: All advanced X-macro validation successful (including function generation)'"
            ],
            "expected": {
              "dmesg": [
                "Driver registry module loaded",
                "Total drivers registered: 5",
                "Driver: SERIAL_USB.*Type: 0x0100.*Flags: 0x03",
                "Driver: SERIAL_UART.*Type: 0x0101.*Flags: 0x00",
                "Driver: GPIO_PIN.*Type: 0x0200.*Flags: 0x00",
                "Driver: GPIO_LED.*Type: 0x0201.*Flags: 0x00",
                "Driver: SPI_FLASH.*Type: 0x0300.*Flags: 0x01",
                "Testing driver initialization with type.*",
                "Initializing.*driver",
                "Type code: 0x.*",
                "Flags: 0x.*",
                "Driver initialization succeeded",
                "Testing type detection with code.*",
                "Detected driver:.*",
                "Testing flag counting with flag.*",
                "Drivers with flag.*",
                "Cleaning up.*driver",
                "Type code: 0x.*",
                "Driver registry demonstration completed",
                "Driver registry module unloaded"
              ],
              "stdout": [
                "PASS: All declarations found",
                "SUCCESS: X-macro test completed",
                "PASS: Functions include type code \\(proves macro generation\\)",
                "PASS: Functions include flags \\(proves macro generation\\)",
                "PASS:.*flags correct",
                "PASS: Module loading",
                "PASS: Driver count correct",
                "PASS: Struct array generation",
                "PASS: X-macro expansion",
                "PASS: Switch dispatch working",
                "PASS: Function pointer table",
                "PASS: If-else chain generation",
                "PASS: Flag counting logic",
                "PASS: Cleanup dispatch",
                "PASS: All targets validated",
                "PASS: All advanced X-macro validation successful \\(including function generation\\)"
              ]
            },
            "timeout": 30
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Driver registry module loaded",
        "Total drivers registered: 5",
        "Driver: SERIAL_USB (Type: 0x0100, Flags: 0x03)",
        "Driver: SERIAL_UART (Type: 0x0101, Flags: 0x00)",
        "Driver: GPIO_PIN (Type: 0x0200, Flags: 0x00)",
        "Driver: GPIO_LED (Type: 0x0201, Flags: 0x00)",
        "Driver: SPI_FLASH (Type: 0x0300, Flags: 0x01)",
        "Testing driver initialization with type 0",
        "Initializing SERIAL_USB driver",
        "Type code: 0x0100",
        "Flags: 0x03",
        "Driver initialization succeeded",
        "Testing type detection with code 0x0100",
        "Detected driver: SERIAL_USB",
        "Testing flag counting with flag",
        "Drivers with flag",
        "Cleaning up SERIAL_USB driver",
        "Type code: 0x0100",
        "Driver registry demonstration completed",
        "Driver registry module unloaded"
      ],
      "requirements": [
        "Use required function names: driver_registry_init, driver_registry_exit, initialize_driver, cleanup_driver, detect_driver_by_code, count_drivers_by_flag, print_driver_table, get_driver_name",
        "Use required variable names: driver_table[], ops_table[], driver_count",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h",
        "Code must contain: #define DRIVER_TABLE(X), X(SERIAL_USB, 0x0100, init_usb_serial, cleanup_usb_serial, DRV_HOTPLUG | DRV_IRQ), X(SERIAL_UART, 0x0101, init_uart_serial, cleanup_uart_serial, DRV_STATIC), X(GPIO_PIN, 0x0200, init_gpio_pin, cleanup_gpio_pin, DRV_STATIC), X(GPIO_LED, 0x0201, init_gpio_led, cleanup_gpio_led, DRV_STATIC), X(SPI_FLASH, 0x0300, init_spi_flash, cleanup_spi_flash, DRV_HOTPLUG), #define MAKE_ENUM(name, ...) DRV_##name,, enum driver_type, DRIVER_TABLE(MAKE_ENUM), #undef MAKE_ENUM, #define MAKE_INIT_DECL(name, code, init, cleanup, flags), int init(void);, DRIVER_TABLE(MAKE_INIT_DECL), #undef MAKE_INIT_DECL, #define MAKE_CLEANUP_DECL(name, code, init, cleanup, flags), void cleanup(void);, DRIVER_TABLE(MAKE_CLEANUP_DECL), #undef MAKE_CLEANUP_DECL, #define MAKE_INIT_FUNC(name, code, init, cleanup, flags), int init(void), printk.*#name, Type code.*0x%04x.*code, Flags.*0x%02x.*flags, DRIVER_TABLE(MAKE_INIT_FUNC), #undef MAKE_INIT_FUNC, #define MAKE_CLEANUP_FUNC(name, code, init, cleanup, flags), void cleanup(void), DRIVER_TABLE(MAKE_CLEANUP_FUNC), #undef MAKE_CLEANUP_FUNC, #define MAKE_INFO, DRIVER_TABLE(MAKE_INFO), #define MAKE_OPS, DRIVER_TABLE(MAKE_OPS), #define MAKE_INIT_CASE, case DRV_##name: return init();, DRIVER_TABLE(MAKE_INIT_CASE), #define MAKE_CLEANUP_CASE, case DRV_##name: cleanup(); break;, DRIVER_TABLE(MAKE_CLEANUP_CASE), #define MAKE_DETECT, if (type_code == code) return DRV_##name;, DRIVER_TABLE(MAKE_DETECT), sizeof(driver_table) / sizeof(driver_table[0]), driver_table[i].flags & flag, module_param(test_driver_type, int, 0644), module_param(test_type_code, int, 0644), module_param(test_flag, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Driver registry module loaded",
          "linkedFunction": "static int __init driver_registry_init(void)",
          "exact": true
        },
        {
          "pattern": "Total drivers registered: 5",
          "linkedFunction": "static int __init driver_registry_init(void)",
          "exact": true
        },
        {
          "pattern": "Driver: SERIAL_USB (Type: 0x0100, Flags: 0x03)",
          "linkedFunction": "void print_driver_table(void)",
          "exact": true
        },
        {
          "pattern": "Driver: SERIAL_UART (Type: 0x0101, Flags: 0x00)",
          "linkedFunction": "void print_driver_table(void)",
          "exact": true
        },
        {
          "pattern": "Driver: GPIO_PIN (Type: 0x0200, Flags: 0x00)",
          "linkedFunction": "void print_driver_table(void)",
          "exact": true
        },
        {
          "pattern": "Driver: GPIO_LED (Type: 0x0201, Flags: 0x00)",
          "linkedFunction": "void print_driver_table(void)",
          "exact": true
        },
        {
          "pattern": "Driver: SPI_FLASH (Type: 0x0300, Flags: 0x01)",
          "linkedFunction": "void print_driver_table(void)",
          "exact": true
        },
        {
          "pattern": "Testing driver initialization with type 0",
          "linkedFunction": "static int __init driver_registry_init(void)",
          "exact": true
        },
        {
          "pattern": "Initializing SERIAL_USB driver",
          "linkedFunction": "int init_usb_serial(void)",
          "exact": true
        },
        {
          "pattern": "Type code: 0x0100",
          "linkedFunction": "int init_usb_serial(void)",
          "exact": true
        },
        {
          "pattern": "Flags: 0x03",
          "linkedFunction": "int init_usb_serial(void)",
          "exact": true
        },
        {
          "pattern": "Driver initialization succeeded",
          "linkedFunction": "static int __init driver_registry_init(void)",
          "exact": true
        },
        {
          "pattern": "Testing type detection with code 0x0100",
          "linkedFunction": "static int __init driver_registry_init(void)",
          "exact": true
        },
        {
          "pattern": "Detected driver: SERIAL_USB",
          "linkedFunction": "static int __init driver_registry_init(void)",
          "exact": true
        },
        {
          "pattern": "Cleaning up SERIAL_USB driver",
          "linkedFunction": "void cleanup_usb_serial(void)",
          "exact": true
        },
        {
          "pattern": "Type code: 0x0100",
          "linkedFunction": "void cleanup_usb_serial(void)",
          "exact": true
        },
        {
          "pattern": "Driver registry demonstration completed",
          "linkedFunction": "static int __init driver_registry_init(void)",
          "exact": true
        },
        {
          "pattern": "Driver registry module unloaded",
          "linkedFunction": "static void __exit driver_registry_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 29,
    "title": "Two-Level Memory Allocation - Array of Pointers Pattern",
    "difficulty": 6,
    "xp": 60,
    "phase": "foundations",
    "description": "Master the two-level allocation pattern using double pointers in kernel development. Learn to allocate arrays of pointers where each element points to dynamically allocated memory. Understand partial allocation failure recovery, reverse-order cleanup, and when this pattern is required. This prepares you for complex data structures like dynamic vectors and linked lists.",
    "concepts": [
      "WHEN to use kmalloc vs static allocation (decision tree)",
      "WHY static allocation fails (runtime-determined sizes)",
      "Two-level allocation pattern (array of pointers)",
      "kmalloc() function and GFP_KERNEL flags",
      "kfree() function and proper cleanup order",
      "NULL pointer checking and error handling",
      "Memory lifecycle: allocate, check, use, free",
      "Use-after-free prevention"
    ],
    "skills": [
      "Applying decision tree for static vs dynamic allocation",
      "Identifying scenarios requiring kmalloc (runtime sizes, persistent lifetime, returning pointers)",
      "Implementing two-level allocation (array of structs)",
      "Using kmalloc(sizeof(Type) * count, GFP_KERNEL) for arrays",
      "Proper error handling for partial allocation failures",
      "Two-level cleanup in reverse order",
      "Setting pointers to NULL after freeing"
    ],
    "files": [
      {
        "name": "dynamic_memory.h",
        "content": "#ifndef DYNAMIC_MEMORY_H\n#define DYNAMIC_MEMORY_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: WHEN to Use Static vs Dynamic Memory Allocation */\n/* ========================================================================== */\n/* This problem teaches the DECISION-MAKING PROCESS for choosing between\n * static allocation and dynamic allocation (kmalloc).\n *\n * CRITICAL LEARNING OBJECTIVE:\n * Understanding WHEN kmalloc is REQUIRED vs OPTIONAL is essential for\n * kernel development. Many students learn the syntax but not the criteria!\n *\n * DECISION TREE:\n * \n * Q1: Is the size known at compile time?\n *     NO  -> MUST use kmalloc (required)\n *     YES -> Continue to Q2\n *\n * Q2: Does memory need to outlive the function scope?\n *     YES -> MUST use kmalloc (required)\n *     NO  -> Continue to Q3\n *\n * Q3: Do you need to return a pointer from a function?\n *     YES -> MUST use kmalloc (required)\n *     NO  -> Static allocation is acceptable\n *\n * EXAMPLES OF WHEN KMALLOC IS REQUIRED:\n *\n * 1. RUNTIME-DETERMINED SIZE (Cannot use static allocation):\n *    int count = module_parameter;  // Unknown at compile time\n *    Device devices[count];  // ILLEGAL in C (VLA not allowed in kernel)\n *    Device *devices = kmalloc(sizeof(Device) * count, GFP_KERNEL);  // REQUIRED\n *\n * 2. RETURNING MEMORY FROM FUNCTION (Cannot use local variables):\n *    Device* bad_create(void) {\n *        Device local = {1, 2, true};  // Stack variable destroyed on return\n *        return &local;  // DANGER: Dangling pointer!\n *    }\n *    Device* good_create(void) {\n *        Device *dev = kmalloc(sizeof(Device), GFP_KERNEL);  // REQUIRED\n *        return dev;  // SAFE: Heap memory persists\n *    }\n *\n * 3. PERSISTENT LIFETIME (Beyond function scope):\n *    void init_device(void) {\n *        Device temp = {1, 2, true};  // Destroyed when function exits\n *    }\n *    Device *persistent_device = kmalloc(sizeof(Device), GFP_KERNEL);  // REQUIRED\n *\n * EXAMPLES OF WHEN STATIC IS ACCEPTABLE:\n *\n * 1. FIXED SIZE, KNOWN AT COMPILE TIME:\n *    Device single_device = {1001, 200, true};  // OK: Size known, lifetime OK\n *\n * 2. FIXED-SIZE ARRAY:\n *    Device devices[5] = {...};  // OK: Size known at compile time\n *\n * WHY THIS MATTERS IN KERNEL DEVELOPMENT:\n * - The Linux kernel uses kmalloc extensively for runtime-sized data structures\n * - Driver registration, device management, buffer allocation all use kmalloc\n * - Misunderstanding leads to stack corruption, memory leaks, crashes\n */\n\n/* ========================================================================== */\n/* MEMORY ALLOCATION PATTERN: The Lifecycle */\n/* ========================================================================== */\n/* KMALLOC/KFREE LIFECYCLE (4 Essential Steps):\n *\n * Step 1: ALLOCATE\n *   Device *dev = kmalloc(sizeof(Device), GFP_KERNEL);\n *   ^       ^      ^       ^               ^\n *   type    result function size           flags\n *\n * Step 2: CHECK (Critical - kmalloc can fail!)\n *   if (!dev) {\n *       printk(KERN_ERR \"Allocation failed!\\n\");\n *       return -ENOMEM;\n *   }\n *\n * Step 3: USE\n *   dev->device_id = 1001;\n *   dev->status = 200;\n *   dev->is_active = true;\n *\n * Step 4: FREE (When done)\n *   kfree(dev);\n *   dev = NULL;  // Prevent use-after-free bugs\n *\n * COMMON MISTAKES:\n * - Forgetting to check if kmalloc returned NULL\n * - Using memory after kfree (use-after-free bug)\n * - Forgetting to kfree (memory leak)\n * - Double-freeing the same pointer (double-free bug)\n */\n\n/* Device structure definition */\ntypedef struct {\n    int device_id;\n    int status;\n    bool is_active;\n} Device;\n\n/* Global device array pointer - dynamically allocated */\nextern Device **device_array;\nextern int device_count;\n\n/* ========================================================================== */\n/* SECTION 1: Function Declarations */\n/* ========================================================================== */\n/* TODO: Declare the following functions (declaration only, no implementation) */\n/* \n * REQUIRED FUNCTIONS:\n * 1. allocate_devices - Takes device count, returns 0 on success, -ENOMEM on failure\n * 2. initialize_device - Takes device pointer and ID, initializes device fields\n * 3. print_device_info - Takes device pointer, prints device information\n * 4. cleanup_devices - Takes no parameters, frees all allocated memory\n *\n * HINTS:\n * - allocate_devices should return int (for error code)\n * - initialize_device should take (Device *dev, int id) as parameters\n * - print_device_info should take (Device *dev) as parameter\n * - cleanup_devices should return void\n */\n\n#endif /* DYNAMIC_MEMORY_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "dynamic_memory.c",
        "content": "#include \"dynamic_memory.h\"\n\n/* Global device array pointer - starts as NULL */\nDevice **device_array = NULL;\nint device_count = 3;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses device_count to verify your dynamic allocation\n * works with RUNTIME-DETERMINED sizes (the key learning objective!).\n */\nmodule_param(device_count, int, 0644);\nMODULE_PARM_DESC(device_count, \"Number of devices to allocate (runtime-determined)\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: WHY Static Allocation Fails Here */\n/* ========================================================================== */\n/* PROBLEM: We need to allocate 'device_count' devices, but device_count\n * is determined at MODULE LOAD TIME (runtime), not compile time!\n *\n * STATIC ALLOCATION ATTEMPT (WILL NOT WORK):\n *   Device devices[device_count];  // ILLEGAL: VLA not allowed in kernel!\n *   \n * WHY THIS FAILS:\n * - device_count is only known when module loads (insmod dynamic_memory.ko device_count=5)\n * - C requires array sizes to be known at compile time\n * - Variable-Length Arrays (VLAs) are prohibited in kernel code for safety\n *\n * SOLUTION: MUST use kmalloc for runtime-determined sizes!\n *   Device **devices = kmalloc(sizeof(Device*) * device_count, GFP_KERNEL);\n *   ^       ^          ^        ^                  ^\n *   type    result     function size calculation   flags\n *\n * This is a REQUIRED use case for dynamic memory allocation!\n */\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: Two-Level Allocation Pattern */\n/* ========================================================================== */\n/* For an array of device pointers, we need TWO allocations:\n *\n * LEVEL 1: Allocate the array of pointers\n *   Device **device_array = kmalloc(sizeof(Device*) * count, GFP_KERNEL);\n *   This creates: [ptr0][ptr1][ptr2]...[ptrN]  (array of pointers)\n *\n * LEVEL 2: Allocate each individual device\n *   for (i = 0; i < count; i++) {\n *       device_array[i] = kmalloc(sizeof(Device), GFP_KERNEL);\n *   }\n *   This creates: [ptr0] -> Device{id, status, active}\n *                 [ptr1] -> Device{id, status, active}\n *                 [ptr2] -> Device{id, status, active}\n *\n * MEMORY LAYOUT VISUALIZATION:\n *   Stack:                    Heap (Level 1):           Heap (Level 2):\n *   +-------------+          +-------+                 +---------+\n *   |device_array |--------->| ptr0  |---------------->| Device 0|\n *   +-------------+          | ptr1  |---------------->| Device 1|\n *                            | ptr2  |---------------->| Device 2|\n *                            +-------+                 +---------+\n *\n * CLEANUP MUST BE TWO-LEVEL (in reverse order):\n *   Step 1: Free each device (Level 2)\n *   Step 2: Free the pointer array (Level 1)\n */\n\n/* ========================================================================== */\n/* SECTION 1: Memory Allocation Function */\n/* ========================================================================== */\n/* TODO: Implement allocate_devices function\n *\n * REQUIREMENTS:\n * - Function signature: int allocate_devices(int count)\n * - Allocate array of Device pointers (Level 1)\n * - Allocate each individual Device (Level 2)\n * - Check BOTH allocations for NULL (error handling!)\n * - Return 0 on success, -ENOMEM on failure\n * - Store result in global device_array variable\n *\n * ALGORITHM:\n * 1. Print message: \"Allocating %d devices...\" with count\n * 2. Allocate Level 1: device_array = kmalloc(sizeof(Device*) * count, GFP_KERNEL)\n * 3. Check if device_array is NULL (allocation failed)\n *    - If NULL: print error, return -ENOMEM\n * 4. Loop i from 0 to count-1:\n *    a. Allocate Level 2: device_array[i] = kmalloc(sizeof(Device), GFP_KERNEL)\n *    b. Check if device_array[i] is NULL\n *       - If NULL: free all previously allocated devices (0 to i-1), free device_array, return -ENOMEM\n * 5. Print success message: \"Successfully allocated %d devices\"\n * 6. Return 0\n *\n * CRITICAL ERROR HANDLING:\n * If Level 2 allocation fails partway through (e.g., device 3 out of 5),\n * you MUST free devices 0, 1, 2 before returning!\n */\nint allocate_devices(int count)\n{\n    /* TODO: Implement two-level allocation as described above */\n    return -ENOMEM;  /* Replace with actual implementation */\n}\n\n/* ========================================================================== */\n/* SECTION 2: Device Initialization Function */\n/* ========================================================================== */\n/* TODO: Implement initialize_device function\n *\n * REQUIREMENTS:\n * - Function signature: void initialize_device(Device *dev, int id)\n * - Check if dev pointer is NULL (safety check)\n * - Initialize device fields:\n *   - device_id = id\n *   - status = 200\n *   - is_active = true\n * - Print message: \"Device %d initialized\"\n *\n * ALGORITHM:\n * 1. Check if dev is NULL\n *    - If NULL: print error \"Cannot initialize NULL device\", return\n * 2. Set dev->device_id = id\n * 3. Set dev->status = 200\n * 4. Set dev->is_active = true\n * 5. Print success message with device ID\n */\nvoid initialize_device(Device *dev, int id)\n{\n    /* TODO: Implement device initialization as described above */\n}\n\n/* ========================================================================== */\n/* SECTION 3: Device Info Printing Function */\n/* ========================================================================== */\n/* TODO: Implement print_device_info function\n *\n * REQUIREMENTS:\n * - Function signature: void print_device_info(Device *dev)\n * - Check if dev pointer is NULL (safety check)\n * - Print device information:\n *   - \"=== Device Info ===\"\n *   - \"Device ID: %d\" (dev->device_id)\n *   - \"Status: %d\" (dev->status)\n *   - \"Active: YES\" or \"Active: NO\" (based on dev->is_active)\n *\n * ALGORITHM:\n * 1. Check if dev is NULL\n *    - If NULL: print error \"Cannot print info: device is NULL\", return\n * 2. Print header \"=== Device Info ===\"\n * 3. Print \"Device ID: %d\" with dev->device_id\n * 4. Print \"Status: %d\" with dev->status\n * 5. Print \"Active: YES\" if dev->is_active is true, else \"Active: NO\"\n */\nvoid print_device_info(Device *dev)\n{\n    /* TODO: Implement device info printing as described above */\n}\n\n/* ========================================================================== */\n/* SECTION 4: Memory Cleanup Function */\n/* ========================================================================== */\n/* TODO: Implement cleanup_devices function\n *\n * REQUIREMENTS:\n * - Function signature: void cleanup_devices(void)\n * - Free all allocated memory (two-level cleanup!)\n * - Set pointers to NULL after freeing (prevent use-after-free)\n * - Use global variables: device_array, device_count\n *\n * ALGORITHM:\n * 1. Check if device_array is NULL\n *    - If NULL: print \"No devices to free\", return\n * 2. Print message: \"Freeing %d devices...\" with device_count\n * 3. Loop i from 0 to device_count-1:\n *    a. Check if device_array[i] is not NULL\n *    b. Free device_array[i] using kfree\n *    c. Set device_array[i] = NULL\n * 4. Free device_array using kfree\n * 5. Set device_array = NULL\n * 6. Print success message: \"All devices freed\"\n *\n * CRITICAL: Must free in REVERSE order of allocation!\n * - First free individual devices (Level 2)\n * - Then free pointer array (Level 1)\n */\nvoid cleanup_devices(void)\n{\n    /* TODO: Implement two-level cleanup as described above */\n}\n\n/* ========================================================================== */\n/* MODULE INIT/EXIT */\n/* ========================================================================== */\nstatic int __init dynamic_memory_init(void)\n{\n    int ret;\n    int i;\n    int base_id = 1000;\n    \n    printk(KERN_INFO \"Dynamic memory module loaded\\n\");\n    printk(KERN_INFO \"Runtime device count: %d\\n\", device_count);\n    \n    /* Allocate devices dynamically */\n    ret = allocate_devices(device_count);\n    if (ret != 0) {\n        printk(KERN_ERR \"Failed to allocate devices\\n\");\n        return ret;\n    }\n    \n    /* Initialize all devices */\n    printk(KERN_INFO \"Initializing %d devices...\\n\", device_count);\n    for (i = 0; i < device_count; i++) {\n        initialize_device(device_array[i], base_id + i);\n    }\n    \n    /* Print information for all devices */\n    printk(KERN_INFO \"Printing device information...\\n\");\n    for (i = 0; i < device_count; i++) {\n        printk(KERN_INFO \"Device %d:\\n\", i);\n        print_device_info(device_array[i]);\n    }\n    \n    printk(KERN_INFO \"Dynamic allocation demonstration completed\\n\");\n    return 0;\n}\n\nstatic void __exit dynamic_memory_exit(void)\n{\n    printk(KERN_INFO \"Dynamic memory module unloading\\n\");\n    \n    /* Clean up all allocated memory */\n    cleanup_devices();\n    \n    printk(KERN_INFO \"Module unloaded cleanly\\n\");\n}\n\nmodule_init(dynamic_memory_init);\nmodule_exit(dynamic_memory_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Dynamic memory allocation with runtime-determined sizes\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Dynamic memory module Makefile\nobj-m += dynamic_memory.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "dynamic_memory.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "dynamic_memory_init",
          "dynamic_memory_exit",
          "allocate_devices",
          "initialize_device",
          "print_device_info",
          "cleanup_devices"
        ],
        "function_declarations": [
          {
            "name": "allocate_devices",
            "returnType": "int",
            "parameters": [
              "int count"
            ]
          },
          {
            "name": "initialize_device",
            "returnType": "void",
            "parameters": [
              "Device *dev",
              "int id"
            ]
          },
          {
            "name": "print_device_info",
            "returnType": "void",
            "parameters": [
              "Device *dev"
            ]
          },
          {
            "name": "cleanup_devices",
            "returnType": "void",
            "parameters": []
          }
        ],
        "variables_declarations": [
          {
            "name": "Device",
            "type": "typedef struct",
            "value": "{int device_id; int status; bool is_active;}",
            "storageClass": "none"
          },
          {
            "name": "device_array",
            "type": "Device **",
            "storageClass": "extern"
          },
          {
            "name": "device_count",
            "type": "int",
            "storageClass": "extern"
          }
        ],
        "variables": [
          {
            "name": "device_array",
            "type": "Device **",
            "value": "NULL",
            "storageClass": "none"
          },
          {
            "name": "device_count",
            "type": "int",
            "value": "3",
            "storageClass": "none"
          }
        ],
        "outputMessages": [
          "Dynamic memory module loaded",
          "Runtime device count: 3",
          "Allocating 3 devices...",
          "Successfully allocated 3 devices",
          "Initializing 3 devices...",
          "Device 1000 initialized",
          "Device 1001 initialized",
          "Device 1002 initialized",
          "Printing device information...",
          "Device 0:",
          "=== Device Info ===",
          "Device ID: 1000",
          "Status: 200",
          "Active: YES",
          "Device 1:",
          "Device ID: 1001",
          "Device 2:",
          "Device ID: 1002",
          "Dynamic allocation demonstration completed",
          "Dynamic memory module unloading",
          "Freeing 3 devices...",
          "All devices freed",
          "Module unloaded cleanly"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h",
          "linux/slab.h"
        ],
        "mustContain": [
          "kmalloc(sizeof(Device*) * count, GFP_KERNEL)",
          "kmalloc(sizeof(Device), GFP_KERNEL)",
          "kfree(device_array[i])",
          "kfree(device_array)",
          "if (!device_array)",
          "device_array = NULL",
          "module_param(device_count, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int allocate_devices(int count)",
            "void initialize_device(Device *dev, int id)",
            "void print_device_info(Device *dev)",
            "void cleanup_devices(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int allocate_devices(int count)",
            "void initialize_device(Device *dev, int id)",
            "void print_device_info(Device *dev)",
            "void cleanup_devices(void)",
            "static int __init dynamic_memory_init(void)",
            "static void __exit dynamic_memory_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages with Function Linkage",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Dynamic memory module loaded",
              "exact": true,
              "linkedFunction": "static int __init dynamic_memory_init(void)"
            },
            {
              "pattern": "Runtime device count:",
              "exact": false,
              "linkedFunction": "static int __init dynamic_memory_init(void)"
            },
            {
              "pattern": "Allocating",
              "exact": false,
              "linkedFunction": "int allocate_devices(int count)"
            },
            {
              "pattern": "Successfully allocated",
              "exact": false,
              "linkedFunction": "int allocate_devices(int count)"
            },
            {
              "pattern": "Initializing",
              "exact": false,
              "linkedFunction": "static int __init dynamic_memory_init(void)"
            },
            {
              "pattern": "Device 1000 initialized",
              "exact": true,
              "linkedFunction": "void initialize_device(Device *dev, int id)"
            },
            {
              "pattern": "Printing device information...",
              "exact": true,
              "linkedFunction": "static int __init dynamic_memory_init(void)"
            },
            {
              "pattern": "Device 0:",
              "exact": true,
              "linkedFunction": "static int __init dynamic_memory_init(void)"
            },
            {
              "pattern": "=== Device Info ===",
              "exact": true,
              "linkedFunction": "void print_device_info(Device *dev)"
            },
            {
              "pattern": "Device ID: 1000",
              "exact": true,
              "linkedFunction": "void print_device_info(Device *dev)"
            },
            {
              "pattern": "Status: 200",
              "exact": true,
              "linkedFunction": "void print_device_info(Device *dev)"
            },
            {
              "pattern": "Active: YES",
              "exact": true,
              "linkedFunction": "void print_device_info(Device *dev)"
            },
            {
              "pattern": "Dynamic allocation demonstration completed",
              "exact": true,
              "linkedFunction": "static int __init dynamic_memory_init(void)"
            },
            {
              "pattern": "Dynamic memory module unloading",
              "exact": true,
              "linkedFunction": "static void __exit dynamic_memory_exit(void)"
            },
            {
              "pattern": "Freeing",
              "exact": false,
              "linkedFunction": "void cleanup_devices(void)"
            },
            {
              "pattern": "All devices freed",
              "exact": true,
              "linkedFunction": "void cleanup_devices(void)"
            },
            {
              "pattern": "Module unloaded cleanly",
              "exact": true,
              "linkedFunction": "static void __exit dynamic_memory_exit(void)"
            }
          ]
        },
        {
          "id": "advanced_dynamic_memory_validation",
          "name": "Advanced Dynamic Memory Implementation with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "memory_dynamic_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Runtime-Determined Size Allocation Test ===\\\\n\\\");\\n    \\n    srand(time(NULL));\\n    \\n    // Test different device counts (runtime-determined)\\n    int test_count1 = (rand() % 3) + 2;  // 2-4 devices\\n    int test_count2 = (rand() % 4) + 5;  // 5-8 devices\\n    \\n    printf(\\\"Test 1: Allocating %d devices (runtime size)\\\\n\\\", test_count1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/dynamic_memory.ko device_count=%d\\\", test_count1);\\n    system(\\\"rmmod dynamic_memory 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Allocating %d devices (runtime size)\\\\n\\\", test_count2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/dynamic_memory.ko device_count=%d\\\", test_count2);\\n    system(\\\"rmmod dynamic_memory\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Runtime-sized allocation test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced dynamic memory implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
              "echo '#define true 1' >> /tmp/linux/types.h",
              "echo '#define false 0' >> /tmp/linux/types.h",
              "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
              "echo '#define MAX_DEVICES 5' >> /tmp/linux/types.h",
              "echo '#define GFP_KERNEL 0' > /tmp/linux/slab.h",
              "echo '#define ENOMEM 12' >> /tmp/linux/slab.h",
              "echo 'void *kmalloc(size_t size, int flags);' >> /tmp/linux/slab.h",
              "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
              "echo 'Creating test file that includes dynamic memory header...'",
              "echo '#include \"/lib/modules/dynamic_memory.h\"' > /tmp/test.c",
              "echo 'int main() { allocate_devices(3); initialize_device(device_array[0], 1000); print_device_info(device_array[0]); cleanup_devices(); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
              "echo 'Phase 2: Runtime-Determined Size Allocation Testing'",
              "/bin/memory_dynamic_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Extract Runtime Device Counts'",
              "sleep 1",
              "echo 'Extracting runtime device counts from test output...'",
              "COUNT1=$(grep -o 'Test 1: Allocating [0-9]*' /tmp/test_output.log | cut -d' ' -f4)",
              "COUNT2=$(grep -o 'Test 2: Allocating [0-9]*' /tmp/test_output.log | cut -d' ' -f4)",
              "echo 'Extracted runtime counts: COUNT1='$COUNT1', COUNT2='$COUNT2",
              "if [ -z \"$COUNT1\" ] || [ -z \"$COUNT2\" ]; then echo 'FAIL: Could not extract runtime counts'; else echo 'PASS: Runtime device counts extracted successfully'; fi",
              "echo 'Phase 4: Two-Level Allocation Validation (CRITICAL)'",
              "echo 'Validating Level 1: Array of device pointers allocation...'",
              "dmesg | grep -E '(Allocating|allocated)' && echo 'PASS: Level 1 allocation (device array) working' || echo 'FAIL: Level 1 allocation broken'",
              "dmesg | grep -E '(Successfully allocated|allocated)' && echo 'PASS: Two-level allocation successful' || echo 'FAIL: Two-level allocation broken'",
              "echo 'Phase 5: Runtime Device Count Validation'",
              "echo 'Validating with runtime count '$COUNT1' devices...'",
              "dmesg | grep \"Runtime device count: $COUNT1\" && echo 'PASS: Runtime count '$COUNT1' detected' || echo 'FAIL: Runtime count detection broken'",
              "dmesg | grep -E '(Allocating|allocated)' && echo 'PASS: Correct device count allocation' || echo 'FAIL: Wrong device count'",
              "dmesg | grep -E '(Successfully|allocated)' && echo 'PASS: All devices allocated' || echo 'FAIL: Allocation incomplete'",
              "echo 'Phase 6: Device Initialization Validation'",
              "dmesg | grep 'Device 1000 initialized' && echo 'PASS: Device initialization working' || echo 'FAIL: Device initialization broken'",
              "dmesg | grep 'Device ID: 1000' && echo 'PASS: First device data correct' || echo 'FAIL: First device data wrong'",
              "dmesg | grep 'Status: 200' && echo 'PASS: Device status field correct' || echo 'FAIL: Device status wrong'",
              "dmesg | grep 'Active: YES' && echo 'PASS: Device boolean field correct' || echo 'FAIL: Device boolean wrong'",
              "echo 'Phase 7: Two-Level Cleanup Validation (CRITICAL)'",
              "dmesg | grep -E '(Freeing|free)' && echo 'PASS: Cleanup initiated' || echo 'FAIL: Cleanup not initiated'",
              "dmesg | grep 'All devices freed' && echo 'PASS: Two-level cleanup successful' || echo 'FAIL: Cleanup broken'",
              "dmesg | grep 'Module unloaded cleanly' && echo 'PASS: Complete cleanup successful' || echo 'FAIL: Module unload broken'",
              "echo 'Phase 8: Final Validation Summary'",
              "echo 'PASS: All runtime-determined allocation validation successful'"
            ],
            "expected": {
              "dmesg": [
                "Dynamic memory module loaded",
                "Runtime device count: .*",
                "Allocat",
                "Initializing.*devices",
                "Device 1000 initialized",
                "Device ID: 1000",
                "Status: 200",
                "Active: YES",
                "Freeing",
                "All devices freed",
                "Module unloaded cleanly"
              ],
              "stdout": [
                "PASS: All function and variable declarations found in header file",
                "SUCCESS: Runtime-sized allocation test completed",
                "PASS: Runtime device counts extracted successfully",
                "PASS: Level 1 allocation \\(device array\\) working",
                "PASS: Two-level allocation successful",
                "PASS: Runtime count.*detected",
                "PASS: Correct device count allocation",
                "PASS: All devices allocated",
                "PASS: Device initialization working",
                "PASS: First device data correct",
                "PASS: Device status field correct",
                "PASS: Device boolean field correct",
                "PASS: Cleanup initiated",
                "PASS: Two-level cleanup successful",
                "PASS: Complete cleanup successful",
                "PASS: All runtime-determined allocation validation successful"
              ]
            },
            "timeout": 15
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Dynamic memory module loaded",
        "Runtime device count: 3",
        "Allocating 3 devices...",
        "Successfully allocated 3 devices",
        "Initializing 3 devices...",
        "Device 1000 initialized",
        "Device 1001 initialized",
        "Device 1002 initialized",
        "Printing device information...",
        "Device 0:",
        "=== Device Info ===",
        "Device ID: 1000",
        "Status: 200",
        "Active: YES",
        "Device 1:",
        "Device ID: 1001",
        "Device 2:",
        "Device ID: 1002",
        "Dynamic allocation demonstration completed",
        "Dynamic memory module unloading",
        "Freeing 3 devices...",
        "All devices freed",
        "Module unloaded cleanly"
      ],
      "requirements": [
        "Use required function names: dynamic_memory_init, dynamic_memory_exit, allocate_devices, initialize_device, print_device_info, cleanup_devices",
        "Use required variable names: device_array, device_count",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h, linux/slab.h",
        "Code must contain: kmalloc(sizeof(Device*) * count, GFP_KERNEL), kmalloc(sizeof(Device), GFP_KERNEL), kfree(device_array[i]), kfree(device_array), if (!device_array), device_array = NULL, module_param(device_count, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Dynamic memory module loaded",
          "linkedFunction": "static int __init dynamic_memory_init(void)",
          "exact": true
        },
        {
          "pattern": "Runtime device count:",
          "linkedFunction": "static int __init dynamic_memory_init(void)",
          "exact": false
        },
        {
          "pattern": "Allocating",
          "linkedFunction": "int allocate_devices(int count)",
          "exact": false
        },
        {
          "pattern": "Successfully allocated",
          "linkedFunction": "int allocate_devices(int count)",
          "exact": false
        },
        {
          "pattern": "Initializing",
          "linkedFunction": "static int __init dynamic_memory_init(void)",
          "exact": false
        },
        {
          "pattern": "Device 1000 initialized",
          "linkedFunction": "void initialize_device(Device *dev, int id)",
          "exact": true
        },
        {
          "pattern": "Printing device information...",
          "linkedFunction": "static int __init dynamic_memory_init(void)",
          "exact": true
        },
        {
          "pattern": "Device 0:",
          "linkedFunction": "static int __init dynamic_memory_init(void)",
          "exact": true
        },
        {
          "pattern": "=== Device Info ===",
          "linkedFunction": "void print_device_info(Device *dev)",
          "exact": true
        },
        {
          "pattern": "Device ID: 1000",
          "linkedFunction": "void print_device_info(Device *dev)",
          "exact": true
        },
        {
          "pattern": "Status: 200",
          "linkedFunction": "void print_device_info(Device *dev)",
          "exact": true
        },
        {
          "pattern": "Active: YES",
          "linkedFunction": "void print_device_info(Device *dev)",
          "exact": true
        },
        {
          "pattern": "Dynamic allocation demonstration completed",
          "linkedFunction": "static int __init dynamic_memory_init(void)",
          "exact": true
        },
        {
          "pattern": "Dynamic memory module unloading",
          "linkedFunction": "static void __exit dynamic_memory_exit(void)",
          "exact": true
        },
        {
          "pattern": "Freeing",
          "linkedFunction": "void cleanup_devices(void)",
          "exact": false
        },
        {
          "pattern": "All devices freed",
          "linkedFunction": "void cleanup_devices(void)",
          "exact": true
        },
        {
          "pattern": "Module unloaded cleanly",
          "linkedFunction": "static void __exit dynamic_memory_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 30,
    "title": "Dynamic Vector Implementation - Kernel Memory Management",
    "difficulty": 8,
    "xp": 85,
    "phase": "foundations",
    "description": "Master dynamic memory management by implementing a production-grade generic vector in kernel space. Learn kmalloc/kfree, dynamic array expansion/shrinking, void* generic programming, and memory-safe operations. This problem teaches critical kernel development skills: dynamic memory allocation, capacity management, bounds checking, and proper resource cleanup - patterns used throughout the Linux kernel in data structure implementations.",
    "concepts": [
      "dynamic memory allocation",
      "kernel memory management (kmalloc/kfree/krealloc)",
      "generic programming with void pointers",
      "dynamic array implementation",
      "capacity management and resizing",
      "bounds checking and error handling",
      "amortized time complexity",
      "memory safety patterns"
    ],
    "skills": [
      "Using kmalloc, kfree, and krealloc correctly",
      "Implementing dynamic array expansion/shrinking",
      "Managing capacity and size separately",
      "Generic data structure design with void*",
      "Proper error handling and return codes",
      "Memory leak prevention",
      "Bounds checking implementation",
      "Understanding amortized analysis"
    ],
    "files": [
      {
        "name": "kernel_vector.h",
        "content": "#ifndef KERNEL_VECTOR_H\n#define KERNEL_VECTOR_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n/* Initial capacity and error codes */\n#define VECTOR_INIT_CAPACITY 4\n#define VECTOR_SUCCESS 0\n#define VECTOR_ERROR -1\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: Dynamic Vector Data Structure */\n/* ========================================================================== */\n/* This problem teaches PRODUCTION-LEVEL dynamic memory management patterns!\n *\n * WHAT IS A VECTOR?\n * A vector is a dynamic array that automatically grows when needed.\n * Unlike fixed arrays, vectors can change size at runtime.\n *\n * VECTOR STRUCTURE EXPLAINED:\n * typedef struct vector {\n *     void **items;    // Array of void pointers (generic storage)\n *     int capacity;    // Maximum elements before resize needed\n *     int total;       // Current number of elements\n * } vector;\n *\n * MEMORY LAYOUT VISUALIZATION:\n * vector v = {.capacity=4, .total=2}\n * \n * Stack (vector struct):           Heap (items array):\n * ┌──────────────┐                ┌──────┐\n * │ items    ────┼────────────────→│ ptr0 │ → \"first item\"\n * │ capacity = 4 │                 │ ptr1 │ → \"second item\"\n * │ total    = 2 │                 │ ptr2 │ → NULL (unused)\n * └──────────────┘                 │ ptr3 │ → NULL (unused)\n *                                  └──────┘\n *\n * WHY VOID POINTERS (void**)?\n * void* can point to ANY data type:\n * - Store strings: items[0] = \"hello\";\n * - Store integers: items[1] = (void*)(long)42;\n * - Store structs: items[2] = &my_struct;\n * This makes vectors GENERIC - one implementation works for all types!\n */\n\n/* Vector structure definition */\ntypedef struct vector {\n    void **items;     /* Array of void pointers for generic storage */\n    int capacity;     /* Maximum number of elements before resize */\n    int total;        /* Current number of elements */\n} vector;\n\n/* ========================================================================== */\n/* SECTION 1: FUNCTION DECLARATIONS */\n/* ========================================================================== */\n/* TODO: Declare vector manipulation functions */\n\n/* int vector_init(vector *v); */\n/* int vector_total(vector *v); */\n/* int vector_add(vector *v, void *item); */\n/* int vector_set(vector *v, int index, void *item); */\n/* void *vector_get(vector *v, int index); */\n/* int vector_delete(vector *v, int index); */\n/* void vector_free(vector *v); */\n\n/* ========================================================================== */\n/* CONVENIENCE MACROS (OPTIONAL) */\n/* ========================================================================== */\n/* These macros provide cleaner syntax for vector operations:\n *\n * WITHOUT MACROS:         WITH MACROS:\n * vector_init(&v);        VECTOR_INIT(v);\n * vector_add(&v, item);   VECTOR_ADD(v, item);\n * vector_get(&v, 0);      VECTOR_GET(v, char*, 0);\n *\n * Students can choose to implement these or use function calls directly.\n */\n\n#define VECTOR_INIT(vec) vector_init(&vec)\n#define VECTOR_ADD(vec, item) vector_add(&vec, (void*)item)\n#define VECTOR_SET(vec, id, item) vector_set(&vec, id, (void*)item)\n#define VECTOR_GET(vec, type, id) (type)vector_get(&vec, id)\n#define VECTOR_DELETE(vec, id) vector_delete(&vec, id)\n#define VECTOR_TOTAL(vec) vector_total(&vec)\n#define VECTOR_FREE(vec) vector_free(&vec)\n\n#endif /* KERNEL_VECTOR_H */\n",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "VECTOR_OPERATIONS_GUIDE.md",
        "content": "# Dynamic Vector Operations - Complete Visual Guide\n\n## Table of Contents\n1. [What is a Vector?](#what-is-a-vector)\n2. [Vector vs Fixed Arrays](#vector-vs-fixed-arrays)\n3. [Vector Structure Explained](#vector-structure-explained)\n4. [Memory Layout](#memory-layout)\n5. [Operation: Initialization](#operation-initialization)\n6. [Operation: Add with Capacity Doubling](#operation-add-with-capacity-doubling)\n7. [Operation: Get and Set](#operation-get-and-set)\n8. [Operation: Delete with Element Shifting](#operation-delete-with-element-shifting)\n9. [Operation: Resize Mechanics](#operation-resize-mechanics)\n10. [Common Pitfalls and Solutions](#common-pitfalls-and-solutions)\n\n---\n\n## What is a Vector?\n\nA **vector** is a **dynamic array** that automatically grows when you need more space.\n\n### Key Concept:\n```\nFixed Array:  [A][B][C][D]           <- Size NEVER changes\n              Size = 4 (forever)\n\nVector:       [A][B][C][D]           <- Can grow!\n              Size = 4 (for now)\n\n              Add more items...\n\n              [A][B][C][D][E][F][G][H]\n              Size = 8 (doubled!)\n```\n\n### Why \"Dynamic\"?\n- You don't need to know the size at compile time\n- It grows automatically when full\n- It can shrink to save memory when mostly empty\n\n---\n\n## Vector vs Fixed Arrays\n\n### Fixed Array (Static)\n\n```c\nDevice devices[5];    // Size fixed at compile time\n\n// Problem 1: What if you need 6 devices?\ndevices[5] = new_device;  // CRASH! Out of bounds!\n\n// Problem 2: What if you only use 2 devices?\n// Waste: 3 unused entries taking memory\n```\n\n### Vector (Dynamic)\n\n```c\nvector v;\nvector_init(&v);      // Starts at capacity 4\n\n// No problem adding 6 items:\nvector_add(&v, device1);  // total=1, capacity=4\nvector_add(&v, device2);  // total=2, capacity=4\nvector_add(&v, device3);  // total=3, capacity=4\nvector_add(&v, device4);  // total=4, capacity=4\nvector_add(&v, device5);  // total=5, capacity=8 (auto-doubled!)\nvector_add(&v, device6);  // total=6, capacity=8\n\n// No waste: only uses what it needs!\n```\n\n---\n\n## Vector Structure Explained\n\n```c\ntypedef struct vector {\n    void **items;     // Pointer to array of pointers\n    int capacity;     // Maximum slots available\n    int total;        // Current number of items\n} vector;\n```\n\n### Field Meanings:\n\n**items**: Array of `void*` pointers (generic storage)\n- Each slot holds a pointer to ANY type of data\n- This is why vectors are generic\n\n**capacity**: Maximum number of items before resize needed\n- Tracks allocated space\n- Example: capacity=8 means 8 slots allocated\n\n**total**: Current number of actual items stored\n- Tracks how many slots are in use\n- Example: total=5 means 5 items stored\n\n### Relationship Between Fields:\n\n```\ntotal <= capacity (always!)\n\nExamples:\ntotal=3, capacity=4   <- Vector has room for 1 more item\ntotal=4, capacity=4   <- Vector is FULL (triggers resize on next add)\ntotal=5, capacity=8   <- Vector has room for 3 more items\n```\n\n---\n\n## Memory Layout\n\n### Two Levels of Memory:\n\n```\nLevel 1: The Vector Structure (on stack or heap)\n┌─────────────────────────────┐\n│ vector v                    │\n│                             │\n│  void **items   ───────┐    │\n│  int capacity = 4      │    │\n│  int total = 2         │    │\n└────────────────────────│────┘\n                         │\n                         │\nLevel 2: Items Array (on heap, allocated with kmalloc)\n                         │\n                         │\n                         ▼\n         ┌───────┬───────┬───────┬───────┐\n         │ ptr0  │ ptr1  │ ptr2  │ ptr3  │\n         └───┬───┴───┬───┴───────┴───────┘\n             │       │\n             │       └──────────────┐\n             │                      │\n             ▼                      ▼\n         \"first item\"           \"second item\"\n```\n\n### Memory Addresses Example:\n\n```\nStack/Heap (vector struct):\n  v.items    = 0x7fff1234   (points to items array)\n  v.capacity = 4\n  v.total    = 2\n\nHeap (items array at 0x7fff1234):\n  items[0] = 0x7fff5000   (points to \"first item\")\n  items[1] = 0x7fff5020   (points to \"second item\")\n  items[2] = NULL         (unused slot)\n  items[3] = NULL         (unused slot)\n\nHeap (actual data):\n  0x7fff5000: \"first item\"\n  0x7fff5020: \"second item\"\n```\n\n---\n\n## Operation: Initialization\n\n### Code:\n```c\nvector v;\nvector_init(&v);\n```\n\n### What Happens:\n\n```\nStep 1: Allocate vector structure\n┌─────────────────────────────┐\n│ vector v                    │\n│  void **items   = ?         │\n│  int capacity   = ?         │\n│  int total      = ?         │\n└─────────────────────────────┘\n\nStep 2: Set initial values\n┌─────────────────────────────┐\n│ vector v                    │\n│  void **items   = NULL      │\n│  int capacity   = 4         │\n│  int total      = 0         │\n└─────────────────────────────┘\n\nStep 3: Allocate items array (kmalloc)\n┌─────────────────────────────┐\n│ vector v                    │\n│  void **items   ───────┐    │\n│  int capacity   = 4    │    │\n│  int total      = 0    │    │\n└────────────────────────│────┘\n                         │\n                         ▼\n         ┌──────┬──────┬──────┬──────┐\n         │ NULL │ NULL │ NULL │ NULL │\n         └──────┴──────┴──────┴──────┘\n           [0]    [1]    [2]    [3]\n```\n\n### Memory Allocation:\n```c\n// Inside vector_init():\nv->capacity = 4;\nv->total = 0;\nv->items = kmalloc(sizeof(void*) * 4, GFP_KERNEL);\n//                  ^^^^^^^^^^^^^^^^\n//                  4 pointers × 8 bytes = 32 bytes\n```\n\n---\n\n## Operation: Add with Capacity Doubling\n\n### Scenario: Add 5 items to a vector starting with capacity=4\n\n#### Initial State (Empty):\n```\ncapacity = 4, total = 0\n\n┌──────┬──────┬──────┬──────┐\n│ NULL │ NULL │ NULL │ NULL │\n└──────┴──────┴──────┴──────┘\n  [0]    [1]    [2]    [3]\n```\n\n#### After add #1: \"first\"\n```\ncapacity = 4, total = 1\n\n┌────────┬──────┬──────┬──────┐\n│ \"first\"│ NULL │ NULL │ NULL │\n└────────┴──────┴──────┴──────┘\n   [0]     [1]    [2]    [3]\n\nCode: vector_add(&v, \"first\");\nAction: items[0] = \"first\"; total++;\n```\n\n#### After add #2: \"second\"\n```\ncapacity = 4, total = 2\n\n┌────────┬─────────┬──────┬──────┐\n│ \"first\"│ \"second\"│ NULL │ NULL │\n└────────┴─────────┴──────┴──────┘\n   [0]      [1]      [2]    [3]\n\nCode: vector_add(&v, \"second\");\nAction: items[1] = \"second\"; total++;\n```\n\n#### After add #3: \"third\"\n```\ncapacity = 4, total = 3\n\n┌────────┬─────────┬────────┬──────┐\n│ \"first\"│ \"second\"│ \"third\"│ NULL │\n└────────┴─────────┴────────┴──────┘\n   [0]      [1]      [2]     [3]\n\nCode: vector_add(&v, \"third\");\nAction: items[2] = \"third\"; total++;\n```\n\n#### After add #4: \"fourth\"\n```\ncapacity = 4, total = 4  <- FULL!\n\n┌────────┬─────────┬────────┬─────────┐\n│ \"first\"│ \"second\"│ \"third\"│ \"fourth\"│\n└────────┴─────────┴────────┴─────────┘\n   [0]      [1]      [2]      [3]\n\nCode: vector_add(&v, \"fourth\");\nAction: items[3] = \"fourth\"; total++;\nStatus: capacity == total (vector is FULL!)\n```\n\n#### Add #5: \"fifth\" - TRIGGERS RESIZE!\n\n##### Step 1: Detect full condition\n```\nCheck: capacity (4) == total (4)?  YES!\nAction: Need to resize before adding!\n```\n\n##### Step 2: Call vector_resize(v, 8)\n```\nOld capacity = 4, New capacity = 8\n\nBEFORE RESIZE:\n┌────────┬─────────┬────────┬─────────┐\n│ \"first\"│ \"second\"│ \"third\"│ \"fourth\"│\n└────────┴─────────┴────────┴─────────┘\n\nAFTER RESIZE (krealloc):\n┌────────┬─────────┬────────┬─────────┬──────┬──────┬──────┬──────┐\n│ \"first\"│ \"second\"│ \"third\"│ \"fourth\"│ NULL │ NULL │ NULL │ NULL │\n└────────┴─────────┴────────┴─────────┴──────┴──────┴──────┴──────┘\n   [0]      [1]      [2]      [3]      [4]    [5]    [6]    [7]\n\nOld data preserved, new slots added!\n```\n\n##### Step 3: Add \"fifth\" to new slot\n```\ncapacity = 8, total = 5\n\n┌────────┬─────────┬────────┬─────────┬────────┬──────┬──────┬──────┐\n│ \"first\"│ \"second\"│ \"third\"│ \"fourth\"│ \"fifth\"│ NULL │ NULL │ NULL │\n└────────┴─────────┴────────┴─────────┴────────┴──────┴──────┴──────┘\n   [0]      [1]      [2]      [3]      [4]     [5]    [6]    [7]\n\nCode: items[4] = \"fifth\"; total++;\n```\n\n### Complete Doubling Sequence:\n\n```\nCapacity Progression:\n4 → 8 → 16 → 32 → 64 → 128 → ...\n\nWhen it happens:\ncapacity=4,  total=4   → Add 5th item → Resize to 8\ncapacity=8,  total=8   → Add 9th item → Resize to 16\ncapacity=16, total=16  → Add 17th item → Resize to 32\n```\n\n### Why Double (Not +1 or +10)?\n\n```\nStrategy 1: Increase by 1 each time\nAdd 1000 items = 1000 resizes!\nCost: O(n²) - VERY SLOW\n\nStrategy 2: Increase by 10 each time\nAdd 1000 items = 100 resizes\nCost: Still expensive\n\nStrategy 3: Double each time (×2)\nAdd 1000 items = ~10 resizes (log₂(1000) ≈ 10)\nCost: O(n) amortized - FAST!\n\nDoubling gives O(1) amortized time per add operation.\n```\n\n---\n\n## Operation: Get and Set\n\n### Get Operation: vector_get(&v, index)\n\n```\nVector state:\ncapacity = 8, total = 5\n\n┌────────┬─────────┬────────┬─────────┬────────┬──────┬──────┬──────┐\n│ \"first\"│ \"second\"│ \"third\"│ \"fourth\"│ \"fifth\"│ NULL │ NULL │ NULL │\n└────────┴─────────┴────────┴─────────┴────────┴──────┴──────┴──────┘\n   [0]      [1]      [2]      [3]      [4]     [5]    [6]    [7]\n\nValid indices: 0, 1, 2, 3, 4 (total=5)\nInvalid indices: 5, 6, 7 (beyond total), -1 (negative)\n\nExamples:\nvector_get(&v, 2)   → \"third\"  ✓ (index < total)\nvector_get(&v, 5)   → NULL     ✓ (index >= total, return NULL)\nvector_get(&v, -1)  → NULL     ✓ (negative index, return NULL)\n```\n\n### Set Operation: vector_set(&v, index, item)\n\n```\nBefore: vector_set(&v, 1, \"MODIFIED\")\n\n┌────────┬─────────┬────────┬─────────┬────────┐\n│ \"first\"│ \"second\"│ \"third\"│ \"fourth\"│ \"fifth\"│\n└────────┴─────────┴────────┴─────────┴────────┘\n   [0]      [1]      [2]      [3]      [4]\n\nAfter: items[1] = \"MODIFIED\"\n\n┌────────┬───────────┬────────┬─────────┬────────┐\n│ \"first\"│ \"MODIFIED\"│ \"third\"│ \"fourth\"│ \"fifth\"│\n└────────┴───────────┴────────┴─────────┴────────┘\n   [0]       [1]       [2]      [3]      [4]\n\nImportant: Can only set EXISTING indices (0 to total-1)\nvector_set(&v, 10, \"new\")  → ERROR (index >= total)\n```\n\n### Bounds Checking Diagram:\n\n```\ntotal = 5, capacity = 8\n\n                    total\n                      ↓\n┌────┬────┬────┬────┬────┬────┬────┬────┐\n│ OK │ OK │ OK │ OK │ OK │ NO │ NO │ NO │\n└────┴────┴────┴────┴────┴────┴────┴────┘\n  0    1    2    3    4    5    6    7\n  ↑                   ↑              ↑\nValid range      First invalid   capacity-1\n(0 to total-1)\n```\n\n---\n\n## Operation: Delete with Element Shifting\n\n### Scenario: Delete index 1 from a vector with 5 items\n\n#### Initial State:\n```\ncapacity = 8, total = 5\n\n┌────────┬─────────┬────────┬─────────┬────────┬──────┬──────┬──────┐\n│ \"first\"│ \"second\"│ \"third\"│ \"fourth\"│ \"fifth\"│ NULL │ NULL │ NULL │\n└────────┴─────────┴────────┴─────────┴────────┴──────┴──────┴──────┘\n   [0]      [1]      [2]      [3]      [4]     [5]    [6]    [7]\n            DELETE\n            THIS!\n```\n\n#### Step 1: Mark deletion target\n```\nCode: vector_delete(&v, 1);\n\nTarget index: 1 (\"second\")\nNeed to shift: [2], [3], [4] to the left\n```\n\n#### Step 2: Shift elements left\n```\nIteration 1: i=1\nitems[1] = items[2];   // \"third\" moves to index 1\n\n┌────────┬────────┬────────┬─────────┬────────┬──────┬──────┬──────┐\n│ \"first\"│ \"third\"│ \"third\"│ \"fourth\"│ \"fifth\"│ NULL │ NULL │ NULL │\n└────────┴────────┴────────┴─────────┴────────┴──────┴──────┴──────┘\n   [0]      [1]      [2]      [3]      [4]     [5]    [6]    [7]\n                   (duplicate)\n\nIteration 2: i=2\nitems[2] = items[3];   // \"fourth\" moves to index 2\n\n┌────────┬────────┬─────────┬─────────┬────────┬──────┬──────┬──────┐\n│ \"first\"│ \"third\"│ \"fourth\"│ \"fourth\"│ \"fifth\"│ NULL │ NULL │ NULL │\n└────────┴────────┴─────────┴─────────┴────────┴──────┴──────┴──────┘\n   [0]      [1]      [2]       [3]      [4]     [5]    [6]    [7]\n                              (duplicate)\n\nIteration 3: i=3\nitems[3] = items[4];   // \"fifth\" moves to index 3\n\n┌────────┬────────┬─────────┬────────┬────────┬──────┬──────┬──────┐\n│ \"first\"│ \"third\"│ \"fourth\"│ \"fifth\"│ \"fifth\"│ NULL │ NULL │ NULL │\n└────────┴────────┴─────────┴────────┴────────┴──────┴──────┴──────┘\n   [0]      [1]      [2]      [3]      [4]     [5]    [6]    [7]\n                                      (duplicate)\n\nLoop ends: i=4, condition i < total-1 (4 < 4) is FALSE\n```\n\n#### Step 3: Clear old last position\n```\nitems[total-1] = NULL;   // items[4] = NULL\n\n┌────────┬────────┬─────────┬────────┬──────┬──────┬──────┬──────┐\n│ \"first\"│ \"third\"│ \"fourth\"│ \"fifth\"│ NULL │ NULL │ NULL │ NULL │\n└────────┴────────┴─────────┴────────┴──────┴──────┴──────┴──────┘\n   [0]      [1]      [2]      [3]     [4]    [5]    [6]    [7]\n\nOld duplicate at [4] is now cleared\n```\n\n#### Step 4: Decrement total\n```\ntotal--;   // total becomes 4\n\ncapacity = 8, total = 4\n\n┌────────┬────────┬─────────┬────────┬──────┬──────┬──────┬──────┐\n│ \"first\"│ \"third\"│ \"fourth\"│ \"fifth\"│ NULL │ NULL │ NULL │ NULL │\n└────────┴────────┴─────────┴────────┴──────┴──────┴──────┴──────┘\n   [0]      [1]      [2]      [3]     [4]    [5]    [6]    [7]\n                                   ↑\n                              total=4\n\nDeletion complete! \"second\" is gone, all elements shifted left.\n```\n\n### Delete Algorithm Code:\n\n```c\nint vector_delete(vector *v, int index) {\n    // Step 1: Bounds check\n    if (index < 0 || index >= v->total)\n        return VECTOR_ERROR;\n\n    // Step 2: Shift elements left\n    for (int i = index; i < v->total - 1; i++) {\n        v->items[i] = v->items[i + 1];\n    }\n\n    // Step 3: Clear old last position\n    v->items[v->total - 1] = NULL;\n\n    // Step 4: Decrement total\n    v->total--;\n\n    return VECTOR_SUCCESS;\n}\n```\n\n### Multiple Deletes Example:\n\n```\nStart: total=5\n┌────────┬────────┬─────────┬────────┬────────┐\n│   A    │   B    │    C    │   D    │   E    │\n└────────┴────────┴─────────┴────────┴────────┘\n   [0]     [1]      [2]      [3]      [4]\n\nDelete index 1 (B): total=4\n┌────────┬─────────┬────────┬────────┬──────┐\n│   A    │    C    │   D    │   E    │ NULL │\n└────────┴─────────┴────────┴────────┴──────┘\n   [0]      [1]      [2]      [3]     [4]\n\nDelete index 2 (D): total=3\n┌────────┬─────────┬────────┬──────┬──────┐\n│   A    │    C    │   E    │ NULL │ NULL │\n└────────┴─────────┴────────┴──────┴──────┘\n   [0]      [1]      [2]     [3]    [4]\n\nDelete index 0 (A): total=2\n┌─────────┬────────┬──────┬──────┬──────┐\n│    C    │   E    │ NULL │ NULL │ NULL │\n└─────────┴────────┴──────┴──────┴──────┘\n    [0]     [1]     [2]    [3]    [4]\n```\n\n---\n\n## Operation: Resize Mechanics\n\n### When Resize Happens:\n\n**Expansion**: When vector is full (capacity == total) and you try to add\n**Shrinking** (optional): When vector is 25% full (total == capacity/4)\n\n### Resize Implementation with krealloc:\n\n```c\nstatic int vector_resize(vector *v, int new_capacity) {\n    // Calculate new size in bytes\n    size_t new_size = sizeof(void*) * new_capacity;\n\n    // Use krealloc to resize\n    void **new_items = krealloc(v->items, new_size, GFP_KERNEL);\n\n    // Check if successful\n    if (!new_items) {\n        return VECTOR_ERROR;  // Allocation failed!\n    }\n\n    // Update vector fields\n    v->items = new_items;\n    v->capacity = new_capacity;\n\n    return VECTOR_SUCCESS;\n}\n```\n\n### What krealloc Does:\n\n```\nBefore: v->items points to old 4-slot array\n┌──────┬──────┬──────┬──────┐\n│  A   │  B   │  C   │  D   │\n└──────┴──────┴──────┴──────┘\n  0x1000 (old address)\n\nCall: krealloc(v->items, sizeof(void*) * 8, GFP_KERNEL)\n\nkrealloc process:\n1. Allocate new 8-slot array at new address\n2. Copy old 4 items to new array\n3. Free old 4-slot array\n4. Return pointer to new 8-slot array\n\nAfter: v->items points to new 8-slot array\n┌──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┐\n│  A   │  B   │  C   │  D   │ NULL │ NULL │ NULL │ NULL │\n└──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┘\n  0x2000 (new address)\n\nOld data preserved! Address may change!\n```\n\n### Capacity Doubling in Action:\n\n```\nInitial: capacity=4, total=0\n┌──────┬──────┬──────┬──────┐\n│ NULL │ NULL │ NULL │ NULL │\n└──────┴──────┴──────┴──────┘\n\nAdd items until full: total=4\n┌──────┬──────┬──────┬──────┐\n│  A   │  B   │  C   │  D   │\n└──────┴──────┴──────┴──────┘\n\nAdd 5th item: Resize 4 → 8\n┌──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┐\n│  A   │  B   │  C   │  D   │  E   │ NULL │ NULL │ NULL │\n└──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┘\ncapacity=8, total=5\n\nContinue adding: total=8\n┌──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┐\n│  A   │  B   │  C   │  D   │  E   │  F   │  G   │  H   │\n└──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┘\n\nAdd 9th item: Resize 8 → 16\n┌──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┐\n│  A   │  B   │  C   │  D   │  E   │  F   │  G   │  H   │  I   │ NULL │ NULL │ NULL │ NULL │ NULL │ NULL │ NULL │\n└──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┘\ncapacity=16, total=9\n```\n\n### Capacity Shrinking (Optional Feature):\n\n```\nStart: capacity=16, total=16 (100% full)\n┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐\n│ A │ B │ C │ D │ E │ F │ G │ H │ I │ J │ K │ L │ M │ N │ O │ P │\n└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘\n\nDelete many items: capacity=16, total=8 (50% full)\n┌───┬───┬───┬───┬───┬───┬───┬───┬────┬────┬────┬────┬────┬────┬────┬────┐\n│ A │ B │ C │ D │ E │ F │ G │ H │NULL│NULL│NULL│NULL│NULL│NULL│NULL│NULL│\n└───┴───┴───┴───┴───┴───┴───┴───┴────┴────┴────┴────┴────┴────┴────┴────┘\nNo shrink yet (not 25% full)\n\nDelete more: capacity=16, total=4 (25% full)\n┌───┬───┬───┬───┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐\n│ A │ B │ C │ D │NULL│NULL│NULL│NULL│NULL│NULL│NULL│NULL│NULL│NULL│NULL│NULL│\n└───┴───┴───┴───┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┘\nTrigger shrink! 25% full\n\nShrink 16 → 8: capacity=8, total=4 (50% full)\n┌───┬───┬───┬───┬────┬────┬────┬────┐\n│ A │ B │ C │ D │NULL│NULL│NULL│NULL│\n└───┴───┴───┴───┴────┴────┴────┴────┘\nMemory saved! Efficiency restored.\n\nWhy 25% threshold?\n- Prevents thrashing (repeated resize up/down)\n- Maintains good memory efficiency\n- Gives headroom before next expansion\n```\n\n---\n\n## Common Pitfalls and Solutions\n\n### Pitfall 1: Accessing Out-of-Bounds Index\n\n```\nWRONG:\ncapacity = 8, total = 3\n\n┌───┬───┬───┬────┬────┬────┬────┬────┐\n│ A │ B │ C │NULL│NULL│NULL│NULL│NULL│\n└───┴───┴───┴────┴────┴────┴────┴────┘\n\nchar *item = vector_get(&v, 5);  // index 5 is beyond total!\n// Returns NULL, but some code doesn't check!\nprintf(\"%s\", item);  // CRASH! NULL pointer dereference\n\nCORRECT:\nchar *item = vector_get(&v, 5);\nif (item == NULL) {\n    printf(\"Index out of bounds!\\n\");\n    return;\n}\nprintf(\"%s\", item);  // Safe\n```\n\n### Pitfall 2: Forgetting to Check Allocation Failure\n\n```\nWRONG:\nvector v;\nvector_init(&v);  // What if this fails?\nvector_add(&v, \"data\");  // CRASH if init failed!\n\nCORRECT:\nvector v;\nif (vector_init(&v) != VECTOR_SUCCESS) {\n    printk(KERN_ERR \"Failed to initialize vector\\n\");\n    return -ENOMEM;\n}\nvector_add(&v, \"data\");  // Safe now\n```\n\n### Pitfall 3: Memory Leak - Not Freeing Items\n\n```\nWRONG:\nvector v;\nvector_init(&v);\n\nfor (int i = 0; i < 100; i++) {\n    char *str = kmalloc(64, GFP_KERNEL);  // Allocate string\n    sprintf(str, \"Item %d\", i);\n    vector_add(&v, str);  // Add to vector\n}\n\nvector_free(&v);  // LEAK! Only frees items array, not the strings!\n\nCORRECT:\nfor (int i = 0; i < vector_total(&v); i++) {\n    char *str = vector_get(&v, i);\n    kfree(str);  // Free each string first\n}\nvector_free(&v);  // Now free the vector\n```\n\n### Pitfall 4: Using After Free\n\n```\nWRONG:\nvector v;\nvector_init(&v);\nvector_add(&v, \"data\");\nvector_free(&v);\n\nchar *item = vector_get(&v, 0);  // CRASH! v.items is NULL now\nprintf(\"%s\", item);\n\nCORRECT:\nvector v;\nvector_init(&v);\nvector_add(&v, \"data\");\n\nchar *item = vector_get(&v, 0);  // Get BEFORE freeing\nprintf(\"%s\", item);\n\nvector_free(&v);  // Free at the end\n```\n\n### Pitfall 5: Modifying During Iteration\n\n```\nWRONG:\nfor (int i = 0; i < vector_total(&v); i++) {\n    if (some_condition) {\n        vector_delete(&v, i);  // Deletes shift elements!\n        // i++ will skip an element after shift!\n    }\n}\n\nCORRECT Method 1: Iterate backwards\nfor (int i = vector_total(&v) - 1; i >= 0; i--) {\n    if (some_condition) {\n        vector_delete(&v, i);  // Safe: no elements skipped\n    }\n}\n\nCORRECT Method 2: Don't increment when deleting\nfor (int i = 0; i < vector_total(&v); ) {\n    if (some_condition) {\n        vector_delete(&v, i);  // Don't increment i\n    } else {\n        i++;  // Only increment when not deleting\n    }\n}\n```\n\n---\n\n## Summary Cheat Sheet\n\n```\nOperation          Time Complexity    Space Used\n-------------------------------------------------\nvector_init        O(1)               capacity × sizeof(void*)\nvector_add         O(1) amortized     + data pointed to\nvector_get         O(1)               No extra space\nvector_set         O(1)               No extra space\nvector_delete      O(n)               No extra space\nvector_free        O(1)               Frees all\n\nKey Rules:\n1. Always check return codes (VECTOR_SUCCESS / VECTOR_ERROR)\n2. Always check if vector_get returns NULL\n3. Free your data before freeing the vector\n4. Don't use vector after vector_free\n5. Capacity doubles when full (4→8→16→32...)\n6. Capacity can shrink when 25% full (optional)\n7. Delete shifts all elements after deleted index\n8. Get/Set only work on indices 0 to total-1\n```\n\n---\n\n## Practice Understanding Check\n\nBefore you start coding, make sure you understand:\n\n1. What is the difference between `capacity` and `total`?\n2. Why does capacity double instead of increasing by 1?\n3. What happens to elements after a delete operation?\n4. What does krealloc do when resizing?\n5. Why must you check bounds in get and set operations?\n6. What memory must you free when cleaning up a vector?\n7. When does automatic resizing happen?\n8. Why use void pointers (void**) instead of a specific type?\n\nIf you can answer these, you're ready to implement the vector!\n",
        "readOnly": true,
        "language": "txt"
      },
      {
        "name": "kernel_vector.c",
        "content": "#include \"kernel_vector.h\"\n\n/* Module parameters for dynamic testing */\nint test_capacity = 4;\nint test_add_count = 10;\nint test_delete_index = 2;\n\nmodule_param(test_capacity, int, 0644);\nMODULE_PARM_DESC(test_capacity, \"Initial capacity for testing\");\nmodule_param(test_add_count, int, 0644);\nMODULE_PARM_DESC(test_add_count, \"Number of items to add for testing\");\nmodule_param(test_delete_index, int, 0644);\nMODULE_PARM_DESC(test_delete_index, \"Index to delete for testing\");\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: Dynamic Memory Management in Kernel */\n/* ========================================================================== */\n/* This teaches CRITICAL kernel memory management patterns used throughout Linux!\n *\n * KERNEL MEMORY ALLOCATION API:\n * - kmalloc(size, GFP_KERNEL): Allocate memory (like malloc)\n * - kfree(ptr): Free memory (like free)\n * - krealloc(ptr, new_size, GFP_KERNEL): Resize memory (like realloc)\n *\n * GFP_KERNEL FLAGS EXPLAINED:\n * GFP = Get Free Pages\n * GFP_KERNEL = Can sleep, use for normal allocations in process context\n * GFP_ATOMIC = Cannot sleep, use in interrupt context (not needed here)\n *\n * MEMORY ALLOCATION PATTERN:\n * void **items = kmalloc(sizeof(void*) * capacity, GFP_KERNEL);\n * ↑              ↑       ↑                  ↑\n * result type    function  size calculation  flags\n *\n * WHY sizeof(void*) * capacity?\n * We're allocating an ARRAY of void pointers.\n * Each pointer is sizeof(void*) bytes (usually 8 bytes on 64-bit).\n * For capacity=4: allocate 4 * 8 = 32 bytes.\n *\n * MEMORY SAFETY CRITICAL RULES:\n * 1. ALWAYS check if kmalloc returns NULL (allocation failed)\n * 2. ALWAYS free memory with kfree when done\n * 3. NEVER use memory after freeing it\n * 4. ALWAYS check bounds before accessing array indices\n */\n\n/* ========================================================================== */\n/* HELPER FUNCTION: vector_resize */\n/* ========================================================================== */\n/* This is a STATIC helper function (only used internally in this file)\n *\n * WHAT IS STATIC?\n * static int vector_resize(...) means:\n * - Function is PRIVATE to this file\n * - Cannot be called from other files\n * - Like a \"private\" method in OOP\n *\n * WHY RESIZE?\n * When capacity is full, we need MORE space:\n * Old: [ptr0][ptr1][ptr2][ptr3] (capacity=4, full!)\n * New: [ptr0][ptr1][ptr2][ptr3][null][null][null][null] (capacity=8)\n *\n * KREALLOC EXPLAINED:\n * krealloc(old_ptr, new_size, GFP_KERNEL)\n * - If successful: Returns new pointer, copies old data, frees old memory\n * - If fails: Returns NULL, old memory UNCHANGED\n *\n * CRITICAL: Store result in temporary variable first!\n * void **new_items = krealloc(v->items, new_size, GFP_KERNEL);\n * if (new_items) {\n *     v->items = new_items;  // Only update if successful!\n * }\n */\nstatic int vector_resize(vector *v, int capacity)\n{\n    printk(KERN_INFO \"vector_resize: %d to %d\\n\", v->capacity, capacity);\n\n    /* TODO: Resize the items array using krealloc */\n    /* STEP 1: Calculate new size: sizeof(void*) * capacity */\n    /* STEP 2: Call krealloc(v->items, new_size, GFP_KERNEL) */\n    /* STEP 3: Check if krealloc returned NULL (allocation failed) */\n    /* STEP 4: If successful, update v->items and v->capacity */\n    /* STEP 5: Return VECTOR_SUCCESS or VECTOR_ERROR */\n\n    /* HINT: Use a temporary pointer to store krealloc result */\n    /* void **new_items = krealloc(...); */\n    /* if (new_items) { ... } else { return VECTOR_ERROR; } */\n\n    return VECTOR_ERROR;  /* TODO: Replace with actual implementation */\n}\n\n/* ========================================================================== */\n/* FUNCTION: vector_init */\n/* ========================================================================== */\n/* Initialize an empty vector with initial capacity\n *\n * WHAT THIS FUNCTION DOES:\n * 1. Set capacity to VECTOR_INIT_CAPACITY (4)\n * 2. Set total to 0 (no elements yet)\n * 3. Allocate memory for items array using kmalloc\n * 4. Check if allocation succeeded\n *\n * MEMORY ALLOCATION PATTERN:\n * v->items = kmalloc(sizeof(void*) * v->capacity, GFP_KERNEL);\n *\n * ERROR HANDLING:\n * if (!v->items) {  // kmalloc returned NULL\n *     return VECTOR_ERROR;\n * }\n * return VECTOR_SUCCESS;\n */\nint vector_init(vector *v)\n{\n    printk(KERN_INFO \"vector_init: Initializing vector\\n\");\n\n    /* TODO: Initialize vector fields */\n    /* v->capacity = VECTOR_INIT_CAPACITY; */\n    /* v->total = 0; */\n    /* v->items = kmalloc(sizeof(void*) * v->capacity, GFP_KERNEL); */\n    /* if (!v->items) return VECTOR_ERROR; */\n    /* return VECTOR_SUCCESS; */\n\n    return VECTOR_ERROR;  /* TODO: Replace with actual implementation */\n}\n\n/* ========================================================================== */\n/* FUNCTION: vector_total */\n/* ========================================================================== */\n/* Return the current number of elements in the vector\n *\n * SIMPLE ACCESSOR FUNCTION:\n * Just return v->total (no complex logic needed)\n */\nint vector_total(vector *v)\n{\n    /* TODO: Return the total number of elements */\n    return 0;  /* TODO: Replace with v->total */\n}\n\n/* ========================================================================== */\n/* FUNCTION: vector_add */\n/* ========================================================================== */\n/* Add an item to the end of the vector\n *\n * ALGORITHM:\n * 1. Check if vector is full (v->capacity == v->total)\n * 2. If full, resize to double capacity: vector_resize(v, v->capacity * 2)\n * 3. Check if resize succeeded (it returns VECTOR_SUCCESS or VECTOR_ERROR)\n * 4. Add item to end: v->items[v->total] = item\n * 5. Increment total: v->total++\n *\n * CAPACITY EXPANSION VISUALIZATION:\n * Before add (capacity=4, total=4, FULL!):\n * [ptr0][ptr1][ptr2][ptr3]\n *\n * After resize (capacity=8):\n * [ptr0][ptr1][ptr2][ptr3][null][null][null][null]\n *\n * After add (total=5):\n * [ptr0][ptr1][ptr2][ptr3][NEW][null][null][null]\n *\n * WHY DOUBLE CAPACITY?\n * Doubling ensures O(1) amortized time complexity:\n * - Adding 1000 items: resize only ~10 times (log2(1000))\n * - Not doubling: would resize 1000 times (very slow!)\n */\nint vector_add(vector *v, void *item)\n{\n    printk(KERN_INFO \"vector_add: Adding item (total=%d, capacity=%d)\\n\", v->total, v->capacity);\n\n    /* TODO: Implement add logic */\n    /* STEP 1: Check if v->capacity == v->total (vector is full) */\n    /* STEP 2: If full, call vector_resize(v, v->capacity * 2) */\n    /* STEP 3: Check if resize returned VECTOR_ERROR */\n    /* STEP 4: Add item: v->items[v->total] = item */\n    /* STEP 5: Increment total: v->total++ */\n    /* STEP 6: Return VECTOR_SUCCESS */\n\n    return VECTOR_ERROR;  /* TODO: Replace with actual implementation */\n}\n\n/* ========================================================================== */\n/* FUNCTION: vector_set */\n/* ========================================================================== */\n/* Set/replace an item at a specific index\n *\n * BOUNDS CHECKING:\n * Must verify: index >= 0 AND index < v->total\n * Why < v->total? Can only modify EXISTING elements!\n *\n * Example with total=3:\n * Valid indices: 0, 1, 2\n * Invalid: -1, 3, 4, 100\n *\n * [ptr0][ptr1][ptr2][null]...\n *   ↑     ↑     ↑    ↑\n *   0     1     2    3 (out of bounds!)\n */\nint vector_set(vector *v, int index, void *item)\n{\n    printk(KERN_INFO \"vector_set: Setting index %d\\n\", index);\n\n    /* TODO: Implement set logic */\n    /* STEP 1: Check if index >= 0 AND index < v->total */\n    /* STEP 2: If valid, set v->items[index] = item and return VECTOR_SUCCESS */\n    /* STEP 3: If invalid, return VECTOR_ERROR */\n\n    return VECTOR_ERROR;  /* TODO: Replace with actual implementation */\n}\n\n/* ========================================================================== */\n/* FUNCTION: vector_get */\n/* ========================================================================== */\n/* Get an item at a specific index\n *\n * RETURN VALUE:\n * - Valid index: return v->items[index]\n * - Invalid index: return NULL\n *\n * WHY RETURN NULL?\n * NULL is a standard way to indicate \"no value\" or \"error\" for pointers.\n * Caller can check: if (result == NULL) { // handle error }\n */\nvoid *vector_get(vector *v, int index)\n{\n    /* TODO: Implement get logic */\n    /* STEP 1: Check if index >= 0 AND index < v->total */\n    /* STEP 2: If valid, return v->items[index] */\n    /* STEP 3: If invalid, return NULL */\n\n    return NULL;  /* TODO: Replace with actual implementation */\n}\n\n/* ========================================================================== */\n/* FUNCTION: vector_delete */\n/* ========================================================================== */\n/* Delete an item at a specific index and shift remaining elements\n *\n * DELETION ALGORITHM:\n * Before delete at index 1:\n * [ptr0][ptr1][ptr2][ptr3] (total=4)\n *   0     1     2     3\n *\n * After delete:\n * [ptr0][ptr2][ptr3][null] (total=3)\n *   0     1     2\n *\n * HOW TO SHIFT ELEMENTS:\n * for (int i = index; i < v->total - 1; i++) {\n *     v->items[i] = v->items[i + 1];  // Shift left\n * }\n * v->items[v->total - 1] = NULL;  // Clear old last position\n * v->total--;  // Decrease count\n *\n * CAPACITY SHRINKING:\n * If vector becomes too empty (total == capacity/4), shrink to capacity/2.\n * This saves memory when many items are deleted.\n *\n * Example:\n * capacity=16, total=4 (25% full)\n * → Shrink to capacity=8\n */\nint vector_delete(vector *v, int index)\n{\n    printk(KERN_INFO \"vector_delete: Deleting index %d\\n\", index);\n\n    /* TODO: Implement delete logic */\n    /* STEP 1: Check if index < 0 OR index >= v->total (out of bounds) */\n    /* STEP 2: If invalid, return VECTOR_ERROR */\n    /* STEP 3: Set deleted position to NULL: v->items[index] = NULL */\n    /* STEP 4: Shift elements left (loop from index to total-1) */\n    /* STEP 5: Decrement total: v->total-- */\n    /* STEP 6: Optional shrinking: if (v->total > 0 && v->total == v->capacity / 4) */\n    /*         vector_resize(v, v->capacity / 2); */\n    /* STEP 7: Return VECTOR_SUCCESS */\n\n    return VECTOR_ERROR;  /* TODO: Replace with actual implementation */\n}\n\n/* ========================================================================== */\n/* FUNCTION: vector_free */\n/* ========================================================================== */\n/* Free all memory allocated by the vector\n *\n * MEMORY CLEANUP:\n * 1. Free the items array: kfree(v->items)\n * 2. Reset fields to safe values:\n *    v->items = NULL\n *    v->total = 0\n *    v->capacity = 0\n *\n * WHY RESET TO NULL/0?\n * Prevents use-after-free bugs. If someone tries to use the vector\n * after freeing, they'll get NULL pointer errors instead of corruption.\n *\n * CRITICAL: This ONLY frees the items array, NOT the items themselves!\n * If items were allocated with kmalloc, caller must free them first:\n *\n * for (int i = 0; i < vector_total(&v); i++) {\n *     kfree(vector_get(&v, i));  // Free each item\n * }\n * vector_free(&v);  // Then free the vector structure\n */\nvoid vector_free(vector *v)\n{\n    printk(KERN_INFO \"vector_free: Freeing vector\\n\");\n\n    /* TODO: Implement free logic */\n    /* STEP 1: kfree(v->items); */\n    /* STEP 2: v->items = NULL; */\n    /* STEP 3: v->total = 0; */\n    /* STEP 4: v->capacity = 0; */\n}\n\n/* ========================================================================== */\n/* MODULE INIT: Test the vector implementation */\n/* ========================================================================== */\nstatic int __init kernel_vector_init(void)\n{\n    vector v;\n    int result;\n    int i;\n    char *test_strings[] = {\"first\", \"second\", \"third\", \"fourth\", \"fifth\"};\n\n    printk(KERN_INFO \"Kernel vector module loaded\\n\");\n    printk(KERN_INFO \"Testing with capacity=%d, add_count=%d, delete_index=%d\\n\",\n           test_capacity, test_add_count, test_delete_index);\n\n    /* Test 1: Initialization */\n    printk(KERN_INFO \"Test 1: Vector initialization\\n\");\n    result = vector_init(&v);\n    if (result != VECTOR_SUCCESS) {\n        printk(KERN_ERR \"Failed to initialize vector\\n\");\n        return -ENOMEM;\n    }\n    printk(KERN_INFO \"Vector initialized: capacity=%d, total=%d\\n\", v.capacity, v.total);\n\n    /* Test 2: Adding elements */\n    printk(KERN_INFO \"Test 2: Adding elements\\n\");\n    for (i = 0; i < 5 && i < test_add_count; i++) {\n        result = vector_add(&v, test_strings[i]);\n        if (result != VECTOR_SUCCESS) {\n            printk(KERN_ERR \"Failed to add element %d\\n\", i);\n            vector_free(&v);\n            return -ENOMEM;\n        }\n        printk(KERN_INFO \"Added '%s' at index %d (total=%d, capacity=%d)\\n\",\n               test_strings[i], i, v.total, v.capacity);\n    }\n\n    /* Test 3: Getting elements */\n    printk(KERN_INFO \"Test 3: Getting elements\\n\");\n    for (i = 0; i < vector_total(&v); i++) {\n        char *item = (char*)vector_get(&v, i);\n        if (item) {\n            printk(KERN_INFO \"Element at index %d: %s\\n\", i, item);\n        }\n    }\n\n    /* Test 4: Setting element */\n    printk(KERN_INFO \"Test 4: Setting element\\n\");\n    if (vector_total(&v) > 1) {\n        result = vector_set(&v, 1, \"modified\");\n        if (result == VECTOR_SUCCESS) {\n            char *item = (char*)vector_get(&v, 1);\n            printk(KERN_INFO \"Modified element at index 1: %s\\n\", item);\n        }\n    }\n\n    /* Test 5: Deleting element */\n    printk(KERN_INFO \"Test 5: Deleting element\\n\");\n    if (test_delete_index >= 0 && test_delete_index < vector_total(&v)) {\n        result = vector_delete(&v, test_delete_index);\n        if (result == VECTOR_SUCCESS) {\n            printk(KERN_INFO \"Deleted element at index %d (total=%d)\\n\",\n                   test_delete_index, v.total);\n            printk(KERN_INFO \"Elements after deletion:\\n\");\n            for (i = 0; i < vector_total(&v); i++) {\n                char *item = (char*)vector_get(&v, i);\n                if (item) {\n                    printk(KERN_INFO \"  Index %d: %s\\n\", i, item);\n                }\n            }\n        }\n    }\n\n    /* Test 6: Edge cases */\n    printk(KERN_INFO \"Test 6: Edge case testing\\n\");\n    void *invalid_get = vector_get(&v, 100);\n    printk(KERN_INFO \"Get invalid index (100): %s\\n\", invalid_get == NULL ? \"NULL\" : \"ERROR\");\n\n    int invalid_set = vector_set(&v, 100, \"test\");\n    printk(KERN_INFO \"Set invalid index (100): %s\\n\", invalid_set == VECTOR_ERROR ? \"ERROR\" : \"SUCCESS\");\n\n    /* Cleanup first vector */\n    vector_free(&v);\n    printk(KERN_INFO \"Vector freed\\n\");\n\n    /* Test 7: Empty Vector Operations */\n    printk(KERN_INFO \"Test 7: Empty vector operations\\n\");\n    vector v_empty;\n    vector_init(&v_empty);\n    printk(KERN_INFO \"Empty vector initialized (total=%d)\\n\", v_empty.total);\n    \n    void *empty_get = vector_get(&v_empty, 0);\n    printk(KERN_INFO \"Get from empty vector (index 0): %s\\n\", empty_get == NULL ? \"NULL (correct)\" : \"ERROR\");\n    \n    int empty_delete = vector_delete(&v_empty, 0);\n    printk(KERN_INFO \"Delete from empty vector (index 0): %s\\n\", empty_delete == VECTOR_ERROR ? \"ERROR (correct)\" : \"SUCCESS (wrong)\");\n    \n    int empty_set = vector_set(&v_empty, 0, \"test\");\n    printk(KERN_INFO \"Set on empty vector (index 0): %s\\n\", empty_set == VECTOR_ERROR ? \"ERROR (correct)\" : \"SUCCESS (wrong)\");\n    \n    vector_free(&v_empty);\n    printk(KERN_INFO \"Empty vector test completed\\n\");\n\n    /* Test 8: NULL Pointer Handling */\n    printk(KERN_INFO \"Test 8: NULL pointer handling\\n\");\n    vector v_null;\n    vector_init(&v_null);\n    \n    result = vector_add(&v_null, NULL);\n    printk(KERN_INFO \"Add NULL pointer: %s\\n\", result == VECTOR_SUCCESS ? \"SUCCESS\" : \"ERROR\");\n    \n    void *retrieved_null = vector_get(&v_null, 0);\n    printk(KERN_INFO \"Get NULL pointer: %s\\n\", retrieved_null == NULL ? \"NULL (correct)\" : \"Non-NULL (error)\");\n    \n    vector_add(&v_null, \"valid\");\n    vector_add(&v_null, NULL);\n    vector_add(&v_null, \"another\");\n    printk(KERN_INFO \"Mixed NULL and valid pointers: total=%d\\n\", v_null.total);\n    \n    for (i = 0; i < vector_total(&v_null); i++) {\n        char *item = (char*)vector_get(&v_null, i);\n        if (item == NULL) {\n            printk(KERN_INFO \"  Index %d: NULL\\n\", i);\n        } else {\n            printk(KERN_INFO \"  Index %d: %s\\n\", i, item);\n        }\n    }\n    \n    vector_free(&v_null);\n    printk(KERN_INFO \"NULL pointer test completed\\n\");\n\n    /* Test 9: Capacity Shrinking */\n    printk(KERN_INFO \"Test 9: Capacity shrinking test\\n\");\n    vector v_shrink;\n    vector_init(&v_shrink);\n    \n    /* Add 16 elements to expand capacity to 16 */\n    for (i = 0; i < 16; i++) {\n        vector_add(&v_shrink, \"item\");\n    }\n    printk(KERN_INFO \"After adding 16 items: total=%d, capacity=%d\\n\", v_shrink.total, v_shrink.capacity);\n    \n    /* Delete down to 4 items (25% of capacity 16) */\n    while (v_shrink.total > 4) {\n        vector_delete(&v_shrink, 0);\n    }\n    printk(KERN_INFO \"After deleting to 4 items (25%% full): total=%d, capacity=%d\\n\", v_shrink.total, v_shrink.capacity);\n    printk(KERN_INFO \"Capacity shrinking: %s\\n\", v_shrink.capacity == 8 ? \"SUCCESS (16→8)\" : \"Not implemented\");\n    \n    vector_free(&v_shrink);\n    printk(KERN_INFO \"Capacity shrinking test completed\\n\");\n\n    /* Test 10: Add-Delete Cycles */\n    printk(KERN_INFO \"Test 10: Add-Delete cycle test\\n\");\n    vector v_cycle;\n    vector_init(&v_cycle);\n    \n    int cycles = 3;\n    for (int cycle = 0; cycle < cycles; cycle++) {\n        /* Add 10 items */\n        for (i = 0; i < 10; i++) {\n            vector_add(&v_cycle, \"cycle_item\");\n        }\n        printk(KERN_INFO \"Cycle %d: After adding 10, total=%d\\n\", cycle, v_cycle.total);\n        \n        /* Delete 5 items */\n        for (i = 0; i < 5; i++) {\n            vector_delete(&v_cycle, 0);\n        }\n        printk(KERN_INFO \"Cycle %d: After deleting 5, total=%d\\n\", cycle, v_cycle.total);\n    }\n    printk(KERN_INFO \"After %d cycles: total=%d, capacity=%d\\n\", cycles, v_cycle.total, v_cycle.capacity);\n    \n    vector_free(&v_cycle);\n    printk(KERN_INFO \"Add-Delete cycle test completed\\n\");\n\n    printk(KERN_INFO \"All comprehensive tests completed\\n\");\n    return 0;\n}\n\nstatic void __exit kernel_vector_exit(void)\n{\n    printk(KERN_INFO \"Kernel vector module unloaded\\n\");\n}\n\nmodule_init(kernel_vector_init);\nmodule_exit(kernel_vector_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Dynamic vector implementation in kernel space\");\nMODULE_VERSION(\"1.0\");\n",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Kernel vector module Makefile\nobj-m += kernel_vector.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help\n",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "kernel_vector.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "kernel_vector_init",
          "kernel_vector_exit",
          "vector_init",
          "vector_total",
          "vector_add",
          "vector_set",
          "vector_get",
          "vector_delete",
          "vector_free",
          "vector_resize"
        ],
        "function_declarations": [
          {
            "name": "vector_init",
            "returnType": "int",
            "parameters": [
              "vector *v"
            ]
          },
          {
            "name": "vector_total",
            "returnType": "int",
            "parameters": [
              "vector *v"
            ]
          },
          {
            "name": "vector_add",
            "returnType": "int",
            "parameters": [
              "vector *v",
              "void *item"
            ]
          },
          {
            "name": "vector_set",
            "returnType": "int",
            "parameters": [
              "vector *v",
              "int index",
              "void *item"
            ]
          },
          {
            "name": "vector_get",
            "returnType": "void *",
            "parameters": [
              "vector *v",
              "int index"
            ]
          },
          {
            "name": "vector_delete",
            "returnType": "int",
            "parameters": [
              "vector *v",
              "int index"
            ]
          },
          {
            "name": "vector_free",
            "returnType": "void",
            "parameters": [
              "vector *v"
            ]
          }
        ],
        "variables_declarations": [
          {
            "name": "vector",
            "type": "typedef struct",
            "value": "{void **items; int capacity; int total;}",
            "storageClass": "none"
          }
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/slab.h",
          "linux/types.h"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int vector_init(vector *v)",
            "int vector_total(vector *v)",
            "int vector_add(vector *v, void *item)",
            "int vector_set(vector *v, int index, void *item)",
            "void *vector_get(vector *v, int index)",
            "int vector_delete(vector *v, int index)",
            "void vector_free(vector *v)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Implementations in Source",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "int vector_init(vector *v)",
            "int vector_total(vector *v)",
            "int vector_add(vector *v, void *item)",
            "int vector_set(vector *v, int index, void *item)",
            "void *vector_get(vector *v, int index)",
            "int vector_delete(vector *v, int index)",
            "void vector_free(vector *v)",
            "static int vector_resize(vector *v, int capacity)",
            "static int __init kernel_vector_init(void)",
            "static void __exit kernel_vector_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "struct_definition",
          "name": "Vector Structure Definition",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "typedef struct vector",
            "void **items",
            "int capacity",
            "int total"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages with Function Linkage",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Kernel vector module loaded",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "Testing with capacity=",
              "exact": false,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "Test 1: Vector initialization",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "vector_init: Initializing vector",
              "exact": true,
              "linkedFunction": "int vector_init(vector *v)"
            },
            {
              "pattern": "Vector initialized: capacity=4, total=0",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "Test 2: Adding elements",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "vector_add: Adding item",
              "exact": false,
              "linkedFunction": "int vector_add(vector *v, void *item)"
            },
            {
              "pattern": "Added 'first' at index 0",
              "exact": false,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "Added 'second' at index 1",
              "exact": false,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "Added 'third' at index 2",
              "exact": false,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "Test 3: Getting elements",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "Element at index 0: first",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "Element at index 1:",
              "exact": false,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "Test 4: Setting element",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "vector_set: Setting index 1",
              "exact": true,
              "linkedFunction": "int vector_set(vector *v, int index, void *item)"
            },
            {
              "pattern": "Modified element at index 1: modified",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "Test 5: Deleting element",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "vector_delete: Deleting index",
              "exact": false,
              "linkedFunction": "int vector_delete(vector *v, int index)"
            },
            {
              "pattern": "Deleted element at index",
              "exact": false,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "Elements after deletion:",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "Test 6: Edge case testing",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "Get invalid index (100): NULL",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "Set invalid index (100): ERROR",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "vector_free: Freeing vector",
              "exact": true,
              "linkedFunction": "void vector_free(vector *v)"
            },
            {
              "pattern": "Vector freed",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "Test 7: Empty vector operations",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "Empty vector initialized (total=0)",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "Get from empty vector (index 0): NULL (correct)",
              "exact": true,
              "linkedFunction": "void *vector_get(vector *v, int index)"
            },
            {
              "pattern": "Delete from empty vector (index 0): ERROR (correct)",
              "exact": true,
              "linkedFunction": "int vector_delete(vector *v, int index)"
            },
            {
              "pattern": "Set on empty vector (index 0): ERROR (correct)",
              "exact": true,
              "linkedFunction": "int vector_set(vector *v, int index, void *item)"
            },
            {
              "pattern": "Empty vector test completed",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "Test 8: NULL pointer handling",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "Add NULL pointer: SUCCESS",
              "exact": true,
              "linkedFunction": "int vector_add(vector *v, void *item)"
            },
            {
              "pattern": "Get NULL pointer: NULL (correct)",
              "exact": true,
              "linkedFunction": "void *vector_get(vector *v, int index)"
            },
            {
              "pattern": "Mixed NULL and valid pointers: total=4",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "NULL pointer test completed",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "Test 9: Capacity shrinking test",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "After adding 16 items: total=16, capacity=16",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "After deleting to 4 items",
              "exact": false,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "Capacity shrinking test completed",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "Test 10: Add-Delete cycle test",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "Cycle 0: After adding 10, total=10",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "Cycle 0: After deleting 5, total=5",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "After 3 cycles: total=15",
              "exact": false,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "Add-Delete cycle test completed",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "All comprehensive tests completed",
              "exact": true,
              "linkedFunction": "static int __init kernel_vector_init(void)"
            },
            {
              "pattern": "Kernel vector module unloaded",
              "exact": true,
              "linkedFunction": "static void __exit kernel_vector_exit(void)"
            }
          ]
        },
        {
          "id": "comprehensive_vector_validation",
          "name": "Comprehensive Vector Functionality Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "vector_comprehensive_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Comprehensive Vector Functionality Test ===\\\\n\\\");\\n    \\n    srand(time(NULL));\\n    \\n    int test_capacity = 4 + (rand() % 4);\\n    int test_add_count = 5 + (rand() % 6);\\n    int test_delete_index = 1 + (rand() % 3);\\n    \\n    printf(\\\"Test parameters: capacity=%d, add_count=%d, delete_index=%d\\\\n\\\", test_capacity, test_add_count, test_delete_index);\\n    \\n    system(\\\"rmmod kernel_vector 2>/dev/null\\\");\\n    \\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/kernel_vector.ko test_capacity=%d test_add_count=%d test_delete_index=%d\\\", test_capacity, test_add_count, test_delete_index);\\n    printf(\\\"Loading module with: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Vector comprehensive test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting comprehensive vector validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: TCC Header Validation'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef unsigned long size_t;' > /tmp/linux/types.h",
              "echo 'typedef unsigned char u8;' >> /tmp/linux/types.h",
              "echo 'typedef unsigned short u16;' >> /tmp/linux/types.h",
              "echo 'typedef unsigned int u32;' >> /tmp/linux/types.h",
              "echo '#include <linux/types.h>' > /tmp/linux/slab.h",
              "echo 'void *kmalloc(unsigned long size, int flags);' >> /tmp/linux/slab.h",
              "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
              "echo 'void *krealloc(const void *ptr, unsigned long size, int flags);' >> /tmp/linux/slab.h",
              "echo '#define GFP_KERNEL 0' >> /tmp/linux/slab.h",
              "echo '#include \"/lib/modules/kernel_vector.h\"' > /tmp/test.c",
              "echo 'int main() { vector v; vector_init(&v); vector_add(&v, (void*)0); vector_get(&v, 0); vector_set(&v, 0, (void*)0); vector_delete(&v, 0); vector_free(&v); return 0; }' >> /tmp/test.c",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declarations missing in header'; cat /tmp/tcc_error.log; else echo 'PASS: All function declarations found in header'; fi",
              "echo 'Phase 2: Dynamic Vector Functionality Testing'",
              "/bin/vector_comprehensive_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Vector Operation Validation'",
              "sleep 1",
              "echo 'Validating vector initialization...'",
              "dmesg | grep 'Vector initialized: capacity=4, total=0' && echo 'PASS: Vector initialization correct' || echo 'FAIL: Vector initialization wrong'",
              "echo 'Validating vector add operations...'",
              "dmesg | grep 'Added .first. at index 0' && echo 'PASS: Vector add working' || echo 'FAIL: Vector add broken'",
              "dmesg | grep 'Added .second. at index 1' && echo 'PASS: Vector sequential add working' || echo 'FAIL: Vector sequential add broken'",
              "echo 'Validating vector get operations...'",
              "dmesg | grep 'Element at index 0: first' && echo 'PASS: Vector get working' || echo 'FAIL: Vector get broken'",
              "echo 'Validating vector set operations...'",
              "dmesg | grep 'Modified element at index 1: modified' && echo 'PASS: Vector set working' || echo 'FAIL: Vector set broken'",
              "echo 'Validating vector delete operations...'",
              "dmesg | grep 'Deleted element at index' && echo 'PASS: Vector delete working' || echo 'FAIL: Vector delete broken'",
              "echo 'Phase 4: Extracting Dynamic Test Parameters'",
              "TEST_ADD_COUNT=$(dmesg | grep -o 'Testing with capacity=[0-9]*, add_count=[0-9]*' | tail -1 | grep -o 'add_count=[0-9]*' | cut -d'=' -f2)",
              "TEST_DELETE_INDEX=$(dmesg | grep -o 'delete_index=[0-9]*' | tail -1 | cut -d'=' -f2)",
              "echo 'Extracted: test_add_count='$TEST_ADD_COUNT', test_delete_index='$TEST_DELETE_INDEX",
              "if [ -z \"$TEST_ADD_COUNT\" ] || [ \"$TEST_ADD_COUNT\" = \"\" ]; then echo 'WARN: Could not extract test_add_count, using default 5'; TEST_ADD_COUNT=5; fi",
              "if [ -z \"$TEST_DELETE_INDEX\" ] || [ \"$TEST_DELETE_INDEX\" = \"\" ]; then echo 'WARN: Could not extract test_delete_index, using default 2'; TEST_DELETE_INDEX=2; fi",
              "echo 'Phase 5: Dynamic Capacity Doubling Validation (CRITICAL)'",
              "echo 'Checking if capacity doubled based on test_add_count='$TEST_ADD_COUNT",
              "dmesg | grep 'Added.*at index 0.*capacity=4' && echo 'PASS: Initial capacity=4 confirmed' || echo 'FAIL: Initial capacity wrong'",
              "if [ $TEST_ADD_COUNT -ge 5 ]; then",
              "  echo 'With add_count='$TEST_ADD_COUNT', expecting capacity doubling 4→8 at 5th element (index 4)...'",
              "  dmesg | grep 'Added.*at index 4.*total=5, capacity=8' && echo 'PASS: Capacity doubled correctly (4→8) at index 4' || echo 'FAIL: Capacity doubling broken at index 4'",
              "else",
              "  echo 'With add_count='$TEST_ADD_COUNT', no doubling expected (less than 5 elements)'",
              "  dmesg | grep 'Added.*at index.*capacity=4' && echo 'PASS: Capacity remained 4 (no doubling needed)' || echo 'FAIL: Unexpected capacity change'",
              "fi",
              "if [ $TEST_ADD_COUNT -ge 9 ]; then",
              "  echo 'With add_count='$TEST_ADD_COUNT', expecting second doubling 8→16 at 9th element (index 8)...'",
              "  dmesg | grep 'Added.*at index 8.*total=9, capacity=16' && echo 'PASS: Second capacity doubling (8→16) at index 8' || echo 'FAIL: Second doubling broken'",
              "fi",
              "echo 'Phase 6: Dynamic Delete and Element Shifting Validation (CRITICAL)'",
              "echo 'Verifying delete at index '$TEST_DELETE_INDEX' shifted elements correctly...'",
              "dmesg | grep 'Deleted element at index '$TEST_DELETE_INDEX && echo 'PASS: Deleted at index '$TEST_DELETE_INDEX' (dynamic)' || echo 'FAIL: Delete at index '$TEST_DELETE_INDEX' failed'",
              "dmesg | grep 'Elements after deletion:' && echo 'PASS: Post-deletion verification present' || echo 'FAIL: No post-deletion check'",
              "if [ \"$TEST_ADD_COUNT\" -gt 5 ]; then EXPECTED_TOTAL_AFTER_DELETE=4; else EXPECTED_TOTAL_AFTER_DELETE=$((TEST_ADD_COUNT - 1)); fi",
              "ACTUAL_TOTAL=$(dmesg | grep 'Deleted element at index.*total=' | tail -1 | grep -o 'total=[0-9]*' | cut -d'=' -f2)",
              "if [ -n \"$ACTUAL_TOTAL\" ] && [ \"$ACTUAL_TOTAL\" -eq \"$EXPECTED_TOTAL_AFTER_DELETE\" ] 2>/dev/null; then",
              "  echo 'PASS: Total count correct after delete (expected='$EXPECTED_TOTAL_AFTER_DELETE', actual='$ACTUAL_TOTAL')'",
              "elif [ -n \"$ACTUAL_TOTAL\" ]; then",
              "  echo 'INFO: Total after delete: actual='$ACTUAL_TOTAL' (delete successful)'",
              "else",
              "  echo 'WARN: Could not verify total count after delete'",
              "fi",
              "dmesg | grep -A1 'Elements after deletion:' | grep 'Index 0:' && echo 'PASS: Elements still accessible after delete' || echo 'FAIL: Elements missing after delete'",
              "echo 'Phase 7: Dynamic Resize Function Validation (CRITICAL)'",
              "dmesg | grep 'vector_resize:' && echo 'PASS: vector_resize() function called' || echo 'FAIL: vector_resize() never called'",
              "if [ $TEST_ADD_COUNT -ge 5 ]; then",
              "  dmesg | grep 'vector_resize: 4 to 8' && echo 'PASS: Resize from 4→8 confirmed (dynamic test)' || echo 'FAIL: Expected resize 4→8 missing'",
              "fi",
              "if [ $TEST_ADD_COUNT -ge 9 ]; then",
              "  dmesg | grep 'vector_resize: 8 to 16' && echo 'PASS: Resize from 8→16 confirmed (dynamic test)' || echo 'FAIL: Expected resize 8→16 missing'",
              "fi",
              "RESIZE_COUNT=$(dmesg | grep -c 'vector_resize:')",
              "EXPECTED_RESIZES=0",
              "if [ $TEST_ADD_COUNT -ge 5 ]; then EXPECTED_RESIZES=1; fi",
              "if [ $TEST_ADD_COUNT -ge 9 ]; then EXPECTED_RESIZES=2; fi",
              "echo 'Expected resizes: '$EXPECTED_RESIZES', Actual resizes: '$RESIZE_COUNT",
              "if [ $RESIZE_COUNT -ge $EXPECTED_RESIZES ]; then echo 'PASS: Dynamic resizing implemented correctly ('$RESIZE_COUNT' resize(s))'; else echo 'FAIL: Insufficient resizes (expected >='$EXPECTED_RESIZES', got '$RESIZE_COUNT')'; fi",
              "echo 'Phase 8: Edge Case Validation'",
              "dmesg | grep 'Get invalid index.*100.*: NULL' && echo 'PASS: Invalid get returns NULL' || echo 'FAIL: Invalid get handling broken'",
              "dmesg | grep 'Set invalid index.*100.*: ERROR' && echo 'PASS: Invalid set returns ERROR' || echo 'FAIL: Invalid set handling broken'",
              "echo 'Phase 9: Memory Management Validation'",
              "dmesg | grep 'vector_free: Freeing vector' && echo 'PASS: vector_free() called' || echo 'FAIL: vector_free() not called'",
              "dmesg | grep 'Vector freed' && echo 'PASS: Vector cleanup completed' || echo 'FAIL: Vector cleanup broken'",
              "echo 'Phase 10: Empty Vector Operations Validation (COMPREHENSIVE)'",
              "dmesg | grep 'Test 7: Empty vector operations' && echo 'PASS: Empty vector test present' || echo 'FAIL: Empty vector test missing'",
              "dmesg | grep 'Empty vector initialized.*total=0' && echo 'PASS: Empty vector init correct' || echo 'FAIL: Empty vector init wrong'",
              "dmesg | grep 'Get from empty vector.*NULL.*correct' && echo 'PASS: Empty get returns NULL' || echo 'FAIL: Empty get broken'",
              "dmesg | grep 'Delete from empty vector.*ERROR.*correct' && echo 'PASS: Empty delete returns ERROR' || echo 'FAIL: Empty delete broken'",
              "dmesg | grep 'Set on empty vector.*ERROR.*correct' && echo 'PASS: Empty set returns ERROR' || echo 'FAIL: Empty set broken'",
              "dmesg | grep 'Empty vector test completed' && echo 'PASS: Empty vector comprehensive test passed' || echo 'FAIL: Empty vector test incomplete'",
              "echo 'Phase 11: NULL Pointer Handling Validation (COMPREHENSIVE)'",
              "dmesg | grep 'Test 8: NULL pointer handling' && echo 'PASS: NULL test present' || echo 'FAIL: NULL test missing'",
              "dmesg | grep 'Add NULL pointer: SUCCESS' && echo 'PASS: Can add NULL pointers' || echo 'FAIL: Cannot add NULL'",
              "dmesg | grep 'Get NULL pointer: NULL.*correct' && echo 'PASS: NULL retrieved correctly' || echo 'FAIL: NULL retrieval broken'",
              "dmesg | grep 'Mixed NULL and valid pointers: total=4' && echo 'PASS: Mixed NULL/valid storage' || echo 'FAIL: Mixed storage broken'",
              "dmesg | grep 'Index 0: NULL' && echo 'PASS: NULL at index 0 detected' || echo 'FAIL: NULL detection broken'",
              "dmesg | grep 'Index 1: valid' && echo 'PASS: Valid pointer after NULL' || echo 'FAIL: Valid after NULL broken'",
              "dmesg | grep 'NULL pointer test completed' && echo 'PASS: NULL comprehensive test passed' || echo 'FAIL: NULL test incomplete'",
              "echo 'Phase 12: Capacity Shrinking Validation (COMPREHENSIVE)'",
              "dmesg | grep 'Test 9: Capacity shrinking test' && echo 'PASS: Shrinking test present' || echo 'FAIL: Shrinking test missing'",
              "dmesg | grep 'After adding 16 items: total=16, capacity=16' && echo 'PASS: Expanded to capacity=16' || echo 'FAIL: Expansion to 16 wrong'",
              "dmesg | grep 'After deleting to 4 items.*total=4, capacity=8' && echo 'PASS: Shrinking 16→8 WORKS!' || echo 'INFO: Shrinking not implemented (optional)'",
              "dmesg | grep 'Capacity shrinking: SUCCESS' && echo 'PASS: Shrinking algorithm implemented' || echo 'INFO: Shrinking optional feature'",
              "dmesg | grep 'Capacity shrinking test completed' && echo 'PASS: Shrinking test completed' || echo 'FAIL: Shrinking test incomplete'",
              "echo 'Phase 13: Add-Delete Cycle Validation (COMPREHENSIVE)'",
              "dmesg | grep 'Test 10: Add-Delete cycle test' && echo 'PASS: Cycle test present' || echo 'FAIL: Cycle test missing'",
              "dmesg | grep 'Cycle 0: After adding 10, total=10' && echo 'PASS: Cycle 0 add phase' || echo 'FAIL: Cycle 0 add broken'",
              "dmesg | grep 'Cycle 0: After deleting 5, total=5' && echo 'PASS: Cycle 0 delete phase' || echo 'FAIL: Cycle 0 delete broken'",
              "dmesg | grep 'Cycle 2: After adding 10' && echo 'PASS: Multiple cycles executed' || echo 'FAIL: Only single cycle'",
              "dmesg | grep 'After 3 cycles: total=15' && echo 'PASS: Final total correct (3 cycles, +5 each)' || echo 'FAIL: Cycle math wrong'",
              "dmesg | grep 'Add-Delete cycle test completed' && echo 'PASS: Cycle test passed' || echo 'FAIL: Cycle test incomplete'",
              "echo 'Phase 14: Comprehensive Test Summary'",
              "dmesg | grep 'All comprehensive tests completed' && echo 'PASS: All 10 comprehensive tests completed' || echo 'FAIL: Not all tests completed'",
              "TOTAL_TESTS=$(dmesg | grep -c 'Test [0-9]*:')",
              "echo 'Total test suites detected: '$TOTAL_TESTS",
              "if [ $TOTAL_TESTS -ge 10 ]; then echo 'PASS: All 10 test suites present'; else echo 'FAIL: Missing test suites (found '$TOTAL_TESTS'/10)'; fi",
              "echo '======================================================================'",
              "echo 'COMPREHENSIVE VALIDATION SUMMARY'",
              "echo '======================================================================'",
              "echo 'PASS: Core Operations: init, add, get, set, delete, free'",
              "echo 'PASS: Dynamic Expansion: Capacity doubling (4->8->16->32...)'",
              "echo 'PASS: Dynamic Shrinking: Capacity halving at 25% full'",
              "echo 'PASS: Empty Vector Ops: NULL returns, ERROR codes'",
              "echo 'PASS: NULL Handling: Store and retrieve NULL pointers'",
              "echo 'PASS: Cycle Testing: Add-delete patterns'",
              "echo 'PASS: Edge Cases: Invalid indices, bounds checking'",
              "echo 'PASS: Memory Management: Proper cleanup, no leaks'",
              "echo '======================================================================'",
              "echo 'PASS: All comprehensive vector validation phases completed successfully'"
            ],
            "expected": {
              "dmesg": [
                "Kernel vector module loaded",
                "Testing with capacity=",
                "Test 1: Vector initialization",
                "vector_init: Initializing vector",
                "Vector initialized: capacity=4, total=0",
                "Test 2: Adding elements",
                "vector_add: Adding item",
                "Added 'first' at index 0",
                "Added 'second' at index 1",
                "Test 3: Getting elements",
                "Element at index 0: first",
                "Test 4: Setting element",
                "vector_set: Setting index 1",
                "Modified element at index 1: modified",
                "Test 5: Deleting element",
                "vector_delete: Deleting index",
                "Deleted element at index",
                "Elements after deletion:",
                "Test 6: Edge case testing",
                "Get invalid index.*: NULL",
                "Set invalid index.*: ERROR",
                "vector_resize:",
                "vector_free: Freeing vector",
                "Vector freed",
                "Test 7: Empty vector operations",
                "Empty vector initialized.*total=0",
                "Get from empty vector.*NULL.*correct",
                "Delete from empty vector.*ERROR.*correct",
                "Set on empty vector.*ERROR.*correct",
                "Empty vector test completed",
                "Test 8: NULL pointer handling",
                "Add NULL pointer: SUCCESS",
                "Get NULL pointer: NULL.*correct",
                "Mixed NULL and valid pointers: total=4",
                "Index 0: NULL",
                "Index 1: valid",
                "NULL pointer test completed",
                "Test 9: Capacity shrinking test",
                "After adding 16 items: total=16, capacity=16",
                "After deleting to 4 items.*total=4",
                "Capacity shrinking test completed",
                "Test 10: Add-Delete cycle test",
                "Cycle 0: After adding 10, total=10",
                "Cycle 0: After deleting 5, total=5",
                "After 3 cycles: total=15",
                "Add-Delete cycle test completed",
                "All comprehensive tests completed",
                "Kernel vector module unloaded"
              ],
              "stdout": [
                "PASS: All function declarations found in header",
                "SUCCESS: Vector comprehensive test completed",
                "PASS: Vector initialization correct",
                "PASS: Vector add working",
                "PASS: Vector sequential add working",
                "PASS: Vector get working",
                "PASS: Vector set working",
                "PASS: Vector delete working",
                "Extracted: test_add_count=.*delete_index=",
                "PASS: Initial capacity=4 confirmed",
                "Capacity doubled correctly.*at index 4|Capacity remained 4",
                "PASS: Deleted at index.*dynamic",
                "PASS: Post-deletion verification present",
                "Total count correct after delete|Total after delete.*delete successful",
                "PASS: Elements still accessible after delete",
                "PASS: vector_resize\\(\\) function called",
                "Resize from 4.*8 confirmed.*dynamic|Expected resizes: 0",
                "PASS: Dynamic resizing implemented correctly.*resize",
                "PASS: Invalid get returns NULL",
                "PASS: Invalid set returns ERROR",
                "PASS: vector_free\\(\\) called",
                "PASS: Vector cleanup completed",
                "PASS: Empty vector test present",
                "PASS: Empty vector init correct",
                "PASS: Empty get returns NULL",
                "PASS: Empty delete returns ERROR",
                "PASS: Empty set returns ERROR",
                "PASS: Empty vector comprehensive test passed",
                "PASS: NULL test present",
                "PASS: Can add NULL pointers",
                "PASS: NULL retrieved correctly",
                "PASS: Mixed NULL/valid storage",
                "PASS: NULL at index 0 detected",
                "PASS: Valid pointer after NULL",
                "PASS: NULL comprehensive test passed",
                "PASS: Shrinking test present",
                "PASS: Expanded to capacity=16",
                "PASS: Shrinking test completed",
                "PASS: Cycle test present",
                "PASS: Cycle 0 add phase",
                "PASS: Cycle 0 delete phase",
                "PASS: Multiple cycles executed",
                "PASS: Final total correct.*3 cycles",
                "PASS: Cycle test passed",
                "PASS: All 10 comprehensive tests completed",
                "Total test suites detected:",
                "PASS: All 10 test suites present",
                "COMPREHENSIVE VALIDATION SUMMARY",
                "PASS: Core Operations:",
                "PASS: Dynamic Expansion:",
                "PASS: Dynamic Shrinking:",
                "PASS: Empty Vector Ops:",
                "PASS: NULL Handling:",
                "PASS: Cycle Testing:",
                "PASS: Edge Cases:",
                "PASS: Memory Management:",
                "PASS: All comprehensive vector validation phases completed successfully"
              ]
            },
            "timeout": 30
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [],
      "requirements": [
        "Use required function names: kernel_vector_init, kernel_vector_exit, vector_init, vector_total, vector_add, vector_set, vector_get, vector_delete, vector_free, vector_resize",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/slab.h, linux/types.h",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Kernel vector module loaded",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "Testing with capacity=",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": false
        },
        {
          "pattern": "Test 1: Vector initialization",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "vector_init: Initializing vector",
          "linkedFunction": "int vector_init(vector *v)",
          "exact": true
        },
        {
          "pattern": "Vector initialized: capacity=4, total=0",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "Test 2: Adding elements",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "vector_add: Adding item",
          "linkedFunction": "int vector_add(vector *v, void *item)",
          "exact": false
        },
        {
          "pattern": "Added 'first' at index 0",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": false
        },
        {
          "pattern": "Added 'second' at index 1",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": false
        },
        {
          "pattern": "Added 'third' at index 2",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": false
        },
        {
          "pattern": "Test 3: Getting elements",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "Element at index 0: first",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "Element at index 1:",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": false
        },
        {
          "pattern": "Test 4: Setting element",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "vector_set: Setting index 1",
          "linkedFunction": "int vector_set(vector *v, int index, void *item)",
          "exact": true
        },
        {
          "pattern": "Modified element at index 1: modified",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "Test 5: Deleting element",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "vector_delete: Deleting index",
          "linkedFunction": "int vector_delete(vector *v, int index)",
          "exact": false
        },
        {
          "pattern": "Deleted element at index",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": false
        },
        {
          "pattern": "Elements after deletion:",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "Test 6: Edge case testing",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "Get invalid index (100): NULL",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "Set invalid index (100): ERROR",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "vector_free: Freeing vector",
          "linkedFunction": "void vector_free(vector *v)",
          "exact": true
        },
        {
          "pattern": "Vector freed",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "Test 7: Empty vector operations",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "Empty vector initialized (total=0)",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "Get from empty vector (index 0): NULL (correct)",
          "linkedFunction": "void *vector_get(vector *v, int index)",
          "exact": true
        },
        {
          "pattern": "Delete from empty vector (index 0): ERROR (correct)",
          "linkedFunction": "int vector_delete(vector *v, int index)",
          "exact": true
        },
        {
          "pattern": "Set on empty vector (index 0): ERROR (correct)",
          "linkedFunction": "int vector_set(vector *v, int index, void *item)",
          "exact": true
        },
        {
          "pattern": "Empty vector test completed",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "Test 8: NULL pointer handling",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "Add NULL pointer: SUCCESS",
          "linkedFunction": "int vector_add(vector *v, void *item)",
          "exact": true
        },
        {
          "pattern": "Get NULL pointer: NULL (correct)",
          "linkedFunction": "void *vector_get(vector *v, int index)",
          "exact": true
        },
        {
          "pattern": "Mixed NULL and valid pointers: total=4",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "NULL pointer test completed",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "Test 9: Capacity shrinking test",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "After adding 16 items: total=16, capacity=16",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "After deleting to 4 items",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": false
        },
        {
          "pattern": "Capacity shrinking test completed",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "Test 10: Add-Delete cycle test",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "Cycle 0: After adding 10, total=10",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "Cycle 0: After deleting 5, total=5",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "After 3 cycles: total=15",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": false
        },
        {
          "pattern": "Add-Delete cycle test completed",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "All comprehensive tests completed",
          "linkedFunction": "static int __init kernel_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "Kernel vector module unloaded",
          "linkedFunction": "static void __exit kernel_vector_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 31,
    "title": "Typed Vector Wrappers - Building Generic Libraries with Macros",
    "difficulty": 7,
    "xp": 70,
    "phase": "foundations",
    "description": "Master macro-based generic programming by creating type-safe wrappers around the generic vector. Learn to build reusable 'template-like' libraries in C using typedef aliases and macros - the exact pattern used in production kernel code like the Linux kernel's list.h and other generic data structures. This problem teaches you to turn void* containers into type-safe interfaces without code duplication.",
    "concepts": [
      "typedef aliases for generic types",
      "type-safe macro wrappers",
      "template-like generic programming in C",
      "macro-based type safety",
      "building reusable libraries",
      "kernel generic programming patterns",
      "void* abstraction and type casting",
      "compile-time type wrapping"
    ],
    "skills": [
      "Creating typed aliases with typedef",
      "Writing type-safe wrapper macros",
      "Understanding macro parameter safety ((v) patterns)",
      "Building generic library interfaces",
      "Applying Linux kernel generic patterns",
      "Managing two-level memory allocation",
      "Proper cleanup with typed wrappers",
      "Creating production-quality APIs"
    ],
    "files": [
      {
        "name": "kernel_vector.h",
        "content": "#ifndef KERNEL_VECTOR_H\n#define KERNEL_VECTOR_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n/* Generic vector implementation (from Problem 030) */\n#define VECTOR_INIT_CAPACITY 4\n#define VECTOR_SUCCESS 0\n#define VECTOR_ERROR -1\n\ntypedef struct vector {\n    void **items;\n    int capacity;\n    int total;\n} vector;\n\n/* Generic vector API */\nint vector_init(vector *v);\nint vector_total(vector *v);\nint vector_add(vector *v, void *item);\nint vector_set(vector *v, int index, void *item);\nvoid *vector_get(vector *v, int index);\nint vector_delete(vector *v, int index);\nvoid vector_free(vector *v);\n\n#endif /* KERNEL_VECTOR_H */\n",
        "readOnly": true,
        "language": "h"
      },
      {
        "name": "kernel_vector.c",
        "content": "#include \"kernel_vector.h\"\n\n/* Generic vector implementation (provided from Problem 030) */\n\nstatic int vector_resize(vector *v, int capacity) {\n    void **new_items = krealloc(v->items, sizeof(void*) * capacity, GFP_KERNEL);\n    if (!new_items) return VECTOR_ERROR;\n    v->items = new_items;\n    v->capacity = capacity;\n    return VECTOR_SUCCESS;\n}\n\nint vector_init(vector *v) {\n    v->capacity = VECTOR_INIT_CAPACITY;\n    v->total = 0;\n    v->items = kmalloc(sizeof(void*) * v->capacity, GFP_KERNEL);\n    return v->items ? VECTOR_SUCCESS : VECTOR_ERROR;\n}\nEXPORT_SYMBOL(vector_init);\n\nint vector_total(vector *v) {\n    return v->total;\n}\nEXPORT_SYMBOL(vector_total);\n\nint vector_add(vector *v, void *item) {\n    if (v->capacity == v->total) {\n        if (vector_resize(v, v->capacity * 2) == VECTOR_ERROR)\n            return VECTOR_ERROR;\n    }\n    v->items[v->total++] = item;\n    return VECTOR_SUCCESS;\n}\nEXPORT_SYMBOL(vector_add);\n\nint vector_set(vector *v, int index, void *item) {\n    if (index < 0 || index >= v->total) return VECTOR_ERROR;\n    v->items[index] = item;\n    return VECTOR_SUCCESS;\n}\nEXPORT_SYMBOL(vector_set);\n\nvoid *vector_get(vector *v, int index) {\n    if (index < 0 || index >= v->total) return NULL;\n    return v->items[index];\n}\nEXPORT_SYMBOL(vector_get);\n\nint vector_delete(vector *v, int index) {\n    if (index < 0 || index >= v->total) return VECTOR_ERROR;\n    for (int i = index; i < v->total - 1; i++)\n        v->items[i] = v->items[i + 1];\n    v->total--;\n    if (v->total > 0 && v->total == v->capacity / 4)\n        vector_resize(v, v->capacity / 2);\n    return VECTOR_SUCCESS;\n}\nEXPORT_SYMBOL(vector_delete);\n\nvoid vector_free(vector *v) {\n    kfree(v->items);\n    v->items = NULL;\n    v->total = 0;\n    v->capacity = 0;\n}\nEXPORT_SYMBOL(vector_free);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"KernelQ\");\nMODULE_DESCRIPTION(\"Generic vector implementation for kernel modules\");\nMODULE_VERSION(\"1.0\");\n",
        "readOnly": true,
        "language": "c"
      },
      {
        "name": "sensor_data.h",
        "content": "#ifndef SENSOR_DATA_H\n#define SENSOR_DATA_H\n\n#include <linux/types.h>\n\n#define MAX_SENSOR_NAME 32\n#define MAX_SENSOR_UNIT 16\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: Typed Data Structure for Generic Container */\n/* ========================================================================== */\n/* This teaches you to design data structures that work with generic containers!\n *\n * DESIGN PRINCIPLES:\n * 1. Self-contained: All data needed is in the struct\n * 2. Fixed-size strings: No dynamic allocation within the struct\n * 3. Clear semantics: Field names describe their purpose\n * 4. Production pattern: Exactly how kernel subsystems work\n *\n * EXAMPLE KERNEL USAGE:\n * - struct task_struct for processes (linux/sched.h)\n * - struct net_device for network devices (linux/netdevice.h)\n * - struct file for open files (linux/fs.h)\n */\n\n/* Sensor data structure */\ntypedef struct {\n    uint32_t sensor_id;\n    char sensor_name[MAX_SENSOR_NAME];\n    uint32_t reading_value;  /* Fixed-point: divide by 10 for decimal (e.g., 255 = 25.5) */\n    char unit[MAX_SENSOR_UNIT];\n    uint64_t timestamp;\n    bool is_active;\n} SensorData;\n\n#endif /* SENSOR_DATA_H */\n",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "sensor_vector.h",
        "content": "#ifndef SENSOR_VECTOR_H\n#define SENSOR_VECTOR_H\n\n#include \"kernel_vector.h\"\n#include \"sensor_data.h\"\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: Type-Safe Vector Wrapper Using Macros */\n/* ========================================================================== */\n/* This teaches PRODUCTION-LEVEL generic programming patterns in C!\n *\n * THE PROBLEM:\n * - Generic vector uses void*, which loses type information\n * - Casting everywhere: (SensorData*)vector_get(&v, 0) is error-prone\n * - No compile-time type checking for wrong types\n *\n * THE SOLUTION:\n * - Create typed aliases using typedef\n * - Wrap generic functions with type-safe macros\n * - Hide void* casts inside macros\n * - Provide a clean, type-safe interface\n *\n * REAL-WORLD EXAMPLES:\n * Linux kernel uses this pattern extensively:\n * - list.h: list_for_each_entry()\n * - rbtree.h: rb_entry()\n * - hashtable.h: hash_for_each()\n *\n * TEMPLATE-LIKE BEHAVIOR IN C:\n * C++ Template:                C Macro Equivalent:\n * vector<SensorData> v;        sensor_vector v;\n * v.push_back(sensor);         SENSOR_VEC_ADD(v, sensor_ptr);\n * SensorData s = v[0];         SensorData *s = SENSOR_VEC_GET(v, 0);\n *\n * WHY THIS WORKS:\n * - typedef creates type alias (sensor_vector)\n * - Macros perform type-safe wrapping at compile time\n * - Underlying implementation stays generic\n * - Each typed wrapper is just a few lines of code\n */\n\n/* ========================================================================== */\n/* TODO: CREATE TYPED VECTOR ALIAS */\n/* ========================================================================== */\n/* TASK: Create a type alias for a vector of SensorData pointers\n *\n * PATTERN:\n * typedef vector TYPE_NAME;\n *\n * EXAMPLE:\n * typedef vector sensor_vector;\n *\n * This creates \"sensor_vector\" as an alias for \"vector\", making your\n * intent clear and providing a foundation for typed macros.\n */\n\n/* TODO: typedef vector sensor_vector; */\n\n/* ========================================================================== */\n/* TODO: CREATE TYPE-SAFE WRAPPER MACROS */\n/* ========================================================================== */\n/* TASK: Create macros that wrap the generic vector API with type safety\n *\n * MACRO PATTERNS:\n *\n * 1. INITIALIZATION MACRO:\n *    #define SENSOR_VEC_INIT(v) vector_init(&(v))\n *    Why &(v)? The generic API expects vector*, this ensures correct usage\n *\n * 2. ADD MACRO (with type cast):\n *    #define SENSOR_VEC_ADD(v, sensor_ptr) vector_add(&(v), (void*)(sensor_ptr))\n *    Casts SensorData* to void* for storage in generic vector\n *\n * 3. GET MACRO (with type cast):\n *    #define SENSOR_VEC_GET(v, idx) ((SensorData*)vector_get(&(v), (idx)))\n *    Casts void* back to SensorData* for type-safe access\n *\n * 4. TOTAL MACRO:\n *    #define SENSOR_VEC_TOTAL(v) vector_total(&(v))\n *\n * 5. SET MACRO:\n *    #define SENSOR_VEC_SET(v, idx, sensor_ptr) vector_set(&(v), (idx), (void*)(sensor_ptr))\n *\n * 6. DELETE MACRO:\n *    #define SENSOR_VEC_DELETE(v, idx) vector_delete(&(v), (idx))\n *\n * 7. FREE MACRO:\n *    #define SENSOR_VEC_FREE(v) vector_free(&(v))\n *\n * CRITICAL SAFETY NOTES:\n * - Use (v) in parentheses to avoid macro expansion issues\n * - Cast to void* when adding, cast from void* when getting\n * - These macros provide type safety at compile time\n * - They hide the ugly casts, making code cleaner\n */\n\n/* TODO: Implement all 7 type-safe wrapper macros */\n/* #define SENSOR_VEC_INIT(v)              vector_init(&(v)) */\n/* #define SENSOR_VEC_ADD(v, sensor_ptr)   vector_add(&(v), (void*)(sensor_ptr)) */\n/* #define SENSOR_VEC_GET(v, idx)          ((SensorData*)vector_get(&(v), (idx))) */\n/* #define SENSOR_VEC_TOTAL(v)             vector_total(&(v)) */\n/* #define SENSOR_VEC_SET(v, idx, ptr)     vector_set(&(v), (idx), (void*)(ptr)) */\n/* #define SENSOR_VEC_DELETE(v, idx)       vector_delete(&(v), (idx)) */\n/* #define SENSOR_VEC_FREE(v)              vector_free(&(v)) */\n\n/* ========================================================================== */\n/* HELPER FUNCTION DECLARATIONS */\n/* ========================================================================== */\n/* TODO: Declare helper functions for sensor operations */\n/* SensorData* create_sensor(uint32_t id, const char *name, uint32_t value, const char *unit); */\n/* void print_sensor(SensorData *sensor); */\n/* void free_all_sensors(sensor_vector *sv); */\n\n#endif /* SENSOR_VECTOR_H */\n",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "sensor_vector.c",
        "content": "#include \"sensor_vector.h\"\n#include <linux/string.h>\n#include <linux/jiffies.h>\n\n/* Module parameters for dynamic testing */\nint test_sensor_count = 3;\nint test_sensor_id_base = 1000;\n\nmodule_param(test_sensor_count, int, 0644);\nMODULE_PARM_DESC(test_sensor_count, \"Number of sensors to create for testing\");\nmodule_param(test_sensor_id_base, int, 0644);\nMODULE_PARM_DESC(test_sensor_id_base, \"Base sensor ID for anti-hardcoding testing\");\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: Creating Type-Safe Instances */\n/* ========================================================================== */\n/* This teaches you to create instances of your typed data for the container!\n *\n * MEMORY MANAGEMENT PATTERN:\n * 1. Allocate: Use kmalloc for each instance\n * 2. Initialize: Fill in all struct fields\n * 3. Store: Add pointer to vector\n * 4. Access: Get pointer from vector, use ->\n * 5. Cleanup: Free each instance, then free vector\n *\n * WHY HEAP ALLOCATION?\n * - Vector stores pointers, not values\n * - Heap allocation persists beyond function scope\n * - Allows dynamic creation and deletion\n * - Standard kernel development practice\n */\n\n/* TODO: Implement sensor creation function */\n/* ALGORITHM:\n * 1. Allocate memory: kmalloc(sizeof(SensorData), GFP_KERNEL)\n * 2. Check for NULL (allocation failure)\n * 3. Fill all fields:\n *    - sensor_id = id\n *    - Use strscpy() for strings (kernel-safe string copy)\n *    - reading_value = value\n *    - timestamp = get_jiffies_64() (kernel time)\n *    - is_active = true\n * 4. Return pointer\n *\n * EXAMPLE:\n * SensorData *sensor = kmalloc(sizeof(SensorData), GFP_KERNEL);\n * if (!sensor) return NULL;\n * sensor->sensor_id = id;\n * strscpy(sensor->sensor_name, name, MAX_SENSOR_NAME);\n * return sensor;\n */\nSensorData* create_sensor(uint32_t id, const char *name, uint32_t value, const char *unit) {\n    /* TODO: Implement sensor creation with proper initialization */\n    return NULL;\n}\n\n/* TODO: Implement sensor printing function */\n/* ALGORITHM:\n * 1. Check if sensor pointer is NULL\n * 2. Use printk(KERN_INFO, ...) to print:\n *    - \"Sensor ID: %u\"\n *    - \"Name: %s\"\n *    - \"Reading: %u %s\" (value is fixed-point, divide by 10 for display)\n *    - \"Timestamp: %llu\"\n *    - \"Active: %s\" (\"YES\" or \"NO\")\n */\nvoid print_sensor(SensorData *sensor) {\n    /* TODO: Implement sensor information printing */\n}\n\n/* TODO: Implement cleanup function for all sensors in vector */\n/* ALGORITHM:\n * 1. Loop through all elements: for (i = 0; i < SENSOR_VEC_TOTAL(*sv); i++)\n * 2. Get each sensor: SensorData *s = SENSOR_VEC_GET(*sv, i);\n * 3. Free each sensor: kfree(s);\n * 4. After loop, free the vector itself: SENSOR_VEC_FREE(*sv);\n *\n * CRITICAL: Must free in reverse order:\n * - First free all SensorData instances (heap allocated)\n * - Then free the vector structure\n */\nvoid free_all_sensors(sensor_vector *sv) {\n    /* TODO: Implement proper two-level cleanup */\n}\n\n/* ========================================================================== */\n/* MODULE INIT: Test the typed vector wrapper */\n/* ========================================================================== */\nstatic int __init sensor_vector_init(void)\n{\n    sensor_vector sv;\n    SensorData *sensor;\n    int result;\n    int i;\n\n    printk(KERN_INFO \"Sensor vector module loaded\\n\");\n    printk(KERN_INFO \"Testing with %d sensors starting from ID %d\\n\", \n           test_sensor_count, test_sensor_id_base);\n\n    /* Test 1: Initialize typed vector */\n    printk(KERN_INFO \"Test 1: Initializing sensor vector\\n\");\n    result = SENSOR_VEC_INIT(sv);\n    if (result != VECTOR_SUCCESS) {\n        printk(KERN_ERR \"Failed to initialize sensor vector\\n\");\n        return -ENOMEM;\n    }\n    printk(KERN_INFO \"Sensor vector initialized\\n\");\n\n    /* Test 2: Create and add sensors using dynamic parameters */\n    printk(KERN_INFO \"Test 2: Creating and adding sensors\\n\");\n    for (i = 0; i < test_sensor_count && i < 5; i++) {\n        char name[MAX_SENSOR_NAME];\n        snprintf(name, sizeof(name), \"Sensor_%d\", test_sensor_id_base + i);\n        \n        sensor = create_sensor(test_sensor_id_base + i, name, \n                               255 + i * 5, \"Celsius\");\n        if (!sensor) {\n            printk(KERN_ERR \"Failed to create sensor %d\\n\", i);\n            free_all_sensors(&sv);\n            return -ENOMEM;\n        }\n\n        result = SENSOR_VEC_ADD(sv, sensor);\n        if (result != VECTOR_SUCCESS) {\n            printk(KERN_ERR \"Failed to add sensor %d\\n\", i);\n            kfree(sensor);\n            free_all_sensors(&sv);\n            return -ENOMEM;\n        }\n        printk(KERN_INFO \"Added sensor ID %u (total=%d)\\n\", \n               sensor->sensor_id, SENSOR_VEC_TOTAL(sv));\n    }\n\n    /* Test 3: Access and print sensors */\n    printk(KERN_INFO \"Test 3: Accessing and printing sensors\\n\");\n    for (i = 0; i < SENSOR_VEC_TOTAL(sv); i++) {\n        sensor = SENSOR_VEC_GET(sv, i);\n        if (sensor) {\n            printk(KERN_INFO \"--- Sensor at index %d ---\\n\", i);\n            print_sensor(sensor);\n        }\n    }\n\n    /* Test 4: Modify sensor using SET */\n    printk(KERN_INFO \"Test 4: Modifying sensor\\n\");\n    if (SENSOR_VEC_TOTAL(sv) > 0) {\n        SensorData *new_sensor = create_sensor(9999, \"Modified_Sensor\", \n                                               999, \"Fahrenheit\");\n        if (new_sensor) {\n            SensorData *old_sensor = SENSOR_VEC_GET(sv, 0);\n            if (old_sensor) {\n                kfree(old_sensor);  /* Free old sensor first */\n            }\n            result = SENSOR_VEC_SET(sv, 0, new_sensor);\n            if (result == VECTOR_SUCCESS) {\n                printk(KERN_INFO \"Modified sensor at index 0\\n\");\n                print_sensor(new_sensor);\n            }\n        }\n    }\n\n    /* Test 5: Delete sensor */\n    printk(KERN_INFO \"Test 5: Deleting sensor\\n\");\n    if (SENSOR_VEC_TOTAL(sv) > 1) {\n        SensorData *to_delete = SENSOR_VEC_GET(sv, 1);\n        if (to_delete) {\n            printk(KERN_INFO \"Deleting sensor ID %u at index 1\\n\", \n                   to_delete->sensor_id);\n            kfree(to_delete);  /* Free sensor before deleting from vector */\n            result = SENSOR_VEC_DELETE(sv, 1);\n            if (result == VECTOR_SUCCESS) {\n                printk(KERN_INFO \"Deleted sensor (total=%d)\\n\", \n                       SENSOR_VEC_TOTAL(sv));\n            }\n        }\n    }\n\n    /* Test 6: Final state */\n    printk(KERN_INFO \"Test 6: Final vector state\\n\");\n    printk(KERN_INFO \"Final sensor count: %d\\n\", SENSOR_VEC_TOTAL(sv));\n    for (i = 0; i < SENSOR_VEC_TOTAL(sv); i++) {\n        sensor = SENSOR_VEC_GET(sv, i);\n        if (sensor) {\n            printk(KERN_INFO \"  [%d] Sensor ID %u: %s\\n\", \n                   i, sensor->sensor_id, sensor->sensor_name);\n        }\n    }\n\n    /* Cleanup */\n    printk(KERN_INFO \"Cleaning up all sensors\\n\");\n    free_all_sensors(&sv);\n    printk(KERN_INFO \"All tests completed successfully\\n\");\n\n    return 0;\n}\n\nstatic void __exit sensor_vector_exit(void)\n{\n    printk(KERN_INFO \"Sensor vector module unloaded\\n\");\n}\n\nmodule_init(sensor_vector_init);\nmodule_exit(sensor_vector_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Typed vector wrapper implementation using macros\");\nMODULE_VERSION(\"1.0\");\n",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Sensor vector module Makefile\nobj-m += kernel_vector.o sensor_vector.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help\n",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "sensor_vector.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "sensor_vector_init",
          "sensor_vector_exit",
          "create_sensor",
          "print_sensor",
          "free_all_sensors"
        ],
        "macro_declarations": [
          {
            "name": "SENSOR_VEC_INIT",
            "type": "function-like",
            "parameters": [
              "v"
            ],
            "value": "vector_init(&(v))",
            "description": "Initialize the sensor vector"
          },
          {
            "name": "SENSOR_VEC_ADD",
            "type": "function-like",
            "parameters": [
              "v",
              "sensor_ptr"
            ],
            "value": "vector_add(&(v), (void*)(sensor_ptr))",
            "description": "Add a sensor pointer to the vector"
          },
          {
            "name": "SENSOR_VEC_GET",
            "type": "function-like",
            "parameters": [
              "v",
              "idx"
            ],
            "value": "((SensorData*)vector_get(&(v), (idx)))",
            "description": "Get a sensor pointer from the vector (with type cast)"
          },
          {
            "name": "SENSOR_VEC_TOTAL",
            "type": "function-like",
            "parameters": [
              "v"
            ],
            "value": "vector_total(&(v))",
            "description": "Get total number of sensors in the vector"
          },
          {
            "name": "SENSOR_VEC_SET",
            "type": "function-like",
            "parameters": [
              "v",
              "idx",
              "ptr"
            ],
            "value": "vector_set(&(v), (idx), (void*)(ptr))",
            "description": "Set a sensor at a specific index"
          },
          {
            "name": "SENSOR_VEC_DELETE",
            "type": "function-like",
            "parameters": [
              "v",
              "idx"
            ],
            "value": "vector_delete(&(v), (idx))",
            "description": "Delete a sensor at a specific index"
          },
          {
            "name": "SENSOR_VEC_FREE",
            "type": "function-like",
            "parameters": [
              "v"
            ],
            "value": "vector_free(&(v))",
            "description": "Free the vector structure"
          }
        ],
        "function_declarations": [
          {
            "name": "create_sensor",
            "returnType": "SensorData*",
            "parameters": [
              "uint32_t id",
              "const char *name",
              "uint32_t value",
              "const char *unit"
            ]
          },
          {
            "name": "print_sensor",
            "returnType": "void",
            "parameters": [
              "SensorData *sensor"
            ]
          },
          {
            "name": "free_all_sensors",
            "returnType": "void",
            "parameters": [
              "sensor_vector *sv"
            ]
          }
        ],
        "variables_declarations": [
          {
            "name": "SensorData",
            "type": "typedef struct",
            "value": "{uint32_t sensor_id; char sensor_name[MAX_SENSOR_NAME]; uint32_t reading_value; char unit[MAX_SENSOR_UNIT]; uint64_t timestamp; bool is_active;}",
            "storageClass": "none"
          },
          {
            "name": "sensor_vector",
            "type": "typedef vector",
            "storageClass": "none"
          }
        ],
        "variables": [
          {
            "name": "test_sensor_count",
            "type": "int",
            "value": 3,
            "storageClass": "none"
          },
          {
            "name": "test_sensor_id_base",
            "type": "int",
            "value": 1000,
            "storageClass": "none"
          }
        ],
        "function_definitions": [
          {
            "name": "create_sensor",
            "returnType": "SensorData*",
            "parameters": [
              "uint32_t id",
              "const char *name",
              "uint32_t value",
              "const char *unit"
            ],
            "description": "Allocate and initialize a SensorData instance with kmalloc"
          },
          {
            "name": "print_sensor",
            "returnType": "void",
            "parameters": [
              "SensorData *sensor"
            ],
            "description": "Print sensor information using printk"
          },
          {
            "name": "free_all_sensors",
            "returnType": "void",
            "parameters": [
              "sensor_vector *sv"
            ],
            "description": "Free all sensors in vector, then free the vector itself"
          },
          {
            "name": "sensor_vector_init",
            "returnType": "static int",
            "parameters": [
              "void"
            ],
            "description": "Module initialization function",
            "attributes": [
              "__init"
            ]
          },
          {
            "name": "sensor_vector_exit",
            "returnType": "static void",
            "parameters": [
              "void"
            ],
            "description": "Module cleanup function",
            "attributes": [
              "__exit"
            ]
          }
        ],
        "outputMessages": [
          "Sensor vector module loaded",
          "Testing with 3 sensors starting from ID 1000",
          "Test 1: Initializing sensor vector",
          "Sensor vector initialized",
          "Test 2: Creating and adding sensors",
          "Added sensor ID 1000",
          "Added sensor ID 1001",
          "Added sensor ID 1002",
          "Test 3: Accessing and printing sensors",
          "Sensor ID: 1000",
          "Sensor ID: 1001",
          "Sensor ID: 1002",
          "Test 4: Modifying sensor",
          "Modified sensor at index 0",
          "Sensor ID: 9999",
          "Test 5: Deleting sensor",
          "Deleted sensor",
          "Test 6: Final vector state",
          "Cleaning up all sensors",
          "All tests completed successfully",
          "Sensor vector module unloaded"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/slab.h",
          "linux/types.h",
          "linux/string.h",
          "linux/jiffies.h"
        ],
        "mustContain": [
          "typedef vector sensor_vector",
          "#define SENSOR_VEC_INIT(v) vector_init(&(v))",
          "#define SENSOR_VEC_ADD(v, sensor_ptr) vector_add(&(v), (void*)(sensor_ptr))",
          "#define SENSOR_VEC_GET(v, idx) ((SensorData*)vector_get(&(v), (idx)))",
          "#define SENSOR_VEC_TOTAL(v) vector_total(&(v))",
          "#define SENSOR_VEC_FREE(v) vector_free(&(v))",
          "kmalloc(sizeof(SensorData), GFP_KERNEL)",
          "strscpy(",
          "get_jiffies_64()",
          "for (i = 0; i < SENSOR_VEC_TOTAL(*sv); i++)",
          "kfree(s)",
          "SENSOR_VEC_FREE(*sv)",
          "module_param(test_sensor_count, int, 0644)",
          "module_param(test_sensor_id_base, int, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "SensorData* create_sensor(uint32_t id, const char *name, uint32_t value, const char *unit)",
            "void print_sensor(SensorData *sensor)",
            "void free_all_sensors(sensor_vector *sv)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Implementations in Source",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "SensorData* create_sensor(uint32_t id, const char *name, uint32_t value, const char *unit)",
            "void print_sensor(SensorData *sensor)",
            "void free_all_sensors(sensor_vector *sv)",
            "static int __init sensor_vector_init(void)",
            "static void __exit sensor_vector_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "struct_definition",
          "name": "SensorData Structure Definition",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "typedef struct",
            "uint32_t sensor_id",
            "char sensor_name[MAX_SENSOR_NAME]",
            "uint32_t reading_value",
            "char unit[MAX_SENSOR_UNIT]",
            "uint64_t timestamp",
            "bool is_active"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Sensor vector module loaded",
              "exact": true,
              "linkedFunction": "static int __init sensor_vector_init(void)"
            },
            {
              "pattern": "Testing with 3 sensors starting from ID 1000",
              "exact": true,
              "linkedFunction": "static int __init sensor_vector_init(void)"
            },
            {
              "pattern": "Sensor vector initialized",
              "exact": true,
              "linkedFunction": "static int __init sensor_vector_init(void)"
            },
            {
              "pattern": "Added sensor ID 1000",
              "exact": false,
              "linkedFunction": "static int __init sensor_vector_init(void)"
            },
            {
              "pattern": "Sensor ID: 1000",
              "exact": true,
              "linkedFunction": "void print_sensor(SensorData *sensor)"
            },
            {
              "pattern": "Sensor ID: 9999",
              "exact": true,
              "linkedFunction": "void print_sensor(SensorData *sensor)"
            },
            {
              "pattern": "All tests completed successfully",
              "exact": true,
              "linkedFunction": "static int __init sensor_vector_init(void)"
            },
            {
              "pattern": "Sensor vector module unloaded",
              "exact": true,
              "linkedFunction": "static void __exit sensor_vector_exit(void)"
            }
          ]
        },
        {
          "id": "comprehensive_typed_vector_validation",
          "name": "Comprehensive Typed Vector Wrapper Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "sensor_vector_dynamic_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Typed Vector Wrapper Test ===\\\\n\\\");\\n    \\n    srand(time(NULL));\\n    \\n    int random_sensor_count = (rand() % 3) + 2;\\n    int random_id_base = (rand() % 900) + 1000;\\n    \\n    printf(\\\"Test 1: Creating %d sensors with base ID %d\\\\n\\\", random_sensor_count, random_id_base);\\n    \\n    system(\\\"rmmod sensor_vector 2>/dev/null\\\");\\n    system(\\\"rmmod kernel_vector 2>/dev/null\\\");\\n    \\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/kernel_vector.ko && insmod /lib/modules/sensor_vector.ko test_sensor_count=%d test_sensor_id_base=%d\\\", random_sensor_count, random_id_base);\\n    printf(\\\"DEBUG: Command: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Dynamic typed vector test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting comprehensive typed vector wrapper validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: TCC Header Validation'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
              "echo 'typedef unsigned long long uint64_t;' >> /tmp/linux/types.h",
              "echo '#define true 1' >> /tmp/linux/types.h",
              "echo '#define false 0' >> /tmp/linux/types.h",
              "echo '#define MAX_SENSOR_NAME 32' >> /tmp/linux/types.h",
              "echo '#define MAX_SENSOR_UNIT 16' >> /tmp/linux/types.h",
              "echo 'void *kmalloc(unsigned long size, int flags);' > /tmp/linux/slab.h",
              "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
              "echo '#define GFP_KERNEL 0' >> /tmp/linux/slab.h",
              "echo 'unsigned long long get_jiffies_64(void);' > /tmp/linux/jiffies.h",
              "echo 'char *strscpy(char *dest, const char *src, unsigned long count);' > /tmp/linux/string.h",
              "echo '#include \"/lib/modules/sensor_vector.h\"' > /tmp/test.c",
              "echo 'int main() { sensor_vector sv; SensorData *s; SENSOR_VEC_INIT(sv); s = create_sensor(1, \"test\", 314, \"C\"); SENSOR_VEC_ADD(sv, s); print_sensor(s); free_all_sensors(&sv); return 0; }' >> /tmp/test.c",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or macro declarations missing in header'; cat /tmp/tcc_error.log; else echo 'PASS: All function and macro declarations found in header file'; fi",
              "echo 'Phase 2: Dynamic Typed Vector Testing'",
              "/bin/sensor_vector_dynamic_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Extract Runtime Values'",
              "sleep 1",
              "SENSOR_COUNT=$(grep -o 'Creating [0-9]* sensors' /tmp/test_output.log | grep -o '[0-9]*' | head -1)",
              "ID_BASE=$(grep -o 'base ID [0-9]*' /tmp/test_output.log | grep -o '[0-9]*' | head -1)",
              "echo 'Extracted values: SENSOR_COUNT='$SENSOR_COUNT', ID_BASE='$ID_BASE",
              "if [ -z \"$SENSOR_COUNT\" ] || [ -z \"$ID_BASE\" ]; then echo 'FAIL: Could not extract test values'; else echo 'PASS: Test values extracted successfully'; fi",
              "echo 'Phase 4: Validate Typedef and Macros'",
              "dmesg | grep 'Sensor vector initialized' && echo 'PASS: SENSOR_VEC_INIT macro working' || echo 'FAIL: Init macro broken'",
              "dmesg | grep -E 'Added sensor ID' && echo 'PASS: SENSOR_VEC_ADD macro working' || echo 'FAIL: Add macro broken'",
              "dmesg | grep 'Sensor ID: '$ID_BASE && echo 'PASS: SENSOR_VEC_GET macro working with dynamic ID' || echo 'FAIL: Get macro broken'",
              "echo 'Phase 5: Validate Sensor Creation'",
              "dmesg | grep 'Sensor ID: '$ID_BASE && echo 'PASS: create_sensor() working with dynamic ID' || echo 'FAIL: create_sensor broken'",
              "ID_PLUS_1=$((ID_BASE + 1))",
              "dmesg | grep 'Sensor ID: '$ID_PLUS_1 && echo 'PASS: Multiple sensors created correctly' || echo 'FAIL: Multiple sensor creation broken'",
              "echo 'Phase 6: Validate Printing and Cleanup'",
              "dmesg | grep 'Name:' && echo 'PASS: print_sensor() implemented' || echo 'FAIL: print_sensor missing'",
              "dmesg | grep 'Reading:' && echo 'PASS: Sensor reading field printed' || echo 'FAIL: Reading field missing'",
              "dmesg | grep 'Cleaning up all sensors' && echo 'PASS: free_all_sensors() called' || echo 'FAIL: Cleanup not called'",
              "echo 'Phase 7: Validate Modified Sensor (ID 9999)'",
              "dmesg | grep 'Sensor ID: 9999' && echo 'PASS: SENSOR_VEC_SET macro working' || echo 'FAIL: Set macro broken'",
              "dmesg | grep 'Modified_Sensor' && echo 'PASS: Sensor modification working' || echo 'FAIL: Modification broken'",
              "echo 'Phase 8: Module System Validation'",
              "dmesg | grep 'Sensor vector module loaded' && echo 'PASS: Module init working' || echo 'FAIL: Module init broken'",
              "dmesg | grep 'All tests completed successfully' && echo 'PASS: All tests passed' || echo 'FAIL: Tests incomplete'",
              "echo 'PASS: All comprehensive typed vector validation completed successfully'"
            ],
            "expected": {
              "dmesg": [
                "Sensor vector module loaded",
                "Testing with.*sensors starting from ID",
                "Sensor vector initialized",
                "Added sensor ID",
                "Sensor ID: .*",
                "Name: .*",
                "Reading: .*",
                "Modified sensor at index 0",
                "Sensor ID: 9999",
                "Cleaning up all sensors",
                "All tests completed successfully",
                "Sensor vector module unloaded"
              ],
              "stdout": [
                "PASS: All function and macro declarations found in header file",
                "SUCCESS: Dynamic typed vector test completed",
                "PASS: Test values extracted successfully",
                "PASS: SENSOR_VEC_INIT macro working",
                "PASS: SENSOR_VEC_ADD macro working",
                "PASS: SENSOR_VEC_GET macro working with dynamic ID",
                "PASS: create_sensor\\(\\) working with dynamic ID",
                "PASS: Multiple sensors created correctly",
                "PASS: print_sensor\\(\\) implemented",
                "PASS: Sensor reading field printed",
                "PASS: free_all_sensors\\(\\) called",
                "PASS: SENSOR_VEC_SET macro working",
                "PASS: Sensor modification working",
                "PASS: Module init working",
                "PASS: All tests passed",
                "PASS: All comprehensive typed vector validation completed successfully"
              ]
            },
            "timeout": 20
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Sensor vector module loaded",
        "Testing with 3 sensors starting from ID 1000",
        "Test 1: Initializing sensor vector",
        "Sensor vector initialized",
        "Test 2: Creating and adding sensors",
        "Added sensor ID 1000",
        "Added sensor ID 1001",
        "Added sensor ID 1002",
        "Test 3: Accessing and printing sensors",
        "Sensor ID: 1000",
        "Sensor ID: 1001",
        "Sensor ID: 1002",
        "Test 4: Modifying sensor",
        "Modified sensor at index 0",
        "Sensor ID: 9999",
        "Test 5: Deleting sensor",
        "Deleted sensor",
        "Test 6: Final vector state",
        "Cleaning up all sensors",
        "All tests completed successfully",
        "Sensor vector module unloaded"
      ],
      "requirements": [
        "Use required function names: sensor_vector_init, sensor_vector_exit, create_sensor, print_sensor, free_all_sensors",
        "Use required variable names: test_sensor_count, test_sensor_id_base",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/slab.h, linux/types.h, linux/string.h, linux/jiffies.h",
        "Code must contain: typedef vector sensor_vector, #define SENSOR_VEC_INIT(v) vector_init(&(v)), #define SENSOR_VEC_ADD(v, sensor_ptr) vector_add(&(v), (void*)(sensor_ptr)), #define SENSOR_VEC_GET(v, idx) ((SensorData*)vector_get(&(v), (idx))), #define SENSOR_VEC_TOTAL(v) vector_total(&(v)), #define SENSOR_VEC_FREE(v) vector_free(&(v)), kmalloc(sizeof(SensorData), GFP_KERNEL), strscpy(, get_jiffies_64(), for (i = 0; i < SENSOR_VEC_TOTAL(*sv); i++), kfree(s), SENSOR_VEC_FREE(*sv), module_param(test_sensor_count, int, 0644), module_param(test_sensor_id_base, int, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Sensor vector module loaded",
          "linkedFunction": "static int __init sensor_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "Testing with 3 sensors starting from ID 1000",
          "linkedFunction": "static int __init sensor_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "Sensor vector initialized",
          "linkedFunction": "static int __init sensor_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "Added sensor ID 1000",
          "linkedFunction": "static int __init sensor_vector_init(void)",
          "exact": false
        },
        {
          "pattern": "Sensor ID: 1000",
          "linkedFunction": "void print_sensor(SensorData *sensor)",
          "exact": true
        },
        {
          "pattern": "Sensor ID: 9999",
          "linkedFunction": "void print_sensor(SensorData *sensor)",
          "exact": true
        },
        {
          "pattern": "All tests completed successfully",
          "linkedFunction": "static int __init sensor_vector_init(void)",
          "exact": true
        },
        {
          "pattern": "Sensor vector module unloaded",
          "linkedFunction": "static void __exit sensor_vector_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 32,
    "title": "Const Correctness - Writing Safe APIs",
    "difficulty": 5,
    "xp": 50,
    "phase": "foundations",
    "description": "Master the const keyword to write safe, professional APIs that prevent accidental data modification. Learn to distinguish between pointer-to-const, const-pointer, and const-pointer-to-const. Understand const propagation through function call chains and why const correctness is fundamental to production C code - not an advanced feature, but a safety practice that should be used from day one.",
    "concepts": [
      "const keyword semantics",
      "pointer-to-const (const Type *ptr)",
      "const-pointer (Type * const ptr)",
      "const-pointer-to-const (const Type * const ptr)",
      "const propagation through function calls",
      "const-correct API design",
      "compile-time safety guarantees",
      "professional C coding practices"
    ],
    "skills": [
      "Using const for function parameters",
      "Distinguishing const pointer types",
      "Writing const-correct APIs",
      "Understanding const propagation",
      "Preventing accidental modifications",
      "Reading const qualifiers correctly",
      "Returning const pointers",
      "Applying const in production code"
    ],
    "files": [
      {
        "name": "config_system.h",
        "content": "#ifndef CONFIG_SYSTEM_H\n#define CONFIG_SYSTEM_H\n\n#include <linux/types.h>\n\n#define MAX_CONFIG_NAME 32\n#define MAX_CONFIG_VALUE 64\n#define MAX_CONFIGS 10\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: Const Correctness in Data Structures */\n/* ========================================================================== */\n/* This teaches you PROFESSIONAL API DESIGN with const!\n *\n * THE PROBLEM:\n * - Without const, functions can accidentally modify data they shouldn't\n * - Bugs from unintended modifications are hard to debug\n * - Professional C code uses const everywhere for safety\n *\n * THE SOLUTION:\n * - Mark data that shouldn't change as const\n * - Use const in function parameters to guarantee no modification\n * - Compiler enforces const correctness at compile time\n *\n * REAL-WORLD EXAMPLES:\n * Linux kernel uses const extensively:\n * - const char *name in struct device\n * - const struct file_operations (function pointer tables)\n * - int copy_to_user(void __user *to, const void *from, unsigned long n)\n *\n * THREE TYPES OF CONST:\n * 1. const int *ptr        - Pointer to const data (can't change *ptr)\n * 2. int * const ptr       - Const pointer (can't change ptr itself)\n * 3. const int * const ptr - Both pointer and data are const\n */\n\n/* Configuration entry - read-only after initialization */\ntypedef struct {\n    char name[MAX_CONFIG_NAME];\n    char value[MAX_CONFIG_VALUE];\n    uint32_t priority;\n    bool is_readonly;\n} ConfigEntry;\n\n/* Configuration database */\ntypedef struct {\n    ConfigEntry entries[MAX_CONFIGS];\n    int count;\n} ConfigDatabase;\n\n/* ========================================================================== */\n/* TODO: CONST-CORRECT FUNCTION DECLARATIONS */\n/* ========================================================================== */\n/* TASK: Declare functions with proper const qualifiers\n *\n * GUIDELINES:\n * 1. If a function READS data but doesn't modify it → use const\n * 2. If a function parameter is a pointer to data that won't change → const Type *\n * 3. Return const Type * if the returned data shouldn't be modified\n *\n * EXAMPLE PATTERNS:\n * - void print_config(const ConfigEntry *entry);  // entry won't be modified\n * - const char* get_value(const char *key);        // key won't change, return shouldn't change\n * - int set_value(const char *key, const char *val); // keys and values are read-only inputs\n */\n\n/* Initialize database with default configs */\nvoid config_db_init(ConfigDatabase *db);\n\n/* Add a configuration entry (name and value should be const - we're just reading them) */\n/* TODO: Add proper const qualifiers to parameters */\nint config_add(ConfigDatabase *db, const char *name, const char *value, uint32_t priority, bool readonly);\n\n/* Get configuration value by name (name is read-only, return value is read-only) */\n/* TODO: Add proper const qualifiers */\nconst char* config_get(const ConfigDatabase *db, const char *name);\n\n/* Print a single config entry (entry should be const - we're just reading it) */\n/* TODO: Add proper const qualifiers */\nvoid config_print(const ConfigEntry *entry);\n\n/* Print all configs (db should be const - we're just reading it) */\n/* TODO: Add proper const qualifiers */\nvoid config_print_all(const ConfigDatabase *db);\n\n/* Validate config name (name should be const - we're just checking it) */\n/* TODO: Add proper const qualifiers */\nbool config_validate_name(const char *name);\n\n/* Helper: Check if a string is valid (str should be const) */\n/* TODO: Add proper const qualifiers */\nbool is_valid_string(const char *str);\n\n/* ========================================================================== */\n/* CONST PROPAGATION EXAMPLE */\n/* ========================================================================== */\n/* When a function calls another function, const must propagate:\n *\n * bool config_validate_name(const char *name) {\n *     return is_valid_string(name);  // OK: const char* → const char*\n * }\n *\n * If is_valid_string() didn't take const char*, you'd get a compiler warning!\n * This is GOOD - it prevents accidentally passing const data to functions that might modify it.\n */\n\n#endif /* CONFIG_SYSTEM_H */\n",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "config_system.c",
        "content": "#include \"config_system.h\"\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/string.h>\n\n/* Module parameters for dynamic testing */\nstatic char *test_config_name = \"TestConfig\";\nstatic char *test_config_value = \"TestValue\";\nstatic int test_priority = 5;\n\nmodule_param(test_config_name, charp, 0644);\nMODULE_PARM_DESC(test_config_name, \"Configuration name for testing\");\nmodule_param(test_config_value, charp, 0644);\nMODULE_PARM_DESC(test_config_value, \"Configuration value for testing\");\nmodule_param(test_priority, int, 0644);\nMODULE_PARM_DESC(test_priority, \"Priority for test configuration\");\n\n/* ========================================================================== */\n/* TODO: IMPLEMENT CONST-CORRECT HELPER FUNCTIONS */\n/* ========================================================================== */\n\n/* TODO: Implement is_valid_string with const correctness */\n/* ALGORITHM:\n * 1. Check if str is NULL → return false\n * 2. Check if first character is '\\0' (empty string) → return false\n * 3. Loop through string (read-only, we're not modifying it!)\n * 4. Check for valid characters (alphanumeric, underscore, hyphen)\n * 5. Return true if all valid\n *\n * CONST PATTERN:\n * bool is_valid_string(const char *str) {\n *     const char *p = str;  // We can assign const char* to const char*\n *     while (*p) {          // Read-only access to characters\n *         // Check validity...\n *         p++;              // Move pointer (OK: we're changing p, not *p)\n *     }\n *     return true;\n * }\n */\nbool is_valid_string(const char *str) {\n    /* TODO: Implement string validation with const correctness */\n    return false;\n}\n\n/* TODO: Implement config_validate_name with const correctness */\n/* ALGORITHM:\n * 1. Check if name is NULL → return false\n * 2. Check name length (should be < MAX_CONFIG_NAME)\n * 3. Call is_valid_string(name) - const propagates!\n * 4. Return result\n *\n * CONST PROPAGATION:\n * const char *name → passed to → const char *str\n * This is SAFE - we're promising not to modify at every level\n */\nbool config_validate_name(const char *name) {\n    /* TODO: Implement name validation */\n    return false;\n}\n\n/* ========================================================================== */\n/* TODO: IMPLEMENT CONFIGURATION DATABASE FUNCTIONS */\n/* ========================================================================== */\n\n/* Initialize database */\nvoid config_db_init(ConfigDatabase *db) {\n    /* TODO: Initialize database */\n}\n\n/* TODO: Implement config_add with const correctness */\n/* ALGORITHM:\n * 1. Validate parameters (db not NULL, name and value valid)\n * 2. Check if database is full (count >= MAX_CONFIGS)\n * 3. Validate name using config_validate_name(name) - const parameter!\n * 4. Copy name and value to entry (strscpy for safety)\n * 5. Set priority and readonly flag\n * 6. Increment count\n * 7. Return 0 on success, -1 on error\n *\n * CONST CORRECTNESS:\n * - name and value are const char* (we're reading from them)\n * - db is ConfigDatabase* (we're modifying it - not const!)\n * - strscpy(dest, const char *src, ...) expects const src\n */\nint config_add(ConfigDatabase *db, const char *name, const char *value, \n               uint32_t priority, bool readonly) {\n    /* TODO: Implement config addition with const-correct parameters */\n    return -1;\n}\n\n/* TODO: Implement config_get with const correctness */\n/* ALGORITHM:\n * 1. Validate db and name (both const - we're not modifying them)\n * 2. Loop through entries (read-only)\n * 3. Compare names (strcmp - both parameters are const char*)\n * 4. Return const char* to value (caller shouldn't modify it!)\n * 5. Return NULL if not found\n *\n * CONST CORRECTNESS:\n * - db is const ConfigDatabase* (we promise not to modify database)\n * - name is const char* (we promise not to modify search key)\n * - Return const char* (caller promises not to modify returned value)\n *\n * WHY RETURN const char*?\n * - The value is stored in the database\n * - We don't want callers modifying it directly\n * - Forces explicit copy if modification is needed\n */\nconst char* config_get(const ConfigDatabase *db, const char *name) {\n    /* TODO: Implement config retrieval with const correctness */\n    return NULL;\n}\n\n/* TODO: Implement config_print with const correctness */\n/* ALGORITHM:\n * 1. Check if entry is NULL\n * 2. Print all entry fields using printk\n * 3. Format: \"Config: [name] = [value] (priority: X, readonly: Y)\"\n *\n * CONST CORRECTNESS:\n * - entry is const ConfigEntry* (we're just reading it to print)\n * - All field accesses are read-only\n */\nvoid config_print(const ConfigEntry *entry) {\n    /* TODO: Implement config printing */\n}\n\n/* TODO: Implement config_print_all with const correctness */\n/* ALGORITHM:\n * 1. Check if db is NULL\n * 2. Print header with count\n * 3. Loop through all entries\n * 4. Call config_print for each entry (const propagates!)\n *\n * CONST PROPAGATION:\n * const ConfigDatabase *db → const ConfigEntry *entry → config_print(const ConfigEntry*)\n * Every step maintains const correctness\n */\nvoid config_print_all(const ConfigDatabase *db) {\n    /* TODO: Implement print all configs */\n}\n\n/* ========================================================================== */\n/* MODULE INIT: Test const correctness */\n/* ========================================================================== */\nstatic int __init config_system_init(void)\n{\n    ConfigDatabase db;\n    const char *value;\n    \n    printk(KERN_INFO \"Config system module loaded\\n\");\n    printk(KERN_INFO \"Testing with config: %s = %s (priority %d)\\n\",\n           test_config_name, test_config_value, test_priority);\n    \n    /* Test 1: Initialize database */\n    printk(KERN_INFO \"Test 1: Initialize database\\n\");\n    config_db_init(&db);\n    \n    /* Test 2: Add default configs (const strings) */\n    printk(KERN_INFO \"Test 2: Adding default configurations\\n\");\n    config_add(&db, \"kernel_version\", \"6.1.0\", 10, true);\n    config_add(&db, \"debug_level\", \"INFO\", 5, false);\n    config_add(&db, \"max_connections\", \"100\", 7, false);\n    \n    /* Test 3: Add dynamic config from module parameters */\n    printk(KERN_INFO \"Test 3: Adding dynamic configuration\\n\");\n    config_add(&db, test_config_name, test_config_value, test_priority, false);\n    \n    /* Test 4: Print all configs (const database) */\n    printk(KERN_INFO \"Test 4: Printing all configurations\\n\");\n    config_print_all(&db);\n    \n    /* Test 5: Retrieve specific config (const return) */\n    printk(KERN_INFO \"Test 5: Retrieving specific configuration\\n\");\n    value = config_get(&db, \"kernel_version\");\n    if (value) {\n        printk(KERN_INFO \"Retrieved: kernel_version = %s\\n\", value);\n    }\n    \n    /* Test 6: Retrieve dynamic config */\n    printk(KERN_INFO \"Test 6: Retrieving dynamic configuration\\n\");\n    value = config_get(&db, test_config_name);\n    if (value) {\n        printk(KERN_INFO \"Retrieved: %s = %s\\n\", test_config_name, value);\n    }\n    \n    /* Test 7: Test validation */\n    printk(KERN_INFO \"Test 7: Testing validation\\n\");\n    if (config_validate_name(\"valid_name_123\")) {\n        printk(KERN_INFO \"Validation: 'valid_name_123' is valid\\n\");\n    }\n    if (!config_validate_name(\"invalid@name!\")) {\n        printk(KERN_INFO \"Validation: 'invalid@name!' is correctly rejected\\n\");\n    }\n    \n    printk(KERN_INFO \"All tests completed successfully\\n\");\n    return 0;\n}\n\nstatic void __exit config_system_exit(void)\n{\n    printk(KERN_INFO \"Config system module unloaded\\n\");\n}\n\nmodule_init(config_system_init);\nmodule_exit(config_system_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Const correctness demonstration in configuration system\");\nMODULE_VERSION(\"1.0\");\n",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Config system module Makefile\nobj-m += config_system.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help\n",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "config_system.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "config_system_init",
          "config_system_exit",
          "config_db_init",
          "config_add",
          "config_get",
          "config_print",
          "config_print_all",
          "config_validate_name",
          "is_valid_string"
        ],
        "variables_declarations": [
          {
            "name": "ConfigEntry",
            "type": "typedef struct",
            "value": "{char name[MAX_CONFIG_NAME]; char value[MAX_CONFIG_VALUE]; uint32_t priority; bool is_readonly;}",
            "storageClass": "none"
          },
          {
            "name": "ConfigDatabase",
            "type": "typedef struct",
            "value": "{ConfigEntry entries[MAX_CONFIGS]; int count;}",
            "storageClass": "none"
          }
        ],
        "variables": [
          {
            "name": "test_config_name",
            "type": "char*",
            "value": "TestConfig",
            "storageClass": "static"
          },
          {
            "name": "test_config_value",
            "type": "char*",
            "value": "TestValue",
            "storageClass": "static"
          },
          {
            "name": "test_priority",
            "type": "int",
            "value": 5,
            "storageClass": "static"
          }
        ],
        "function_definitions": [
          {
            "name": "is_valid_string",
            "returnType": "bool",
            "parameters": [
              "const char *str"
            ],
            "description": "Validate string contains only allowed characters"
          },
          {
            "name": "config_validate_name",
            "returnType": "bool",
            "parameters": [
              "const char *name"
            ],
            "description": "Validate configuration name"
          },
          {
            "name": "config_db_init",
            "returnType": "void",
            "parameters": [
              "ConfigDatabase *db"
            ],
            "description": "Initialize configuration database"
          },
          {
            "name": "config_add",
            "returnType": "int",
            "parameters": [
              "ConfigDatabase *db",
              "const char *name",
              "const char *value",
              "uint32_t priority",
              "bool readonly"
            ],
            "description": "Add configuration entry with const-correct parameters"
          },
          {
            "name": "config_get",
            "returnType": "const char*",
            "parameters": [
              "const ConfigDatabase *db",
              "const char *name"
            ],
            "description": "Get configuration value with const correctness"
          },
          {
            "name": "config_print",
            "returnType": "void",
            "parameters": [
              "const ConfigEntry *entry"
            ],
            "description": "Print configuration entry"
          },
          {
            "name": "config_print_all",
            "returnType": "void",
            "parameters": [
              "const ConfigDatabase *db"
            ],
            "description": "Print all configurations"
          }
        ],
        "outputMessages": [
          "Config system module loaded",
          "Config database initialized",
          "Added config: kernel_version = 6.1.0",
          "Added config: debug_level = INFO",
          "Added config: max_connections = 100",
          "Retrieved: kernel_version = 6.1.0",
          "Validation: 'valid_name_123' is valid",
          "Validation: 'invalid@name!' is correctly rejected",
          "All tests completed successfully",
          "Config system module unloaded"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/string.h",
          "linux/types.h"
        ],
        "mustContain": [
          "const char *name",
          "const char *value",
          "const ConfigDatabase *db",
          "const ConfigEntry *entry",
          "const char* config_get",
          "bool config_validate_name(const char *name)",
          "bool is_valid_string(const char *str)",
          "strscpy(",
          "strcmp("
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void config_db_init(ConfigDatabase *db)",
            "int config_add(ConfigDatabase *db, const char *name, const char *value, uint32_t priority, bool readonly)",
            "const char* config_get(const ConfigDatabase *db, const char *name)",
            "void config_print(const ConfigEntry *entry)",
            "void config_print_all(const ConfigDatabase *db)",
            "bool config_validate_name(const char *name)",
            "bool is_valid_string(const char *str)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "const_function_signatures",
          "name": "Const Correctness in Function Signatures",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "const char *name",
            "const char *value",
            "const ConfigDatabase *db",
            "const ConfigEntry *entry",
            "const char* config_get",
            "bool config_validate_name(const char *name)",
            "bool is_valid_string(const char *str)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Implementations in Source",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "bool is_valid_string(const char *str)",
            "bool config_validate_name(const char *name)",
            "void config_db_init(ConfigDatabase *db)",
            "int config_add(ConfigDatabase *db, const char *name, const char *value, uint32_t priority, bool readonly)",
            "const char* config_get(const ConfigDatabase *db, const char *name)",
            "void config_print(const ConfigEntry *entry)",
            "void config_print_all(const ConfigDatabase *db)",
            "static int __init config_system_init(void)",
            "static void __exit config_system_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Config system module loaded",
              "exact": true,
              "linkedFunction": "static int __init config_system_init(void)"
            },
            {
              "pattern": "Config database initialized",
              "exact": true,
              "linkedFunction": "void config_db_init(ConfigDatabase *db)"
            },
            {
              "pattern": "Added config: kernel_version = 6.1.0",
              "exact": true,
              "linkedFunction": "int config_add(ConfigDatabase *db, const char *name, const char *value, uint32_t priority, bool readonly)"
            },
            {
              "pattern": "Retrieved: kernel_version = 6.1.0",
              "exact": true,
              "linkedFunction": "const char* config_get(const ConfigDatabase *db, const char *name)"
            },
            {
              "pattern": "Validation: 'valid_name_123' is valid",
              "exact": true,
              "linkedFunction": "bool config_validate_name(const char *name)"
            },
            {
              "pattern": "All tests completed successfully",
              "exact": true,
              "linkedFunction": "static int __init config_system_init(void)"
            },
            {
              "pattern": "Config system module unloaded",
              "exact": true,
              "linkedFunction": "static void __exit config_system_exit(void)"
            }
          ]
        },
        {
          "id": "comprehensive_const_validation",
          "name": "Comprehensive Const Correctness Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "setupCommands": [
              "echo 'Starting comprehensive const correctness validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef int bool;' > /tmp/linux/types.h",
              "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
              "echo '#define true 1' >> /tmp/linux/types.h",
              "echo '#define false 0' >> /tmp/linux/types.h",
              "echo '#define MAX_CONFIG_NAME 32' >> /tmp/linux/types.h",
              "echo '#define MAX_CONFIG_VALUE 64' >> /tmp/linux/types.h",
              "echo '#define MAX_CONFIGS 10' >> /tmp/linux/types.h",
              "echo 'char *strscpy(char *dest, const char *src, unsigned long count);' > /tmp/linux/string.h",
              "echo 'int strcmp(const char *s1, const char *s2);' >> /tmp/linux/string.h",
              "echo 'Creating test file that includes student header...'",
              "echo '#include \"/lib/modules/config_system.h\"' > /tmp/test.c",
              "echo 'int main() { ConfigDatabase db; config_db_init(&db); config_add(&db, \"test\", \"val\", 1, 0); config_get(&db, \"test\"); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation with comprehensive error detection...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function declarations found in header file'; fi",
              "",
              "echo 'Phase 2: Compile-Time Const Checking'",
              "echo 'Verifying const qualifiers are present in function signatures...'",
              "grep -E 'const char \\*name' /lib/modules/config_system.h && echo 'PASS: const char *name found' || echo 'FAIL: Missing const in name parameter'",
              "grep -E 'const char \\*value' /lib/modules/config_system.h && echo 'PASS: const char *value found' || echo 'FAIL: Missing const in value parameter'",
              "grep -E 'const ConfigDatabase \\*db' /lib/modules/config_system.h && echo 'PASS: const ConfigDatabase *db found' || echo 'FAIL: Missing const in db parameter'",
              "grep -E 'const ConfigEntry \\*entry' /lib/modules/config_system.h && echo 'PASS: const ConfigEntry *entry found' || echo 'FAIL: Missing const in entry parameter'",
              "grep -E 'const char\\* config_get' /lib/modules/config_system.h && echo 'PASS: const char* return type found' || echo 'FAIL: Missing const return type'",
              "echo 'Phase 2: Loading and Basic Testing'",
              "rmmod config_system 2>/dev/null || true",
              "insmod /lib/modules/config_system.ko",
              "sleep 1",
              "dmesg | tail -30",
              "echo 'Phase 3: Runtime Validation'",
              "dmesg | grep 'Config database initialized' && echo 'PASS: Database initialized' || echo 'FAIL: Init failed'",
              "dmesg | grep 'Added config: kernel_version = 6.1.0' && echo 'PASS: Config add working' || echo 'FAIL: Add failed'",
              "dmesg | grep 'Retrieved: kernel_version = 6.1.0' && echo 'PASS: Config get working' || echo 'FAIL: Get failed'",
              "dmesg | grep \"Validation: 'valid_name_123' is valid\" && echo 'PASS: Validation working' || echo 'FAIL: Validation failed'",
              "dmesg | grep 'All tests completed successfully' && echo 'PASS: All tests passed' || echo 'FAIL: Tests incomplete'",
              "echo 'Phase 4: Dynamic Parameter Testing'",
              "rmmod config_system",
              "insmod /lib/modules/config_system.ko test_config_name=DynamicTest test_config_value=DynamicValue test_priority=8",
              "sleep 1",
              "dmesg | tail -20 | grep 'DynamicTest' && echo 'PASS: Dynamic parameters working' || echo 'FAIL: Dynamic params failed'",
              "dmesg | tail -20 | grep 'Retrieved: DynamicTest = DynamicValue' && echo 'PASS: Dynamic config retrieved' || echo 'FAIL: Dynamic retrieval failed'",
              "rmmod config_system",
              "echo 'PASS: All const correctness validation completed successfully'"
            ],
            "expected": {
              "dmesg": [
                "Config system module loaded",
                "Config database initialized",
                "Added config: kernel_version = 6.1.0",
                "Added config: debug_level = INFO",
                "Added config: max_connections = 100",
                "Retrieved: kernel_version = 6.1.0",
                "Validation: 'valid_name_123' is valid",
                "Validation: 'invalid@name!' is correctly rejected",
                "All tests completed successfully",
                "Config system module unloaded"
              ],
              "stdout": [
                "PASS: const char \\*name found",
                "PASS: const char \\*value found",
                "PASS: const ConfigDatabase \\*db found",
                "PASS: const ConfigEntry \\*entry found",
                "PASS: const char\\* return type found",
                "PASS: Database initialized",
                "PASS: Config add working",
                "PASS: Config get working",
                "PASS: Validation working",
                "PASS: All tests passed",
                "PASS: Dynamic parameters working",
                "PASS: Dynamic config retrieved",
                "PASS: All const correctness validation completed successfully"
              ]
            },
            "timeout": 15
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Config system module loaded",
        "Config database initialized",
        "Added config: kernel_version = 6.1.0",
        "Added config: debug_level = INFO",
        "Added config: max_connections = 100",
        "Retrieved: kernel_version = 6.1.0",
        "Validation: 'valid_name_123' is valid",
        "Validation: 'invalid@name!' is correctly rejected",
        "All tests completed successfully",
        "Config system module unloaded"
      ],
      "requirements": [
        "Use required function names: config_system_init, config_system_exit, config_db_init, config_add, config_get, config_print, config_print_all, config_validate_name, is_valid_string",
        "Use required variable names: test_config_name, test_config_value, test_priority",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/string.h, linux/types.h",
        "Code must contain: const char *name, const char *value, const ConfigDatabase *db, const ConfigEntry *entry, const char* config_get, bool config_validate_name(const char *name), bool is_valid_string(const char *str), strscpy(, strcmp(",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Config system module loaded",
          "linkedFunction": "static int __init config_system_init(void)",
          "exact": true
        },
        {
          "pattern": "Config database initialized",
          "linkedFunction": "void config_db_init(ConfigDatabase *db)",
          "exact": true
        },
        {
          "pattern": "Added config: kernel_version = 6.1.0",
          "linkedFunction": "int config_add(ConfigDatabase *db, const char *name, const char *value, uint32_t priority, bool readonly)",
          "exact": true
        },
        {
          "pattern": "Retrieved: kernel_version = 6.1.0",
          "linkedFunction": "const char* config_get(const ConfigDatabase *db, const char *name)",
          "exact": true
        },
        {
          "pattern": "Validation: 'valid_name_123' is valid",
          "linkedFunction": "bool config_validate_name(const char *name)",
          "exact": true
        },
        {
          "pattern": "All tests completed successfully",
          "linkedFunction": "static int __init config_system_init(void)",
          "exact": true
        },
        {
          "pattern": "Config system module unloaded",
          "linkedFunction": "static void __exit config_system_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 79,
    "title": "Secure String Handling - Modern Kernel Text Operations",
    "difficulty": 4,
    "xp": 40,
    "phase": "kernel_core",
    "description": "Learn modern, secure string handling in kernel space using current best practices. Master strscpy(), snprintf(), and safe string operations essential for handling device names, user messages, and configuration data in kernel modules.",
    "concepts": [
      "secure string copying with strscpy()",
      "safe string formatting with snprintf()",
      "string validation and error handling",
      "module parameter strings",
      "kernel logging best practices",
      "buffer overflow prevention"
    ],
    "skills": [
      "Using modern kernel string functions",
      "Implementing secure string operations",
      "Error handling in string operations",
      "Input validation and sanitization",
      "Safe buffer management in kernel space",
      "Professional kernel logging patterns"
    ],
    "files": [
      {
        "name": "strings.h",
        "content": "#ifndef STRINGS_H\n#define STRINGS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n\n#define MAX_DEVICE_NAME 32\n#define MAX_STATUS_MSG 64\n#define MAX_BUFFER_SIZE 128\n\nextern char device_name[MAX_DEVICE_NAME];\nextern char status_message[MAX_STATUS_MSG];\nextern int name_length;\n\n/* TODO: Declare your functions */\n/* void display_device_info(void); */\n/* ssize_t update_device_name(const char *new_name); */\n/* int format_status_message(const char *status); */\n/* int validate_string_input(const char *input); */\n\n#endif /* STRINGS_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "strings.c",
        "content": "#include \"strings.h\"\n\n/* TODO: Initialize device name and status message */\n/* char device_name[MAX_DEVICE_NAME] = \"sensor_001\"; */\n/* char status_message[MAX_STATUS_MSG] = \"initializing\"; */\nint name_length = 0;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your string operations work\n * with different input values. Removing them will cause test failures.\n */\nmodule_param_string(device_name, device_name, MAX_DEVICE_NAME, 0644);\nMODULE_PARM_DESC(device_name, \"Device name for testing string operations\");\nmodule_param_string(status_message, status_message, MAX_STATUS_MSG, 0644);\nMODULE_PARM_DESC(status_message, \"Status message for string formatting tests\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* TODO: Implement function to display device information */\n/* Use printk with KERN_INFO to display device name, length, and status */\n/* Format: \"Device: [name] (Length: [X])\" and \"Status: [status]\" */\n\n/* TODO: Implement function to safely update device name using strscpy() */\n/* Use strscpy() instead of manual copying for security */\n/* Return the number of characters copied, or negative on error */\n/* Update name_length after successful copy */\n\n/* TODO: Implement function to format status message using snprintf() */\n/* Use snprintf() to safely format: \"Device [name] is [status]\" */\n/* Return 0 on success, negative on error */\n/* Check for truncation and log warning if needed */\n\n/* TODO: Implement function to validate string input */\n/* Check if input is not NULL and length is reasonable */\n/* Use strlen() to get length, return length or -EINVAL on error */\n/* Reject empty strings and strings that are too long */\n\nstatic int __init strings_init(void)\n{\n    printk(KERN_INFO \"Secure string handling module loaded\\n\");\n    \n    /* TODO: Validate and calculate initial name length */\n    /* name_length = validate_string_input(device_name); */\n    /* if (name_length < 0) { */\n    /*     printk(KERN_ERR \"Invalid device name\\n\"); */\n    /*     return name_length; */\n    /* } */\n    \n    /* TODO: Display initial device information */\n    /* display_device_info(); */\n    \n    /* TODO: Update device name and display results */\n    /* ssize_t result = update_device_name(\"updated_sensor\"); */\n    /* if (result < 0) { */\n    /*     printk(KERN_WARNING \"Device name update failed: %zd\\n\", result); */\n    /* } else { */\n    /*     printk(KERN_INFO \"Device name updated successfully\\n\"); */\n    /*     display_device_info(); */\n    /* } */\n    \n    /* TODO: Format and display status message */\n    /* int fmt_result = format_status_message(\"active\"); */\n    /* if (fmt_result < 0) { */\n    /*     printk(KERN_WARNING \"Status formatting failed: %d\\n\", fmt_result); */\n    /* } */\n    \n    return 0;\n}\n\nstatic void __exit strings_exit(void)\n{\n    printk(KERN_INFO \"Secure string handling module unloaded\\n\");\n}\n\nmodule_init(strings_init);\nmodule_exit(strings_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning secure string handling in kernel space\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# String handling module Makefile\nobj-m += strings.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "strings.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "strings_init",
          "strings_exit",
          "display_device_info",
          "update_device_name",
          "format_status_message",
          "validate_string_input"
        ],
        "variables": [
          {
            "name": "device_name",
            "type": "char[]",
            "value": "\"sensor_001\""
          },
          {
            "name": "status_message",
            "type": "char[]",
            "value": "\"initializing\""
          },
          {
            "name": "name_length",
            "type": "int",
            "value": 0
          }
        ],
        "outputMessages": [
          "Secure string handling module loaded",
          "Device: sensor_001 (Length: 10)",
          "Status: initializing",
          "Device name updated successfully",
          "Device: updated_sensor (Length: 14)",
          "Status: Device updated_sensor is active"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/types.h",
          "linux/string.h"
        ],
        "mustContain": [
          "#define MAX_DEVICE_NAME 32",
          "#define MAX_STATUS_MSG 64",
          "extern char device_name[MAX_DEVICE_NAME]",
          "extern char status_message[MAX_STATUS_MSG]",
          "module_param_string(device_name, device_name, MAX_DEVICE_NAME, 0644)",
          "module_param_string(status_message, status_message, MAX_STATUS_MSG, 0644)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_declarations",
          "name": "Function Declarations in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void display_device_info(void)",
            "ssize_t update_device_name(const char *new_name)",
            "int format_status_message(const char *status)",
            "int validate_string_input(const char *input)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "void display_device_info(void)",
            "ssize_t update_device_name(const char *new_name)",
            "int format_status_message(const char *status)",
            "int validate_string_input(const char *input)",
            "static int __init strings_init(void)",
            "static void __exit strings_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "advanced_string_implementation_validation",
          "name": "Advanced String Implementation with TCC Header Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "string_impl_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\"=== Dynamic String Implementation Test ===\\\\n\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random device names and statuses\\n    const char* device_prefixes[] = {\"sensor\", \"actuator\", \"controller\", \"monitor\"};\\n    const char* statuses[] = {\"active\", \"idle\", \"error\", \"maintenance\", \"ready\"};\\n    \\n    int device_idx = rand() % 4;\\n    int device_num = (rand() % 100) + 1;\\n    int status_idx = rand() % 5;\\n    \\n    char device_name[32];\\n    snprintf(device_name, sizeof(device_name), \"%s_%03d\", device_prefixes[device_idx], device_num);\\n    \\n    printf(\"Test 1: Device name '%s' with status '%s'\\\\n\", device_name, statuses[status_idx]);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \"insmod /lib/modules/strings.ko device_name=%s status_message=%s\", device_name, statuses[status_idx]);\\n    system(\"rmmod strings 2>/dev/null\");\\n    system(cmd1);\\n    \\n    // Second test with different values\\n    device_idx = rand() % 4;\\n    device_num = (rand() % 100) + 1;\\n    status_idx = rand() % 5;\\n    snprintf(device_name, sizeof(device_name), \"%s_%03d\", device_prefixes[device_idx], device_num);\\n    \\n    printf(\"Test 2: Device name '%s' with status '%s'\\\\n\", device_name, statuses[status_idx]);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \"insmod /lib/modules/strings.ko device_name=%s status_message=%s\", device_name, statuses[status_idx]);\\n    system(\"rmmod strings\");\\n    system(cmd2);\\n    \\n    printf(\"SUCCESS: Dynamic string test completed\\\\n\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting advanced string implementation validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
              "echo 'Creating minimal kernel header stubs for TCC...'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo '#define KERN_WARNING' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define module_param_string(name, string, len, perm)' >> /tmp/linux/module.h",
              "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef long ssize_t;' > /tmp/linux/types.h",
              "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
              "echo 'ssize_t strscpy(char *dest, const char *src, size_t count);' > /tmp/linux/string.h",
              "echo 'int snprintf(char *buf, size_t size, const char *fmt, ...);' >> /tmp/linux/string.h",
              "echo 'size_t strlen(const char *s);' >> /tmp/linux/string.h",
              "echo '#define EINVAL 22' > /tmp/linux/errno.h",
              "echo '#define E2BIG 7' >> /tmp/linux/errno.h",
              "echo 'Creating test file that includes student header...'",
              "echo '#include \"/lib/modules/strings.h\"' > /tmp/test.c",
              "echo 'int main() { display_device_info(); update_device_name(\"test\"); format_status_message(\"active\"); validate_string_input(\"input\"); return 0; }' >> /tmp/test.c",
              "echo 'Running TCC validation...'",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
              "echo 'PASS: All function declarations found in header file'",
              "echo 'Phase 2: Dynamic String Implementation Testing'",
              "/bin/string_impl_tester > /tmp/test_output.log",
              "cat /tmp/test_output.log",
              "echo 'Phase 3: Dynamic Value Extraction and Validation'",
              "echo 'Adding delay to ensure dmesg messages are written...'",
              "sleep 1",
              "echo 'Extracting random test values from output...'",
              "TEST1_LINE=$(grep 'Test 1: Device name' /tmp/test_output.log)",
              "TEST2_LINE=$(grep 'Test 2: Device name' /tmp/test_output.log)",
              "echo 'Test 1 values: '$TEST1_LINE",
              "echo 'Test 2 values: '$TEST2_LINE",
              "echo 'Validating string operation output'",
              "dmesg | grep 'Secure string handling module loaded' && echo 'PASS: Module loaded correctly' || echo 'FAIL: Module loading issue'",
              "dmesg | grep 'Device:.*Length:' && echo 'PASS: Device info display working' || echo 'FAIL: Device info display broken'",
              "dmesg | grep 'Status:' && echo 'PASS: Status message working' || echo 'FAIL: Status message broken'",
              "dmesg | grep 'Device name updated successfully' && echo 'PASS: String update working' || echo 'FAIL: String update broken'",
              "echo 'All dynamic string validations completed'"
            ],
            "expected": {
              "dmesg": [
                "Secure string handling module loaded",
                "Device: .* \\(Length: .*\\)",
                "Status: .*",
                "Device name updated successfully"
              ],
              "stdout": [
                "PASS: All function declarations found in header file",
                "SUCCESS: Dynamic string test completed",
                "PASS: Module loaded correctly",
                "PASS: Device info display working",
                "PASS: Status message working",
                "PASS: String update working"
              ]
            },
            "timeout": 35
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Secure string handling module loaded",
        "Device: sensor_001 (Length: 10)",
        "Status: initializing",
        "Device name updated successfully",
        "Device: updated_sensor (Length: 14)",
        "Status: Device updated_sensor is active"
      ],
      "requirements": [
        "Use required function names: strings_init, strings_exit, display_device_info, update_device_name, format_status_message, validate_string_input",
        "Use required variable names: device_name, status_message, name_length",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/types.h, linux/string.h",
        "Code must contain: #define MAX_DEVICE_NAME 32, #define MAX_STATUS_MSG 64, extern char device_name[MAX_DEVICE_NAME], extern char status_message[MAX_STATUS_MSG], module_param_string(device_name, device_name, MAX_DEVICE_NAME, 0644), module_param_string(status_message, status_message, MAX_STATUS_MSG, 0644)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ]
    }
  },
  {
    "id": 100,
    "title": "/proc File - Read Only Counter",
    "difficulty": 4,
    "xp": 25,
    "phase": "kernel_core",
    "description": "Learn kernel-userspace communication by creating your first /proc file. The /proc filesystem is how the kernel exposes information to userspace - every time you run 'cat /proc/cpuinfo', you're reading from a kernel module! Create /proc/counter that returns an incrementing number each time it's read. This teaches file_operations, copy_to_user, and the foundation for all device drivers.",
    "concepts": [
      "/proc filesystem - kernel's window to userspace",
      "proc_create() and proc_remove() for file lifecycle",
      "proc_ops structure - simpler than file_operations",
      "copy_to_user() - THE critical kernel-userspace boundary",
      "__user annotation - marking userspace pointers",
      "Why kernel and userspace have separate memory spaces",
      "Read callback implementation and EOF handling",
      "Virtual filesystem - files that don't exist on disk",
      "On-demand data generation in kernel",
      "Foundation for all device drivers"
    ],
    "skills": [
      "Creating /proc files with proc_create()",
      "Implementing read callbacks with proper signature",
      "Using copy_to_user() correctly for safe data transfer",
      "Handling EOF to prevent infinite read loops",
      "Understanding __user pointer annotation",
      "Managing file offset for proper read behavior",
      "Removing /proc files cleanly on module unload",
      "Building simple kernel-userspace interfaces",
      "Understanding memory space separation",
      "Foundation for character device drivers"
    ],
    "files": [
      {
        "name": "proc_counter.c",
        "content": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: /proc Filesystem - Kernel's Window to Userspace */\n/* ========================================================================== */\n/* This problem teaches FUNDAMENTAL kernel-userspace communication!\n *\n * WHAT IS /proc?\n * /proc is a \"pseudo-filesystem\" - virtual files that don't exist on disk.\n * When you read /proc/cpuinfo, there's no physical file - the kernel generates\n * the content on-the-fly when you read it!\n *\n * REAL-WORLD EXAMPLES:\n * - cat /proc/cpuinfo     → Kernel returns CPU information\n * - cat /proc/meminfo     → Kernel returns memory statistics\n * - cat /proc/modules     → Kernel returns loaded module list\n * - cat /proc/version     → Kernel returns kernel version\n *\n * WHY /proc EXISTS:\n * Before /proc, kernel had no standard way to expose information to userspace.\n * /proc provides a simple file-based interface - userspace just reads files!\n * No special tools needed - simple 'cat' command works!\n *\n * HOW /proc WORKS:\n * 1. Kernel module creates virtual file: proc_create()\n * 2. Module registers read callback: .proc_read = counter_read\n * 3. Userspace opens file: open(\"/proc/counter\", O_RDONLY)\n * 4. Userspace reads: read(fd, buffer, size)\n * 5. Kernel calls YOUR callback: counter_read()\n * 6. Your callback copies data to userspace: copy_to_user()\n * 7. Userspace receives the data!\n */\n\n/* ========================================================================== */\n/* PART 1: WHAT IS copy_to_user AND WHY IT EXISTS */\n/* ========================================================================== */\n/* THE FUNDAMENTAL PROBLEM:\n * Kernel and userspace have SEPARATE memory spaces.\n * Kernel pointer: 0xffff888012345000 (kernel virtual address)\n * User pointer:   0x00007fff00001000 (user virtual address)\n * These are DIFFERENT address spaces - cannot directly access!\n *\n * WHY SEPARATE MEMORY SPACES?\n * 1. Security: User programs can't access kernel memory\n * 2. Stability: User program crash doesn't crash kernel\n * 3. Isolation: Each process has its own memory space\n *\n * THE WRONG WAY (CRASHES):\n * char kernel_buffer[128];\n * sprintf(kernel_buffer, \"Counter: %d\\n\", counter);\n * strcpy(user_buffer, kernel_buffer);  // ❌ CRASH! User pointer invalid in kernel!\n *\n * THE RIGHT WAY:\n * char kernel_buffer[128];\n * sprintf(kernel_buffer, \"Counter: %d\\n\", counter);\n * copy_to_user(user_buffer, kernel_buffer, strlen(kernel_buffer));\n *   ✅ Safely copies from kernel space to user space\n *\n * WHAT copy_to_user DOES:\n * 1. Validates user pointer is valid and writable\n * 2. Handles page faults (if user memory not in RAM)\n * 3. Translates kernel virtual address → user virtual address\n * 4. Performs the actual copy\n * 5. Returns number of bytes that FAILED to copy (0 = success)\n *\n * SIGNATURE:\n * unsigned long copy_to_user(void __user *to, const void *from, unsigned long n);\n *                            ↑              ↑                   ↑\n *                            userspace ptr  kernel ptr          bytes to copy\n *\n * RETURN VALUE:\n * - 0 = success (all bytes copied)\n * - Non-zero = number of bytes that could NOT be copied (error)\n */\n\n/* ========================================================================== */\n/* PART 2: THE __user ANNOTATION */\n/* ========================================================================== */\n/* WHAT IS __user?\n * It's a marker that tells:\n * 1. Sparse static analyzer: \"This pointer points to USER memory\"\n * 2. Developers: \"Don't dereference this directly!\"\n * 3. Kernel: \"Must use copy_to_user/copy_from_user\"\n *\n * EXAMPLES:\n * char __user *buffer;     // Points to userspace memory\n * char *kernel_buf;        // Points to kernel memory\n *\n * CORRECT USAGE:\n * copy_to_user(buffer, kernel_buf, len);  ✅\n *\n * WRONG USAGE:\n * buffer[0] = 'A';        ❌ Direct access = CRASH!\n * *buffer = 'A';          ❌ Dereferencing = CRASH!\n */\n\n/* ========================================================================== */\n/* PART 3: PROC FILE CREATION AND LIFECYCLE */\n/* ========================================================================== */\n/* CREATING /proc FILES:\n *\n * struct proc_dir_entry *proc_create(\n *     const char *name,              // File name: \"counter\"\n *     umode_t mode,                  // Permissions: 0444 (read-only)\n *     struct proc_dir_entry *parent, // Parent dir: NULL = /proc root\n *     const struct proc_ops *proc_ops // Callbacks\n * );\n *\n * EXAMPLE:\n * proc_entry = proc_create(\"counter\", 0444, NULL, &proc_fops);\n * Creates: /proc/counter with read-only permissions (0444)\n *\n * PERMISSIONS:\n * 0444 = read-only for all (owner, group, others)\n * 0644 = read-write for owner, read-only for others\n * 0666 = read-write for all\n *\n * REMOVING /proc FILES:\n * proc_remove(proc_entry);\n * CRITICAL: Must remove in module_exit or you get:\n * - Kernel panic if userspace tries to read after module unload\n * - Memory leak (proc entry not freed)\n */\n\n/* ========================================================================== */\n/* PART 4: proc_ops STRUCTURE */\n/* ========================================================================== */\n/* MODERN KERNEL (5.6+): Use proc_ops\n * struct proc_ops {\n *     ssize_t (*proc_read)(struct file *, char __user *, size_t, loff_t *);\n *     ssize_t (*proc_write)(struct file *, const char __user *, size_t, loff_t *);\n *     // ... many other optional callbacks\n * };\n *\n * FOR READ-ONLY FILE:\n * static const struct proc_ops proc_fops = {\n *     .proc_read = counter_read,  // Our read callback\n * };\n *\n * OLDER KERNELS (before 5.6): Use file_operations\n * But we use proc_ops for modern kernels!\n */\n\n/* ========================================================================== */\n/* PART 5: READ CALLBACK IMPLEMENTATION */\n/* ========================================================================== */\n/* READ CALLBACK SIGNATURE:\n * static ssize_t counter_read(\n *     struct file *file,         // File being read\n *     char __user *buffer,       // User buffer to fill\n *     size_t len,                // Max bytes user wants\n *     loff_t *offset             // Current position in file\n * )\n *\n * PARAMETERS EXPLAINED:\n * - file: File handle (we don't need it for simple cases)\n * - buffer: WHERE to copy data (userspace pointer)\n * - len: HOW MUCH data user wants (buffer size)\n * - offset: File position (0 = start, increments after reads)\n *\n * RETURN VALUE:\n * - Positive number: Bytes successfully copied to user\n * - 0: EOF (no more data)\n * - Negative: Error code (-EFAULT, -EINVAL, etc.)\n *\n * EOF HANDLING (CRITICAL!):\n * Without EOF check, 'cat /proc/counter' LOOPS FOREVER!\n *\n * ALGORITHM:\n * 1. Check if offset > 0 → return 0 (EOF)\n * 2. Prepare data in kernel buffer\n * 3. Copy to user with copy_to_user()\n * 4. Update offset\n * 5. Return bytes copied\n *\n * WHY CHECK OFFSET?\n * First read:  offset=0  → return data, set offset=len\n * Second read: offset=len → return 0 (EOF)\n * This tells 'cat' command there's no more data!\n */\n\n#define PROC_NAME \"counter\"\n#define BUFFER_SIZE 128\n\n/* Global counter - increments on each read */\nstatic int counter = 0;\n\n/* Proc file entry pointer */\nstatic struct proc_dir_entry *proc_entry = NULL;\n\n/* ========================================================================== */\n/* TODO: Implement counter_read callback */\n/* ========================================================================== */\n/* STEP-BY-STEP IMPLEMENTATION GUIDE:\n *\n * STEP 1: DECLARE LOCAL VARIABLES\n * char msg[BUFFER_SIZE];           // Kernel buffer for message\n * int msg_len;                     // Length of message\n *\n * STEP 2: CHECK EOF (CRITICAL!)\n * if (*offset > 0) {\n *     return 0;  // Already read, return EOF\n * }\n *\n * WHY? Without this, cat /proc/counter loops forever!\n * First call: offset=0, return data\n * Second call: offset>0, return 0 (EOF)\n *\n * STEP 3: FORMAT MESSAGE IN KERNEL BUFFER\n * msg_len = sprintf(msg, \"Counter: %d\\n\", counter);\n * This creates: \"Counter: 0\\n\" in kernel memory\n *\n * STEP 4: CHECK IF USER BUFFER IS BIG ENOUGH\n * if (len < msg_len) {\n *     return -EINVAL;  // User buffer too small\n * }\n *\n * STEP 5: COPY TO USERSPACE (THE CRITICAL OPERATION!)\n * if (copy_to_user(buffer, msg, msg_len)) {\n *     return -EFAULT;  // Failed to copy (bad user pointer)\n * }\n *\n * copy_to_user returns:\n * - 0 on success (all bytes copied)\n * - Non-zero on failure (number of bytes NOT copied)\n *\n * STEP 6: INCREMENT COUNTER\n * counter++;\n *\n * STEP 7: UPDATE OFFSET (MARK DATA AS READ)\n * *offset = msg_len;\n *\n * This prevents infinite loop:\n * Next call will have *offset > 0, triggering EOF\n *\n * STEP 8: RETURN BYTES READ\n * return msg_len;\n *\n * COMPLETE EXAMPLE:\n * User runs: cat /proc/counter\n * 1st read: offset=0  → return \"Counter: 0\\n\" (10 bytes), set offset=10\n * 2nd read: offset=10 → return 0 (EOF)\n * cat exits\n *\n * User runs: cat /proc/counter again\n * 1st read: offset=0  → return \"Counter: 1\\n\" (10 bytes), set offset=10\n * 2nd read: offset=10 → return 0 (EOF)\n */\nstatic ssize_t counter_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)\n{\n    /* TODO: Declare local variables for kernel buffer and message length */\n    \n    /* TODO: Check if already read (EOF check) - return 0 if offset > 0 */\n    \n    /* TODO: Format message: sprintf(msg, \"Counter: %d\\n\", counter); */\n    \n    /* TODO: Check if user buffer is big enough - return -EINVAL if len < msg_len */\n    \n    /* TODO: Copy to userspace using copy_to_user() - return -EFAULT on error */\n    \n    /* TODO: Increment counter */\n    \n    /* TODO: Update offset to msg_len */\n    \n    /* TODO: Log the read operation */\n    printk(KERN_INFO \"Counter read: returned %d\\n\", counter - 1);\n    \n    /* TODO: Return number of bytes copied */\n    return 0;  /* Replace with actual msg_len */\n}\n\n/* ========================================================================== */\n/* proc_ops structure - defines file operations */\n/* ========================================================================== */\n/* This structure connects /proc file operations to our callback functions.\n * When userspace reads /proc/counter, kernel calls counter_read().\n *\n * FIELDS:\n * .proc_read = counter_read   → Called when file is read\n * .proc_write = ...           → Called when file is written (not used here)\n * .proc_open = ...            → Called when file is opened (not needed)\n * .proc_release = ...         → Called when file is closed (not needed)\n *\n * For simple read-only file, we only need proc_read!\n */\nstatic const struct proc_ops proc_fops = {\n    .proc_read = counter_read,\n};\n\n/* ========================================================================== */\n/* Module Initialization */\n/* ========================================================================== */\nstatic int __init proc_counter_init(void)\n{\n    printk(KERN_INFO \"Initializing /proc/counter module\\n\");\n    \n    /* TODO: Create /proc/counter file */\n    /* Use: proc_create(PROC_NAME, 0444, NULL, &proc_fops) */\n    /* Store result in proc_entry */\n    /* Check if proc_entry is NULL (creation failed) */\n    /*   If NULL: printk error and return -ENOMEM */\n    \n    printk(KERN_INFO \"Created /proc/%s\\n\", PROC_NAME);\n    return 0;\n}\n\n/* ========================================================================== */\n/* Module Cleanup */\n/* ========================================================================== */\nstatic void __exit proc_counter_exit(void)\n{\n    /* TODO: Remove /proc/counter file */\n    /* Use: proc_remove(proc_entry) */\n    /* CRITICAL: Must remove or kernel panics if accessed after unload! */\n    \n    printk(KERN_INFO \"Removed /proc/%s\\n\", PROC_NAME);\n    printk(KERN_INFO \"Final counter value: %d\\n\", counter);\n}\n\nmodule_init(proc_counter_init);\nmodule_exit(proc_counter_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Simple /proc counter demonstrating kernel-userspace communication\");\nMODULE_VERSION(\"1.0\");\n",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# /proc counter module Makefile\nobj-m += proc_counter.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help\n",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "proc_counter.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "proc_counter_init",
          "proc_counter_exit",
          "counter_read"
        ],
        "variables": [
          {
            "name": "counter",
            "type": "int",
            "value": "0",
            "storageClass": "static"
          },
          {
            "name": "proc_entry",
            "type": "struct proc_dir_entry *",
            "value": "NULL",
            "storageClass": "static"
          },
          {
            "name": "proc_fops",
            "type": "const struct proc_ops",
            "value": "{.proc_read = counter_read}",
            "storageClass": "static"
          }
        ],
        "outputMessages": [
          "Initializing /proc/counter module",
          "Created /proc/counter",
          "Counter read: returned 0",
          "Counter read: returned 1",
          "Counter read: returned 2",
          "Removed /proc/counter",
          "Final counter value:"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/proc_fs.h",
          "linux/uaccess.h"
        ],
        "macro_definitions": [
          {
            "name": "PROC_NAME",
            "type": "constant",
            "value": "\"counter\"",
            "description": "Name of the /proc file"
          },
          {
            "name": "BUFFER_SIZE",
            "type": "constant",
            "value": "128",
            "description": "Size of kernel buffer for message"
          }
        ],
        "mustContain": [
          "proc_create",
          "proc_remove",
          "copy_to_user",
          "__user",
          "proc_ops",
          ".proc_read = counter_read",
          "if (*offset > 0)",
          "sprintf(msg, \"Counter: %d\\\\n\", counter)",
          "counter++",
          "#define PROC_NAME",
          "#define BUFFER_SIZE"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_signatures",
          "name": "Function Signatures",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "static ssize_t counter_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)",
            "static int __init proc_counter_init(void)",
            "static void __exit proc_counter_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "proc_ops_structure",
          "name": "proc_ops Structure Definition",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "static const struct proc_ops proc_fops",
            ".proc_read = counter_read"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "copy_to_user_usage",
          "name": "copy_to_user Implementation",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "copy_to_user(buffer, msg, msg_len)",
            "__user"
          ],
          "prohibitedSymbols": [
            "strcpy(buffer",
            "memcpy(buffer"
          ]
        },
        {
          "id": "eof_handling",
          "name": "EOF Handling Implementation",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "if (*offset > 0)",
            "return 0"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "proc_lifecycle",
          "name": "Proc File Lifecycle",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "proc_create(PROC_NAME, 0444, NULL, &proc_fops)",
            "proc_remove(proc_entry)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Initializing /proc/counter module",
              "exact": true,
              "linkedFunction": "static int __init proc_counter_init(void)"
            },
            {
              "pattern": "Created /proc/counter",
              "exact": true,
              "linkedFunction": "static int __init proc_counter_init(void)"
            },
            {
              "pattern": "Counter read: returned 0",
              "exact": true,
              "linkedFunction": "static ssize_t counter_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)"
            },
            {
              "pattern": "Counter read: returned 1",
              "exact": true,
              "linkedFunction": "static ssize_t counter_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)"
            },
            {
              "pattern": "Counter read: returned 2",
              "exact": true,
              "linkedFunction": "static ssize_t counter_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)"
            },
            {
              "pattern": "Removed /proc/counter",
              "exact": true,
              "linkedFunction": "static void __exit proc_counter_exit(void)"
            },
            {
              "pattern": "Final counter value:",
              "exact": false,
              "linkedFunction": "static void __exit proc_counter_exit(void)"
            }
          ]
        },
        {
          "id": "comprehensive_proc_validation",
          "name": "Comprehensive /proc File Functionality Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "proc_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <unistd.h>\\n\\nint main() {\\n    printf(\\\"=== /proc Counter Test ===\\\\n\\\");\\n    \\n    printf(\\\"Test 1: Verify /proc/counter exists\\\\n\\\");\\n    if (access(\\\"/proc/counter\\\", F_OK) == 0) {\\n        printf(\\\"PASS: /proc/counter exists\\\\n\\\");\\n    } else {\\n        printf(\\\"FAIL: /proc/counter does not exist\\\\n\\\");\\n        return 1;\\n    }\\n    \\n    printf(\\\"\\\\nTest 2: Read /proc/counter three times\\\\n\\\");\\n    for (int i = 0; i < 3; i++) {\\n        printf(\\\"Read %d: \\\", i + 1);\\n        fflush(stdout);\\n        system(\\\"cat /proc/counter\\\");\\n    }\\n    \\n    printf(\\\"\\\\nSUCCESS: All /proc tests completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting /proc file validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Module Loading and /proc File Creation'",
              "/bin/proc_tester > /tmp/test_output.log 2>&1",
              "cat /tmp/test_output.log",
              "",
              "echo 'Phase 2: Validate /proc/counter exists'",
              "sleep 1",
              "ls -la /proc/counter && echo 'PASS: /proc/counter file exists' || echo 'FAIL: /proc/counter not created'",
              "",
              "echo 'Phase 3: Validate counter increments'",
              "FIRST_READ=$(cat /proc/counter 2>/dev/null | grep -o 'Counter: [0-9]*' | cut -d' ' -f2)",
              "echo 'First read value: '$FIRST_READ",
              "if [ -n \"$FIRST_READ\" ]; then echo 'PASS: Successfully read from /proc/counter'; else echo 'FAIL: Could not read from /proc/counter'; fi",
              "",
              "SECOND_READ=$(cat /proc/counter 2>/dev/null | grep -o 'Counter: [0-9]*' | cut -d' ' -f2)",
              "echo 'Second read value: '$SECOND_READ",
              "if [ \"$SECOND_READ\" -gt \"$FIRST_READ\" ] 2>/dev/null; then echo 'PASS: Counter increments between reads'; else echo 'INFO: Counter behavior check'; fi",
              "",
              "echo 'Phase 4: Validate dmesg output'",
              "dmesg | grep 'Created /proc/counter' && echo 'PASS: Module initialization logged' || echo 'FAIL: Init message missing'",
              "dmesg | grep 'Counter read: returned' && echo 'PASS: Read operations logged' || echo 'FAIL: Read logging missing'",
              "",
              "echo 'Phase 5: Validate counter functionality'",
              "dmesg | grep -E 'Counter read: returned [0-9]+' && echo 'PASS: Counter read operations working' || echo 'FAIL: Counter reads not working'",
              "",
              "echo 'PASS: All comprehensive /proc validation completed successfully'"
            ],
            "expected": {
              "dmesg": [
                "Initializing /proc/counter module",
                "Created /proc/counter",
                "Counter read: returned 0",
                "Counter read: returned 1",
                "Counter read: returned 2",
                "Removed /proc/counter",
                "Final counter value:"
              ],
              "stdout": [
                "SUCCESS: All /proc tests completed",
                "PASS: /proc/counter file exists",
                "PASS: Successfully read from /proc/counter",
                "PASS: Module initialization logged",
                "PASS: Read operations logged",
                "PASS: Counter read operations working",
                "PASS: All comprehensive /proc validation completed successfully"
              ]
            },
            "timeout": 30
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Initializing /proc/counter module",
        "Created /proc/counter",
        "Counter read: returned 0",
        "Counter read: returned 1",
        "Counter read: returned 2",
        "Removed /proc/counter",
        "Final counter value:"
      ],
      "requirements": [
        "Use required function names: proc_counter_init, proc_counter_exit, counter_read",
        "Use required variable names: counter, proc_entry, proc_fops",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/proc_fs.h, linux/uaccess.h",
        "Code must contain: proc_create, proc_remove, copy_to_user, __user, proc_ops, .proc_read = counter_read, if (*offset > 0), sprintf(msg, \"Counter: %d\\\\n\", counter), counter++, #define PROC_NAME, #define BUFFER_SIZE",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Initializing /proc/counter module",
          "linkedFunction": "static int __init proc_counter_init(void)",
          "exact": true
        },
        {
          "pattern": "Created /proc/counter",
          "linkedFunction": "static int __init proc_counter_init(void)",
          "exact": true
        },
        {
          "pattern": "Counter read: returned 0",
          "linkedFunction": "static ssize_t counter_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)",
          "exact": true
        },
        {
          "pattern": "Counter read: returned 1",
          "linkedFunction": "static ssize_t counter_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)",
          "exact": true
        },
        {
          "pattern": "Counter read: returned 2",
          "linkedFunction": "static ssize_t counter_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)",
          "exact": true
        },
        {
          "pattern": "Removed /proc/counter",
          "linkedFunction": "static void __exit proc_counter_exit(void)",
          "exact": true
        },
        {
          "pattern": "Final counter value:",
          "linkedFunction": "static void __exit proc_counter_exit(void)",
          "exact": false
        }
      ]
    }
  },
  {
    "id": 101,
    "title": "/proc File - Read/Write Message Communication",
    "difficulty": 6,
    "xp": 55,
    "phase": "kernel_core",
    "description": "Master bidirectional kernel-userspace communication by implementing both read and write operations for /proc files. Learn copy_from_user() to safely receive data from userspace, completing the /proc interface that allows users to both send messages to and retrieve messages from the kernel. This builds on /proc read-only concepts by adding write capability.",
    "concepts": [
      "bidirectional kernel-userspace communication",
      "copy_from_user() function",
      "proc_write callback",
      "message buffer management",
      "complete /proc file implementation",
      "buffer overflow protection",
      "userspace data validation"
    ],
    "skills": [
      "Implementing .proc_write callback",
      "Using copy_from_user() safely",
      "Managing kernel message buffers",
      "Handling newline characters from echo",
      "Creating read-write /proc files",
      "Understanding bidirectional communication",
      "Proper buffer size validation"
    ],
    "files": [
      {
        "name": "proc_message.c",
        "content": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\n#define PROC_NAME \"message\"\n#define BUFFER_SIZE 256\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: Bidirectional /proc File Implementation */\n/* ========================================================================== */\n/* This teaches COMPLETE /proc file interface with both READ and WRITE!\n *\n * WHAT YOU'VE LEARNED (Problem 100):\n * - Creating /proc files\n * - copy_to_user() - sending data FROM kernel TO userspace\n * - .proc_read callback\n *\n * WHAT THIS PROBLEM TEACHES:\n * - copy_from_user() - receiving data FROM userspace TO kernel\n * - .proc_write callback\n * - Message buffer management in kernel\n * - Bidirectional communication patterns\n *\n * REAL-WORLD USAGE:\n * This is EXACTLY how kernel configuration works:\n * - Read /proc/sys/net/ipv4/ip_forward to check forwarding status\n * - Write to /proc/sys/net/ipv4/ip_forward to enable/disable it\n * - Many kernel tunables use this read/write /proc pattern\n *\n * THE FLOW:\n * 1. User writes: echo \"Hello\" > /proc/message\n * 2. Kernel receives via message_write() using copy_from_user()\n * 3. Kernel stores in message_buffer\n * 4. User reads: cat /proc/message\n * 5. Kernel returns via message_read() using copy_to_user()\n */\n\n/* ========================================================================== */\n/* SECTION 1: MESSAGE STORAGE */\n/* ========================================================================== */\n/* We need to STORE the user's message so we can return it on read\n *\n * STORAGE REQUIREMENTS:\n * - Buffer to hold the message text\n * - Length tracker to know how many bytes are valid\n * - Must persist between read/write operations\n *\n * WHY STATIC?\n * - Static variables persist across function calls\n * - Shared between message_read() and message_write()\n * - File-scope (only visible in this .c file)\n */\n\n/* TODO: Declare message storage buffer */\n/* static char message_buffer[BUFFER_SIZE]; */\n\n/* TODO: Declare message length tracker */\n/* static size_t message_len = 0; */\n\n/* TODO: Declare proc_dir_entry pointer */\n/* static struct proc_dir_entry *proc_entry; */\n\n/* ========================================================================== */\n/* SECTION 2: READ CALLBACK - Return Stored Message */\n/* ========================================================================== */\n/* This is similar to Problem 100, but instead of generating data,\n * we return the stored message from message_buffer.\n *\n * FUNCTION SIGNATURE:\n * static ssize_t message_read(struct file *file, char __user *user_buffer,\n *                             size_t count, loff_t *offset)\n *\n * PARAMETERS:\n * - file: File structure (not used here)\n * - user_buffer: Userspace buffer to write to (has __user annotation)\n * - count: Maximum bytes user wants to read\n * - offset: Current position in file (for sequential reads)\n *\n * RETURN VALUE:\n * - Number of bytes successfully copied to userspace\n * - 0 means \"end of file\" (no more data)\n * - Negative value means error\n *\n * OFFSET HANDLING:\n * - First call: *offset = 0, we copy data and update *offset\n * - Second call: *offset != 0, we return 0 (EOF)\n * - This prevents infinite reading\n */\n\n/* TODO: Implement message_read function */\nstatic ssize_t message_read(struct file *file, char __user *user_buffer,\n                           size_t count, loff_t *offset)\n{\n    /* STEP 1: Check for end-of-file condition */\n    /* TODO: If *offset != 0, return 0 (already read, EOF) */\n    /* TODO: If message_len == 0, return 0 (no message stored) */\n\n    /* STEP 2: Determine how many bytes to copy */\n    /* TODO: bytes_to_copy = min(count, message_len) */\n    /* TODO: We can't copy more than what's stored OR what user requested */\n\n    /* STEP 3: Copy message to userspace */\n    /* TODO: Use copy_to_user(user_buffer, message_buffer, bytes_to_copy) */\n    /* TODO: Check if copy_to_user returns non-zero (indicates failure) */\n    /* TODO: If failed, return -EFAULT */\n\n    /* STEP 4: Update offset and return bytes copied */\n    /* TODO: *offset += bytes_to_copy */\n    /* TODO: return bytes_to_copy */\n\n    return 0; /* TODO: Replace with actual implementation */\n}\n\n/* ========================================================================== */\n/* SECTION 3: WRITE CALLBACK - Store User's Message */\n/* ========================================================================== */\n/* This is the NEW functionality! Receiving data from userspace.\n *\n * FUNCTION SIGNATURE:\n * static ssize_t message_write(struct file *file, const char __user *user_buffer,\n *                              size_t count, loff_t *offset)\n *\n * PARAMETERS:\n * - file: File structure (not used here)\n * - user_buffer: Userspace buffer to read from (has __user annotation)\n * - count: Number of bytes user wants to write\n * - offset: Current position in file (usually ignored for simple write)\n *\n * RETURN VALUE:\n * - Number of bytes successfully copied from userspace\n * - This tells user how many bytes were written\n * - Negative value means error\n *\n * COPY_FROM_USER EXPLAINED:\n * copy_from_user(kernel_dest, __user *user_src, size)\n * - Opposite of copy_to_user()\n * - Safely copies data FROM userspace TO kernel\n * - Returns: number of bytes that FAILED to copy (0 = success!)\n * - Must check return value for security!\n *\n * BUFFER OVERFLOW PROTECTION:\n * - User might try to write more than BUFFER_SIZE\n * - We must limit bytes_to_copy to (BUFFER_SIZE - 1)\n * - Leave room for null terminator\n */\n\n/* TODO: Implement message_write function */\nstatic ssize_t message_write(struct file *file, const char __user *user_buffer,\n                            size_t count, loff_t *offset)\n{\n    /* STEP 1: Validate input size */\n    /* TODO: If count == 0, return 0 (nothing to write) */\n    /* TODO: If count >= BUFFER_SIZE, limit to (BUFFER_SIZE - 1) */\n    /* TODO: size_t bytes_to_copy = min(count, (size_t)(BUFFER_SIZE - 1)) */\n\n    /* STEP 2: Clear the message buffer */\n    /* TODO: memset(message_buffer, 0, BUFFER_SIZE) */\n    /* TODO: This ensures clean state before writing new message */\n\n    /* STEP 3: Copy data from userspace to kernel buffer */\n    /* TODO: if (copy_from_user(message_buffer, user_buffer, bytes_to_copy)) */\n    /* TODO:     return -EFAULT (copy failed) */\n    /* TODO: Note: copy_from_user returns non-zero on failure! */\n\n    /* STEP 4: Handle newline character (if present) */\n    /* TODO: When user does \"echo Hello > /proc/message\", it includes \\n */\n    /* TODO: if (bytes_to_copy > 0 && message_buffer[bytes_to_copy - 1] == '\\n') */\n    /* TODO:     message_buffer[bytes_to_copy - 1] = '\\0' (replace with null) */\n    /* TODO:     bytes_to_copy-- (reduce length) */\n    /* TODO: else */\n    /* TODO:     message_buffer[bytes_to_copy] = '\\0' (add null terminator) */\n\n    /* STEP 5: Update message length */\n    /* TODO: message_len = bytes_to_copy */\n\n    /* STEP 6: Log the received message */\n    /* TODO: printk(KERN_INFO \"Received message: %s (length=%zu)\\n\", message_buffer, message_len) */\n\n    /* STEP 7: Return bytes written */\n    /* TODO: Return count (not bytes_to_copy) - report what user tried to write */\n    /* TODO: This matches standard write() semantics */\n\n    return 0; /* TODO: Replace with actual implementation */\n}\n\n/* ========================================================================== */\n/* SECTION 4: PROC OPS STRUCTURE - Register Both Callbacks */\n/* ========================================================================== */\n/* This is where we connect our read AND write functions!\n *\n * PROC_OPS FIELDS:\n * .proc_read  = message_read   <- Called when user reads from /proc/message\n * .proc_write = message_write  <- Called when user writes to /proc/message\n *\n * COMPARISON TO PROBLEM 100:\n * Problem 100: Only .proc_read (read-only /proc file)\n * Problem 101: Both .proc_read and .proc_write (bidirectional)\n *\n * PERMISSIONS:\n * - Read-only file: 0444 (everyone can read)\n * - Read-write file: 0666 (everyone can read and write)\n * - We'll use 0666 since we support both operations\n */\n\n/* TODO: Define proc_ops structure with both read and write */\nstatic const struct proc_ops message_ops = {\n    /* TODO: .proc_read = message_read, */\n    /* TODO: .proc_write = message_write, */\n};\n\n/* ========================================================================== */\n/* SECTION 5: MODULE INIT - Create /proc Entry */\n/* ========================================================================== */\nstatic int __init proc_message_init(void)\n{\n    printk(KERN_INFO \"Initializing /proc/%s module\\n\", PROC_NAME);\n\n    /* TODO: Create /proc entry with read-write permissions */\n    /* TODO: proc_entry = proc_create(PROC_NAME, 0666, NULL, &message_ops) */\n    /* TODO: Check if proc_entry is NULL (creation failed) */\n    /* TODO: If failed, return -ENOMEM */\n\n    /* TODO: Initialize message buffer and length */\n    /* TODO: memset(message_buffer, 0, BUFFER_SIZE) */\n    /* TODO: message_len = 0 */\n\n    /* TODO: Print success message */\n    /* TODO: printk(KERN_INFO \"/proc/%s created successfully\\n\", PROC_NAME) */\n\n    return 0;\n}\n\n/* ========================================================================== */\n/* SECTION 6: MODULE EXIT - Remove /proc Entry */\n/* ========================================================================== */\nstatic void __exit proc_message_exit(void)\n{\n    /* TODO: Remove /proc entry */\n    /* TODO: proc_remove(proc_entry) */\n\n    printk(KERN_INFO \"/proc/%s removed\\n\", PROC_NAME);\n}\n\nmodule_init(proc_message_init);\nmodule_exit(proc_message_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"/proc file with read and write operations\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# /proc read-write message module Makefile\nobj-m += proc_message.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "proc_message.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "proc_message_init",
          "proc_message_exit",
          "message_read",
          "message_write"
        ],
        "variables": [
          {
            "name": "message_buffer",
            "type": "char",
            "value": "[BUFFER_SIZE]",
            "storageClass": "static"
          },
          {
            "name": "message_len",
            "type": "size_t",
            "value": "0",
            "storageClass": "static"
          },
          {
            "name": "proc_entry",
            "type": "struct proc_dir_entry *",
            "value": "NULL",
            "storageClass": "static"
          }
        ],
        "outputMessages": [
          "Initializing /proc/message module",
          "/proc/message created successfully",
          "Received message:",
          "/proc/message removed"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/proc_fs.h",
          "linux/uaccess.h"
        ],
        "mustContain": [
          "copy_from_user",
          "copy_to_user",
          "proc_create",
          "proc_remove",
          ".proc_read = message_read",
          ".proc_write = message_write",
          "message_buffer[BUFFER_SIZE]",
          "message_len",
          "BUFFER_SIZE - 1"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "static ssize_t message_read",
            "struct file *file",
            "char __user *user_buffer",
            "size_t count",
            "loff_t *offset",
            "static ssize_t message_write",
            "const char __user *user_buffer",
            "static int __init proc_message_init(void)",
            "static void __exit proc_message_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "proc_ops_structure",
          "name": "proc_ops Structure with Read and Write",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "static const struct proc_ops message_ops",
            ".proc_read = message_read",
            ".proc_write = message_write"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Function-Linked Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Initializing /proc/message module",
              "exact": true,
              "linkedFunction": "static int __init proc_message_init(void)"
            },
            {
              "pattern": "/proc/message created successfully",
              "exact": true,
              "linkedFunction": "static int __init proc_message_init(void)"
            },
            {
              "pattern": "Received message:",
              "exact": false,
              "linkedFunction": "static ssize_t message_write()"
            },
            {
              "pattern": "/proc/message removed",
              "exact": true,
              "linkedFunction": "static void __exit proc_message_exit(void)"
            }
          ]
        },
        {
          "id": "proc_bidirectional_validation",
          "name": "Complete /proc Read-Write Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "proc_rw_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#include <time.h>\\n\\nint main() {\\n    FILE *fp;\\n    char buffer[256];\\n    \\n    printf(\\\"=== /proc Read-Write Bidirectional Test ===\\\\n\\\");\\n    \\n    /* Generate dynamic test messages */\\n    srand(time(NULL));\\n    int random_num = (rand() % 900) + 100;\\n    char test_msg1[256];\\n    char test_msg2[256];\\n    snprintf(test_msg1, sizeof(test_msg1), \\\"TestMessage_%d\\\", random_num);\\n    snprintf(test_msg2, sizeof(test_msg2), \\\"UpdatedMessage_%d\\\", random_num + 1);\\n    \\n    printf(\\\"Test 1: Writing first message: %s\\\\n\\\", test_msg1);\\n    fp = fopen(\\\"/proc/message\\\", \\\"w\\\");\\n    if (!fp) {\\n        printf(\\\"FAIL: Cannot open /proc/message for writing\\\\n\\\");\\n        return 1;\\n    }\\n    fprintf(fp, \\\"%s\\\", test_msg1);\\n    fclose(fp);\\n    \\n    printf(\\\"Test 2: Reading first message back...\\\\n\\\");\\n    fp = fopen(\\\"/proc/message\\\", \\\"r\\\");\\n    if (!fp) {\\n        printf(\\\"FAIL: Cannot open /proc/message for reading\\\\n\\\");\\n        return 1;\\n    }\\n    memset(buffer, 0, sizeof(buffer));\\n    if (fgets(buffer, sizeof(buffer), fp)) {\\n        /* Remove newline if present */\\n        buffer[strcspn(buffer, \\\"\\\\n\\\")] = 0;\\n        printf(\\\"Read: %s\\\\n\\\", buffer);\\n        if (strcmp(buffer, test_msg1) == 0) {\\n            printf(\\\"PASS: First message read correctly\\\\n\\\");\\n        } else {\\n            printf(\\\"FAIL: First message mismatch (expected: %s, got: %s)\\\\n\\\", test_msg1, buffer);\\n        }\\n    } else {\\n        printf(\\\"FAIL: Could not read first message\\\\n\\\");\\n    }\\n    fclose(fp);\\n    \\n    printf(\\\"Test 3: Overwriting with second message: %s\\\\n\\\", test_msg2);\\n    fp = fopen(\\\"/proc/message\\\", \\\"w\\\");\\n    if (!fp) {\\n        printf(\\\"FAIL: Cannot reopen /proc/message for writing\\\\n\\\");\\n        return 1;\\n    }\\n    fprintf(fp, \\\"%s\\\", test_msg2);\\n    fclose(fp);\\n    \\n    printf(\\\"Test 4: Reading second message back...\\\\n\\\");\\n    fp = fopen(\\\"/proc/message\\\", \\\"r\\\");\\n    if (!fp) {\\n        printf(\\\"FAIL: Cannot reopen /proc/message for reading\\\\n\\\");\\n        return 1;\\n    }\\n    memset(buffer, 0, sizeof(buffer));\\n    if (fgets(buffer, sizeof(buffer), fp)) {\\n        buffer[strcspn(buffer, \\\"\\\\n\\\")] = 0;\\n        printf(\\\"Read: %s\\\\n\\\", buffer);\\n        if (strcmp(buffer, test_msg2) == 0) {\\n            printf(\\\"PASS: Second message read correctly\\\\n\\\");\\n        } else {\\n            printf(\\\"FAIL: Second message mismatch (expected: %s, got: %s)\\\\n\\\", test_msg2, buffer);\\n        }\\n    } else {\\n        printf(\\\"FAIL: Could not read second message\\\\n\\\");\\n    }\\n    fclose(fp);\\n    \\n    printf(\\\"SUCCESS: All bidirectional /proc tests completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting /proc read-write bidirectional validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: Module Loading'",
              "insmod /lib/modules/proc_message.ko",
              "sleep 1",
              "dmesg | grep 'Initializing /proc/message module' && echo 'PASS: Module init message' || echo 'FAIL: Module init message missing'",
              "dmesg | grep '/proc/message created successfully' && echo 'PASS: /proc file created' || echo 'FAIL: /proc creation failed'",
              "",
              "echo 'Phase 2: /proc File Existence Check'",
              "ls /proc/message && echo 'PASS: /proc/message file exists' || echo 'FAIL: /proc/message file missing'",
              "",
              "echo 'Phase 3: Bidirectional Communication Test'",
              "/bin/proc_rw_tester",
              "sleep 1",
              "",
              "echo 'Phase 4: Kernel Message Logging Validation'",
              "dmesg | grep 'Received message: TestMessage_' && echo 'PASS: Write callback logged first message' || echo 'FAIL: First write logging missing'",
              "dmesg | grep 'Received message: UpdatedMessage_' && echo 'PASS: Write callback logged second message' || echo 'FAIL: Second write logging missing'",
              "",
              "echo 'Phase 5: Module Cleanup'",
              "rmmod proc_message",
              "sleep 1",
              "dmesg | grep '/proc/message removed' && echo 'PASS: Module cleanup message' || echo 'FAIL: Cleanup message missing'",
              "",
              "echo 'PASS: All /proc read-write bidirectional validation completed successfully'"
            ],
            "expected": {
              "dmesg": [
                "Initializing /proc/message module",
                "/proc/message created successfully",
                "Received message: TestMessage_.*",
                "Received message: UpdatedMessage_.*",
                "/proc/message removed"
              ],
              "stdout": [
                "/proc Read-Write Bidirectional Test",
                "Test 1: Writing first message: TestMessage_.*",
                "Test 2: Reading first message back",
                "PASS: First message read correctly",
                "Test 3: Overwriting with second message: UpdatedMessage_.*",
                "Test 4: Reading second message back",
                "PASS: Second message read correctly",
                "SUCCESS: All bidirectional /proc tests completed",
                "PASS: Module init message",
                "PASS: /proc file created",
                "PASS: /proc/message file exists",
                "PASS: Write callback logged first message",
                "PASS: Write callback logged second message",
                "PASS: Module cleanup message",
                "PASS: All /proc read-write bidirectional validation completed successfully"
              ]
            },
            "timeout": 20
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Initializing /proc/message module",
        "/proc/message created successfully",
        "Received message:",
        "/proc/message removed"
      ],
      "requirements": [
        "Use required function names: proc_message_init, proc_message_exit, message_read, message_write",
        "Use required variable names: message_buffer, message_len, proc_entry",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/proc_fs.h, linux/uaccess.h",
        "Code must contain: copy_from_user, copy_to_user, proc_create, proc_remove, .proc_read = message_read, .proc_write = message_write, message_buffer[BUFFER_SIZE], message_len, BUFFER_SIZE - 1",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Initializing /proc/message module",
          "linkedFunction": "static int __init proc_message_init(void)",
          "exact": true
        },
        {
          "pattern": "/proc/message created successfully",
          "linkedFunction": "static int __init proc_message_init(void)",
          "exact": true
        },
        {
          "pattern": "Received message:",
          "linkedFunction": "static ssize_t message_write()",
          "exact": false
        },
        {
          "pattern": "/proc/message removed",
          "linkedFunction": "static void __exit proc_message_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 102,
    "title": "Character Device Counter - Your First Device Driver",
    "difficulty": 4,
    "xp": 30,
    "phase": "kernel_core",
    "description": "Learn the fundamentals of character device drivers by creating a simple counter device. Every time a user reads from /dev/counter, the device returns an incrementing number. This teaches device registration, file operations, and kernel-userspace communication - the foundation for all device drivers including GPU drivers.",
    "concepts": [
      "character device drivers",
      "device registration with register_chrdev",
      "file_operations structure",
      "device open and release operations",
      "device read operation",
      "copy_to_user for kernel-userspace communication",
      "major and minor device numbers",
      "device node creation with mknod",
      "device state management",
      "device cleanup with unregister_chrdev"
    ],
    "skills": [
      "Creating character device drivers",
      "Using register_chrdev and unregister_chrdev",
      "Implementing file_operations callbacks",
      "Using copy_to_user safely",
      "Managing device state across operations",
      "Understanding major/minor device numbers",
      "Creating device nodes manually",
      "Proper device driver cleanup"
    ],
    "files": [
      {
        "name": "counter_dev.h",
        "content": "#ifndef COUNTER_DEV_H\n#define COUNTER_DEV_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: Character Device Fundamentals */\n/* ========================================================================== */\n/* This problem teaches the FOUNDATION of ALL device drivers!\n *\n * WHAT IS A CHARACTER DEVICE?\n * Character devices provide stream-based I/O - they handle data one byte at a time.\n * Examples: /dev/null, /dev/zero, /dev/random, /dev/tty, GPU devices!\n *\n * VS BLOCK DEVICES:\n * Block devices handle data in blocks (hard drives, SSDs) - random access\n * Character devices handle data as streams (keyboards, mice, GPUs) - sequential access\n *\n * REAL-WORLD EXAMPLES:\n * - /dev/null - discards all data written to it\n * - /dev/zero - returns infinite zeros when read\n * - /dev/random - returns random bytes when read\n * - /dev/nvidia0 - NVIDIA GPU character device!\n * - /dev/dri/card0 - AMD/Intel GPU character device (DRM)\n *\n * WHY THIS MATTERS FOR GPU DRIVERS:\n * ALL GPU drivers start as character devices before adding DRM/graphics features!\n * Understanding character devices is the FIRST STEP to GPU driver development.\n */\n\n/* ========================================================================== */\n/* DEVICE CONFIGURATION */\n/* ========================================================================== */\n/* MAJOR AND MINOR DEVICE NUMBERS EXPLAINED:\n *\n * In Linux, devices are identified by TWO numbers:\n * 1. MAJOR NUMBER: Identifies the device driver (which module handles this device)\n * 2. MINOR NUMBER: Identifies specific device instance (first GPU, second GPU, etc.)\n *\n * Example: /dev/nvidia0 (major=195, minor=0), /dev/nvidia1 (major=195, minor=1)\n * Same driver (major 195), different GPU instances (minor 0, 1)\n *\n * MAJOR NUMBER RANGES:\n * - 0-255: Static allocation (some reserved, some available)\n * - 240-254: Available for custom/experimental drivers (we use 240)\n * - Dynamic: Kernel can auto-assign (modern approach, but we use static for learning)\n */\n\n/* TODO: Define device name macro */\n/* #define DEVICE_NAME \"counter\" */\n\n/* TODO: Define major device number */\n/* #define MAJOR_NUM 240 */\n\n/* ========================================================================== */\n/* KERNEL CODING STYLE: Static Functions */\n/* ========================================================================== */\n/* IMPORTANT RULE: \"Variables and functions must be static, unless they have\n * a prototype, and are supposed to be exported.\"\n *\n * For character device drivers:\n * - device_open(), device_release(), device_read() are INTERNAL to our module\n * - They are NOT exported to other modules\n * - Therefore: they MUST be declared as 'static' in the .c file\n * - They are NOT declared in this header file\n * - They are only referenced through the file_operations structure\n *\n * LINUX FILE OPERATIONS MODEL:\n * When user does:           Kernel calls:\n * open(\"/dev/counter\")  -> device_open()    (static function in .c)\n * read(fd, buf, len)    -> device_read()    (static function in .c)\n * close(fd)             -> device_release() (static function in .c)\n *\n * This is standard practice in ALL Linux kernel drivers!\n */\n\n#endif /* COUNTER_DEV_H */\n",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "counter_dev.c",
        "content": "#include \"counter_dev.h\"\n\n/* ========================================================================== */\n/* GLOBAL DEVICE STATE */\n/* ========================================================================== */\n/* These variables maintain the device state across multiple operations.\n *\n * WHY STATIC?\n * Static variables have:\n * 1. File scope - only visible within this .c file (encapsulation)\n * 2. Persistent lifetime - values retained across function calls\n * 3. Initialized once - at module load time\n *\n * This is the EXACT pattern used in real kernel drivers!\n */\n\n/* TODO: Declare static counter variable */\n/* This holds the current counter value - increments with each read */\n/* static int counter = 0; */\n\n/* TODO: Declare static device_open_count variable */\n/* Tracks how many times the device is currently open */\n/* Used to prevent issues with multiple simultaneous opens (optional but good practice) */\n/* static int device_open_count = 0; */\n\n/* ========================================================================== */\n/* FILE OPERATIONS STRUCTURE */\n/* ========================================================================== */\n/* This is the KEY data structure connecting userspace operations to kernel functions!\n *\n * HOW IT WORKS:\n * 1. We create a struct file_operations with function pointers\n * 2. We register it with the kernel using register_chrdev()\n * 3. When user opens /dev/counter, kernel uses THIS table to call OUR functions\n *\n * FUNCTION POINTER PATTERN (from Problem 21!):\n * struct file_operations {\n *     struct module *owner;           // Module that owns this (THIS_MODULE)\n *     ssize_t (*read)(...);          // Function pointer for read()\n *     int (*open)(...);              // Function pointer for open()\n *     int (*release)(...);           // Function pointer for close()\n *     // ... many more operations (write, ioctl, mmap, etc.)\n * };\n *\n * WHY THIS PATTERN?\n * - Extensibility: New devices just implement their own functions\n * - Polymorphism: Different devices, same interface (like OOP in C!)\n * - Flexibility: Can implement only needed operations (others NULL)\n *\n * REAL KERNEL EXAMPLES:\n * - GPU drivers implement: open, read, write, ioctl, mmap, poll\n * - /dev/null implements: open, read (returns 0), write (discards), release\n * - /dev/zero implements: open, read (returns zeros), release\n */\n\n/* TODO: Define file_operations structure */\n/* REQUIRED FIELDS:\n * - .owner = THIS_MODULE (tells kernel which module owns this)\n * - .read = device_read (function called on read())\n * - .open = device_open (function called on open())\n * - .release = device_release (function called on close())\n *\n * PATTERN:\n * static struct file_operations fops = {\n *     .owner = THIS_MODULE,\n *     .read = device_read,\n *     .open = device_open,\n *     .release = device_release\n * };\n */\n\n/* ========================================================================== */\n/* DEVICE OPERATION FUNCTIONS */\n/* ========================================================================== */\n\n/* TODO: Implement device_open() */\n/* Called when userspace opens /dev/counter with open() system call\n *\n * WHAT THIS FUNCTION SHOULD DO:\n * 1. Increment device_open_count\n * 2. Print message: \"Counter device opened\"\n * 3. Return 0 for success\n *\n * REAL-WORLD USAGE:\n * GPU drivers use open() to:\n * - Allocate per-process GPU context\n * - Set up memory mappings\n * - Initialize command buffers\n * - Track which process owns which GPU resources\n *\n * PATTERN:\n * static int device_open(struct inode *inode, struct file *file) {\n *     device_open_count++;\n *     printk(KERN_INFO \"Counter device opened\\n\");\n *     return 0;\n * }\n */\n\n/* TODO: Implement device_release() */\n/* Called when userspace closes the device with close() system call\n *\n * WHAT THIS FUNCTION SHOULD DO:\n * 1. Decrement device_open_count\n * 2. Print message: \"Counter device closed\"\n * 3. Return 0 for success\n *\n * REAL-WORLD USAGE:\n * GPU drivers use release() to:\n * - Free per-process GPU context\n * - Release GPU memory allocations\n * - Clean up command buffers\n * - Ensure GPU resources are properly freed\n *\n * PATTERN:\n * static int device_release(struct inode *inode, struct file *file) {\n *     device_open_count--;\n *     printk(KERN_INFO \"Counter device closed\\n\");\n *     return 0;\n * }\n */\n\n/* TODO: Implement device_read() */\n/* Called when userspace reads from device with read() system call\n *\n * WHAT THIS FUNCTION SHOULD DO:\n * 1. Format counter as string: \"Counter: %d\\n\"\n * 2. Use copy_to_user() to send string to userspace buffer\n * 3. Print message: \"Counter read: returned %d\" (with counter value)\n * 4. Increment counter for next read\n * 5. Return number of bytes read (length of string)\n *\n * CRITICAL: WHY copy_to_user()?\n * Kernel memory and userspace memory are SEPARATE!\n * - Kernel cannot directly write to userspace pointers\n * - copy_to_user() safely transfers data across this boundary\n * - It handles page faults and memory protection\n * - Using it wrong = kernel crash!\n *\n * COPY_TO_USER SYNTAX:\n * int copy_to_user(void __user *to, const void *from, unsigned long n)\n * - to: Userspace buffer pointer (from function parameter)\n * - from: Kernel buffer with our data\n * - n: Number of bytes to copy\n * Returns: 0 on success, number of bytes NOT copied on failure\n *\n * ALGORITHM:\n * 1. Create kernel buffer: char msg[64];\n * 2. Format message: sprintf(msg, \"Counter: %d\\n\", counter);\n * 3. Get length: int len = strlen(msg);\n * 4. Copy to user: if (copy_to_user(buffer, msg, len)) return -EFAULT;\n * 5. Log the read: printk(KERN_INFO \"Counter read: returned %d\\n\", counter);\n * 6. Increment: counter++;\n * 7. Return bytes read: return len;\n *\n * REAL-WORLD USAGE:\n * GPU drivers use read() to:\n * - Read GPU register values\n * - Get error/debug information\n * - Read performance counters\n * - Return GPU status information\n *\n * PATTERN:\n * static ssize_t device_read(struct file *file, char __user *buffer, size_t len, loff_t *offset) {\n *     char msg[64];\n *     int msg_len;\n *     \n *     sprintf(msg, \"Counter: %d\\n\", counter);\n *     msg_len = strlen(msg);\n *     \n *     if (copy_to_user(buffer, msg, msg_len)) {\n *         return -EFAULT;  // Bad address\n *     }\n *     \n *     printk(KERN_INFO \"Counter read: returned %d\\n\", counter);\n *     counter++;\n *     \n *     return msg_len;\n * }\n */\n\n/* ========================================================================== */\n/* MODULE INITIALIZATION AND CLEANUP */\n/* ========================================================================== */\n\n/* TODO: Implement counter_init() */\n/* Module initialization - called when module is loaded with insmod\n *\n * WHAT THIS FUNCTION SHOULD DO:\n * 1. Register character device with register_chrdev()\n * 2. Check if registration succeeded (returns negative on error)\n * 3. Print success message with major number\n * 4. Print instruction for creating device node\n * 5. Return 0 on success, error code on failure\n *\n * REGISTER_CHRDEV EXPLAINED:\n * int register_chrdev(unsigned int major, const char *name, struct file_operations *fops)\n * - major: Major device number (MAJOR_NUM, 240 in our case)\n * - name: Device name (appears in /proc/devices)\n * - fops: Pointer to our file_operations structure\n * Returns: 0 on success, negative error code on failure\n *\n * DEVICE NODE CREATION:\n * After registering the driver, we need to create a device node in /dev/\n * This is done with mknod command:\n * mknod /dev/counter c 240 0\n *        ↑           ↑  ↑   ↑\n *        device      c  maj min\n *        name        h  or  or\n *                    a  num num\n *                    r\n *\n * WHY SEPARATE STEPS?\n * - Driver registration: Tells kernel \"I can handle major number 240\"\n * - Device node: Creates /dev/counter file that userspace can open()\n * - Modern systems use udev to auto-create nodes (we do it manually for learning)\n *\n * ALGORITHM:\n * 1. Call register_chrdev(MAJOR_NUM, DEVICE_NAME, &fops)\n * 2. Check if result < 0 (error)\n * 3. If error, print error message and return error code\n * 4. If success, print: \"Counter device registered with major number %d\"\n * 5. Print: \"Create device with: mknod /dev/counter c %d 0\" (with MAJOR_NUM)\n * 6. Return 0\n *\n * PATTERN:\n * static int __init counter_init(void) {\n *     int result = register_chrdev(MAJOR_NUM, DEVICE_NAME, &fops);\n *     \n *     if (result < 0) {\n *         printk(KERN_ERR \"Failed to register character device\\n\");\n *         return result;\n *     }\n *     \n *     printk(KERN_INFO \"Counter device registered with major number %d\\n\", MAJOR_NUM);\n *     printk(KERN_INFO \"Create device with: mknod /dev/counter c %d 0\\n\", MAJOR_NUM);\n *     \n *     return 0;\n * }\n */\n\n/* TODO: Implement counter_exit() */\n/* Module cleanup - called when module is unloaded with rmmod\n *\n * WHAT THIS FUNCTION SHOULD DO:\n * 1. Unregister character device with unregister_chrdev()\n * 2. Print cleanup message\n *\n * UNREGISTER_CHRDEV SYNTAX:\n * void unregister_chrdev(unsigned int major, const char *name)\n * - major: Same major number used in register_chrdev()\n * - name: Same device name used in register_chrdev()\n *\n * CRITICAL CLEANUP:\n * ALWAYS unregister devices in exit function!\n * If you don't:\n * - Kernel keeps reference to our module\n * - Module cannot be reloaded properly\n * - System may crash on next access\n *\n * PATTERN:\n * static void __exit counter_exit(void) {\n *     unregister_chrdev(MAJOR_NUM, DEVICE_NAME);\n *     printk(KERN_INFO \"Counter device unregistered\\n\");\n * }\n */\n\n/* TODO: Register module_init and module_exit */\n/* module_init(counter_init); */\n/* module_exit(counter_exit); */\n\n/* TODO: Add module metadata */\n/* MODULE_LICENSE(\"GPL\"); */\n/* MODULE_AUTHOR(\"Student\"); */\n/* MODULE_DESCRIPTION(\"Simple counter character device driver\"); */\n/* MODULE_VERSION(\"1.0\"); */\n",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Counter character device Makefile\nobj-m += counter_dev.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help\n",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "counter_dev.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "counter_init",
          "counter_exit",
          "device_open",
          "device_release",
          "device_read"
        ],
        "macro_declarations": [
          {
            "name": "DEVICE_NAME",
            "type": "constant",
            "value": "\"counter\"",
            "description": "Character device name"
          },
          {
            "name": "MAJOR_NUM",
            "type": "constant",
            "value": "240",
            "description": "Major device number"
          }
        ],
        "variables": [
          {
            "name": "counter",
            "type": "int",
            "value": "0",
            "storageClass": "static"
          },
          {
            "name": "device_open_count",
            "type": "int",
            "value": "0",
            "storageClass": "static"
          },
          {
            "name": "fops",
            "type": "struct file_operations",
            "value": "{.owner = THIS_MODULE, .read = device_read, .open = device_open, .release = device_release}",
            "storageClass": "static"
          }
        ],
        "outputMessages": [
          "Counter device registered with major number 240",
          "Create device with: mknod /dev/counter c 240 0",
          "Counter device opened",
          "Counter read: returned 0",
          "Counter read: returned 1",
          "Counter read: returned 2",
          "Counter device closed",
          "Counter device unregistered"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/fs.h",
          "linux/uaccess.h"
        ],
        "mustContain": [
          "register_chrdev",
          "unregister_chrdev",
          "copy_to_user",
          "struct file_operations",
          ".read",
          ".open",
          ".release",
          "THIS_MODULE",
          "device_open_count++",
          "device_open_count--",
          "counter++"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "macro_definitions",
          "name": "Macro Definitions",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "#define DEVICE_NAME \"counter\"",
            "#define MAJOR_NUM 240"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Implementations in Source",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "static int device_open(struct inode *inode, struct file *file)",
            "static int device_release(struct inode *inode, struct file *file)",
            "static ssize_t device_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)",
            "static int __init counter_init(void)",
            "static void __exit counter_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "file_operations_structure",
          "name": "file_operations Structure",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "struct file_operations",
            ".owner = THIS_MODULE",
            ".read = device_read",
            ".open = device_open",
            ".release = device_release"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "device_registration",
          "name": "Device Registration Implementation",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "register_chrdev",
            "MAJOR_NUM",
            "DEVICE_NAME",
            "&fops"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "copy_to_user_usage",
          "name": "copy_to_user Implementation",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "copy_to_user",
            "buffer",
            "sprintf",
            "Counter:"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Counter device registered with major number 240",
              "exact": true,
              "linkedFunction": "static int __init counter_init(void)"
            },
            {
              "pattern": "Create device with: mknod /dev/counter c 240 0",
              "exact": true,
              "linkedFunction": "static int __init counter_init(void)"
            },
            {
              "pattern": "Counter device opened",
              "exact": true,
              "linkedFunction": "int device_open(struct inode *inode, struct file *file)"
            },
            {
              "pattern": "Counter read: returned 0",
              "exact": true,
              "linkedFunction": "ssize_t device_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)"
            },
            {
              "pattern": "Counter read: returned 1",
              "exact": true,
              "linkedFunction": "ssize_t device_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)"
            },
            {
              "pattern": "Counter read: returned 2",
              "exact": true,
              "linkedFunction": "ssize_t device_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)"
            },
            {
              "pattern": "Counter device closed",
              "exact": true,
              "linkedFunction": "int device_release(struct inode *inode, struct file *file)"
            },
            {
              "pattern": "Counter device unregistered",
              "exact": true,
              "linkedFunction": "static void __exit counter_exit(void)"
            }
          ]
        },
        {
          "id": "character_device_integration",
          "name": "Character Device Integration Test",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [
              {
                "name": "counter_device_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <fcntl.h>\\n#include <unistd.h>\\n#include <string.h>\\n\\nint main() {\\n    int fd;\\n    char buffer[128];\\n    int bytes_read;\\n    int i;\\n    \\n    printf(\\\"=== Character Device Counter Test ===\\\\n\\\");\\n    \\n    /* Open the device */\\n    printf(\\\"Opening /dev/counter...\\\\n\\\");\\n    fd = open(\\\"/dev/counter\\\", O_RDONLY);\\n    if (fd < 0) {\\n        printf(\\\"ERROR: Failed to open /dev/counter\\\\n\\\");\\n        return 1;\\n    }\\n    printf(\\\"Device opened successfully\\\\n\\\");\\n    \\n    /* Read from device 3 times */\\n    for (i = 0; i < 3; i++) {\\n        memset(buffer, 0, sizeof(buffer));\\n        bytes_read = read(fd, buffer, sizeof(buffer) - 1);\\n        \\n        if (bytes_read < 0) {\\n            printf(\\\"ERROR: Failed to read from device\\\\n\\\");\\n            close(fd);\\n            return 1;\\n        }\\n        \\n        printf(\\\"Read %d bytes: %s\\\", bytes_read, buffer);\\n    }\\n    \\n    /* Close the device */\\n    printf(\\\"Closing device...\\\\n\\\");\\n    close(fd);\\n    printf(\\\"Device closed successfully\\\\n\\\");\\n    \\n    printf(\\\"SUCCESS: All character device operations completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting character device counter validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: TCC Header Validation'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define THIS_MODULE ((struct module *)0)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef long long loff_t;' > /tmp/linux/types.h",
              "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
              "echo 'typedef long ssize_t;' >> /tmp/linux/types.h",
              "echo '#define __user' >> /tmp/linux/types.h",
              "echo '#include <linux/types.h>' > /tmp/linux/fs.h",
              "echo 'struct inode { int dummy; };' >> /tmp/linux/fs.h",
              "echo 'struct file { int dummy; };' >> /tmp/linux/fs.h",
              "echo 'struct file_operations { void *owner; void *read; void *open; void *release; };' >> /tmp/linux/fs.h",
              "echo 'int register_chrdev(unsigned int major, const char *name, struct file_operations *fops);' >> /tmp/linux/fs.h",
              "echo 'void unregister_chrdev(unsigned int major, const char *name);' >> /tmp/linux/fs.h",
              "echo 'unsigned long copy_to_user(void *to, const void *from, unsigned long n);' > /tmp/linux/uaccess.h",
              "echo '#define EFAULT 14' >> /tmp/linux/uaccess.h",
              "echo 'Creating TCC test file to validate header includes...'",
              "echo '#include \"/lib/modules/counter_dev.h\"' > /tmp/test.c",
              "echo 'int main() { return 0; }' >> /tmp/test.c",
              "/usr/bin/tcc -I/tmp -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Header file has errors (check for uncommented function declarations)'; cat /tmp/tcc_error.log; else echo 'PASS: Header file compiles successfully'; fi",
              "",
              "echo 'Phase 2: Module Loading and Device Registration'",
              "insmod /lib/modules/counter_dev.ko",
              "sleep 1",
              "",
              "echo 'Phase 3: Device Registration Validation'",
              "dmesg | grep 'Counter device registered with major number 240' && echo 'PASS: Device registered successfully' || echo 'FAIL: Device registration message missing'",
              "dmesg | grep 'Create device with: mknod /dev/counter c 240 0' && echo 'PASS: mknod instruction present' || echo 'FAIL: mknod instruction missing'",
              "",
              "echo 'Phase 4: Device Node Creation'",
              "mknod /dev/counter c 240 0",
              "ls -l /dev/counter && echo 'PASS: Device node created' || echo 'FAIL: Device node creation failed'",
              "",
              "echo 'Phase 5: Character Device Functional Testing'",
              "/bin/counter_device_tester > /tmp/device_test_output.log 2>&1",
              "cat /tmp/device_test_output.log",
              "sleep 1",
              "",
              "echo 'Phase 6: Validate Device Operations'",
              "dmesg | grep 'Counter device opened' && echo 'PASS: Device open working' || echo 'FAIL: Device open broken'",
              "dmesg | grep 'Counter read: returned 0' && echo 'PASS: First counter read (0) working' || echo 'FAIL: First read broken'",
              "dmesg | grep 'Counter read: returned 1' && echo 'PASS: Second counter read (1) working' || echo 'FAIL: Second read broken'",
              "dmesg | grep 'Counter read: returned 2' && echo 'PASS: Third counter read (2) working' || echo 'FAIL: Third read broken'",
              "dmesg | grep 'Counter device closed' && echo 'PASS: Device release working' || echo 'FAIL: Device release broken'",
              "",
              "echo 'Phase 7: Validate Userspace Counter Output'",
              "grep 'Counter: 0' /tmp/device_test_output.log && echo 'PASS: Userspace received counter 0' || echo 'FAIL: Counter 0 not received'",
              "grep 'Counter: 1' /tmp/device_test_output.log && echo 'PASS: Userspace received counter 1' || echo 'FAIL: Counter 1 not received'",
              "grep 'Counter: 2' /tmp/device_test_output.log && echo 'PASS: Userspace received counter 2' || echo 'FAIL: Counter 2 not received'",
              "grep 'SUCCESS: All character device operations completed' /tmp/device_test_output.log && echo 'PASS: All operations succeeded' || echo 'FAIL: Operations incomplete'",
              "",
              "echo 'Phase 8: Module Cleanup'",
              "rm /dev/counter",
              "rmmod counter_dev",
              "sleep 1",
              "dmesg | grep 'Counter device unregistered' && echo 'PASS: Device unregistered successfully' || echo 'FAIL: Device unregistration message missing'",
              "",
              "echo 'PASS: All character device integration tests completed successfully'"
            ],
            "expected": {
              "dmesg": [
                "Counter device registered with major number 240",
                "Create device with: mknod /dev/counter c 240 0",
                "Counter device opened",
                "Counter read: returned 0",
                "Counter read: returned 1",
                "Counter read: returned 2",
                "Counter device closed",
                "Counter device unregistered"
              ],
              "stdout": [
                "PASS: Header file compiles successfully",
                "PASS: Device registered successfully",
                "PASS: mknod instruction present",
                "PASS: Device node created",
                "Device opened successfully",
                "Counter: 0",
                "Counter: 1",
                "Counter: 2",
                "Device closed successfully",
                "SUCCESS: All character device operations completed",
                "PASS: Device open working",
                "PASS: First counter read \\(0\\) working",
                "PASS: Second counter read \\(1\\) working",
                "PASS: Third counter read \\(2\\) working",
                "PASS: Device release working",
                "PASS: Userspace received counter 0",
                "PASS: Userspace received counter 1",
                "PASS: Userspace received counter 2",
                "PASS: All operations succeeded",
                "PASS: Device unregistered successfully",
                "PASS: All character device integration tests completed successfully"
              ]
            },
            "timeout": 30
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Counter device registered with major number 240",
        "Create device with: mknod /dev/counter c 240 0",
        "Counter device opened",
        "Counter read: returned 0",
        "Counter read: returned 1",
        "Counter read: returned 2",
        "Counter device closed",
        "Counter device unregistered"
      ],
      "requirements": [
        "Use required function names: counter_init, counter_exit, device_open, device_release, device_read",
        "Use required variable names: counter, device_open_count, fops",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/fs.h, linux/uaccess.h",
        "Code must contain: register_chrdev, unregister_chrdev, copy_to_user, struct file_operations, .read, .open, .release, THIS_MODULE, device_open_count++, device_open_count--, counter++",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Counter device registered with major number 240",
          "linkedFunction": "static int __init counter_init(void)",
          "exact": true
        },
        {
          "pattern": "Create device with: mknod /dev/counter c 240 0",
          "linkedFunction": "static int __init counter_init(void)",
          "exact": true
        },
        {
          "pattern": "Counter device opened",
          "linkedFunction": "int device_open(struct inode *inode, struct file *file)",
          "exact": true
        },
        {
          "pattern": "Counter read: returned 0",
          "linkedFunction": "ssize_t device_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)",
          "exact": true
        },
        {
          "pattern": "Counter read: returned 1",
          "linkedFunction": "ssize_t device_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)",
          "exact": true
        },
        {
          "pattern": "Counter read: returned 2",
          "linkedFunction": "ssize_t device_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)",
          "exact": true
        },
        {
          "pattern": "Counter device closed",
          "linkedFunction": "int device_release(struct inode *inode, struct file *file)",
          "exact": true
        },
        {
          "pattern": "Counter device unregistered",
          "linkedFunction": "static void __exit counter_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 103,
    "title": "Character Device with Write - Bidirectional Communication",
    "difficulty": 5,
    "xp": 35,
    "phase": "kernel_core",
    "description": "Expand your character device skills by adding write operations. Create a device that stores a message written by the user and returns it when read. This teaches bidirectional kernel-userspace communication, buffer management, and state persistence - essential skills for real device drivers including GPUs. Learn kmalloc/kfree, copy_from_user, and proper resource cleanup.",
    "concepts": [
      "Bidirectional device communication",
      "Write operation implementation",
      "Kernel memory allocation (kmalloc/kfree)",
      "GFP_KERNEL allocation flags",
      "copy_from_user() - userspace to kernel",
      "copy_to_user() - kernel to userspace",
      "Buffer management and state persistence",
      "Resource cleanup and memory leak prevention",
      "file_operations structure with read and write",
      "Character device driver patterns"
    ],
    "skills": [
      "Implementing device_write() operation",
      "Using kmalloc() for dynamic kernel memory allocation",
      "Using kfree() for proper memory deallocation",
      "Using copy_from_user() safely",
      "Managing device state across operations",
      "Preventing memory leaks in kernel code",
      "Error handling in memory allocation",
      "Building stateful character devices",
      "Understanding bidirectional data flow",
      "Professional kernel memory management"
    ],
    "files": [
      {
        "name": "message_dev.h",
        "content": "#ifndef MESSAGE_DEV_H\n#define MESSAGE_DEV_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\n/* Device configuration */\n#define DEVICE_NAME \"message\"\n#define MAJOR_NUM 241\n#define MAX_MESSAGE_SIZE 1024\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: Bidirectional Character Device */\n/* ========================================================================== */\n/* This problem teaches you to create devices that BOTH read AND write!\n *\n * EVOLUTION FROM PROBLEM 102:\n * Problem 102: Read-only counter device\n *   - Only device_read() implemented\n *   - Data flows: kernel → userspace\n *   - Simple, unidirectional\n *\n * Problem 103: Read/Write message device\n *   - Both device_read() AND device_write() implemented\n *   - Data flows: userspace ↔ kernel (bidirectional)\n *   - Stateful: stores data between operations\n *   - Requires dynamic memory management\n *\n * REAL-WORLD ANALOGY:\n * Problem 102 = Thermometer (read-only sensor)\n * Problem 103 = Notepad (read and write messages)\n */\n\n/* ========================================================================== */\n/* MEMORY MANAGEMENT IN KERNEL SPACE */\n/* ========================================================================== */\n/* CRITICAL DIFFERENCE: Kernel vs Userspace Memory\n *\n * USERSPACE (normal programs):\n *   char *buffer = kmalloc(1024);  // Userspace allocation\n *   kfree(buffer);                  // Userspace deallocation\n *\n * KERNEL SPACE (device drivers):\n *   char *buffer = kmalloc(1024, GFP_KERNEL);  // Kernel allocation\n *   kfree(buffer);                              // Kernel deallocation\n *\n * WHY DIFFERENT?\n * - Kernel runs in protected memory space\n * - Cannot use userspace malloc/free\n * - Must use kernel-specific allocators (kmalloc/kfree)\n * - Kernel memory is PHYSICAL memory (no virtual memory tricks)\n *\n * GFP_KERNEL FLAG EXPLAINED:\n * GFP = Get Free Pages\n * GFP_KERNEL = Standard allocation, can sleep (safe for most uses)\n * Other flags:\n *   - GFP_ATOMIC: Cannot sleep (use in interrupt handlers)\n *   - GFP_USER: Userspace allocation\n *   - GFP_DMA: DMA-capable memory\n */\n\n/* ========================================================================== */\n/* COPY_FROM_USER vs COPY_TO_USER */\n/* ========================================================================== */\n/* CRITICAL SECURITY PATTERN: Never trust userspace pointers!\n *\n * WHY WE NEED THESE FUNCTIONS:\n * - Kernel cannot directly access userspace memory (segmentation fault!)\n * - Userspace pointers may be invalid, malicious, or paged out\n * - Must use safe copy functions with validation\n *\n * COPY_TO_USER (kernel → userspace) - Used in READ:\n *   int copy_to_user(void __user *to, const void *from, unsigned long n)\n *   - to:   userspace destination pointer\n *   - from: kernel source pointer\n *   - n:    number of bytes to copy\n *   - Returns: 0 on success, bytes NOT copied on failure\n *\n *   Example in device_read():\n *   if (copy_to_user(buffer, message_buffer, message_size)) {\n *       return -EFAULT;  // Bad userspace address\n *   }\n *\n * COPY_FROM_USER (userspace → kernel) - Used in WRITE:\n *   unsigned long copy_from_user(void *to, const void __user *from, unsigned long n)\n *   - to:   kernel destination pointer\n *   - from: userspace source pointer\n *   - n:    number of bytes to copy\n *   - Returns: 0 on success, bytes NOT copied on failure\n *\n *   Example in device_write():\n *   if (copy_from_user(message_buffer, buffer, len)) {\n *       kfree(message_buffer);  // Clean up on error!\n *       return -EFAULT;\n *   }\n */\n\n/* ========================================================================== */\n/* DEVICE OPERATIONS: READ vs WRITE */\n/* ========================================================================== */\n/* UNDERSTANDING THE FLOW:\n *\n * USER WRITES TO DEVICE (echo \"Hello\" > /dev/message):\n * 1. Shell calls write() system call\n * 2. Kernel routes to device_write()\n * 3. device_write() uses copy_from_user() to get data\n * 4. Stores data in kernel buffer (message_buffer)\n * 5. Returns number of bytes written\n *\n * USER READS FROM DEVICE (cat /dev/message):\n * 1. Shell calls read() system call\n * 2. Kernel routes to device_read()\n * 3. device_read() uses copy_to_user() to send data\n * 4. Returns number of bytes read\n *\n * VISUAL FLOW:\n * echo \"Hello\" > /dev/message     cat /dev/message\n *        ↓                              ↑\n *   write() syscall                read() syscall\n *        ↓                              ↑\n *   device_write()                 device_read()\n *        ↓                              ↑\n *   copy_from_user()              copy_to_user()\n *        ↓                              ↑\n *   [message_buffer in kernel memory]\n */\n\n/* ========================================================================== */\n/* NOTE: Function Declarations */\n/* ========================================================================== */\n/* For character device drivers, the device operation functions (open, release,\n * read, write) are declared as 'static' in the .c file and are NOT declared\n * in the header file. They are internal to the driver module and only\n * referenced through the file_operations structure.\n *\n * This is standard practice in Linux kernel drivers:\n * - device_open(), device_release(), device_read(), device_write() -> static in .c\n * - Only public API functions (if any) go in headers\n * - module_init/module_exit are also internal (static __init/__exit)\n */\n\n#endif /* MESSAGE_DEV_H */\n",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "message_dev.c",
        "content": "#include \"message_dev.h\"\n\n/* Global state variables */\nstatic char *message_buffer = NULL;  /* Dynamically allocated message storage */\nstatic size_t message_size = 0;      /* Current message length */\nstatic int device_open_count = 0;    /* Number of times device is open */\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: Device Operations Implementation */\n/* ========================================================================== */\n\n/* TODO: Implement device_open function */\n/* REQUIREMENTS:\n * - Function signature: static int device_open(struct inode *inode, struct file *file)\n * - Increment device_open_count\n * - Print: \"Message device opened\"\n * - Return 0 for success\n *\n * This is IDENTICAL to Problem 102 - you've done this before!\n */\nstatic int device_open(struct inode *inode, struct file *file)\n{\n    /* TODO: Increment open count */\n    /* TODO: Print open message using printk(KERN_INFO, ...) */\n    /* TODO: Return 0 */\n    return 0;\n}\n\n/* TODO: Implement device_release function */\n/* REQUIREMENTS:\n * - Function signature: static int device_release(struct inode *inode, struct file *file)\n * - Decrement device_open_count\n * - Print: \"Message device closed\"\n * - Return 0 for success\n *\n * Also IDENTICAL to Problem 102!\n */\nstatic int device_release(struct inode *inode, struct file *file)\n{\n    /* TODO: Decrement open count */\n    /* TODO: Print close message using printk(KERN_INFO, ...) */\n    /* TODO: Return 0 */\n    return 0;\n}\n\n/* ========================================================================== */\n/* DEVICE_READ: Kernel → Userspace Data Transfer */\n/* ========================================================================== */\n/* TODO: Implement device_read function */\n/* REQUIREMENTS:\n * - Function signature: static ssize_t device_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)\n * - Check if message exists: if (!message_buffer || message_size == 0) return 0;\n * - Check if already read (EOF): if (*offset > 0) return 0;\n * - Determine bytes to read: min(len, message_size)\n * - Copy to userspace: if (copy_to_user(buffer, message_buffer, bytes_to_read)) return -EFAULT;\n * - Update offset: *offset += bytes_to_read;\n * - Print: \"Message read: X bytes\"\n * - Return bytes_to_read\n *\n * ALGORITHM:\n * 1. Validate message exists\n * 2. Check EOF condition (offset)\n * 3. Calculate bytes to copy\n * 4. Copy safely to userspace\n * 5. Update offset\n * 6. Return bytes copied\n */\nstatic ssize_t device_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)\n{\n    /* TODO: Check if message exists */\n    /* if (!message_buffer || message_size == 0) return 0; */\n    \n    /* TODO: Check if already read (EOF) */\n    /* if (*offset > 0) return 0; */\n    \n    /* TODO: Calculate bytes to read */\n    /* size_t bytes_to_read = (len < message_size) ? len : message_size; */\n    \n    /* TODO: Copy to userspace with error checking */\n    /* if (copy_to_user(buffer, message_buffer, bytes_to_read)) return -EFAULT; */\n    \n    /* TODO: Update offset */\n    /* *offset += bytes_to_read; */\n    \n    /* TODO: Print read message */\n    /* printk(KERN_INFO \"Message read: %zu bytes\\n\", bytes_to_read); */\n    \n    /* TODO: Return bytes read */\n    return 0;\n}\n\n/* ========================================================================== */\n/* DEVICE_WRITE: Userspace → Kernel Data Transfer (NEW!) */\n/* ========================================================================== */\n/* TODO: Implement device_write function */\n/* REQUIREMENTS:\n * - Function signature: static ssize_t device_write(struct file *file, const char __user *buffer, size_t len, loff_t *offset)\n * - Validate length: if (len > MAX_MESSAGE_SIZE) len = MAX_MESSAGE_SIZE;\n * - Free old buffer: if (message_buffer) kfree(message_buffer);\n * - Allocate new buffer: message_buffer = kmalloc(len, GFP_KERNEL);\n * - Check allocation: if (!message_buffer) return -ENOMEM;\n * - Copy from userspace: if (copy_from_user(message_buffer, buffer, len)) { kfree(message_buffer); return -EFAULT; }\n * - Store size: message_size = len;\n * - Print: \"Message written: X bytes\"\n * - Return len\n *\n * ALGORITHM:\n * 1. Validate input length\n * 2. Free old message buffer (if exists)\n * 3. Allocate new buffer with kmalloc\n * 4. Check allocation success\n * 5. Copy data from userspace\n * 6. Store message size\n * 7. Return bytes written\n *\n * CRITICAL MEMORY MANAGEMENT:\n * - Always free old buffer before allocating new one (prevent memory leak)\n * - Check kmalloc return value (allocation can fail!)\n * - On copy_from_user error, free the buffer before returning\n * - This prevents memory leaks on error conditions\n */\nstatic ssize_t device_write(struct file *file, const char __user *buffer, size_t len, loff_t *offset)\n{\n    /* TODO: Validate and cap length */\n    /* if (len > MAX_MESSAGE_SIZE) len = MAX_MESSAGE_SIZE; */\n    \n    /* TODO: Free old buffer if exists */\n    /* if (message_buffer) kfree(message_buffer); */\n    \n    /* TODO: Allocate new buffer */\n    /* message_buffer = kmalloc(len, GFP_KERNEL); */\n    /* if (!message_buffer) return -ENOMEM; */\n    \n    /* TODO: Copy from userspace with error checking */\n    /* if (copy_from_user(message_buffer, buffer, len)) { */\n    /*     kfree(message_buffer); */\n    /*     message_buffer = NULL; */\n    /*     return -EFAULT; */\n    /* } */\n    \n    /* TODO: Store message size */\n    /* message_size = len; */\n    \n    /* TODO: Print write message */\n    /* printk(KERN_INFO \"Message written: %zu bytes\\n\", len); */\n    \n    /* TODO: Return bytes written */\n    return 0;\n}\n\n/* ========================================================================== */\n/* FILE OPERATIONS STRUCTURE */\n/* ========================================================================== */\n/* TODO: Define file_operations structure */\n/* REQUIREMENTS:\n * - Include .owner = THIS_MODULE\n * - Include .read = device_read\n * - Include .write = device_write  (NEW!)\n * - Include .open = device_open\n * - Include .release = device_release\n *\n * This tells the kernel which functions to call for each operation.\n */\nstatic struct file_operations fops = {\n    /* TODO: Set .owner = THIS_MODULE */\n    /* TODO: Set .read = device_read */\n    /* TODO: Set .write = device_write */\n    /* TODO: Set .open = device_open */\n    /* TODO: Set .release = device_release */\n};\n\n/* ========================================================================== */\n/* MODULE INITIALIZATION */\n/* ========================================================================== */\n/* TODO: Implement message_init function */\n/* REQUIREMENTS:\n * - Function signature: static int __init message_init(void)\n * - Register character device: register_chrdev(MAJOR_NUM, DEVICE_NAME, &fops)\n * - Check registration result (< 0 means error)\n * - Initialize message_buffer to NULL\n * - Print success message with major number\n * - Print device creation instructions\n * - Return 0 on success, negative error code on failure\n *\n * Same pattern as Problem 102!\n */\nstatic int __init message_init(void)\n{\n    int result;\n    \n    /* TODO: Register character device */\n    /* result = register_chrdev(MAJOR_NUM, DEVICE_NAME, &fops); */\n    /* if (result < 0) { */\n    /*     printk(KERN_ALERT \"Message device registration failed: %d\\n\", result); */\n    /*     return result; */\n    /* } */\n    \n    /* TODO: Initialize message buffer */\n    /* message_buffer = NULL; */\n    /* message_size = 0; */\n    \n    /* TODO: Print success messages */\n    /* printk(KERN_INFO \"Message device registered with major number %d\\n\", MAJOR_NUM); */\n    /* printk(KERN_INFO \"Create device with: mknod /dev/%s c %d 0\\n\", DEVICE_NAME, MAJOR_NUM); */\n    \n    return 0;\n}\n\n/* ========================================================================== */\n/* MODULE CLEANUP */\n/* ========================================================================== */\n/* TODO: Implement message_exit function */\n/* REQUIREMENTS:\n * - Function signature: static void __exit message_exit(void)\n * - Free message buffer if allocated: if (message_buffer) kfree(message_buffer);\n * - Unregister device: unregister_chrdev(MAJOR_NUM, DEVICE_NAME)\n * - Print cleanup message\n *\n * CRITICAL: Must free allocated memory before unloading!\n * This prevents memory leaks in the kernel.\n */\nstatic void __exit message_exit(void)\n{\n    /* TODO: Free message buffer if allocated */\n    /* if (message_buffer) { */\n    /*     kfree(message_buffer); */\n    /*     message_buffer = NULL; */\n    /* } */\n    \n    /* TODO: Unregister device */\n    /* unregister_chrdev(MAJOR_NUM, DEVICE_NAME); */\n    \n    /* TODO: Print cleanup message */\n    /* printk(KERN_INFO \"Message device unregistered\\n\"); */\n}\n\n/* Register init and exit functions */\nmodule_init(message_init);\nmodule_exit(message_exit);\n\n/* Module metadata */\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Character device with read/write operations\");\nMODULE_VERSION(\"1.0\");\n",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# Message device module Makefile\nobj-m += message_dev.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help\n",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "message_dev.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "message_init",
          "message_exit",
          "device_open",
          "device_release",
          "device_read",
          "device_write"
        ],
        "macro_declarations": [
          {
            "name": "DEVICE_NAME",
            "type": "constant",
            "value": "\"message\"",
            "description": "Character device name"
          },
          {
            "name": "MAJOR_NUM",
            "type": "constant",
            "value": "241",
            "description": "Device major number"
          },
          {
            "name": "MAX_MESSAGE_SIZE",
            "type": "constant",
            "value": "1024",
            "description": "Maximum message buffer size"
          }
        ],
        "variables": [
          {
            "name": "message_buffer",
            "type": "char *",
            "value": "NULL",
            "storageClass": "static"
          },
          {
            "name": "message_size",
            "type": "size_t",
            "value": "0",
            "storageClass": "static"
          },
          {
            "name": "device_open_count",
            "type": "int",
            "value": "0",
            "storageClass": "static"
          },
          {
            "name": "fops",
            "type": "struct file_operations",
            "value": "{.owner = THIS_MODULE, .read = device_read, .write = device_write, .open = device_open, .release = device_release}",
            "storageClass": "static"
          }
        ],
        "outputMessages": [
          "Message device registered with major number 241",
          "Create device with: mknod /dev/message c 241 0",
          "Message device opened",
          "Message written: 13 bytes",
          "Message read: 13 bytes",
          "Message device closed",
          "Message device unregistered"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/fs.h",
          "linux/uaccess.h",
          "linux/slab.h"
        ],
        "mustContain": [
          "register_chrdev(MAJOR_NUM, DEVICE_NAME, &fops)",
          "unregister_chrdev(MAJOR_NUM, DEVICE_NAME)",
          "copy_to_user",
          "copy_from_user",
          "kmalloc",
          "kfree",
          "GFP_KERNEL",
          ".write = device_write",
          "if (message_buffer)",
          "message_size = len"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "macro_definitions",
          "name": "Macro Definitions",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "#define DEVICE_NAME \"message\"",
            "#define MAJOR_NUM 241",
            "#define MAX_MESSAGE_SIZE 1024"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Implementations in Source",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "static int device_open(struct inode *inode, struct file *file)",
            "static int device_release(struct inode *inode, struct file *file)",
            "static ssize_t device_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)",
            "static ssize_t device_write(struct file *file, const char __user *buffer, size_t len, loff_t *offset)",
            "static int __init message_init(void)",
            "static void __exit message_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "file_operations_structure",
          "name": "File Operations Structure with Write",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "static struct file_operations fops",
            ".owner = THIS_MODULE",
            ".read = device_read",
            ".write = device_write",
            ".open = device_open",
            ".release = device_release"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "memory_management_api",
          "name": "Memory Management API Usage",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "kmalloc",
            "kfree",
            "GFP_KERNEL",
            "copy_from_user",
            "copy_to_user",
            "if (message_buffer)",
            "message_buffer = NULL"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "Message device registered with major number 241",
              "exact": true,
              "linkedFunction": "static int __init message_init(void)"
            },
            {
              "pattern": "Create device with: mknod /dev/message c 241 0",
              "exact": true,
              "linkedFunction": "static int __init message_init(void)"
            },
            {
              "pattern": "Message device opened",
              "exact": true,
              "linkedFunction": "static int device_open(struct inode *inode, struct file *file)"
            },
            {
              "pattern": "Message written: .* bytes",
              "exact": false,
              "linkedFunction": "static ssize_t device_write(struct file *file, const char __user *buffer, size_t len, loff_t *offset)"
            },
            {
              "pattern": "Message read: .* bytes",
              "exact": false,
              "linkedFunction": "static ssize_t device_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)"
            },
            {
              "pattern": "Message device closed",
              "exact": true,
              "linkedFunction": "static int device_release(struct inode *inode, struct file *file)"
            },
            {
              "pattern": "Message device unregistered",
              "exact": true,
              "linkedFunction": "static void __exit message_exit(void)"
            }
          ]
        },
        {
          "id": "comprehensive_message_device_validation",
          "name": "Comprehensive Message Device Write/Read Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "userspaceApps": [],
            "setupCommands": [
              "echo 'Starting comprehensive message device validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: TCC Header Validation'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_ALERT' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define THIS_MODULE ((void*)0)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'typedef long long loff_t;' > /tmp/linux/types.h",
              "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
              "echo 'typedef long ssize_t;' >> /tmp/linux/types.h",
              "echo '#define __user' >> /tmp/linux/types.h",
              "echo '#include <linux/types.h>' > /tmp/linux/fs.h",
              "echo 'struct inode { int i_rdev; };' >> /tmp/linux/fs.h",
              "echo 'struct file { void *private_data; };' >> /tmp/linux/fs.h",
              "echo 'struct file_operations { void *owner; int (*open)(struct inode*, struct file*); int (*release)(struct inode*, struct file*); ssize_t (*read)(struct file*, char*, size_t, loff_t*); ssize_t (*write)(struct file*, const char*, size_t, loff_t*); };' >> /tmp/linux/fs.h",
              "echo 'int register_chrdev(unsigned int major, const char *name, struct file_operations *fops);' >> /tmp/linux/fs.h",
              "echo 'void unregister_chrdev(unsigned int major, const char *name);' >> /tmp/linux/fs.h",
              "echo 'unsigned long copy_to_user(void *to, const void *from, unsigned long n);' > /tmp/linux/uaccess.h",
              "echo 'unsigned long copy_from_user(void *to, const void *from, unsigned long n);' >> /tmp/linux/uaccess.h",
              "echo 'void *kmalloc(size_t size, int flags);' > /tmp/linux/slab.h",
              "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
              "echo '#define GFP_KERNEL 0' >> /tmp/linux/slab.h",
              "echo '#include \"/lib/modules/message_dev.h\"' > /tmp/test.c",
              "echo 'int main() { return 0; }' >> /tmp/test.c",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Header file has compilation errors'; cat /tmp/tcc_error.log; else echo 'PASS: Header file compiles successfully'; fi",
              "",
              "echo 'Phase 2: Module Loading and Device Creation'",
              "insmod /lib/modules/message_dev.ko",
              "sleep 1",
              "dmesg | grep 'Message device registered with major number 241' && echo 'PASS: Device registration successful' || echo 'FAIL: Device registration failed'",
              "dmesg | grep 'Create device with: mknod /dev/message c 241 0' && echo 'PASS: Device creation instructions printed' || echo 'FAIL: Missing instructions'",
              "",
              "echo 'Phase 3: Create Device Node'",
              "mknod /dev/message c 241 0",
              "chmod 666 /dev/message",
              "ls -l /dev/message && echo 'PASS: Device node created' || echo 'FAIL: Device node creation failed'",
              "",
              "echo 'Phase 4: Write First Message'",
              "echo -n 'Hello Kernel!' > /dev/message",
              "sleep 1",
              "dmesg | grep 'Message written: 13 bytes' && echo 'PASS: First write successful (13 bytes)' || echo 'FAIL: First write failed'",
              "",
              "echo 'Phase 5: Read First Message'",
              "READ_OUTPUT=$(cat /dev/message)",
              "echo \"Read output: '$READ_OUTPUT'\"",
              "if [ \"$READ_OUTPUT\" = 'Hello Kernel!' ]; then echo 'PASS: Read returned correct message'; else echo 'FAIL: Read returned wrong message'; fi",
              "dmesg | grep 'Message read: 13 bytes' && echo 'PASS: Read byte count correct' || echo 'FAIL: Read byte count wrong'",
              "",
              "echo 'Phase 6: Write Second Message (Buffer Replacement)'",
              "echo -n 'New Message' > /dev/message",
              "sleep 1",
              "dmesg | grep 'Message written: 11 bytes' && echo 'PASS: Second write successful (11 bytes)' || echo 'FAIL: Second write failed'",
              "",
              "echo 'Phase 7: Read Second Message'",
              "READ_OUTPUT2=$(cat /dev/message)",
              "echo \"Read output: '$READ_OUTPUT2'\"",
              "if [ \"$READ_OUTPUT2\" = 'New Message' ]; then echo 'PASS: Read returned updated message'; else echo 'FAIL: Read returned wrong message'; fi",
              "dmesg | grep 'Message read: 11 bytes' && echo 'PASS: Updated read byte count correct' || echo 'FAIL: Updated read byte count wrong'",
              "",
              "echo 'Phase 8: Write Long Message (Size Limit)'",
              "dd if=/dev/zero bs=1 count=2048 2>/dev/null | tr '\\000' 'A' > /tmp/longmsg",
              "cat /tmp/longmsg > /dev/message",
              "sleep 1",
              "WRITTEN_BYTES=$(dmesg | grep 'Message written:' | tail -1 | grep -o '[0-9]* bytes' | grep -o '[0-9]*')",
              "if [ \"$WRITTEN_BYTES\" -le 1024 ]; then echo 'PASS: Message size capped at MAX_MESSAGE_SIZE'; else echo 'FAIL: Message size not capped properly'; fi",
              "",
              "echo 'Phase 9: Device Open/Close Tracking'",
              "dmesg | grep 'Message device opened' && echo 'PASS: Device open logged' || echo 'FAIL: Device open not logged'",
              "dmesg | grep 'Message device closed' && echo 'PASS: Device close logged' || echo 'FAIL: Device close not logged'",
              "",
              "echo 'Phase 10: Module Unload and Cleanup'",
              "rm -f /dev/message",
              "rmmod message_dev",
              "sleep 1",
              "dmesg | grep 'Message device unregistered' && echo 'PASS: Device unregistered successfully' || echo 'FAIL: Device unregistration failed'",
              "",
              "echo 'Phase 11: Memory Management Validation'",
              "dmesg | grep 'kfree' && echo 'INFO: kfree calls detected (good cleanup)' || echo 'INFO: kfree not in logs (expected if optimized)'",
              "",
              "echo 'PASS: All comprehensive message device validation phases completed successfully'"
            ],
            "expected": {
              "dmesg": [
                "Message device registered with major number 241",
                "Create device with: mknod /dev/message c 241 0",
                "Message device opened",
                "Message written: 13 bytes",
                "Message read: 13 bytes",
                "Message written: 11 bytes",
                "Message read: 11 bytes",
                "Message device closed",
                "Message device unregistered"
              ],
              "stdout": [
                "PASS: Header file compiles successfully",
                "PASS: Device registration successful",
                "PASS: Device creation instructions printed",
                "PASS: Device node created",
                "PASS: First write successful \\(13 bytes\\)",
                "PASS: Read returned correct message",
                "PASS: Read byte count correct",
                "PASS: Second write successful \\(11 bytes\\)",
                "PASS: Read returned updated message",
                "PASS: Updated read byte count correct",
                "PASS: Message size capped at MAX_MESSAGE_SIZE",
                "PASS: Device open logged",
                "PASS: Device close logged",
                "PASS: Device unregistered successfully",
                "PASS: All comprehensive message device validation phases completed successfully"
              ]
            },
            "timeout": 30
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "Message device registered with major number 241",
        "Create device with: mknod /dev/message c 241 0",
        "Message device opened",
        "Message written: 13 bytes",
        "Message read: 13 bytes",
        "Message device closed",
        "Message device unregistered"
      ],
      "requirements": [
        "Use required function names: message_init, message_exit, device_open, device_release, device_read, device_write",
        "Use required variable names: message_buffer, message_size, device_open_count, fops",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/fs.h, linux/uaccess.h, linux/slab.h",
        "Code must contain: register_chrdev(MAJOR_NUM, DEVICE_NAME, &fops), unregister_chrdev(MAJOR_NUM, DEVICE_NAME), copy_to_user, copy_from_user, kmalloc, kfree, GFP_KERNEL, .write = device_write, if (message_buffer), message_size = len",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "Message device registered with major number 241",
          "linkedFunction": "static int __init message_init(void)",
          "exact": true
        },
        {
          "pattern": "Create device with: mknod /dev/message c 241 0",
          "linkedFunction": "static int __init message_init(void)",
          "exact": true
        },
        {
          "pattern": "Message device opened",
          "linkedFunction": "static int device_open(struct inode *inode, struct file *file)",
          "exact": true
        },
        {
          "pattern": "Message written: .* bytes",
          "linkedFunction": "static ssize_t device_write(struct file *file, const char __user *buffer, size_t len, loff_t *offset)",
          "exact": false
        },
        {
          "pattern": "Message read: .* bytes",
          "linkedFunction": "static ssize_t device_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)",
          "exact": false
        },
        {
          "pattern": "Message device closed",
          "linkedFunction": "static int device_release(struct inode *inode, struct file *file)",
          "exact": true
        },
        {
          "pattern": "Message device unregistered",
          "linkedFunction": "static void __exit message_exit(void)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 107,
    "title": "Basic PCI GPU Detection - Your First Graphics Driver",
    "difficulty": 6,
    "xp": 50,
    "phase": "kernel_core",
    "description": "Learn the absolute basics of GPU driver development by detecting a PCI graphics device. This is the first step every GPU driver takes - whether AMD, NVIDIA, or Intel. You'll learn PCI enumeration, vendor/device IDs, and basic PCI device structure.",
    "concepts": [
      "PCI device enumeration",
      "PCI vendor and device IDs",
      "PCI driver structure",
      "Device probe and remove functions",
      "GPU driver initialization basics",
      "pci_enable_device() usage"
    ],
    "skills": [
      "Understanding PCI bus architecture",
      "Creating PCI device ID tables",
      "Implementing probe and remove functions",
      "Using pci_dev structure members",
      "Basic GPU driver registration",
      "PCI address interpretation"
    ],
    "files": [
      {
        "name": "pci_gpu_detect.h",
        "content": "#ifndef PCI_GPU_DETECT_H\n#define PCI_GPU_DETECT_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n\n/* PCI Device ID for our virtual GPU */\n/* bochs-display uses vendor 0x1234, device 0x1111 */\n#define GPU_VENDOR_ID 0x1234\n#define GPU_DEVICE_ID 0x1111\n\n/* NOTE: Probe and remove functions are static (internal to the driver module)\n * They are NOT declared in the header because they're only referenced by\n * the pci_driver structure within pci_gpu_detect.c. This is standard practice\n * for PCI drivers in the Linux kernel.\n */\n\n#endif /* PCI_GPU_DETECT_H */",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "pci_gpu_detect.c",
        "content": "#include \"pci_gpu_detect.h\"\n\n/* WHAT IS PCI AND WHY DO WE NEED IT? */\n/* PCI (Peripheral Component Interconnect) is the bus system that connects */\n/* hardware devices like GPUs to your computer's CPU and memory. */\n/* */\n/* Think of PCI like a highway system: */\n/* - CPU/Memory = City center */\n/* - PCI Bus = Highway */\n/* - GPU = Suburb that needs highway access */\n/* */\n/* Every PCI device (GPU, network card, disk controller) needs: */\n/* 1. A way to identify itself (vendor ID + device ID) */\n/* 2. A driver to control it */\n/* 3. Memory-mapped I/O regions to communicate */\n\n/* PCI DEVICE IDENTIFICATION */\n/* Every PCI device has two identifying numbers: */\n/* - Vendor ID: Who made the device? (AMD=0x1002, NVIDIA=0x10de, Intel=0x8086) */\n/* - Device ID: Which specific device is it? (RTX 3070=0x2484, RX 6800=0x73bf) */\n/* */\n/* Our virtual GPU (bochs-display): */\n/* - Vendor ID: 0x1234 (QEMU's vendor ID) */\n/* - Device ID: 0x1111 (bochs VGA device ID) */\n\n/* PCI DEVICE TABLE - CRITICAL CONCEPT */\n/* This table tells the kernel: \"My driver can handle these devices\" */\n/* The kernel automatically calls your probe() function when it finds a match! */\n/* */\n/* Real-world examples: */\n/* AMD amdgpu driver supports ~200 device IDs (all AMD GPUs) */\n/* NVIDIA nouveau driver supports ~300 device IDs (all NVIDIA GPUs) */\n/* Intel i915 driver supports ~150 device IDs (all Intel GPUs) */\n\n/* TODO: Create PCI device table */\n/* PATTERN: Define which devices your driver supports */\n/* static const struct pci_device_id gpu_pci_table[] = { */\n/*     { PCI_DEVICE(GPU_VENDOR_ID, GPU_DEVICE_ID) }, */\n/*     { 0, }  // Terminator entry (always required!) */\n/* }; */\n/* MODULE_DEVICE_TABLE(pci, gpu_pci_table); */\n/* Your implementation here */\n\n/* WHAT HAPPENS DURING DEVICE PROBE? */\n/* When kernel finds your GPU: */\n/* 1. Kernel: \"I found device 0x1234:0x1111 on PCI bus!\" */\n/* 2. Kernel: \"Does any driver support this device?\" */\n/* 3. Kernel: \"Yes! gpu_pci_detect driver says it supports 0x1234:0x1111\" */\n/* 4. Kernel: \"Calling gpu_pci_probe() function...\" */\n/* 5. Your probe function: Initialize the device, allocate resources */\n\n/* PCI PROBE FUNCTION - DRIVER ENTRY POINT */\n/* This function is called AUTOMATICALLY by the kernel when: */\n/* - System boots and finds your GPU */\n/* - You load your driver module with 'insmod' */\n/* - GPU is hot-plugged (rare for desktop GPUs, common for external GPUs) */\n\n/* TODO: Implement probe function */\n/* WHAT YOUR PROBE FUNCTION SHOULD DO (simplified for learning): */\n/* 1. Print that probe was called (you've been chosen!) */\n/* 2. Print device location (which PCI slot/address) */\n/* 3. Print vendor ID and device ID (confirm it's the right device) */\n/* 4. Print device name (helpful for users to see what was detected) */\n/* 5. Enable the PCI device (tell hardware we want to use it) */\n/* 6. Print success message */\n/* */\n/* PARAMETERS EXPLAINED: */\n/* - struct pci_dev *pdev: Pointer to PCI device structure (contains all device info) */\n/* - const struct pci_device_id *id: Which entry from gpu_pci_table matched */\n/* */\n/* RETURN VALUE: */\n/* - Return 0 on success (device initialized correctly) */\n/* - Return negative error code on failure (like -ENOMEM for out of memory) */\n/* */\n/* DEVICE STRUCTURE FIELDS YOU'LL USE: */\n/* - pdev->bus->number: Which PCI bus this device is on (0, 1, 2...) */\n/* - pdev->devfn: Device and function number combined */\n/*   - PCI_SLOT(pdev->devfn): Extract device number (0-31) */\n/*   - PCI_FUNC(pdev->devfn): Extract function number (0-7) */\n/* - pdev->vendor: Vendor ID (should be 0x1234) */\n/* - pdev->device: Device ID (should be 0x1111) */\n/* */\n/* REAL-WORLD EXAMPLE FROM AMD AMDGPU DRIVER: */\n/* static int amdgpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent) { */\n/*     printk(\"amdgpu: Probing device %04x:%04x\", pdev->vendor, pdev->device); */\n/*     ret = pci_enable_device(pdev);  // Enable the device */\n/*     // ... lots more initialization code ... */\n/*     return 0; */\n/* } */\n/* */\n/* WHAT pci_enable_device() DOES: */\n/* - Turns on power to the device */\n/* - Enables device to access PCI bus */\n/* - Enables device to generate interrupts */\n/* - Prepares device for memory-mapped I/O */\n/* Without this, the device is present but inactive! */\nstatic int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n    int ret;\n    \n    /* TODO: Step 1 - Print probe message */\n    /* HINT: printk(KERN_INFO \"GPU Driver: Probing device...\\n\"); */\n    \n    /* TODO: Step 2 - Print PCI location */\n    /* HINT: printk(KERN_INFO \"GPU Driver: Found at %04x:%02x:%02x.%d\\n\", */\n    /*              pci_domain_nr(pdev->bus), pdev->bus->number, */\n    /*              PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn)); */\n    /* */\n    /* EXPLANATION OF PCI ADDRESS FORMAT: %04x:%02x:%02x.%d */\n    /* - %04x = Domain (usually 0000, used in multi-domain systems) */\n    /* - %02x = Bus number (0-255) */\n    /* - %02x = Device/Slot number (0-31) */\n    /* - %d  = Function number (0-7) */\n    /* Example: 0000:00:05.0 means domain 0, bus 0, slot 5, function 0 */\n    \n    /* TODO: Step 3 - Print vendor and device ID */\n    /* HINT: printk(KERN_INFO \"GPU Driver: Device %04x:%04x\\n\", */\n    /*              pdev->vendor, pdev->device); */\n    \n    /* TODO: Step 4 - Enable the PCI device */\n    /* HINT: ret = pci_enable_device(pdev); */\n    /*       if (ret) { */\n    /*           printk(KERN_ERR \"GPU Driver: Failed to enable device\\n\"); */\n    /*           return ret; */\n    /*       } */\n    \n    /* TODO: Step 5 - Print success message */\n    /* HINT: printk(KERN_INFO \"GPU Driver: Device initialized successfully\\n\"); */\n    \n    /* Your implementation here */\n    return 0;\n}\n\n/* PCI REMOVE FUNCTION - CLEANUP */\n/* This function is called when: */\n/* - You unload your driver module with 'rmmod' */\n/* - System shuts down */\n/* - Device is hot-unplugged */\n/* */\n/* IMPORTANT: Always cleanup resources in remove! */\n/* - Disable interrupts */\n/* - Free allocated memory */\n/* - Release PCI regions */\n/* - Disable device */\n\n/* TODO: Implement remove function */\n/* WHAT YOUR REMOVE FUNCTION SHOULD DO: */\n/* 1. Print that device is being removed */\n/* 2. Disable the PCI device (reverse of pci_enable_device) */\n/* 3. Print cleanup complete message */\n/* */\n/* REAL-WORLD EXAMPLE FROM AMD AMDGPU: */\n/* static void amdgpu_pci_remove(struct pci_dev *pdev) { */\n/*     printk(\"amdgpu: Removing device\"); */\n/*     amdgpu_driver_unload_kms(pdev);  // Unload driver */\n/*     pci_disable_device(pdev);        // Disable device */\n/* } */\nstatic void gpu_pci_remove(struct pci_dev *pdev)\n{\n    /* TODO: Step 1 - Print removal message */\n    /* HINT: printk(KERN_INFO \"GPU Driver: Removing device\\n\"); */\n    \n    /* TODO: Step 2 - Disable PCI device */\n    /* HINT: pci_disable_device(pdev); */\n    \n    /* TODO: Step 3 - Print cleanup message */\n    /* HINT: printk(KERN_INFO \"GPU Driver: Device cleanup complete\\n\"); */\n    \n    /* Your implementation here */\n}\n\n/* PCI DRIVER STRUCTURE - GLUES EVERYTHING TOGETHER */\n/* This structure tells the kernel: */\n/* - What your driver is called */\n/* - Which devices it supports (id_table) */\n/* - What functions to call for probe/remove */\n/* */\n/* The kernel uses this structure to manage your driver */\n\n/* TODO: Create PCI driver structure */\n/* PATTERN: Define your driver's properties */\n/* static struct pci_driver gpu_pci_driver = { */\n/*     .name     = \"simple_gpu_driver\", */\n/*     .id_table = gpu_pci_table, */\n/*     .probe    = gpu_pci_probe, */\n/*     .remove   = gpu_pci_remove, */\n/* }; */\n/* Your implementation here */\n\n/* MODULE REGISTRATION MACRO */\n/* This macro automatically generates module_init() and module_exit() */\n/* functions that register/unregister your PCI driver */\n/* */\n/* module_pci_driver(gpu_pci_driver) expands to: */\n/* static int __init gpu_init(void) { return pci_register_driver(&gpu_pci_driver); } */\n/* static void __exit gpu_exit(void) { pci_unregister_driver(&gpu_pci_driver); } */\n/* module_init(gpu_init); */\n/* module_exit(gpu_exit); */\n\n/* TODO: Register PCI driver using convenience macro */\n/* HINT: module_pci_driver(gpu_pci_driver); */\n/* Your implementation here */\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"KernelQ Student\");\nMODULE_DESCRIPTION(\"Simple PCI GPU Detection Driver - Learning GPU Driver Basics\");\nMODULE_VERSION(\"1.0\");",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# PCI GPU detection driver Makefile\nobj-m += pci_gpu_detect.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "pci_gpu_detect.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "gpu_pci_probe",
          "gpu_pci_remove"
        ],
        "macro_declarations": [
          {
            "name": "GPU_VENDOR_ID",
            "type": "constant",
            "value": "0x1234",
            "description": "PCI vendor ID for QEMU (bochs-display GPU)"
          },
          {
            "name": "GPU_DEVICE_ID",
            "type": "constant",
            "value": "0x1111",
            "description": "PCI device ID for bochs VGA device"
          }
        ],
        "variables": [
          {
            "name": "gpu_pci_table",
            "type": "const struct pci_device_id",
            "value": "[{ PCI_DEVICE(GPU_VENDOR_ID, GPU_DEVICE_ID) }, { 0, }]",
            "storageClass": "static"
          },
          {
            "name": "gpu_pci_driver",
            "type": "struct pci_driver",
            "value": "{.name = \"simple_gpu_driver\", .id_table = gpu_pci_table, .probe = gpu_pci_probe, .remove = gpu_pci_remove}",
            "storageClass": "static"
          }
        ],
        "outputMessages": [
          "GPU Driver: Probing device",
          "GPU Driver: Found at 0000:00:05.0",
          "GPU Driver: Device 1234:1111",
          "GPU Driver: Device initialized successfully",
          "GPU Driver: Removing device",
          "GPU Driver: Device cleanup complete"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/pci.h"
        ],
        "mustContain": [
          "static const struct pci_device_id gpu_pci_table[]",
          "{ PCI_DEVICE(GPU_VENDOR_ID, GPU_DEVICE_ID) }",
          "{ 0, }",
          "MODULE_DEVICE_TABLE(pci, gpu_pci_table)",
          "static struct pci_driver gpu_pci_driver",
          ".name = \"simple_gpu_driver\"",
          ".id_table = gpu_pci_table",
          ".probe = gpu_pci_probe",
          ".remove = gpu_pci_remove",
          "module_pci_driver(gpu_pci_driver)",
          "pci_enable_device(pdev)",
          "pci_disable_device(pdev)",
          "pci_domain_nr(pdev->bus)",
          "PCI_SLOT(pdev->devfn)",
          "PCI_FUNC(pdev->devfn)"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "macro_definitions_header",
          "name": "Macro Definitions in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "#define GPU_VENDOR_ID 0x1234",
            "#define GPU_DEVICE_ID 0x1111"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "header_includes",
          "name": "Required Header File Includes",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/pci.h>"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "pci_device_table_structure",
          "name": "PCI Device ID Table Structure",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "static const struct pci_device_id gpu_pci_table",
            "PCI_DEVICE",
            "GPU_VENDOR_ID",
            "GPU_DEVICE_ID",
            "{ 0, }",
            "MODULE_DEVICE_TABLE",
            "pci",
            "gpu_pci_table"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "pci_driver_structure",
          "name": "PCI Driver Structure Definition",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "static struct pci_driver gpu_pci_driver",
            ".name",
            "simple_gpu_driver",
            ".id_table",
            "gpu_pci_table",
            ".probe",
            "gpu_pci_probe",
            ".remove",
            "gpu_pci_remove",
            "module_pci_driver",
            "gpu_pci_driver"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "probe_function_implementation",
          "name": "Probe Function Implementation",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "static int gpu_pci_probe",
            "struct pci_dev *pdev",
            "const struct pci_device_id *id",
            "pci_enable_device",
            "pci_domain_nr",
            "pdev->bus",
            "PCI_SLOT",
            "PCI_FUNC",
            "pdev->vendor",
            "pdev->device",
            "GPU Driver: Probing device",
            "GPU Driver: Found at",
            "GPU Driver: Device",
            "GPU Driver: Device initialized successfully"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "remove_function_implementation",
          "name": "Remove Function Implementation",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "static void gpu_pci_remove",
            "struct pci_dev *pdev",
            "pci_disable_device",
            "GPU Driver: Removing device",
            "GPU Driver: Device cleanup complete"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "pci_api_calls",
          "name": "Required PCI API Function Calls",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "ret = pci_enable_device(pdev)",
            "pci_disable_device(pdev)",
            "pdev->vendor",
            "pdev->device",
            "pdev->bus->number",
            "pdev->devfn"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Signatures in Source File",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)",
            "static void gpu_pci_remove(struct pci_dev *pdev)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages with Function Attribution",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "GPU Driver: Probing device",
              "exact": true,
              "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
            },
            {
              "pattern": "GPU Driver: Found at 0000:00:05.0",
              "exact": true,
              "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
            },
            {
              "pattern": "GPU Driver: Device 1234:1111",
              "exact": true,
              "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
            },
            {
              "pattern": "GPU Driver: Device initialized successfully",
              "exact": true,
              "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
            },
            {
              "pattern": "GPU Driver: Removing device",
              "exact": true,
              "linkedFunction": "static void gpu_pci_remove(struct pci_dev *pdev)"
            },
            {
              "pattern": "GPU Driver: Device cleanup complete",
              "exact": true,
              "linkedFunction": "static void gpu_pci_remove(struct pci_dev *pdev)"
            }
          ]
        },
        {
          "id": "pci_gpu_detection_test",
          "name": "PCI GPU Device Detection and Initialization",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "qemuArgs": [
              "-device",
              "bochs-display,addr=05.0",
              "-vga",
              "none"
            ],
            "userspaceApps": [
              {
                "name": "pci_gpu_tester",
                "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\\\"=== PCI GPU Detection Test ===\\\\n\\\");\\n    \\n    printf(\\\"Phase 1: Checking PCI device presence\\\\n\\\");\\n    system(\\\"ls /sys/bus/pci/devices/0000:00:05.0 > /dev/null 2>&1 && echo 'PASS: PCI device found' || echo 'FAIL: PCI device not found'\\\");\\n    \\n    printf(\\\"Phase 2: Loading GPU driver module\\\\n\\\");\\n    system(\\\"insmod /lib/modules/pci_gpu_detect.ko\\\");\\n    system(\\\"sleep 1\\\");\\n    system(\\\"lsmod | grep pci_gpu_detect && echo 'PASS: Module loaded' || echo 'FAIL: Module not loaded'\\\");\\n    \\n    printf(\\\"Phase 3: Checking driver binding\\\\n\\\");\\n    system(\\\"if [ -e /sys/bus/pci/devices/0000:00:05.0/driver ]; then echo 'PASS: Driver bound to device'; else echo 'FAIL: Driver not bound'; fi\\\");\\n    \\n    printf(\\\"SUCCESS: PCI GPU driver test completed\\\\n\\\");\\n    return 0;\\n}"
              }
            ],
            "setupCommands": [
              "echo 'Starting PCI GPU detection validation'"
            ],
            "testCommands": [
              "echo '=== Phase 1: TCC Header Validation ==='",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'struct pci_dev { unsigned short vendor; unsigned short device; struct pci_bus *bus; unsigned int devfn; };' > /tmp/linux/pci.h",
              "echo 'struct pci_device_id { unsigned int vendor; unsigned int device; };' >> /tmp/linux/pci.h",
              "echo 'struct pci_bus { int number; };' >> /tmp/linux/pci.h",
              "echo '#define PCI_DEVICE(vend,dev) .vendor = (vend), .device = (dev)' >> /tmp/linux/pci.h",
              "echo 'int pci_enable_device(struct pci_dev *dev);' >> /tmp/linux/pci.h",
              "echo 'void pci_disable_device(struct pci_dev *dev);' >> /tmp/linux/pci.h",
              "echo 'int pci_domain_nr(struct pci_bus *bus);' >> /tmp/linux/pci.h",
              "echo '#define PCI_SLOT(devfn) (((devfn) >> 3) & 0x1f)' >> /tmp/linux/pci.h",
              "echo '#define PCI_FUNC(devfn) ((devfn) & 0x07)' >> /tmp/linux/pci.h",
              "echo '#include \"/lib/modules/pci_gpu_detect.h\"' > /tmp/test.c",
              "echo 'int main() { unsigned short vendor = GPU_VENDOR_ID; unsigned short device = GPU_DEVICE_ID; return (vendor == 0x1234 && device == 0x1111) ? 0 : 1; }' >> /tmp/test.c",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Header file validation failed'; cat /tmp/tcc_error.log; else echo 'PASS: Header file includes and macros validated'; fi",
              "",
              "echo '=== Phase 2: PCI Device Enumeration Check ==='",
              "ls /sys/bus/pci/devices/0000:00:05.0 && echo 'PASS: GPU device present on PCI bus' || echo 'FAIL: GPU device not found'",
              "",
              "echo '=== Phase 3: Vendor and Device ID Verification ==='",
              "VENDOR=$(cat /sys/bus/pci/devices/0000:00:05.0/vendor)",
              "DEVICE=$(cat /sys/bus/pci/devices/0000:00:05.0/device)",
              "echo \"Detected Vendor: $VENDOR, Device: $DEVICE\"",
              "if [ \"$VENDOR\" = \"0x1234\" ] && [ \"$DEVICE\" = \"0x1111\" ]; then echo 'PASS: Correct GPU vendor/device IDs'; else echo 'FAIL: Wrong vendor/device IDs'; fi",
              "",
              "echo '=== Phase 4: Module Loading and Probe Test ==='",
              "/bin/pci_gpu_tester",
              "sleep 1",
              "",
              "echo '=== Phase 5: Driver Output Validation ==='",
              "dmesg | grep 'GPU Driver: Probing device' && echo 'PASS: Probe function called' || echo 'FAIL: Probe not called'",
              "dmesg | grep 'GPU Driver: Found at 0000:00:05.0' && echo 'PASS: PCI address detection working' || echo 'FAIL: PCI address not detected'",
              "dmesg | grep 'GPU Driver: Device 1234:1111' && echo 'PASS: Vendor/Device ID detection working' || echo 'FAIL: IDs not detected'",
              "dmesg | grep 'GPU Driver: Device initialized successfully' && echo 'PASS: PCI device enabled successfully' || echo 'FAIL: Device init failed'",
              "",
              "echo '=== All GPU detection tests completed ==='",
              "echo 'PASS: GPU PCI detection validation successful'"
            ],
            "expected": {
              "dmesg": [
                "GPU Driver: Probing device",
                "GPU Driver: Found at 0000:00:05.0",
                "GPU Driver: Device 1234:1111",
                "GPU Driver: Device initialized successfully"
              ],
              "stdout": [
                "PASS: Header file includes and macros validated",
                "PASS: GPU device present on PCI bus",
                "PASS: Correct GPU vendor/device IDs",
                "PASS: PCI device found",
                "PASS: Module loaded",
                "PASS: Driver bound to device",
                "SUCCESS: PCI GPU driver test completed",
                "PASS: Probe function called",
                "PASS: PCI address detection working",
                "PASS: Vendor/Device ID detection working",
                "PASS: PCI device enabled successfully",
                "PASS: GPU PCI detection validation successful"
              ]
            },
            "timeout": 15
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "GPU Driver: Probing device",
        "GPU Driver: Found at 0000:00:05.0",
        "GPU Driver: Device 1234:1111",
        "GPU Driver: Device initialized successfully",
        "GPU Driver: Removing device",
        "GPU Driver: Device cleanup complete"
      ],
      "requirements": [
        "Use required function names: gpu_pci_probe, gpu_pci_remove",
        "Use required variable names: gpu_pci_table, gpu_pci_driver",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/pci.h",
        "Code must contain: static const struct pci_device_id gpu_pci_table[], { PCI_DEVICE(GPU_VENDOR_ID, GPU_DEVICE_ID) }, { 0, }, MODULE_DEVICE_TABLE(pci, gpu_pci_table), static struct pci_driver gpu_pci_driver, .name = \"simple_gpu_driver\", .id_table = gpu_pci_table, .probe = gpu_pci_probe, .remove = gpu_pci_remove, module_pci_driver(gpu_pci_driver), pci_enable_device(pdev), pci_disable_device(pdev), pci_domain_nr(pdev->bus), PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn)",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "GPU Driver: Probing device",
          "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)",
          "exact": true
        },
        {
          "pattern": "GPU Driver: Found at 0000:00:05.0",
          "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)",
          "exact": true
        },
        {
          "pattern": "GPU Driver: Device 1234:1111",
          "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)",
          "exact": true
        },
        {
          "pattern": "GPU Driver: Device initialized successfully",
          "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)",
          "exact": true
        },
        {
          "pattern": "GPU Driver: Removing device",
          "linkedFunction": "static void gpu_pci_remove(struct pci_dev *pdev)",
          "exact": true
        },
        {
          "pattern": "GPU Driver: Device cleanup complete",
          "linkedFunction": "static void gpu_pci_remove(struct pci_dev *pdev)",
          "exact": true
        }
      ]
    }
  },
  {
    "id": 108,
    "title": "PCI BAR Mapping - Accessing GPU Memory Regions",
    "difficulty": 7,
    "xp": 60,
    "phase": "kernel_core",
    "description": "Learn how real GPU drivers map and access device memory. Every GPU driver (AMD amdgpu, NVIDIA nouveau, Intel i915) must map PCI Base Address Registers (BARs) to access GPU memory and registers. You'll learn memory-mapped I/O (MMIO), resource management, and reading GPU hardware registers - the foundation of all GPU operations.",
    "concepts": [
      "PCI Base Address Registers (BARs)",
      "Memory-mapped I/O (MMIO)",
      "Physical vs virtual address mapping",
      "Resource management and reservation",
      "ioremap vs ioremap_wc",
      "GPU memory regions (framebuffer vs registers)",
      "Hardware register access with ioread/iowrite",
      "Proper driver cleanup and resource release",
      "Write-combining for performance",
      "PCI resource flags and attributes"
    ],
    "skills": [
      "Mapping PCI BARs to virtual memory",
      "Using ioremap() for MMIO registers",
      "Using ioremap_wc() for framebuffer memory",
      "Reading PCI resource information",
      "Requesting and releasing PCI regions",
      "Reading hardware registers with ioread32()",
      "Proper error handling and cleanup",
      "Understanding GPU memory architecture",
      "Managing I/O memory mappings",
      "Professional driver resource management"
    ],
    "files": [
      {
        "name": "pci_bar_map.h",
        "content": "#ifndef PCI_BAR_MAP_H\n#define PCI_BAR_MAP_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/io.h>\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: PCI BAR Mapping and MMIO Access */\n/* ========================================================================== */\n/* This problem teaches PRODUCTION GPU DRIVER patterns used in ALL GPU drivers!\n *\n * WHAT ARE PCI BARs (Base Address Registers)?\n * - BARs are hardware registers that tell the OS where device memory is located\n * - Each BAR points to a region of memory or I/O space\n * - GPUs typically have 3 BARs:\n *   - BAR 0: Framebuffer (VRAM) - where screen images are stored\n *   - BAR 2: MMIO Registers - control registers for GPU operations\n *   - BAR 4: I/O ports (some older GPUs)\n *\n * REAL-WORLD GPU BAR LAYOUTS:\n * AMD Radeon RX 6800:\n *   - BAR 0: 16GB VRAM (visible VRAM for CPU access)\n *   - BAR 2: 256KB MMIO registers (command registers, status, configuration)\n *   - BAR 5: 128MB doorbell pages (for GPU command submission)\n *\n * NVIDIA RTX 3070:\n *   - BAR 0: 8GB framebuffer (GPU memory window)\n *   - BAR 1: 16MB register space (control registers)\n *   - BAR 3: 32MB expansion ROM\n *\n * Intel Integrated Graphics (i915):\n *   - BAR 0: 16MB display registers and GTT\n *   - BAR 2: 256MB aperture (CPU-accessible GPU memory)\n *\n * BOCHS-DISPLAY GPU (Our QEMU Device):\n *   - BAR 0: 16MB framebuffer memory\n *   - BAR 2: 8KB MMIO registers\n */\n\n/* GPU device identification (bochs-display in QEMU) */\n#define GPU_VENDOR_ID 0x1234\n#define GPU_DEVICE_ID 0x1111\n\n/* BAR indices - which BAR contains what */\n#define GPU_BAR_FRAMEBUFFER 0  /* BAR 0 = framebuffer memory (where pixels are) */\n#define GPU_BAR_MMIO 2         /* BAR 2 = MMIO registers (control registers) */\n\n/* MMIO register offsets (bochs-display specific) */\n#define MMIO_ID_REGISTER 0x0   /* Device identification register at offset 0 */\n\n/* ========================================================================== */\n/* WHAT IS MEMORY-MAPPED I/O (MMIO)?\n * Instead of using special I/O instructions, we access device registers\n * just like regular memory reads/writes.\n *\n * PHYSICAL vs VIRTUAL ADDRESSES:\n * - PCI BAR gives us PHYSICAL address (hardware address on the bus)\n * - Kernel cannot access physical addresses directly\n * - We must MAP physical -> virtual using ioremap()\n *\n * EXAMPLE:\n * Physical address: 0xfe000000 (from PCI BAR)\n * ioremap(0xfe000000, 8192) -> virtual address: 0xffffc90000000000\n * Now we can read/write to 0xffffc90000000000 to talk to hardware!\n */\n\n/* ========================================================================== */\n/* FUNCTION DECLARATIONS */\n/* ========================================================================== */\n/* TODO: Declare PCI probe and remove functions */\n/* static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id); */\n/* static void gpu_pci_remove(struct pci_dev *pdev); */\n\n#endif /* PCI_BAR_MAP_H */\n",
        "readOnly": false,
        "language": "h"
      },
      {
        "name": "pci_bar_map.c",
        "content": "#include \"pci_bar_map.h\"\n\n/* ========================================================================== */\n/* GLOBAL VARIABLES: Mapped Memory Pointers */\n/* ========================================================================== */\n/* These pointers store the VIRTUAL addresses where we mapped the GPU memory.\n * - mmio_base: Points to control registers (read/write config, status)\n * - fb_base: Points to framebuffer memory (where pixel data goes)\n *\n * The __iomem annotation tells the kernel these point to I/O memory,\n * not regular RAM. We must use special ioread/iowrite functions to access them.\n */\nstatic void __iomem *mmio_base = NULL;    /* Virtual address of mapped MMIO */\nstatic void __iomem *fb_base = NULL;      /* Virtual address of mapped framebuffer */\nstatic resource_size_t mmio_size = 0;     /* Size of MMIO region */\nstatic resource_size_t fb_size = 0;       /* Size of framebuffer region */\n\n/* ========================================================================== */\n/* PCI DEVICE TABLE: Tells kernel which devices we support */\n/* ========================================================================== */\nstatic const struct pci_device_id gpu_pci_table[] = {\n    { PCI_DEVICE(GPU_VENDOR_ID, GPU_DEVICE_ID) },\n    { 0, }  /* Terminator */\n};\nMODULE_DEVICE_TABLE(pci, gpu_pci_table);\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: Understanding BAR Mapping Flow */\n/* ========================================================================== */\n/* STEP-BY-STEP BAR MAPPING PROCESS:\n *\n * 1. ENABLE PCI DEVICE\n *    pci_enable_device(pdev)\n *    - Powers on the device\n *    - Enables memory and I/O access\n *\n * 2. GET BAR INFORMATION\n *    phys_addr = pci_resource_start(pdev, BAR_NUMBER)\n *    size = pci_resource_len(pdev, BAR_NUMBER)\n *    flags = pci_resource_flags(pdev, BAR_NUMBER)\n *    - Reads the PCI configuration space\n *    - Gets physical address, size, and type of the BAR\n *\n * 3. REQUEST MEMORY REGIONS\n *    pci_request_regions(pdev, \"driver_name\")\n *    - Reserves the BARs so no other driver can use them\n *    - Prevents conflicts with other drivers\n *\n * 4. MAP PHYSICAL TO VIRTUAL\n *    For MMIO registers:\n *      virt_addr = ioremap(phys_addr, size)\n *      - Creates uncached mapping (every read/write goes to hardware)\n *      - Maintains strict ordering (important for registers)\n *\n *    For Framebuffer:\n *      virt_addr = ioremap_wc(phys_addr, size)\n *      - Creates write-combining mapping (better performance)\n *      - Allows CPU to batch writes for speed\n *\n * 5. ACCESS HARDWARE\n *    value = ioread32(virt_addr + offset)\n *    iowrite32(value, virt_addr + offset)\n *    - Use special I/O functions (never regular pointers!)\n *\n * 6. CLEANUP (in reverse order)\n *    iounmap(virt_addr)\n *    pci_release_regions(pdev)\n *    pci_disable_device(pdev)\n */\n\n/* ========================================================================== */\n/* FUNCTION: gpu_pci_probe */\n/* ========================================================================== */\n/* Called when kernel detects our GPU device.\n * This is where we:\n * - Enable the device\n * - Map the BARs to access GPU memory\n * - Initialize communication with the GPU\n */\nstatic int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n    resource_size_t fb_start, fb_len, fb_flags;\n    resource_size_t mmio_start, mmio_len, mmio_flags;\n    u32 device_id_reg;\n    int ret;\n\n    printk(KERN_INFO \"GPU Driver: Probing device\\n\");\n\n    /* TODO: STEP 1 - Enable PCI device */\n    /* Use pci_enable_device(pdev) to power on and enable the device */\n    /* Check return value: if (ret < 0) return error */\n    /* HINT: Store result in 'ret' variable */\n\n    /* TODO: STEP 2 - Get BAR 0 (Framebuffer) information */\n    /* Use pci_resource_start(pdev, GPU_BAR_FRAMEBUFFER) to get physical address */\n    /* Use pci_resource_len(pdev, GPU_BAR_FRAMEBUFFER) to get size */\n    /* Use pci_resource_flags(pdev, GPU_BAR_FRAMEBUFFER) to get flags */\n    /* Store in fb_start, fb_len, fb_flags (already declared above) */\n    /* HINT: fb_start = pci_resource_start(pdev, GPU_BAR_FRAMEBUFFER); */\n\n    /* TODO: Print BAR 0 information */\n    /* Format: \"GPU Driver: BAR 0 (Framebuffer): start=0x%llx, size=%lluMB, flags=0x%llx\\n\" */\n    /* HINT: Convert size to MB by dividing fb_len by (1024*1024) */\n    /* HINT: Use %llx for 64-bit hex, %llu for 64-bit decimal, %llx for flags */\n    /* printk(KERN_INFO \"GPU Driver: BAR 0 (Framebuffer): start=0x%llx, size=%lluMB, flags=0x%llx\\n\",\n              (unsigned long long)fb_start, (unsigned long long)fb_len / (1024*1024),\n              (unsigned long long)fb_flags); */\n\n    /* TODO: STEP 3 - Get BAR 2 (MMIO) information */\n    /* Same as BAR 0, but use GPU_BAR_MMIO instead */\n    /* Store in mmio_start, mmio_len, mmio_flags */\n\n    /* TODO: Print BAR 2 information */\n    /* Format: \"GPU Driver: BAR 2 (MMIO): start=0x%llx, size=%lluKB, flags=0x%llx\\n\" */\n    /* HINT: Convert size to KB by dividing mmio_len by 1024 */\n    /* HINT: Cast flags to (unsigned long long)mmio_flags */\n\n    /* TODO: STEP 4 - Request memory regions */\n    /* Use pci_request_regions(pdev, \"gpu_bar_driver\") to reserve BARs */\n    /* Check return value: if (ret < 0) goto error_disable; */\n    /* Print: \"GPU Driver: Requested memory regions\\n\" */\n\n    /* TODO: STEP 5 - Map BAR 2 (MMIO registers) */\n    /* Use ioremap(mmio_start, mmio_len) to map MMIO */\n    /* Store result in mmio_base global variable */\n    /* Check if mmio_base is NULL: if (!mmio_base) goto error_release; */\n    /* Store mmio_len in mmio_size global variable */\n    /* Print: \"GPU Driver: Mapped MMIO at virtual address %p\\n\", mmio_base */\n    /* WHY ioremap() not ioremap_wc()? */\n    /* - MMIO registers need strict ordering and no caching */\n    /* - Every write must reach hardware immediately */\n    /* - Example: Writing command register must happen before data register */\n\n    /* TODO: STEP 6 - Map BAR 0 (Framebuffer) with write-combining */\n    /* Use ioremap_wc(fb_start, fb_len) to map framebuffer */\n    /* Store result in fb_base global variable */\n    /* Check if fb_base is NULL: if (!fb_base) goto error_unmap_mmio; */\n    /* Store fb_len in fb_size global variable */\n    /* Print: \"GPU Driver: Mapped framebuffer at virtual address %p\\n\", fb_base */\n    /* WHY ioremap_wc()? */\n    /* - Framebuffer benefits from write-combining for performance */\n    /* - CPU can batch multiple writes into single bus transaction */\n    /* - Huge performance improvement for drawing pixels! */\n    /* - Real example: AMD amdgpu uses ioremap_wc() for 16GB VRAM BAR */\n\n    /* TODO: STEP 7 - Read GPU identification register from MMIO */\n    /* Use ioread32(mmio_base + MMIO_ID_REGISTER) to read device ID */\n    /* Store in device_id_reg variable */\n    /* Print: \"GPU Driver: Hardware register test read: 0x%08x\\n\", device_id_reg */\n    /* IMPORTANT: Never use regular pointer dereference like *mmio_base! */\n    /* MUST use ioread32() for proper hardware access */\n    /* NOTE: The value read may vary - this is just to demonstrate hardware access */\n\n    /* TODO: Print success message */\n    /* Print: \"GPU Driver: All BARs mapped successfully\\n\" */\n\n    return 0;\n\n    /* Error handling (cleanup in reverse order) */\nerror_unmap_mmio:\n    if (mmio_base) {\n        iounmap(mmio_base);\n        mmio_base = NULL;\n    }\nerror_release:\n    pci_release_regions(pdev);\nerror_disable:\n    pci_disable_device(pdev);\n    return -EIO;\n}\n\n/* ========================================================================== */\n/* FUNCTION: gpu_pci_remove */\n/* ========================================================================== */\n/* Called when device is removed or module is unloaded.\n * CRITICAL: Must cleanup in REVERSE order of probe!\n */\nstatic void gpu_pci_remove(struct pci_dev *pdev)\n{\n    printk(KERN_INFO \"GPU Driver: Removing device\\n\");\n\n    /* TODO: STEP 1 - Unmap MMIO (reverse of probe step 5) */\n    /* Check if mmio_base is not NULL */\n    /* Use iounmap(mmio_base) to unmap */\n    /* Set mmio_base = NULL for safety */\n    /* HINT: if (mmio_base) { iounmap(mmio_base); mmio_base = NULL; } */\n\n    /* TODO: STEP 2 - Unmap framebuffer (reverse of probe step 6) */\n    /* Check if fb_base is not NULL */\n    /* Use iounmap(fb_base) to unmap */\n    /* Set fb_base = NULL for safety */\n\n    /* TODO: Print cleanup message */\n    /* Print: \"GPU Driver: Unmapped MMIO and framebuffer\\n\" */\n\n    /* TODO: STEP 3 - Release memory regions (reverse of probe step 4) */\n    /* Use pci_release_regions(pdev) */\n    /* Print: \"GPU Driver: Released memory regions\\n\" */\n\n    /* TODO: STEP 4 - Disable device (reverse of probe step 1) */\n    /* Use pci_disable_device(pdev) */\n}\n\n/* ========================================================================== */\n/* PCI DRIVER STRUCTURE */\n/* ========================================================================== */\nstatic struct pci_driver gpu_pci_driver = {\n    .name = \"gpu_bar_driver\",\n    .id_table = gpu_pci_table,\n    .probe = gpu_pci_probe,\n    .remove = gpu_pci_remove,\n};\n\n/* ========================================================================== */\n/* MODULE INIT/EXIT */\n/* ========================================================================== */\nstatic int __init gpu_bar_init(void)\n{\n    printk(KERN_INFO \"GPU BAR Mapping Driver: Initializing\\n\");\n    return pci_register_driver(&gpu_pci_driver);\n}\n\nstatic void __exit gpu_bar_exit(void)\n{\n    printk(KERN_INFO \"GPU BAR Mapping Driver: Exiting\\n\");\n    pci_unregister_driver(&gpu_pci_driver);\n}\n\nmodule_init(gpu_bar_init);\nmodule_exit(gpu_bar_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning PCI BAR mapping and MMIO access for GPU drivers\");\nMODULE_VERSION(\"1.0\");\n",
        "readOnly": false,
        "language": "c"
      },
      {
        "name": "Makefile",
        "content": "# PCI BAR mapping module Makefile\nobj-m += pci_bar_map.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help\n",
        "readOnly": true,
        "language": "makefile"
      }
    ],
    "mainFile": "pci_bar_map.c",
    "validation": {
      "exactRequirements": {
        "functionNames": [
          "gpu_bar_init",
          "gpu_bar_exit",
          "gpu_pci_probe",
          "gpu_pci_remove"
        ],
        "macro_declarations": [
          {
            "name": "GPU_VENDOR_ID",
            "type": "constant",
            "value": "0x1234",
            "description": "PCI vendor ID for bochs-display GPU"
          },
          {
            "name": "GPU_DEVICE_ID",
            "type": "constant",
            "value": "0x1111",
            "description": "PCI device ID for bochs-display GPU"
          },
          {
            "name": "GPU_BAR_FRAMEBUFFER",
            "type": "constant",
            "value": "0",
            "description": "BAR index for framebuffer memory"
          },
          {
            "name": "GPU_BAR_MMIO",
            "type": "constant",
            "value": "2",
            "description": "BAR index for MMIO registers"
          },
          {
            "name": "MMIO_ID_REGISTER",
            "type": "constant",
            "value": "0x0",
            "description": "Offset of device ID register in MMIO space"
          }
        ],
        "variables": [
          {
            "name": "mmio_base",
            "type": "void __iomem *",
            "value": "NULL",
            "storageClass": "static"
          },
          {
            "name": "fb_base",
            "type": "void __iomem *",
            "value": "NULL",
            "storageClass": "static"
          },
          {
            "name": "mmio_size",
            "type": "resource_size_t",
            "value": "0",
            "storageClass": "static"
          },
          {
            "name": "fb_size",
            "type": "resource_size_t",
            "value": "0",
            "storageClass": "static"
          },
          {
            "name": "gpu_pci_table",
            "type": "const struct pci_device_id",
            "value": "[{ PCI_DEVICE(GPU_VENDOR_ID, GPU_DEVICE_ID) }, { 0, }]",
            "storageClass": "static"
          },
          {
            "name": "gpu_pci_driver",
            "type": "struct pci_driver",
            "value": "{.name = \"gpu_bar_driver\", .id_table = gpu_pci_table, .probe = gpu_pci_probe, .remove = gpu_pci_remove}",
            "storageClass": "static"
          }
        ],
        "outputMessages": [
          "GPU BAR Mapping Driver: Initializing",
          "GPU Driver: Probing device",
          "GPU Driver: BAR 0 (Framebuffer): start=",
          "GPU Driver: BAR 2 (MMIO): start=",
          "GPU Driver: Requested memory regions",
          "GPU Driver: Mapped MMIO at virtual address",
          "GPU Driver: Mapped framebuffer at virtual address",
          "GPU Driver: Hardware register test read:",
          "GPU Driver: All BARs mapped successfully",
          "GPU Driver: Removing device",
          "GPU Driver: Unmapped MMIO and framebuffer",
          "GPU Driver: Released memory regions",
          "GPU BAR Mapping Driver: Exiting"
        ],
        "requiredIncludes": [
          "linux/module.h",
          "linux/kernel.h",
          "linux/init.h",
          "linux/pci.h",
          "linux/io.h"
        ],
        "mustContain": [
          "pci_enable_device",
          "pci_resource_start",
          "pci_resource_len",
          "pci_resource_flags",
          "pci_request_regions",
          "ioremap",
          "ioremap_wc",
          "ioread32",
          "iounmap",
          "pci_release_regions",
          "pci_disable_device",
          "GPU_BAR_FRAMEBUFFER",
          "GPU_BAR_MMIO",
          "MMIO_ID_REGISTER",
          "PCI_DEVICE(GPU_VENDOR_ID, GPU_DEVICE_ID)",
          "pci_register_driver",
          "pci_unregister_driver"
        ],
        "moduleInfo": {
          "license": "GPL"
        }
      },
      "testCases": [
        {
          "id": "macro_definitions",
          "name": "Macro Definitions in Header",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "#define GPU_VENDOR_ID",
            "0x1234",
            "#define GPU_DEVICE_ID",
            "0x1111",
            "#define GPU_BAR_FRAMEBUFFER",
            "#define GPU_BAR_MMIO",
            "#define MMIO_ID_REGISTER"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "function_signatures_source",
          "name": "Function Implementations in Source",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)",
            "static void gpu_pci_remove(struct pci_dev *pdev)",
            "static int __init gpu_bar_init(void)",
            "static void __exit gpu_bar_exit(void)"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "variable_declarations",
          "name": "Global Variable Declarations",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "static void __iomem *mmio_base",
            "static void __iomem *fb_base",
            "static resource_size_t mmio_size",
            "static resource_size_t fb_size",
            "static const struct pci_device_id gpu_pci_table",
            "static struct pci_driver gpu_pci_driver"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "pci_bar_api_usage",
          "name": "PCI BAR API Functions Usage",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "pci_enable_device",
            "pci_resource_start",
            "pci_resource_len",
            "pci_resource_flags",
            "pci_request_regions",
            "ioremap",
            "ioremap_wc",
            "ioread32",
            "iounmap",
            "pci_release_regions",
            "pci_disable_device"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "bar_macros_usage",
          "name": "BAR Macros Usage in Code",
          "type": "code_analysis",
          "critical": true,
          "expectedSymbols": [
            "GPU_BAR_FRAMEBUFFER",
            "GPU_BAR_MMIO",
            "MMIO_ID_REGISTER"
          ],
          "prohibitedSymbols": []
        },
        {
          "id": "exact_output",
          "name": "Exact Output Messages",
          "type": "output_match",
          "critical": true,
          "expected": [
            {
              "pattern": "GPU BAR Mapping Driver: Initializing",
              "exact": true,
              "linkedFunction": "static int __init gpu_bar_init(void)"
            },
            {
              "pattern": "GPU Driver: Probing device",
              "exact": true,
              "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
            },
            {
              "pattern": "GPU Driver: BAR 0 \\(Framebuffer\\):.*start=0x.*size=.*MB.*flags=0x",
              "exact": false,
              "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
            },
            {
              "pattern": "GPU Driver: BAR 2 \\(MMIO\\):.*start=0x.*size=.*KB.*flags=0x",
              "exact": false,
              "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
            },
            {
              "pattern": "GPU Driver: Requested memory regions",
              "exact": true,
              "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
            },
            {
              "pattern": "GPU Driver: Mapped MMIO at virtual address",
              "exact": false,
              "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
            },
            {
              "pattern": "GPU Driver: Mapped framebuffer at virtual address",
              "exact": false,
              "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
            },
            {
              "pattern": "GPU Driver: Hardware register test read: 0x",
              "exact": false,
              "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
            },
            {
              "pattern": "GPU Driver: All BARs mapped successfully",
              "exact": true,
              "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
            },
            {
              "pattern": "GPU Driver: Removing device",
              "exact": true,
              "linkedFunction": "static void gpu_pci_remove(struct pci_dev *pdev)"
            },
            {
              "pattern": "GPU Driver: Unmapped MMIO and framebuffer",
              "exact": true,
              "linkedFunction": "static void gpu_pci_remove(struct pci_dev *pdev)"
            },
            {
              "pattern": "GPU Driver: Released memory regions",
              "exact": true,
              "linkedFunction": "static void gpu_pci_remove(struct pci_dev *pdev)"
            },
            {
              "pattern": "GPU BAR Mapping Driver: Exiting",
              "exact": true,
              "linkedFunction": "static void __exit gpu_bar_exit(void)"
            }
          ]
        },
        {
          "id": "comprehensive_bar_mapping_validation",
          "name": "Comprehensive PCI BAR Mapping and MMIO Access Validation",
          "type": "kernel_project_test",
          "critical": true,
          "testScenario": {
            "qemuArgs": [
              "-device",
              "bochs-display,addr=05.0",
              "-vga",
              "none"
            ],
            "userspaceApps": [],
            "setupCommands": [
              "echo 'Starting comprehensive PCI BAR mapping validation'"
            ],
            "testCommands": [
              "echo 'Phase 1: TCC Header Validation'",
              "mkdir -p /tmp/linux",
              "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
              "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
              "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
              "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
              "echo '#define MODULE_DEVICE_TABLE(type, table)' >> /tmp/linux/module.h",
              "echo '#define module_init(x)' >> /tmp/linux/module.h",
              "echo '#define module_exit(x)' >> /tmp/linux/module.h",
              "echo '#define __init' > /tmp/linux/init.h",
              "echo '#define __exit' >> /tmp/linux/init.h",
              "echo 'struct pci_dev;' > /tmp/linux/pci.h",
              "echo 'struct pci_device_id { unsigned int vendor; unsigned int device; };' >> /tmp/linux/pci.h",
              "echo '#define PCI_DEVICE(vend, dev) .vendor = (vend), .device = (dev)' >> /tmp/linux/pci.h",
              "echo 'int pci_enable_device(struct pci_dev *dev);' >> /tmp/linux/pci.h",
              "echo 'void pci_disable_device(struct pci_dev *dev);' >> /tmp/linux/pci.h",
              "echo 'int pci_register_driver(void *drv);' >> /tmp/linux/pci.h",
              "echo 'void pci_unregister_driver(void *drv);' >> /tmp/linux/pci.h",
              "echo 'typedef unsigned long long resource_size_t;' >> /tmp/linux/pci.h",
              "echo 'resource_size_t pci_resource_start(struct pci_dev *dev, int bar);' >> /tmp/linux/pci.h",
              "echo 'resource_size_t pci_resource_len(struct pci_dev *dev, int bar);' >> /tmp/linux/pci.h",
              "echo 'unsigned long pci_resource_flags(struct pci_dev *dev, int bar);' >> /tmp/linux/pci.h",
              "echo 'int pci_request_regions(struct pci_dev *pdev, const char *name);' >> /tmp/linux/pci.h",
              "echo 'void pci_release_regions(struct pci_dev *pdev);' >> /tmp/linux/pci.h",
              "echo 'struct pci_driver { const char *name; const struct pci_device_id *id_table; int (*probe)(struct pci_dev *, const struct pci_device_id *); void (*remove)(struct pci_dev *); };' >> /tmp/linux/pci.h",
              "echo '#define __iomem' > /tmp/linux/io.h",
              "echo 'typedef unsigned int u32;' >> /tmp/linux/io.h",
              "echo 'void __iomem *ioremap(unsigned long long phys_addr, unsigned long size);' >> /tmp/linux/io.h",
              "echo 'void __iomem *ioremap_wc(unsigned long long phys_addr, unsigned long size);' >> /tmp/linux/io.h",
              "echo 'void iounmap(volatile void __iomem *addr);' >> /tmp/linux/io.h",
              "echo 'u32 ioread32(const volatile void __iomem *addr);' >> /tmp/linux/io.h",
              "echo 'void iowrite32(u32 value, volatile void __iomem *addr);' >> /tmp/linux/io.h",
              "echo '#include \"/lib/modules/pci_bar_map.h\"' > /tmp/test.c",
              "echo 'int main() { return 0; }' >> /tmp/test.c",
              "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
              "TCC_EXIT_CODE=$?",
              "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Header validation failed'; cat /tmp/tcc_error.log; else echo 'PASS: All declarations found in header file'; fi",
              "",
              "echo 'Phase 2: Verify PCI Device Exists'",
              "ls /sys/bus/pci/devices/ | grep -q '0000:00:05.0' && echo 'PASS: PCI device 0000:00:05.0 exists' || echo 'FAIL: PCI device not found'",
              "",
              "echo 'Phase 3: Check PCI Device BARs'",
              "if [ -f /sys/bus/pci/devices/0000:00:05.0/resource ]; then",
              "  echo 'PASS: PCI device has resource file'",
              "  cat /sys/bus/pci/devices/0000:00:05.0/resource",
              "else",
              "  echo 'FAIL: No resource file found'",
              "fi",
              "",
              "echo 'Phase 4: Load Module and Verify Probe'",
              "sleep 1",
              "insmod /lib/modules/pci_bar_map.ko",
              "sleep 2",
              "",
              "echo 'Phase 5: Validate BAR Mapping in dmesg'",
              "dmesg | grep 'GPU BAR Mapping Driver: Initializing' && echo 'PASS: Module initialized' || echo 'FAIL: Module init missing'",
              "dmesg | grep 'GPU Driver: Probing device' && echo 'PASS: Probe function called' || echo 'FAIL: Probe not called'",
              "dmesg | grep 'GPU Driver: BAR 0 (Framebuffer)' && echo 'PASS: BAR 0 information printed' || echo 'FAIL: BAR 0 info missing'",
              "dmesg | grep 'GPU Driver: BAR 2 (MMIO)' && echo 'PASS: BAR 2 information printed' || echo 'FAIL: BAR 2 info missing'",
              "dmesg | grep 'GPU Driver: Requested memory regions' && echo 'PASS: Memory regions requested' || echo 'FAIL: Request regions missing'",
              "dmesg | grep 'GPU Driver: Mapped MMIO at virtual address' && echo 'PASS: MMIO mapped successfully' || echo 'FAIL: MMIO mapping missing'",
              "dmesg | grep 'GPU Driver: Mapped framebuffer at virtual address' && echo 'PASS: Framebuffer mapped successfully' || echo 'FAIL: FB mapping missing'",
              "dmesg | grep 'GPU Driver: Hardware register test read: 0x' && echo 'PASS: Hardware register read from MMIO' || echo 'FAIL: Hardware register read missing'",
              "dmesg | grep 'GPU Driver: All BARs mapped successfully' && echo 'PASS: All BAR mapping completed' || echo 'FAIL: BAR mapping incomplete'",
              "",
              "echo 'Phase 6: Verify Module is Loaded'",
              "lsmod | grep pci_bar_map && echo 'PASS: Module is loaded' || echo 'FAIL: Module not in lsmod'",
              "",
              "echo 'Phase 7: Unload Module and Verify Cleanup'",
              "rmmod pci_bar_map",
              "sleep 1",
              "dmesg | grep 'GPU Driver: Removing device' && echo 'PASS: Remove function called' || echo 'FAIL: Remove not called'",
              "dmesg | grep 'GPU Driver: Unmapped MMIO and framebuffer' && echo 'PASS: Memory unmapped' || echo 'FAIL: Unmap missing'",
              "dmesg | grep 'GPU Driver: Released memory regions' && echo 'PASS: Regions released' || echo 'FAIL: Release missing'",
              "dmesg | grep 'GPU BAR Mapping Driver: Exiting' && echo 'PASS: Module exited cleanly' || echo 'FAIL: Exit missing'",
              "",
              "echo 'Phase 8: Verify Module Unloaded'",
              "lsmod | grep -q pci_bar_map && echo 'FAIL: Module still loaded' || echo 'PASS: Module unloaded successfully'",
              "",
              "echo 'PASS: All comprehensive PCI BAR mapping validation completed successfully'"
            ],
            "expected": {
              "dmesg": [
                "GPU BAR Mapping Driver: Initializing",
                "GPU Driver: Probing device",
                "GPU Driver: BAR 0 \\(Framebuffer\\):.*start=0x.*size=.*MB.*flags=0x",
                "GPU Driver: BAR 2 \\(MMIO\\):.*start=0x.*size=.*KB.*flags=0x",
                "GPU Driver: Requested memory regions",
                "GPU Driver: Mapped MMIO at virtual address",
                "GPU Driver: Mapped framebuffer at virtual address",
                "GPU Driver: Hardware register test read: 0x",
                "GPU Driver: All BARs mapped successfully",
                "GPU Driver: Removing device",
                "GPU Driver: Unmapped MMIO and framebuffer",
                "GPU Driver: Released memory regions",
                "GPU BAR Mapping Driver: Exiting"
              ],
              "stdout": [
                "PASS: All declarations found in header file",
                "PASS: PCI device 0000:00:05.0 exists",
                "PASS: PCI device has resource file",
                "PASS: Module initialized",
                "PASS: Probe function called",
                "PASS: BAR 0 information printed",
                "PASS: BAR 2 information printed",
                "PASS: Memory regions requested",
                "PASS: MMIO mapped successfully",
                "PASS: Framebuffer mapped successfully",
                "PASS: Hardware register read from MMIO",
                "PASS: All BAR mapping completed",
                "PASS: Module is loaded",
                "PASS: Remove function called",
                "PASS: Memory unmapped",
                "PASS: Regions released",
                "PASS: Module exited cleanly",
                "PASS: Module unloaded successfully",
                "PASS: All comprehensive PCI BAR mapping validation completed successfully"
              ]
            },
            "timeout": 30
          }
        }
      ]
    },
    "inputOutput": {
      "expectedOutput": [
        "GPU BAR Mapping Driver: Initializing",
        "GPU Driver: Probing device",
        "GPU Driver: BAR 0 (Framebuffer): start=",
        "GPU Driver: BAR 2 (MMIO): start=",
        "GPU Driver: Requested memory regions",
        "GPU Driver: Mapped MMIO at virtual address",
        "GPU Driver: Mapped framebuffer at virtual address",
        "GPU Driver: Hardware register test read:",
        "GPU Driver: All BARs mapped successfully",
        "GPU Driver: Removing device",
        "GPU Driver: Unmapped MMIO and framebuffer",
        "GPU Driver: Released memory regions",
        "GPU BAR Mapping Driver: Exiting"
      ],
      "requirements": [
        "Use required function names: gpu_bar_init, gpu_bar_exit, gpu_pci_probe, gpu_pci_remove",
        "Use required variable names: mmio_base, fb_base, mmio_size, fb_size, gpu_pci_table, gpu_pci_driver",
        "Print exact message format for backend validation compatibility",
        "Must include: linux/module.h, linux/kernel.h, linux/init.h, linux/pci.h, linux/io.h",
        "Code must contain: pci_enable_device, pci_resource_start, pci_resource_len, pci_resource_flags, pci_request_regions, ioremap, ioremap_wc, ioread32, iounmap, pci_release_regions, pci_disable_device, GPU_BAR_FRAMEBUFFER, GPU_BAR_MMIO, MMIO_ID_REGISTER, PCI_DEVICE(GPU_VENDOR_ID, GPU_DEVICE_ID), pci_register_driver, pci_unregister_driver",
        "Must include MODULE_LICENSE(\"GPL\")"
      ],
      "functionLinkedOutputs": [
        {
          "pattern": "GPU BAR Mapping Driver: Initializing",
          "linkedFunction": "static int __init gpu_bar_init(void)",
          "exact": true
        },
        {
          "pattern": "GPU Driver: Probing device",
          "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)",
          "exact": true
        },
        {
          "pattern": "GPU Driver: BAR 0 \\(Framebuffer\\):.*start=0x.*size=.*MB.*flags=0x",
          "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)",
          "exact": false
        },
        {
          "pattern": "GPU Driver: BAR 2 \\(MMIO\\):.*start=0x.*size=.*KB.*flags=0x",
          "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)",
          "exact": false
        },
        {
          "pattern": "GPU Driver: Requested memory regions",
          "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)",
          "exact": true
        },
        {
          "pattern": "GPU Driver: Mapped MMIO at virtual address",
          "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)",
          "exact": false
        },
        {
          "pattern": "GPU Driver: Mapped framebuffer at virtual address",
          "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)",
          "exact": false
        },
        {
          "pattern": "GPU Driver: Hardware register test read: 0x",
          "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)",
          "exact": false
        },
        {
          "pattern": "GPU Driver: All BARs mapped successfully",
          "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)",
          "exact": true
        },
        {
          "pattern": "GPU Driver: Removing device",
          "linkedFunction": "static void gpu_pci_remove(struct pci_dev *pdev)",
          "exact": true
        },
        {
          "pattern": "GPU Driver: Unmapped MMIO and framebuffer",
          "linkedFunction": "static void gpu_pci_remove(struct pci_dev *pdev)",
          "exact": true
        },
        {
          "pattern": "GPU Driver: Released memory regions",
          "linkedFunction": "static void gpu_pci_remove(struct pci_dev *pdev)",
          "exact": true
        },
        {
          "pattern": "GPU BAR Mapping Driver: Exiting",
          "linkedFunction": "static void __exit gpu_bar_exit(void)",
          "exact": true
        }
      ]
    }
  }
];

export default problemBank;
