{
  "id": 35,
  "title": "Kernel Debugging and Diagnostics",
  "difficulty": 7,
  "xp": 70,
  "phase": "kernel_core",
  "description": "Implement a kernel module with comprehensive debugging, tracing, and diagnostic capabilities. This teaches essential debugging techniques used in production kernel development at companies like Intel, NVIDIA, and Red Hat for troubleshooting complex kernel issues.",
  "concepts": ["pr_debug", "dynamic_debug", "ftrace", "debugfs", "kernel_tracing", "conditional_compilation"],
  "skills": ["kernel_debugging", "diagnostic_tools", "production_debugging", "trace_analysis"],
  "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/trace_events.h>\n\n// TODO: Enable dynamic debug support\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n// TODO: Define debugging levels\n#define DEBUG_LEVEL_NONE    0\n#define DEBUG_LEVEL_ERROR   1  \n#define DEBUG_LEVEL_WARN    2\n#define DEBUG_LEVEL_INFO    3\n#define DEBUG_LEVEL_DEBUG   4\n\nstatic int debug_level = DEBUG_LEVEL_INFO;\nstatic struct dentry *debug_dir = NULL;\nstatic struct dentry *debug_file = NULL;\nstatic unsigned long function_calls = 0;\nstatic unsigned long error_count = 0;\nstatic unsigned long last_error_jiffies = 0;\n\n// TODO: Debug macro with level checking\n#define debug_print(level, fmt, ...) do { \\\n    if (debug_level >= level) { \\\n        pr_info(\"[%s:%d] \" fmt, __func__, __LINE__, ##__VA_ARGS__); \\\n    } \\\n} while (0)\n\n// TODO: Implement a function that can be traced\nstatic int debug_function_a(int param1, const char *param2)\n{\n    // TODO: Increment function call counter\n    // TODO: Add debug prints at different levels\n    // TODO: Validate parameters\n    // TODO: Simulate some work with different code paths\n    \n    debug_print(DEBUG_LEVEL_DEBUG, \"Called with param1=%d, param2=%s\\n\", \n                param1, param2 ? param2 : \"(null)\");\n    \n    if (!param2) {\n        debug_print(DEBUG_LEVEL_ERROR, \"Invalid parameter: param2 is NULL\\n\");\n        error_count++;\n        last_error_jiffies = jiffies;\n        return -EINVAL;\n    }\n    \n    if (param1 < 0) {\n        debug_print(DEBUG_LEVEL_WARN, \"Negative parameter: param1=%d\\n\", param1);\n    }\n    \n    // TODO: Add ftrace marker\n    trace_printk(\"debug_function_a: processing param1=%d\\n\", param1);\n    \n    debug_print(DEBUG_LEVEL_INFO, \"Successfully processed parameters\\n\");\n    return 0;\n}\n\n// TODO: Implement another traceable function with error handling\nstatic void *debug_function_b(size_t size)\n{\n    void *ptr;\n    \n    function_calls++;\n    debug_print(DEBUG_LEVEL_DEBUG, \"Allocating %zu bytes\\n\", size);\n    \n    if (size == 0) {\n        debug_print(DEBUG_LEVEL_ERROR, \"Invalid size: 0\\n\");\n        error_count++;\n        last_error_jiffies = jiffies;\n        return NULL;\n    }\n    \n    if (size > PAGE_SIZE) {\n        debug_print(DEBUG_LEVEL_WARN, \"Large allocation requested: %zu bytes\\n\", size);\n    }\n    \n    ptr = kmalloc(size, GFP_KERNEL);\n    if (!ptr) {\n        debug_print(DEBUG_LEVEL_ERROR, \"Memory allocation failed for %zu bytes\\n\", size);\n        error_count++;\n        last_error_jiffies = jiffies;\n        return NULL;\n    }\n    \n    trace_printk(\"debug_function_b: allocated %zu bytes at %p\\n\", size, ptr);\n    debug_print(DEBUG_LEVEL_INFO, \"Allocated %zu bytes at %p\\n\", size, ptr);\n    \n    return ptr;\n}\n\n// TODO: Implement debugfs show function\nstatic int debug_stats_show(struct seq_file *m, void *v)\n{\n    // TODO: Display debugging statistics\n    // TODO: Show function call counts, error counts, etc.\n    // TODO: Show current debug level\n    // TODO: Show last error time\n    \n    return 0;\n}\n\n// TODO: Implement debugfs open function\nstatic int debug_stats_open(struct inode *inode, struct file *file)\n{\n    return single_open(file, debug_stats_show, NULL);\n}\n\n// TODO: Implement debugfs write function for changing debug level\nstatic ssize_t debug_level_write(struct file *file, const char __user *buf,\n                               size_t count, loff_t *ppos)\n{\n    // TODO: Parse new debug level from user input\n    // TODO: Validate range (0-4)\n    // TODO: Update debug_level\n    // TODO: Log the change\n    \n    return count;\n}\n\n// TODO: Define debugfs file operations\nstatic const struct file_operations debug_fops = {\n    // TODO: Set up file operations\n};\n\nstatic int __init debug_module_init(void)\n{\n    int ret;\n    void *test_ptr;\n    \n    debug_print(DEBUG_LEVEL_INFO, \"Debug module initializing...\\n\");\n    \n    // TODO: Create debugfs directory\n    debug_dir = debugfs_create_dir(\"debug_demo\", NULL);\n    if (!debug_dir) {\n        pr_err(\"Failed to create debugfs directory\\n\");\n        return -ENOMEM;\n    }\n    \n    // TODO: Create debugfs file\n    debug_file = debugfs_create_file(\"stats\", 0644, debug_dir, NULL, &debug_fops);\n    if (!debug_file) {\n        pr_err(\"Failed to create debugfs file\\n\");\n        debugfs_remove_recursive(debug_dir);\n        return -ENOMEM;\n    }\n    \n    // TODO: Test our debug functions\n    ret = debug_function_a(42, \"test_string\");\n    debug_print(DEBUG_LEVEL_DEBUG, \"debug_function_a returned %d\\n\", ret);\n    \n    test_ptr = debug_function_b(1024);\n    if (test_ptr) {\n        debug_print(DEBUG_LEVEL_DEBUG, \"debug_function_b returned %p\\n\", test_ptr);\n        kfree(test_ptr);\n    }\n    \n    // TODO: Test error conditions\n    debug_function_a(-1, NULL);\n    debug_function_b(0);\n    \n    printk(KERN_INFO \"Debug module loaded successfully\\n\");\n    printk(KERN_INFO \"Debug level: %d, Function calls: %lu\\n\", debug_level, function_calls);\n    printk(KERN_INFO \"Debugfs interface: /sys/kernel/debug/debug_demo/\\n\");\n    \n    return 0;\n}\n\nstatic void __exit debug_module_exit(void)\n{\n    // TODO: Remove debugfs entries\n    debugfs_remove_recursive(debug_dir);\n    \n    debug_print(DEBUG_LEVEL_INFO, \"Debug module exiting...\\n\");\n    printk(KERN_INFO \"Debug module unloaded\\n\");\n    printk(KERN_INFO \"Final stats - Calls: %lu, Errors: %lu\\n\", function_calls, error_count);\n}\n\nmodule_init(debug_module_init);\nmodule_exit(debug_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Kernel debugging and diagnostics demonstration\");\nMODULE_VERSION(\"1.0\");",
  "validation": {
    "exactRequirements": {
      "functionNames": [
        "debug_module_init", 
        "debug_module_exit",
        "debug_function_a",
        "debug_function_b",
        "debug_stats_show",
        "debug_stats_open",
        "debug_level_write"
      ],
      "variables": [
        {"name": "debug_level", "type": "int"},
        {"name": "debug_dir", "type": "struct dentry*"},
        {"name": "debug_file", "type": "struct dentry*"},
        {"name": "function_calls", "type": "unsigned long"},
        {"name": "error_count", "type": "unsigned long"}
      ],
      "outputMessages": [
        "Debug module loaded successfully",
        "Debug level: 3, Function calls:",
        "Debugfs interface: /sys/kernel/debug/debug_demo/",
        "Debug module unloaded",
        "Final stats - Calls:"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/debugfs.h"
      ],
      "mustContain": [
        "pr_fmt",
        "pr_info",
        "trace_printk",
        "debugfs_create_dir",
        "debugfs_create_file",
        "debugfs_remove_recursive",
        "seq_printf"
      ]
    },
    "testCases": [
      {
        "id": "debug_levels",
        "name": "Debug Level Definitions",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "#define DEBUG_LEVEL_NONE",
          "#define DEBUG_LEVEL_ERROR",
          "#define DEBUG_LEVEL_WARN", 
          "#define DEBUG_LEVEL_INFO",
          "#define DEBUG_LEVEL_DEBUG"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "debug_macro",
        "name": "Debug Print Macro",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "#define debug_print",
          "if (debug_level >= level)",
          "__func__",
          "__LINE__"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "trace_integration",
        "name": "Ftrace Integration",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "trace_printk",
          "debug_function_a: processing",
          "debug_function_b: allocated"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "debugfs_implementation",
        "name": "Debugfs Implementation",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "debugfs_create_dir(\"debug_demo\"",
          "debugfs_create_file(\"stats\"",
          "seq_printf(m",
          "single_open"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "error_handling",
        "name": "Error Handling and Statistics",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "error_count++",
          "last_error_jiffies = jiffies",
          "function_calls++"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "parameter_validation",
        "name": "Parameter Validation",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "if (!param2)",
          "if (param1 < 0)",
          "if (size == 0)",
          "return -EINVAL"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "debugfs_message",
        "name": "Debugfs Interface Message",
        "type": "output_match",
        "critical": true,
        "expected": [
          {"pattern": "Debugfs interface: /sys/kernel/debug/debug_demo/", "exact": true}
        ]
      }
    ]
  }
}