{
  "id": 55,
  "title": "Memory Hierarchy and Cache Coherency",
  "phase": "kernel_core",
  "difficulty": 7,
  "xp": 65,
  "description": "Understand the memory hierarchy from CPU caches to main memory and the cache coherency problems that arise in modern systems. Learn why special memory management is needed for hardware DMA operations.",
  "concepts": ["memory_hierarchy", "cpu_caches", "cache_coherency", "cache_lines", "memory_barriers"],
  "skills": ["memory_architecture", "cache_understanding", "coherency_concepts"],
  "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/atomic.h>\n#include <linux/cache.h>\n\n// CONCEPT: Memory Hierarchy and Cache Coherency\n// Memory Hierarchy (fastest to slowest):\n// 1. CPU Registers (fastest)\n// 2. L1 Cache (per-core)\n// 3. L2 Cache (per-core or shared)\n// 4. L3 Cache (shared)\n// 5. Main Memory (RAM)\n// 6. Storage (disk/SSD)\n//\n// Cache Coherency Problem:\n// - Multiple CPUs have their own caches\n// - Same memory location can be cached in different CPUs\n// - Updates in one CPU's cache may not be visible to other CPUs\n//\n// WHY: Understanding this is crucial for DMA and multi-processor programming\n\n// Test data structure aligned to cache line\nstruct cache_test_data {\n    volatile int value;\n    char padding[L1_CACHE_BYTES - sizeof(int)];\n} __attribute__((aligned(L1_CACHE_BYTES)));\n\nstatic struct cache_test_data *shared_data;\nstatic atomic_t test_counter = ATOMIC_INIT(0);\nstatic volatile bool test_running = false;\n\n// TODO: Demonstrate cache line effects\nstatic void demonstrate_cache_line_effects(void)\n{\n    struct cache_test_data *test_array;\n    int i;\n    ktime_t start, end;\n    s64 sequential_time, random_time;\n    \n    printk(KERN_INFO \"=== CACHE LINE EFFECTS DEMONSTRATION ===\");\n    printk(KERN_INFO \"Cache line size: %d bytes\\n\", L1_CACHE_BYTES);\n    \n    // Allocate test array\n    test_array = kmalloc(sizeof(struct cache_test_data) * 1000, GFP_KERNEL);\n    if (!test_array) {\n        printk(KERN_ERR \"Failed to allocate test array\\n\");\n        return;\n    }\n    \n    // Initialize array\n    for (i = 0; i < 1000; i++) {\n        test_array[i].value = i;\n    }\n    \n    // Test 1: Sequential access (cache-friendly)\n    start = ktime_get();\n    for (i = 0; i < 1000; i++) {\n        test_array[i].value *= 2;\n    }\n    end = ktime_get();\n    sequential_time = ktime_to_ns(ktime_sub(end, start));\n    \n    // Test 2: Random access (cache-unfriendly)\n    start = ktime_get();\n    for (i = 0; i < 1000; i++) {\n        int index = (i * 37) % 1000; // Pseudo-random pattern\n        test_array[index].value *= 2;\n    }\n    end = ktime_get();\n    random_time = ktime_to_ns(ktime_sub(end, start));\n    \n    printk(KERN_INFO \"Sequential access time: %lld ns\\n\", sequential_time);\n    printk(KERN_INFO \"Random access time: %lld ns\\n\", random_time);\n    printk(KERN_INFO \"Random is %lld%% slower (cache misses)\\n\", \n           (random_time - sequential_time) * 100 / sequential_time);\n    \n    kfree(test_array);\n}\n\n// TODO: Cache coherency test thread\nstatic int cache_coherency_test_thread(void *data)\n{\n    int cpu = smp_processor_id();\n    int local_counter = 0;\n    \n    printk(KERN_INFO \"Cache coherency test thread started on CPU %d\\n\", cpu);\n    \n    while (test_running && !kthread_should_stop()) {\n        // Each CPU modifies shared data\n        shared_data->value = cpu * 1000 + local_counter;\n        \n        // Memory barrier to ensure write is visible\n        smp_wmb();\n        \n        // Increment atomic counter\n        atomic_inc(&test_counter);\n        \n        local_counter++;\n        \n        // Small delay\n        usleep_range(1000, 2000);\n        \n        // Stop after 50 iterations\n        if (local_counter >= 50) {\n            break;\n        }\n    }\n    \n    printk(KERN_INFO \"Cache coherency test thread on CPU %d completed\\n\", cpu);\n    return 0;\n}\n\n// TODO: Demonstrate cache coherency issues\nstatic void demonstrate_cache_coherency(void)\n{\n    struct task_struct *threads[NR_CPUS];\n    int cpu, active_cpus = 0;\n    \n    printk(KERN_INFO \"=== CACHE COHERENCY DEMONSTRATION ===\");\n    printk(KERN_INFO \"Number of CPUs: %d\\n\", num_online_cpus());\n    \n    // Allocate shared data\n    shared_data = kmalloc(sizeof(struct cache_test_data), GFP_KERNEL);\n    if (!shared_data) {\n        printk(KERN_ERR \"Failed to allocate shared data\\n\");\n        return;\n    }\n    \n    shared_data->value = 0;\n    atomic_set(&test_counter, 0);\n    test_running = true;\n    \n    // Start threads on different CPUs\n    for_each_online_cpu(cpu) {\n        if (active_cpus >= 4) break; // Limit to 4 threads\n        \n        threads[active_cpus] = kthread_create(cache_coherency_test_thread, \n                                             NULL, \"cache_test_%d\", cpu);\n        if (!IS_ERR(threads[active_cpus])) {\n            kthread_bind(threads[active_cpus], cpu);\n            wake_up_process(threads[active_cpus]);\n            active_cpus++;\n        }\n    }\n    \n    // Wait for threads to complete\n    msleep(3000);\n    test_running = false;\n    \n    // Wait for all threads to finish\n    for (cpu = 0; cpu < active_cpus; cpu++) {\n        if (!IS_ERR(threads[cpu])) {\n            kthread_stop(threads[cpu]);\n        }\n    }\n    \n    printk(KERN_INFO \"Final shared value: %d\\n\", shared_data->value);\n    printk(KERN_INFO \"Total atomic operations: %d\\n\", atomic_read(&test_counter));\n    \n    kfree(shared_data);\n}\n\n// TODO: Explain memory barriers\nstatic void explain_memory_barriers(void)\n{\n    printk(KERN_INFO \"=== MEMORY BARRIERS EXPLANATION ===\");\n    printk(KERN_INFO \"Memory barriers ensure ordering of memory operations\\n\");\n    \n    printk(KERN_INFO \"Types of memory barriers:\\n\");\n    printk(KERN_INFO \"1. smp_mb() - Full memory barrier\\n\");\n    printk(KERN_INFO \"   - Ensures all memory operations before/after are ordered\\n\");\n    \n    printk(KERN_INFO \"2. smp_wmb() - Write memory barrier\\n\");\n    printk(KERN_INFO \"   - Ensures all writes before barrier complete first\\n\");\n    \n    printk(KERN_INFO \"3. smp_rmb() - Read memory barrier\\n\");\n    printk(KERN_INFO \"   - Ensures all reads before barrier complete first\\n\");\n    \n    printk(KERN_INFO \"When memory barriers are needed:\\n\");\n    printk(KERN_INFO \"- Multi-processor systems (SMP)\\n\");\n    printk(KERN_INFO \"- DMA operations\\n\");\n    printk(KERN_INFO \"- Device driver programming\\n\");\n    printk(KERN_INFO \"- Lock-free programming\\n\");\n}\n\n// TODO: Explain DMA cache problems\nstatic void explain_dma_cache_problems(void)\n{\n    printk(KERN_INFO \"=== DMA AND CACHE PROBLEMS ===\");\n    printk(KERN_INFO \"Why DMA needs special memory management:\\n\");\n    \n    printk(KERN_INFO \"Problem 1: Cache Coherency\\n\");\n    printk(KERN_INFO \"- CPU caches data in L1/L2/L3 caches\\n\");\n    printk(KERN_INFO \"- DMA controller accesses main memory directly\\n\");\n    printk(KERN_INFO \"- CPU and DMA may see different values!\\n\");\n    \n    printk(KERN_INFO \"Problem 2: Write Ordering\\n\");\n    printk(KERN_INFO \"- CPU writes may be reordered by processor\\n\");\n    printk(KERN_INFO \"- DMA may see writes in wrong order\\n\");\n    printk(KERN_INFO \"- Results in corrupted data\\n\");\n    \n    printk(KERN_INFO \"Solutions (next lesson):\\n\");\n    printk(KERN_INFO \"- Coherent memory allocation\\n\");\n    printk(KERN_INFO \"- Cache synchronization functions\\n\");\n    printk(KERN_INFO \"- Memory barriers\\n\");\n    printk(KERN_INFO \"- DMA mapping API\\n\");\n}\n\n// TODO: Demonstrate cache alignment importance\nstatic void demonstrate_cache_alignment(void)\n{\n    struct {\n        int value1;\n        int value2;\n    } unaligned_data;\n    \n    struct {\n        int value1;\n        char padding[L1_CACHE_BYTES - sizeof(int)];\n        int value2;\n    } aligned_data;\n    \n    printk(KERN_INFO \"=== CACHE ALIGNMENT DEMONSTRATION ===\");\n    printk(KERN_INFO \"Unaligned structure size: %zu bytes\\n\", sizeof(unaligned_data));\n    printk(KERN_INFO \"Aligned structure size: %zu bytes\\n\", sizeof(aligned_data));\n    \n    printk(KERN_INFO \"Cache line size: %d bytes\\n\", L1_CACHE_BYTES);\n    printk(KERN_INFO \"False sharing occurs when different variables share cache lines\\n\");\n    printk(KERN_INFO \"Aligned structures prevent false sharing\\n\");\n    \n    printk(KERN_INFO \"Memory addresses:\\n\");\n    printk(KERN_INFO \"  unaligned_data.value1: %p\\n\", &unaligned_data.value1);\n    printk(KERN_INFO \"  unaligned_data.value2: %p\\n\", &unaligned_data.value2);\n    printk(KERN_INFO \"  aligned_data.value1: %p\\n\", &aligned_data.value1);\n    printk(KERN_INFO \"  aligned_data.value2: %p\\n\", &aligned_data.value2);\n}\n\nstatic int __init memory_hierarchy_init(void)\n{\n    printk(KERN_INFO \"Memory hierarchy and cache coherency module loaded\\n\");\n    printk(KERN_INFO \"Learning about CPU caches and memory architecture\\n\");\n    \n    demonstrate_cache_line_effects();\n    demonstrate_cache_alignment();\n    explain_memory_barriers();\n    explain_dma_cache_problems();\n    demonstrate_cache_coherency();\n    \n    return 0;\n}\n\nstatic void __exit memory_hierarchy_exit(void)\n{\n    printk(KERN_INFO \"Memory hierarchy and cache coherency module unloaded\\n\");\n    printk(KERN_INFO \"Remember: Cache coherency is critical for DMA!\\n\");\n}\n\nmodule_init(memory_hierarchy_init);\nmodule_exit(memory_hierarchy_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Memory hierarchy and cache coherency concepts\");\nMODULE_VERSION(\"1.0\");",
  "validation": {
    "exactRequirements": {
      "functionNames": [
        "memory_hierarchy_init",
        "memory_hierarchy_exit",
        "demonstrate_cache_line_effects",
        "cache_coherency_test_thread",
        "demonstrate_cache_coherency",
        "explain_memory_barriers",
        "explain_dma_cache_problems",
        "demonstrate_cache_alignment"
      ],
      "variables": [
        {"name": "shared_data", "type": "struct cache_test_data *"},
        {"name": "test_counter", "type": "atomic_t"},
        {"name": "test_running", "type": "volatile bool"}
      ],
      "outputMessages": [
        "Memory hierarchy and cache coherency module loaded",
        "Learning about CPU caches and memory architecture",
        "=== CACHE LINE EFFECTS DEMONSTRATION ===",
        "Cache line size:",
        "Sequential access time:",
        "Random access time:",
        "=== CACHE COHERENCY DEMONSTRATION ===",
        "Number of CPUs:",
        "=== MEMORY BARRIERS EXPLANATION ===",
        "=== DMA AND CACHE PROBLEMS ===",
        "=== CACHE ALIGNMENT DEMONSTRATION ===",
        "Remember: Cache coherency is critical for DMA!"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/slab.h",
        "linux/smp.h",
        "linux/cache.h"
      ],
      "mustContain": [
        "L1_CACHE_BYTES",
        "smp_wmb",
        "smp_mb",
        "smp_rmb",
        "ktime_get",
        "num_online_cpus"
      ]
    },
    "testCases": [
      {
        "id": "cache_line_demonstration",
        "name": "Cache Line Effects",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "L1_CACHE_BYTES",
          "ktime_get()",
          "sequential_time",
          "random_time"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "memory_barriers",
        "name": "Memory Barriers Usage",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "smp_wmb()",
          "smp_mb()",
          "smp_rmb()"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "cache_coherency_test",
        "name": "Cache Coherency Test",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "kthread_create(cache_coherency_test_thread",
          "kthread_bind(threads[active_cpus], cpu)",
          "for_each_online_cpu(cpu)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "dma_explanation",
        "name": "DMA Cache Problems Explanation",
        "type": "output_match",
        "critical": true,
        "expected": [
          {"pattern": "=== DMA AND CACHE PROBLEMS ===", "exact": true},
          {"pattern": "Cache Coherency", "exact": false},
          {"pattern": "DMA controller accesses main memory directly", "exact": false}
        ]
      },
      {
        "id": "cache_alignment",
        "name": "Cache Alignment Demonstration",
        "type": "output_match",
        "critical": true,
        "expected": [
          {"pattern": "=== CACHE ALIGNMENT DEMONSTRATION ===", "exact": true},
          {"pattern": "False sharing occurs", "exact": false},
          {"pattern": "Cache line size:", "exact": false}
        ]
      }
    ]
  }
}