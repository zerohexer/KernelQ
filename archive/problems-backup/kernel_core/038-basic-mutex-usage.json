{
  "id": 38,
  "title": "Basic Mutex Usage for Synchronization",
  "phase": "kernel_core",
  "difficulty": 6,
  "xp": 55,
  "description": "Learn to use mutexes (mutual exclusion locks) to prevent race conditions. Understand how mutexes provide synchronized access to shared resources and fix the concurrency problems from the previous lesson.",
  "concepts": ["mutex", "synchronization", "critical_section", "mutual_exclusion", "thread_safety"],
  "skills": ["mutex_usage", "synchronization_programming", "thread_safe_code"],
  "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\n// CONCEPT: Mutex (Mutual Exclusion)\n// Mutex = Only one thread can hold the lock at a time\n// Critical Section = Code that accesses shared data\n// \n// Pattern:\n// 1. mutex_lock(&my_mutex)    // Acquire lock\n// 2. /* access shared data */  // Critical section\n// 3. mutex_unlock(&my_mutex)  // Release lock\n//\n// WHY: Prevents race conditions by serializing access to shared data\n\n// Shared data protected by mutex\nstatic int protected_counter = 0;\nstatic DEFINE_MUTEX(counter_mutex);  // Declare and initialize mutex\n\n// TODO: Thread function with proper synchronization\nstatic int safe_thread_function(void *data)\n{\n    int thread_id = (long)data;\n    int i;\n    \n    printk(KERN_INFO \"Thread %d started (with mutex protection)\\n\", thread_id);\n    \n    // Each thread increments counter 1000 times\n    for (i = 0; i < 1000; i++) {\n        // SAFE: Use mutex to protect shared data\n        mutex_lock(&counter_mutex);     // Acquire lock\n        \n        // Critical section - only one thread can be here at a time\n        protected_counter++;\n        \n        mutex_unlock(&counter_mutex);   // Release lock\n        \n        // Small delay to show that synchronization works\n        if (i % 100 == 0) {\n            msleep(1);\n        }\n    }\n    \n    printk(KERN_INFO \"Thread %d finished (protected access)\\n\", thread_id);\n    return 0;\n}\n\n// TODO: Demonstrate proper synchronization with mutex\nstatic void demonstrate_mutex_protection(void)\n{\n    struct task_struct *thread1, *thread2;\n    \n    printk(KERN_INFO \"=== Demonstrating Mutex Protection ===\");\n    printk(KERN_INFO \"Starting 2 threads with mutex synchronization\\n\");\n    printk(KERN_INFO \"Expected final value: 2000\\n\");\n    \n    protected_counter = 0;\n    \n    // Create two threads that will safely access shared data\n    thread1 = kthread_run(safe_thread_function, (void *)1, \"safe_thread1\");\n    thread2 = kthread_run(safe_thread_function, (void *)2, \"safe_thread2\");\n    \n    if (IS_ERR(thread1) || IS_ERR(thread2)) {\n        printk(KERN_ERR \"Failed to create threads\\n\");\n        return;\n    }\n    \n    // Wait for threads to complete\n    msleep(3000);\n    \n    printk(KERN_INFO \"Threads completed\\n\");\n    printk(KERN_INFO \"Final counter value: %d\\n\", protected_counter);\n    printk(KERN_INFO \"Expected value: 2000\\n\");\n    \n    if (protected_counter == 2000) {\n        printk(KERN_INFO \"SUCCESS: Mutex prevented race condition!\\n\");\n    } else {\n        printk(KERN_WARNING \"Unexpected result: %d\\n\", protected_counter);\n    }\n}\n\n// TODO: Demonstrate mutex properties\nstatic void demonstrate_mutex_properties(void)\n{\n    printk(KERN_INFO \"=== Mutex Properties ===\");\n    \n    // Show mutex can be locked\n    printk(KERN_INFO \"Trying to acquire mutex...\\n\");\n    mutex_lock(&counter_mutex);\n    printk(KERN_INFO \"Mutex acquired successfully\\n\");\n    \n    // Show mutex is exclusive (only one holder)\n    printk(KERN_INFO \"Mutex is now locked - no other thread can acquire it\\n\");\n    \n    // Simulate some work\n    msleep(100);\n    \n    // Release the mutex\n    mutex_unlock(&counter_mutex);\n    printk(KERN_INFO \"Mutex released - other threads can now acquire it\\n\");\n}\n\n// TODO: Explain mutex best practices\nstatic void explain_mutex_best_practices(void)\n{\n    printk(KERN_INFO \"=== Mutex Best Practices ===\");\n    printk(KERN_INFO \"1. Always unlock what you lock\\n\");\n    printk(KERN_INFO \"2. Keep critical sections small\\n\");\n    printk(KERN_INFO \"3. Don't hold mutex too long\\n\");\n    printk(KERN_INFO \"4. Can sleep while holding mutex\\n\");\n    printk(KERN_INFO \"5. Use DEFINE_MUTEX() for static mutexes\\n\");\n    printk(KERN_INFO \"6. Use mutex_init() for dynamic mutexes\\n\");\n    \n    printk(KERN_INFO \"When NOT to use mutex:\\n\");\n    printk(KERN_INFO \"- In interrupt context (use spinlocks)\\n\");\n    printk(KERN_INFO \"- Very short critical sections (use spinlocks)\\n\");\n    printk(KERN_INFO \"- High-frequency operations (consider atomics)\\n\");\n}\n\nstatic int __init mutex_demo_init(void)\n{\n    printk(KERN_INFO \"Mutex demonstration module loaded\\n\");\n    printk(KERN_INFO \"Learning proper synchronization with mutexes\\n\");\n    \n    explain_mutex_best_practices();\n    demonstrate_mutex_properties();\n    demonstrate_mutex_protection();\n    \n    return 0;\n}\n\nstatic void __exit mutex_demo_exit(void)\n{\n    printk(KERN_INFO \"Mutex demonstration module unloaded\\n\");\n    printk(KERN_INFO \"Remember: mutex_lock() -> critical section -> mutex_unlock()\\n\");\n}\n\nmodule_init(mutex_demo_init);\nmodule_exit(mutex_demo_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Basic mutex usage for synchronization\");\nMODULE_VERSION(\"1.0\");",
  "validation": {
    "exactRequirements": {
      "functionNames": [
        "mutex_demo_init",
        "mutex_demo_exit",
        "safe_thread_function",
        "demonstrate_mutex_protection",
        "demonstrate_mutex_properties",
        "explain_mutex_best_practices"
      ],
      "variables": [
        {"name": "protected_counter", "type": "int"},
        {"name": "counter_mutex", "type": "struct mutex"}
      ],
      "outputMessages": [
        "Mutex demonstration module loaded",
        "Learning proper synchronization with mutexes",
        "=== Demonstrating Mutex Protection ===",
        "SUCCESS: Mutex prevented race condition!",
        "=== Mutex Properties ===",
        "Mutex acquired successfully",
        "=== Mutex Best Practices ===",
        "Remember: mutex_lock() -> critical section -> mutex_unlock()"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/mutex.h",
        "linux/kthread.h",
        "linux/delay.h"
      ],
      "mustContain": [
        "DEFINE_MUTEX",
        "mutex_lock",
        "mutex_unlock",
        "protected_counter++"
      ]
    },
    "testCases": [
      {
        "id": "mutex_declaration",
        "name": "Mutex Declaration",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "DEFINE_MUTEX(counter_mutex)",
          "mutex_lock(&counter_mutex)",
          "mutex_unlock(&counter_mutex)"
        ],
        "prohibitedSymbols": ["spinlock", "atomic"]
      },
      {
        "id": "critical_section",
        "name": "Protected Critical Section",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "mutex_lock(&counter_mutex)",
          "protected_counter++",
          "mutex_unlock(&counter_mutex)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "synchronization_success",
        "name": "Synchronization Success",
        "type": "output_match",
        "critical": true,
        "expected": [
          {"pattern": "SUCCESS: Mutex prevented race condition!", "exact": true},
          {"pattern": "Final counter value: 2000", "exact": true}
        ]
      },
      {
        "id": "best_practices",
        "name": "Best Practices Explanation",
        "type": "output_match",
        "critical": true,
        "expected": [
          {"pattern": "=== Mutex Best Practices ===", "exact": true},
          {"pattern": "Always unlock what you lock", "exact": false},
          {"pattern": "Keep critical sections small", "exact": false}
        ]
      }
    ]
  }
}