{
  "id": 44,
  "title": "Device Attributes and Sysfs Integration",
  "difficulty": 7,
  "xp": 70,
  "phase": "kernel_core",
  "description": "Extend the character device driver with sysfs attributes for configuration and status monitoring. This teaches device attribute management used extensively in production drivers at enterprise companies for device configuration and debugging.",
  "concepts": ["device_attributes", "sysfs_integration", "show_store_functions", "device_configuration", "runtime_control"],
  "skills": ["device_attribute_management", "sysfs_programming", "device_configuration", "runtime_parameter_control"],
  "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n\n#define DEVICE_NAME \"attrdev\"\n#define CLASS_NAME \"attrclass\"\n#define BUFFER_SIZE 4096\n\n// TODO: Device configuration structure\nstruct device_config {\n    int debug_level;\n    bool read_only;\n    size_t max_buffer_size;\n    char device_name[32];\n    unsigned long access_count;\n    unsigned long last_access_jiffies;\n};\n\n// TODO: Main device structure\nstruct attr_device {\n    struct cdev cdev;\n    struct device *device;\n    struct class *class;\n    dev_t dev_num;\n    char *buffer;\n    size_t buffer_used;\n    struct mutex device_mutex;\n    struct device_config config;\n};\n\nstatic struct attr_device attr_dev;\n\n// TODO: Device attribute show functions\nstatic ssize_t debug_level_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n    struct attr_device *attr_dev_ptr = dev_get_drvdata(dev);\n    return sprintf(buf, \"%d\\n\", attr_dev_ptr->config.debug_level);\n}\n\n// TODO: Device attribute store functions\nstatic ssize_t debug_level_store(struct device *dev, struct device_attribute *attr,\n                                const char *buf, size_t count)\n{\n    struct attr_device *attr_dev_ptr = dev_get_drvdata(dev);\n    int value;\n    int ret;\n    \n    ret = kstrtoint(buf, 10, &value);\n    if (ret) {\n        return ret;\n    }\n    \n    if (value < 0 || value > 3) {\n        return -EINVAL;\n    }\n    \n    mutex_lock(&attr_dev_ptr->device_mutex);\n    attr_dev_ptr->config.debug_level = value;\n    mutex_unlock(&attr_dev_ptr->device_mutex);\n    \n    if (value >= 2) {\n        dev_info(dev, \"Debug level changed to %d\\n\", value);\n    }\n    \n    return count;\n}\n\n// TODO: Read-only attribute show function\nstatic ssize_t read_only_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n    struct attr_device *attr_dev_ptr = dev_get_drvdata(dev);\n    return sprintf(buf, \"%d\\n\", attr_dev_ptr->config.read_only ? 1 : 0);\n}\n\n// TODO: Read-only attribute store function\nstatic ssize_t read_only_store(struct device *dev, struct device_attribute *attr,\n                              const char *buf, size_t count)\n{\n    struct attr_device *attr_dev_ptr = dev_get_drvdata(dev);\n    bool value;\n    int ret;\n    \n    ret = kstrtobool(buf, &value);\n    if (ret) {\n        return ret;\n    }\n    \n    mutex_lock(&attr_dev_ptr->device_mutex);\n    attr_dev_ptr->config.read_only = value;\n    mutex_unlock(&attr_dev_ptr->device_mutex);\n    \n    dev_info(dev, \"Read-only mode %s\\n\", value ? \"enabled\" : \"disabled\");\n    \n    return count;\n}\n\n// TODO: Statistics attribute show function\nstatic ssize_t stats_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n    struct attr_device *attr_dev_ptr = dev_get_drvdata(dev);\n    return sprintf(buf, \"Access count: %lu\\nLast access: %lu jiffies ago\\nBuffer used: %zu/%zu\\n\",\n                   attr_dev_ptr->config.access_count,\n                   jiffies - attr_dev_ptr->config.last_access_jiffies,\n                   attr_dev_ptr->buffer_used,\n                   BUFFER_SIZE);\n}\n\n// TODO: Device name attribute functions\nstatic ssize_t device_name_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n    struct attr_device *attr_dev_ptr = dev_get_drvdata(dev);\n    return sprintf(buf, \"%s\\n\", attr_dev_ptr->config.device_name);\n}\n\nstatic ssize_t device_name_store(struct device *dev, struct device_attribute *attr,\n                                const char *buf, size_t count)\n{\n    struct attr_device *attr_dev_ptr = dev_get_drvdata(dev);\n    \n    if (count >= sizeof(attr_dev_ptr->config.device_name)) {\n        return -EINVAL;\n    }\n    \n    mutex_lock(&attr_dev_ptr->device_mutex);\n    strncpy(attr_dev_ptr->config.device_name, buf, sizeof(attr_dev_ptr->config.device_name) - 1);\n    attr_dev_ptr->config.device_name[sizeof(attr_dev_ptr->config.device_name) - 1] = '\\0';\n    \n    // Remove trailing newline if present\n    if (attr_dev_ptr->config.device_name[strlen(attr_dev_ptr->config.device_name) - 1] == '\\n') {\n        attr_dev_ptr->config.device_name[strlen(attr_dev_ptr->config.device_name) - 1] = '\\0';\n    }\n    \n    mutex_unlock(&attr_dev_ptr->device_mutex);\n    \n    dev_info(dev, \"Device name changed to: %s\\n\", attr_dev_ptr->config.device_name);\n    \n    return count;\n}\n\n// TODO: Define device attributes\nstatic DEVICE_ATTR_RW(debug_level);\nstatic DEVICE_ATTR_RW(read_only);\nstatic DEVICE_ATTR_RO(stats);\nstatic DEVICE_ATTR_RW(device_name);\n\n// TODO: Create attribute group\nstatic struct attribute *attr_dev_attrs[] = {\n    &dev_attr_debug_level.attr,\n    &dev_attr_read_only.attr,\n    &dev_attr_stats.attr,\n    &dev_attr_device_name.attr,\n    NULL,\n};\n\nstatic const struct attribute_group attr_dev_group = {\n    .attrs = attr_dev_attrs,\n};\n\n// TODO: File operations\nstatic int device_open(struct inode *inode, struct file *file)\n{\n    struct attr_device *dev_data = &attr_dev;\n    \n    file->private_data = dev_data;\n    \n    mutex_lock(&dev_data->device_mutex);\n    dev_data->config.access_count++;\n    dev_data->config.last_access_jiffies = jiffies;\n    mutex_unlock(&dev_data->device_mutex);\n    \n    if (dev_data->config.debug_level >= 2) {\n        printk(KERN_INFO \"Device opened (access count: %lu)\\n\", dev_data->config.access_count);\n    }\n    \n    return 0;\n}\n\nstatic int device_release(struct inode *inode, struct file *file)\n{\n    struct attr_device *dev_data = file->private_data;\n    \n    if (dev_data->config.debug_level >= 2) {\n        printk(KERN_INFO \"Device closed\\n\");\n    }\n    \n    return 0;\n}\n\nstatic ssize_t device_read(struct file *file, char __user *user_buffer,\n                          size_t count, loff_t *offset)\n{\n    struct attr_device *dev_data = file->private_data;\n    ssize_t bytes_read = 0;\n    \n    if (mutex_lock_interruptible(&dev_data->device_mutex)) {\n        return -ERESTARTSYS;\n    }\n    \n    dev_data->config.last_access_jiffies = jiffies;\n    \n    if (*offset >= dev_data->buffer_used) {\n        mutex_unlock(&dev_data->device_mutex);\n        return 0; // EOF\n    }\n    \n    bytes_read = min(count, dev_data->buffer_used - *offset);\n    \n    if (copy_to_user(user_buffer, dev_data->buffer + *offset, bytes_read)) {\n        mutex_unlock(&dev_data->device_mutex);\n        return -EFAULT;\n    }\n    \n    *offset += bytes_read;\n    \n    if (dev_data->config.debug_level >= 3) {\n        printk(KERN_INFO \"Device read: %zu bytes\\n\", bytes_read);\n    }\n    \n    mutex_unlock(&dev_data->device_mutex);\n    return bytes_read;\n}\n\nstatic ssize_t device_write(struct file *file, const char __user *user_buffer,\n                           size_t count, loff_t *offset)\n{\n    struct attr_device *dev_data = file->private_data;\n    ssize_t bytes_written = 0;\n    \n    // Check if device is in read-only mode\n    if (dev_data->config.read_only) {\n        return -EPERM;\n    }\n    \n    if (mutex_lock_interruptible(&dev_data->device_mutex)) {\n        return -ERESTARTSYS;\n    }\n    \n    dev_data->config.last_access_jiffies = jiffies;\n    \n    if (*offset >= BUFFER_SIZE) {\n        mutex_unlock(&dev_data->device_mutex);\n        return -ENOSPC;\n    }\n    \n    bytes_written = min(count, BUFFER_SIZE - *offset);\n    \n    if (copy_from_user(dev_data->buffer + *offset, user_buffer, bytes_written)) {\n        mutex_unlock(&dev_data->device_mutex);\n        return -EFAULT;\n    }\n    \n    *offset += bytes_written;\n    if (*offset > dev_data->buffer_used) {\n        dev_data->buffer_used = *offset;\n    }\n    \n    if (dev_data->config.debug_level >= 3) {\n        printk(KERN_INFO \"Device write: %zu bytes\\n\", bytes_written);\n    }\n    \n    mutex_unlock(&dev_data->device_mutex);\n    return bytes_written;\n}\n\nstatic const struct file_operations attr_dev_fops = {\n    .owner = THIS_MODULE,\n    .open = device_open,\n    .release = device_release,\n    .read = device_read,\n    .write = device_write,\n};\n\nstatic int __init attr_dev_init(void)\n{\n    int ret;\n    \n    printk(KERN_INFO \"Attribute device driver initializing...\\n\");\n    \n    // TODO: Initialize device structure\n    memset(&attr_dev, 0, sizeof(attr_dev));\n    mutex_init(&attr_dev.device_mutex);\n    \n    // TODO: Initialize configuration\n    attr_dev.config.debug_level = 1;\n    attr_dev.config.read_only = false;\n    attr_dev.config.max_buffer_size = BUFFER_SIZE;\n    strcpy(attr_dev.config.device_name, \"default_name\");\n    attr_dev.config.access_count = 0;\n    attr_dev.config.last_access_jiffies = jiffies;\n    \n    // TODO: Allocate buffer\n    attr_dev.buffer = kzalloc(BUFFER_SIZE, GFP_KERNEL);\n    if (!attr_dev.buffer) {\n        return -ENOMEM;\n    }\n    \n    // TODO: Register character device\n    ret = alloc_chrdev_region(&attr_dev.dev_num, 0, 1, DEVICE_NAME);\n    if (ret < 0) {\n        kfree(attr_dev.buffer);\n        return ret;\n    }\n    \n    cdev_init(&attr_dev.cdev, &attr_dev_fops);\n    attr_dev.cdev.owner = THIS_MODULE;\n    \n    ret = cdev_add(&attr_dev.cdev, attr_dev.dev_num, 1);\n    if (ret < 0) {\n        unregister_chrdev_region(attr_dev.dev_num, 1);\n        kfree(attr_dev.buffer);\n        return ret;\n    }\n    \n    // TODO: Create device class\n    attr_dev.class = class_create(THIS_MODULE, CLASS_NAME);\n    if (IS_ERR(attr_dev.class)) {\n        cdev_del(&attr_dev.cdev);\n        unregister_chrdev_region(attr_dev.dev_num, 1);\n        kfree(attr_dev.buffer);\n        return PTR_ERR(attr_dev.class);\n    }\n    \n    // TODO: Create device\n    attr_dev.device = device_create(attr_dev.class, NULL, attr_dev.dev_num,\n                                   &attr_dev, DEVICE_NAME);\n    if (IS_ERR(attr_dev.device)) {\n        class_destroy(attr_dev.class);\n        cdev_del(&attr_dev.cdev);\n        unregister_chrdev_region(attr_dev.dev_num, 1);\n        kfree(attr_dev.buffer);\n        return PTR_ERR(attr_dev.device);\n    }\n    \n    // TODO: Set device driver data\n    dev_set_drvdata(attr_dev.device, &attr_dev);\n    \n    // TODO: Create sysfs attribute group\n    ret = sysfs_create_group(&attr_dev.device->kobj, &attr_dev_group);\n    if (ret) {\n        device_destroy(attr_dev.class, attr_dev.dev_num);\n        class_destroy(attr_dev.class);\n        cdev_del(&attr_dev.cdev);\n        unregister_chrdev_region(attr_dev.dev_num, 1);\n        kfree(attr_dev.buffer);\n        return ret;\n    }\n    \n    printk(KERN_INFO \"Attribute device driver loaded successfully\\n\");\n    printk(KERN_INFO \"Device: /dev/%s\\n\", DEVICE_NAME);\n    printk(KERN_INFO \"Sysfs attributes: /sys/class/%s/%s/\\n\", CLASS_NAME, DEVICE_NAME);\n    \n    return 0;\n}\n\nstatic void __exit attr_dev_exit(void)\n{\n    // TODO: Remove sysfs attributes\n    sysfs_remove_group(&attr_dev.device->kobj, &attr_dev_group);\n    \n    // TODO: Clean up device\n    device_destroy(attr_dev.class, attr_dev.dev_num);\n    class_destroy(attr_dev.class);\n    cdev_del(&attr_dev.cdev);\n    unregister_chrdev_region(attr_dev.dev_num, 1);\n    kfree(attr_dev.buffer);\n    \n    printk(KERN_INFO \"Attribute device driver unloaded\\n\");\n}\n\nmodule_init(attr_dev_init);\nmodule_exit(attr_dev_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Character device with sysfs attributes\");\nMODULE_VERSION(\"1.0\");",
  "validation": {
    "exactRequirements": {
      "functionNames": [
        "attr_dev_init",
        "attr_dev_exit",
        "debug_level_show",
        "debug_level_store",
        "read_only_show",
        "read_only_store",
        "stats_show",
        "device_name_show",
        "device_name_store"
      ],
      "variables": [
        {"name": "attr_dev", "type": "struct attr_device"},
        {"name": "attr_dev_group", "type": "struct attribute_group"}
      ],
      "outputMessages": [
        "Attribute device driver loaded successfully",
        "Device: /dev/attrdev",
        "Sysfs attributes: /sys/class/attrclass/attrdev/",
        "Attribute device driver unloaded"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/fs.h",
        "linux/device.h",
        "linux/cdev.h"
      ],
      "mustContain": [
        "DEVICE_ATTR_RW",
        "DEVICE_ATTR_RO",
        "sysfs_create_group",
        "sysfs_remove_group",
        "dev_set_drvdata",
        "dev_get_drvdata"
      ]
    },
    "testCases": [
      {
        "id": "device_attribute_macros",
        "name": "Device Attribute Macros",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "DEVICE_ATTR_RW(debug_level)",
          "DEVICE_ATTR_RW(read_only)",
          "DEVICE_ATTR_RO(stats)",
          "DEVICE_ATTR_RW(device_name)"
        ],
        "prohibitedSymbols": ["DEVICE_ATTR("]
      },
      {
        "id": "show_store_functions",
        "name": "Show and Store Function Implementation",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "sprintf(buf",
          "kstrtoint(buf, 10, &value)",
          "kstrtobool(buf, &value)",
          "strncpy(attr_dev_ptr->config.device_name"
        ],
        "prohibitedSymbols": ["strcpy"]
      },
      {
        "id": "attribute_group_creation",
        "name": "Attribute Group Management",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "sysfs_create_group(&attr_dev.device->kobj, &attr_dev_group)",
          "sysfs_remove_group(&attr_dev.device->kobj, &attr_dev_group)"
        ],
        "prohibitedSymbols": ["device_create_file"]
      },
      {
        "id": "driver_data_management",
        "name": "Driver Data Management",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "dev_set_drvdata(attr_dev.device, &attr_dev)",
          "dev_get_drvdata(dev)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "input_validation",
        "name": "Input Validation in Store Functions",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "if (value < 0 || value > 3)",
          "return -EINVAL",
          "if (count >= sizeof"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "thread_safety_attributes",
        "name": "Thread Safety in Attribute Access",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "mutex_lock(&attr_dev_ptr->device_mutex)",
          "mutex_unlock(&attr_dev_ptr->device_mutex)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "configuration_integration",
        "name": "Configuration Integration with Operations",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "if (dev_data->config.read_only)",
          "if (dev_data->config.debug_level >= 2)",
          "return -EPERM"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "sysfs_attributes_message",
        "name": "Sysfs Attributes Path Message",
        "type": "output_match",
        "critical": true,
        "expected": [
          {"pattern": "Sysfs attributes: /sys/class/attrclass/attrdev/", "exact": true}
        ]
      }
    ]
  }
}