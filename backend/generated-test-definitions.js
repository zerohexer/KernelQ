// Auto-generated from problems/ directory
// DO NOT EDIT THIS FILE DIRECTLY - Edit problems/*.json instead
// Generated at: 2025-09-09T17:41:57.954Z

const generatedTestDefinitions = new Map();


// Problem 1: Hello World - Your First Kernel Module
generatedTestDefinitions.set(1, {
    "name": "Hello World - Your First Kernel Module",
    "category": "foundations",
    "description": "Welcome to kernel programming! Create your very first kernel module - a simple \"Hello World\" program that runs inside the Linux kernel. This introduction uses just one file to keep things simple and help you understand the basics before moving to more advanced topics.",
    "exactRequirements": {
        "functionNames": [
            "hello_init",
            "hello_exit"
        ],
        "outputMessages": [
            "Hello World from kernel!",
            "Goodbye from kernel!"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "printk",
            "KERN_INFO"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "static int __init hello_init(void)",
                "static void __exit hello_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "kernel_functionality_test",
            "name": "Kernel Module Functionality Test",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "hello_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\\\"=== Hello World Module Test ===\\\\n\\\");\\n    \\n    printf(\\\"Test: Loading hello module...\\\\n\\\");\\n    system(\\\"insmod /lib/modules/hello.ko\\\");\\n    \\n    printf(\\\"Test: Unloading hello module...\\\\n\\\");\\n    system(\\\"rmmod hello\\\");\\n    \\n    printf(\\\"SUCCESS: Module load/unload completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "testCommands": [
                    "echo 'Testing kernel module compilation and basic functionality...'",
                    "/bin/hello_tester",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Checking for kernel logging functionality...'",
                    "dmesg | grep 'Hello World from kernel' && echo 'PASS: init function logging working' || echo 'FAIL: init function logging missing'",
                    "dmesg | grep 'Goodbye from kernel' && echo 'PASS: exit function logging working' || echo 'FAIL: exit function logging missing'",
                    "echo 'PASS: All kernel functionality tests completed'"
                ],
                "expected": {
                    "dmesg": [
                        "Hello World from kernel!",
                        "Goodbye from kernel!"
                    ],
                    "stdout": [
                        "Hello World Module Test",
                        "SUCCESS: Module load/unload completed",
                        "PASS: All kernel functionality tests completed"
                    ]
                },
                "timeout": 10
            }
        },
        {
            "id": "exact_output",
            "name": "Function-Linked Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Hello World from kernel!",
                    "exact": true,
                    "linkedFunction": "static int __init hello_init(void)"
                },
                {
                    "pattern": "Goodbye from kernel!",
                    "exact": true,
                    "linkedFunction": "static void __exit hello_exit(void)"
                }
            ]
        }
    ]
});


// Problem 2: Hello World - Multi-File Kernel Module
generatedTestDefinitions.set(2, {
    "name": "Hello World - Multi-File Kernel Module",
    "category": "foundations",
    "description": "Create your first multi-file kernel module with a separate header file. This introduces you to kernel module structure with proper file organization. Note: Module init/exit functions are static and don't need header declarations.",
    "exactRequirements": {
        "functionNames": [
            "hello_init",
            "hello_exit"
        ],
        "outputMessages": [
            "Hello from multi-file kernel module!",
            "Goodbye from multi-file kernel module!"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "printk",
            "KERN_INFO"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "header_structure",
            "name": "Header File Structure",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "#ifndef HELLO_H",
                "#define HELLO_H",
                "#endif"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [],
            "prohibitedSymbols": [
                "static.*hello_init",
                "static.*hello_exit"
            ]
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "static int __init hello_init(void)",
                "static void __exit hello_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "multifile_functionality_test",
            "name": "Multi-File Module Functionality Test",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "multifile_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\\\"=== Multi-File Module Test ===\\\\n\\\");\\n    \\n    printf(\\\"Test: Loading multi-file hello module...\\\\n\\\");\\n    system(\\\"insmod /lib/modules/hello.ko\\\");\\n    \\n    printf(\\\"Test: Unloading multi-file hello module...\\\\n\\\");\\n    system(\\\"rmmod hello\\\");\\n    \\n    printf(\\\"SUCCESS: Multi-file module load/unload completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "testCommands": [
                    "echo 'Testing multi-file kernel module functionality...'",
                    "/bin/multifile_tester",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Checking for module information and functionality...'",
                    "dmesg | grep 'Hello from multi-file kernel module' && echo 'PASS: init function with proper message' || echo 'FAIL: init function message missing'",
                    "dmesg | grep 'Goodbye from multi-file kernel module' && echo 'PASS: exit function with proper message' || echo 'FAIL: exit function message missing'",
                    "echo 'PASS: All multi-file functionality tests completed'"
                ],
                "expected": {
                    "dmesg": [
                        "Hello from multi-file kernel module!",
                        "Goodbye from multi-file kernel module!"
                    ],
                    "stdout": [
                        "Multi-File Module Test",
                        "SUCCESS: Multi-file module load/unload completed",
                        "PASS: All multi-file functionality tests completed"
                    ]
                },
                "timeout": 10
            }
        },
        {
            "id": "exact_output",
            "name": "Function-Linked Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Hello from multi-file kernel module!",
                    "exact": true,
                    "linkedFunction": "static int __init hello_init(void)"
                },
                {
                    "pattern": "Goodbye from multi-file kernel module!",
                    "exact": true,
                    "linkedFunction": "static void __exit hello_exit(void)"
                }
            ]
        }
    ]
});


// Problem 3: Create Your First Variable
generatedTestDefinitions.set(3, {
    "name": "Create Your First Variable",
    "category": "foundations",
    "description": "Learn to create variables in kernel modules using proper file structure. You'll work with separate header and C files - a fundamental practice in professional kernel development that builds good coding habits from day one.",
    "exactRequirements": {
        "functionNames": [
            "variables_init",
            "variables_exit"
        ],
        "variables": [
            {
                "name": "my_number",
                "type": "int",
                "value": 42,
                "storageClass": "none"
            }
        ],
        "outputMessages": [
            "Variables module loaded"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "#ifndef VARIABLES_H",
            "#define VARIABLES_H",
            "extern int my_number",
            "int my_number = 42",
            "#include \"variables.h\""
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "header_guards",
            "name": "Proper Header Guards",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "#ifndef VARIABLES_H",
                "#define VARIABLES_H",
                "#endif"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "variable_declaration",
            "name": "Variable Declaration in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "extern int my_number"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "variable_definition",
            "name": "Variable Definition in C File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int my_number = 42"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "static int __init variables_init(void)",
                "static void __exit variables_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "variable_functionality_test",
            "name": "Variable Declaration and Definition Test",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "variable_param_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Variable Parameter Validation Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random test values\\n    int test_val1 = (rand() % 50) + 10;  // 10-59\\n    int test_val2 = (rand() % 50) + 60;  // 60-109\\n    \\n    printf(\\\"Test 1: Loading with my_number=%d\\\\n\\\", test_val1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/variables.ko my_number=%d\\\", test_val1);\\n    system(\\\"rmmod variables 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Loading with my_number=%d\\\\n\\\", test_val2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/variables.ko my_number=%d\\\", test_val2);\\n    system(\\\"rmmod variables\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Variable parameter test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo 'Creating test file that validates extern variable declaration...'",
                    "echo '#include \"/lib/modules/variables.h\"' > /tmp/test.c",
                    "echo 'int main() { my_number = 42; return my_number; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: extern int my_number not properly declared in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
                    "echo 'PASS: extern int my_number found in header file'",
                    "echo 'Phase 2: Dynamic Parameter Testing'",
                    "/bin/variable_param_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Phase 2.1: Variable parameter extraction...'",
                    "TEST_VAL1=$(grep -o 'Test 1: Loading with my_number=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
                    "TEST_VAL2=$(grep -o 'Test 2: Loading with my_number=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
                    "echo 'Test value 1: '$TEST_VAL1",
                    "echo 'Test value 2: '$TEST_VAL2",
                    "echo 'Phase 2.2: Module parameter validation...'",
                    "dmesg | grep 'Variables module loaded' && echo 'PASS: Module loads with parameter' || echo 'FAIL: Module loading failed'",
                    "echo 'Phase 3: Default value validation (must be 42)...'",
                    "rmmod variables 2>/dev/null",
                    "insmod /lib/modules/variables.ko",
                    "sleep 1",
                    "DEFAULT_VALUE=$(cat /sys/module/variables/parameters/my_number 2>/dev/null || echo 'ERROR')",
                    "echo 'Default value from parameter: '$DEFAULT_VALUE",
                    "if [ \"$DEFAULT_VALUE\" = \"42\" ]; then",
                    "    echo 'PASS: Variable initialized to 42 correctly'",
                    "else",
                    "    echo 'FAIL: Variable not initialized to 42 (got: '$DEFAULT_VALUE')'",
                    "fi",
                    "echo 'Phase 4: Value reassignment test (ensuring variable is mutable)...'",
                    "echo 99 > /sys/module/variables/parameters/my_number 2>/dev/null",
                    "NEW_VALUE=$(cat /sys/module/variables/parameters/my_number 2>/dev/null || echo 'ERROR')",
                    "echo 'Value after reassignment: '$NEW_VALUE",
                    "if [ \"$NEW_VALUE\" = \"99\" ]; then",
                    "    echo 'PASS: Variable is mutable and reassignable'",
                    "else",
                    "    echo 'FAIL: Variable is not properly mutable (expected 99, got: '$NEW_VALUE')'",
                    "fi",
                    "echo 'Phase 5: Parameter accessibility validation...'",
                    "ls /sys/module/variables/parameters/my_number >/dev/null 2>&1 && echo 'PASS: Variable exposed as module parameter' || echo 'FAIL: Variable not declared as module parameter'",
                    "echo 'PASS: All variable validation tests completed'"
                ],
                "expected": {
                    "dmesg": [
                        "Variables module loaded",
                        "Variables module unloaded"
                    ],
                    "stdout": [
                        "PASS: extern int my_number found in header file",
                        "Variable Parameter Validation Test",
                        "SUCCESS: Variable parameter test completed",
                        "PASS: Variable initialized to 42 correctly",
                        "PASS: Variable is mutable and reassignable",
                        "PASS: All variable validation tests completed"
                    ]
                },
                "timeout": 10
            }
        },
        {
            "id": "exact_output",
            "name": "Exact Output Message",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Variables module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init variables_init(void)"
                }
            ]
        }
    ]
});


// Problem 4: Use Your Variable
generatedTestDefinitions.set(4, {
    "name": "Use Your Variable",
    "category": "foundations",
    "description": "Learn to use variables by printing them with proper format specifiers. Build on your knowledge of header/C file structure while introducing printk formatting - a crucial skill for kernel debugging.",
    "exactRequirements": {
        "functionNames": [
            "use_vars_init",
            "use_vars_exit"
        ],
        "variables": [
            {
                "name": "my_number",
                "type": "int",
                "value": 42,
                "storageClass": "none"
            }
        ],
        "outputMessages": [
            "Variable usage module loaded",
            "My number is: 42"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "printk(KERN_INFO \"My number is: %d\\n\", my_number)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "static int __init use_vars_init(void)",
                "static void __exit use_vars_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "variable_usage_test",
            "name": "Variable Usage and Formatting Test",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "variable_usage_dynamic_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Variable Usage Dynamic Validation Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random test values\\n    int test_val1 = (rand() % 50) + 10;  // 10-59\\n    int test_val2 = (rand() % 50) + 60;  // 60-109\\n    int test_val3 = (rand() % 20) + 1;   // 1-20\\n    \\n    printf(\\\"Test 1: Testing with my_number=%d\\\\n\\\", test_val1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/use_vars.ko my_number=%d\\\", test_val1);\\n    system(\\\"rmmod use_vars 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Testing with my_number=%d\\\\n\\\", test_val2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/use_vars.ko my_number=%d\\\", test_val2);\\n    system(\\\"rmmod use_vars\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"Test 3: Testing with my_number=%d\\\\n\\\", test_val3);\\n    char cmd3[256];\\n    snprintf(cmd3, sizeof(cmd3), \\\"insmod /lib/modules/use_vars.ko my_number=%d\\\", test_val3);\\n    system(\\\"rmmod use_vars\\\");\\n    system(cmd3);\\n    \\n    printf(\\\"SUCCESS: Variable usage dynamic test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo 'Creating test file that validates extern variable declaration...'",
                    "echo '#include \"/lib/modules/use_vars.h\"' > /tmp/test.c",
                    "echo 'int main() { my_number = 99; return my_number; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: extern int my_number not properly declared in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
                    "echo 'PASS: extern int my_number found in header file'",
                    "echo 'Phase 2: Dynamic Variable Usage Testing'",
                    "/bin/variable_usage_dynamic_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Phase 2.1: Dynamic test value extraction...'",
                    "TEST_VAL1=$(grep -o 'Test 1: Testing with my_number=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
                    "TEST_VAL2=$(grep -o 'Test 2: Testing with my_number=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
                    "TEST_VAL3=$(grep -o 'Test 3: Testing with my_number=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
                    "echo 'Test values: '$TEST_VAL1', '$TEST_VAL2', '$TEST_VAL3",
                    "echo 'Phase 2.2: Basic module functionality check...'",
                    "dmesg | grep 'Variable usage module loaded' && echo 'PASS: use_vars_init function working' || echo 'FAIL: use_vars_init function missing'",
                    "echo 'Phase 3: Dynamic variable usage validation...'",
                    "dmesg | grep \"My number is: $TEST_VAL1\" && echo \"PASS: Variable correctly prints value $TEST_VAL1\" || echo \"FAIL: Variable not used or wrong value (expected $TEST_VAL1)\"",
                    "dmesg | grep \"My number is: $TEST_VAL2\" && echo \"PASS: Variable correctly prints value $TEST_VAL2\" || echo \"FAIL: Variable not used or wrong value (expected $TEST_VAL2)\"",
                    "dmesg | grep \"My number is: $TEST_VAL3\" && echo \"PASS: Variable correctly prints value $TEST_VAL3\" || echo \"FAIL: Variable not used or wrong value (expected $TEST_VAL3)\"",
                    "echo 'Phase 4: Default value validation (must be 42)...'",
                    "rmmod use_vars 2>/dev/null",
                    "insmod /lib/modules/use_vars.ko",
                    "sleep 1",
                    "dmesg | grep 'My number is: 42' && echo 'PASS: Default value 42 correctly displayed' || echo 'FAIL: Default value not 42 or not printed'",
                    "echo 'Phase 5: Module unload check...'",
                    "dmesg | grep 'Variable usage module unloaded' && echo 'PASS: use_vars_exit function working' || echo 'FAIL: use_vars_exit function missing'",
                    "echo 'PASS: All variable usage dynamic validation tests completed'"
                ],
                "expected": {
                    "dmesg": [
                        "Variable usage module loaded",
                        "My number is: .*",
                        "Variable usage module unloaded"
                    ],
                    "stdout": [
                        "PASS: extern int my_number found in header file",
                        "Variable Usage Dynamic Validation Test",
                        "SUCCESS: Variable usage dynamic test completed",
                        "PASS: Default value 42 correctly displayed",
                        "PASS: All variable usage dynamic validation tests completed"
                    ]
                },
                "timeout": 10
            }
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Variable usage module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init use_vars_init(void)"
                },
                {
                    "pattern": "My number is: 42",
                    "exact": true,
                    "linkedFunction": "static int __init use_vars_init(void)"
                }
            ]
        }
    ]
});


// Problem 5: Multiple Variables - Study Complete Example
generatedTestDefinitions.set(5, {
    "name": "Multiple Variables - Study Complete Example",
    "category": "foundations",
    "description": "Study a complete working example with multiple data types. See how int, char, and bool variables work together with proper format specifiers. This example includes advanced module parameter support that will be used in later problems.",
    "exactRequirements": {
        "functionNames": [
            "multi_vars_init",
            "multi_vars_exit",
            "print_student_info"
        ],
        "variables": [
            {
                "name": "student_id",
                "type": "int",
                "value": 12345
            },
            {
                "name": "student_grade",
                "type": "char",
                "value": "'A'"
            },
            {
                "name": "student_passed",
                "type": "bool",
                "value": true
            }
        ],
        "outputMessages": [
            "Multi-variable module loaded",
            "Student ID: 12345",
            "Student Grade: A",
            "Student Passed: 1"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "int student_id = 12345",
            "char student_grade = 'A'",
            "bool student_passed = true",
            "void print_student_info(void)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "multiple_definitions",
            "name": "Multiple Variable Definitions",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int student_id = 12345",
                "char student_grade = 'A'",
                "bool student_passed = true"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_structure",
            "name": "Print Function Implementation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_student_info(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_student_info(void)",
                "static int __init multi_vars_init(void)",
                "static void __exit multi_vars_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_student_info(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Basic Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Multi-variable module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init multi_vars_init(void)"
                },
                {
                    "pattern": "Student Information",
                    "exact": true,
                    "linkedFunction": "void print_student_info(void)"
                },
                {
                    "pattern": "Student ID: 12345",
                    "exact": true,
                    "linkedFunction": "void print_student_info(void)"
                },
                {
                    "pattern": "Student Grade: A",
                    "exact": true,
                    "linkedFunction": "void print_student_info(void)"
                },
                {
                    "pattern": "Student Passed: 1",
                    "exact": true,
                    "linkedFunction": "void print_student_info(void)"
                }
            ]
        },
        {
            "id": "demonstration_test",
            "name": "Study Example with Dynamic Testing",
            "type": "kernel_project_test",
            "critical": false,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "demo_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\"=== Part A Demo Test ===\\\\n\");\\n    printf(\"Demonstrating dynamic module parameters\\\\n\");\\n    \\n    printf(\"Test: Loading with student_id=99999\\\\n\");\\n    system(\"rmmod multi_vars 2>/dev/null\");\\n    system(\"insmod /lib/modules/multi_vars.ko student_id=99999\");\\n    \\n    printf(\"SUCCESS: Demo completed\\\\n\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Demonstrating module parameter functionality'"
                ],
                "testCommands": [
                    "/bin/demo_tester",
                    "echo 'Check: Module parameter works'",
                    "dmesg | grep 'Student ID: 99999' && echo 'DEMO: Parameter worked!' || echo 'INFO: Using default value'"
                ],
                "expected": {
                    "dmesg": [
                        "Multi-variable module loaded"
                    ],
                    "stdout": [
                        "Part A Demo Test",
                        "SUCCESS: Demo completed"
                    ]
                },
                "timeout": 30
            }
        }
    ]
});


// Problem 6: Multiple Variables - Guided Practice
generatedTestDefinitions.set(6, {
    "name": "Multiple Variables - Guided Practice",
    "category": "foundations",
    "description": "Build on Problem 4 by completing a partially implemented solution. Fill in strategic gaps while working with module parameters for dynamic testing. This bridges complete examples to independent creation.",
    "exactRequirements": {
        "functionNames": [
            "practice_vars_init",
            "practice_vars_exit",
            "print_employee_info"
        ],
        "variables": [
            {
                "name": "employee_id",
                "type": "int",
                "value": 67890
            },
            {
                "name": "performance_grade",
                "type": "char",
                "value": "'A'"
            },
            {
                "name": "is_promoted",
                "type": "bool",
                "value": true
            }
        ],
        "outputMessages": [
            "Practice variables module loaded",
            "Employee Information",
            "Employee ID: 67890",
            "Grade: A",
            "Promoted: 1"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "int employee_id = 67890",
            "char performance_grade = 'A'",
            "bool is_promoted = true",
            "void print_employee_info(void)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "variable_completion",
            "name": "Variable Value Completion",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int employee_id = 67890",
                "char performance_grade = 'A'",
                "bool is_promoted = true"
            ],
            "prohibitedSymbols": [
                "_____"
            ]
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_employee_info(void)",
                "static int __init practice_vars_init(void)",
                "static void __exit practice_vars_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_employee_info(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Function-Linked Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Practice variables module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init practice_vars_init(void)"
                },
                {
                    "pattern": "Employee Information",
                    "exact": true,
                    "linkedFunction": "void print_employee_info(void)"
                },
                {
                    "pattern": "Employee ID: 67890",
                    "exact": true,
                    "linkedFunction": "void print_employee_info(void)"
                },
                {
                    "pattern": "Grade: A",
                    "exact": true,
                    "linkedFunction": "void print_employee_info(void)"
                },
                {
                    "pattern": "Promoted: 1",
                    "exact": true,
                    "linkedFunction": "void print_employee_info(void)"
                }
            ]
        },
        {
            "id": "guided_dynamic_testing",
            "name": "Guided Dynamic Testing",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "practice_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\"=== Part B Practice Test ===\\\\n\");\\n    printf(\"Testing guided completion with dynamic values\\\\n\");\\n    \\n    printf(\"Test: Loading with employee_id=88888\\\\n\");\\n    system(\"rmmod practice_vars 2>/dev/null\");\\n    system(\"insmod /lib/modules/practice_vars.ko employee_id=88888\");\\n    \\n    printf(\"SUCCESS: Practice test completed\\\\n\");\\n    printf(\"PASS: Variable completion works\\\\n\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting guided practice testing'"
                ],
                "testCommands": [
                    "/bin/practice_tester",
                    "echo 'Checking dynamic value'",
                    "dmesg | grep 'Employee ID: 88888' && echo 'PASS: Dynamic employee_id worked' || echo 'FAIL: Must use variables, not hardcoded values'"
                ],
                "expected": {
                    "dmesg": [
                        "Practice variables module loaded",
                        "Employee ID: 88888"
                    ],
                    "stdout": [
                        "Part B Practice Test",
                        "SUCCESS: Practice test completed",
                        "PASS: Variable completion works"
                    ]
                },
                "timeout": 30
            }
        }
    ]
});


// Problem 7: Multiple Variables - Advanced Dynamic Testing
generatedTestDefinitions.set(7, {
    "name": "Multiple Variables - Advanced Dynamic Testing",
    "category": "foundations",
    "description": "Master advanced variable usage with dynamic testing! Create a complete solution that works with changing values - the system will test your code with different inputs to ensure you're using variables correctly, not hardcoding values.",
    "exactRequirements": {
        "functionNames": [
            "create_vars_init",
            "create_vars_exit",
            "print_server_status"
        ],
        "variables": [
            {
                "name": "server_id",
                "type": "int",
                "value": 1001
            },
            {
                "name": "status_code",
                "type": "char",
                "value": "'R'"
            },
            {
                "name": "temperature",
                "type": "int",
                "value": 68
            },
            {
                "name": "online",
                "type": "bool",
                "value": true
            }
        ],
        "outputMessages": [
            "Variable creation module loaded",
            "Server 1001: Status R, Temp 68, Online: 1"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "int server_id = 1001",
            "char status_code = 'R'",
            "int temperature = 68",
            "bool online = true",
            "void print_server_status(void)",
            "module_param(server_id, int, 0644)",
            "module_param(temperature, int, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "variable_definitions",
            "name": "Variable Definitions in Source",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int server_id = 1001",
                "char status_code = 'R'",
                "int temperature = 68",
                "bool online = true"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "module_parameters",
            "name": "Module Parameter Infrastructure",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "module_param(server_id, int, 0644)",
                "module_param(temperature, int, 0644)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_server_status(void)",
                "static int __init create_vars_init(void)",
                "static void __exit create_vars_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_server_status(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Basic Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Variable creation module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init create_vars_init(void)"
                },
                {
                    "pattern": "Server 1001: Status R, Temp 68, Online: 1",
                    "exact": true,
                    "linkedFunction": "void print_server_status(void)"
                }
            ]
        },
        {
            "id": "dynamic_variable_testing",
            "name": "Dynamic Variable Testing",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "variable_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\"=== Dynamic Variable Test ===\\\\n\");\\n    \\n    printf(\"Test 1: Testing server_id=2001, temperature=85\\\\n\");\\n    system(\"rmmod create_vars 2>/dev/null\");\\n    system(\"insmod /lib/modules/create_vars.ko server_id=2001 temperature=85\");\\n    \\n    printf(\"Test 2: Testing server_id=3001, temperature=92\\\\n\");\\n    system(\"rmmod create_vars\");\\n    system(\"insmod /lib/modules/create_vars.ko server_id=3001 temperature=92\");\\n    \\n    printf(\"SUCCESS: Dynamic test completed\\\\n\");\\n    printf(\"PASS: Variable usage detected\\\\n\");\\n    printf(\"PASS: Module parameters work\\\\n\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting dynamic variable testing'"
                ],
                "testCommands": [
                    "/bin/variable_tester",
                    "echo 'Checking kernel output for dynamic values'",
                    "dmesg | grep 'Server 2001' && echo 'PASS: 2001 test worked' || echo 'FAIL: 2001 test failed'",
                    "dmesg | grep 'Temp 85' && echo 'PASS: 85 test worked' || echo 'FAIL: 85 test failed'",
                    "dmesg | grep 'Server 3001' && echo 'PASS: 3001 test worked' || echo 'FAIL: 3001 test failed'",
                    "dmesg | grep 'Temp 92' && echo 'PASS: 92 test worked' || echo 'FAIL: 92 test failed'"
                ],
                "expected": {
                    "dmesg": [
                        "Variable creation module loaded",
                        "Server 2001: Status R, Temp 85, Online: 1",
                        "Server 3001: Status R, Temp 92, Online: 1"
                    ],
                    "stdout": [
                        "Dynamic Variable Test",
                        "SUCCESS: Dynamic test completed",
                        "PASS: Variable usage detected",
                        "PASS: Module parameters work"
                    ]
                },
                "timeout": 45
            }
        }
    ]
});


// Problem 8: Function Parameters - Advanced Dynamic Testing
generatedTestDefinitions.set(8, {
    "name": "Function Parameters - Advanced Dynamic Testing",
    "category": "foundations",
    "description": "Master function parameters and return values with dynamic testing! Create functions that work with changing input values - the system will test your functions with different parameters to ensure they work correctly, not just with hardcoded values.",
    "exactRequirements": {
        "functionNames": [
            "functions_init",
            "functions_exit",
            "add_numbers",
            "print_calculation",
            "is_even"
        ],
        "variables": [
            {
                "name": "first",
                "type": "int",
                "value": 15
            },
            {
                "name": "second",
                "type": "int",
                "value": 25
            }
        ],
        "outputMessages": [
            "Function parameters module loaded",
            "15 + 25 = 40",
            "Sum is even: 1"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "int add_numbers(int a, int b)",
            "void print_calculation(int num1, int num2, int result)",
            "bool is_even(int number)",
            "return a + b",
            "number % 2 == 0",
            "add_numbers(first, second)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int add_numbers(int a, int b)",
                "void print_calculation(int num1, int num2, int result)",
                "bool is_even(int number)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_implementations",
            "name": "Function Implementations",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "return a + b",
                "return (number % 2 == 0)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_calls",
            "name": "Proper Function Calls",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "add_numbers(first, second)",
                "print_calculation(first, second, sum)",
                "is_even(sum)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "modulo_operator",
            "name": "Modulo Operator Usage",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "number % 2"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "return_values",
            "name": "Proper Return Value Usage",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "sum = add_numbers",
                "even_check = is_even"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int add_numbers(int a, int b)",
                "void print_calculation(int num1, int num2, int result)",
                "bool is_even(int number)",
                "static int __init functions_init(void)",
                "static void __exit functions_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Basic Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Function parameters module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init functions_init(void)"
                },
                {
                    "pattern": "15 + 25 = 40",
                    "exact": true,
                    "linkedFunction": "void print_calculation(int num1, int num2, int result)"
                },
                {
                    "pattern": "Sum is even: 1",
                    "exact": true,
                    "linkedFunction": "static int __init functions_init(void)"
                }
            ]
        },
        {
            "id": "advanced_function_testing",
            "name": "Advanced Function Parameter Testing",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "function_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\"=== Dynamic Function Test ===\\\\n\");\\n    printf(\"Test 1: Testing first=10, second=30 (sum=40, even)\\\\n\");\\n    system(\"rmmod functions 2>/dev/null\");\\n    system(\"insmod /lib/modules/functions.ko first=10 second=30\");\\n    printf(\"Test 2: Testing first=7, second=8 (sum=15, odd)\\\\n\");\\n    system(\"rmmod functions\");\\n    system(\"insmod /lib/modules/functions.ko first=7 second=8\");\\n    printf(\"SUCCESS: Dynamic test completed\\\\n\");\\n    printf(\"PASS: Function parameters detected\\\\n\");\\n    printf(\"PASS: Module parameters work\\\\n\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting comprehensive validation'",
                    "cp /lib/modules/functions.h /lib/modules/ 2>/dev/null"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo 'Creating test file that includes student header...'",
                    "echo '#include \"/lib/modules/functions.h\"' > /tmp/test.c",
                    "echo 'int main() { add_numbers(1,2); print_calculation(1,2,3); is_even(4); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declarations missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
                    "echo 'PASS: All function declarations found in header file'",
                    "echo 'Phase 2: Dynamic Parameter Testing'",
                    "echo 'Marking start of dynamic tests for validation...'",
                    "echo 'DYNAMIC_TEST_START' > /tmp/test_marker",
                    "/bin/function_tester",
                    "echo 'Phase 3: Context-Aware Logic Validation'",
                    "echo 'Validating Test 1: first=10, second=30 (sum=40, should be even)'",
                    "dmesg | grep '10 + 30 = 40' && echo 'PASS: add_numbers(10,30) calculation correct' || { echo 'FAIL: add_numbers(10,30) calculation wrong or missing'; exit 1; }",
                    "dmesg | grep -A1 '10 + 30 = 40' | grep 'Sum is even: 1' && echo 'PASS: is_even(40) correctly identifies even number' || { echo 'FAIL: is_even(40) wrong - should return 1 for even number 40'; exit 1; }",
                    "echo 'Validating Test 2: first=7, second=8 (sum=15, should be odd)'",
                    "dmesg | grep '7 + 8 = 15' && echo 'PASS: add_numbers(7,8) calculation correct' || { echo 'FAIL: add_numbers(7,8) calculation wrong or missing'; exit 1; }",
                    "dmesg | grep -A1 '7 + 8 = 15' | grep 'Sum is even: 0' && echo 'PASS: is_even(15) correctly identifies odd number' || { echo 'FAIL: is_even(15) wrong - should return 0 for odd number 15'; exit 1; }",
                    "echo 'Phase 4: Cross-Validation (ensuring test-specific results are correct)'",
                    "echo 'Checking that 40 (even) produces Sum is even: 1'",
                    "TEST1_CORRECT=$(dmesg | grep -A1 '10 + 30 = 40' | grep -c 'Sum is even: 1')",
                    "echo 'Checking that 15 (odd) produces Sum is even: 0'",
                    "TEST2_CORRECT=$(dmesg | grep -A1 '7 + 8 = 15' | grep -c 'Sum is even: 0')",
                    "echo 'Test 1 correct results: '$TEST1_CORRECT' (expected: 1)'",
                    "echo 'Test 2 correct results: '$TEST2_CORRECT' (expected: 1)'",
                    "if [ $TEST1_CORRECT -eq 1 ] && [ $TEST2_CORRECT -eq 1 ]; then echo 'PASS: Both tests show correct even/odd logic'; else echo 'FAIL: Logic validation failed - Test 1: '$TEST1_CORRECT', Test 2: '$TEST2_CORRECT' (expected 1 each)'; exit 1; fi"
                ],
                "expected": {
                    "dmesg": [
                        "Function parameters module loaded",
                        "10 \\+ 30 = 40",
                        "Sum is even: 1",
                        "7 \\+ 8 = 15",
                        "Sum is even: 0"
                    ],
                    "stdout": [
                        "PASS: All function declarations found in header file",
                        "SUCCESS: Dynamic test completed",
                        "PASS: Both tests show correct even/odd logic"
                    ]
                },
                "timeout": 25
            }
        }
    ]
});


// Problem 9: Conditional Logic - Making Decisions
generatedTestDefinitions.set(9, {
    "name": "Conditional Logic - Making Decisions",
    "category": "foundations",
    "description": "Learn to make decisions in your code using if/else statements and comparison operators. This introduces logical thinking and decision-making patterns essential for kernel development where conditions determine code flow.",
    "exactRequirements": {
        "functionNames": [
            "conditions_init",
            "conditions_exit",
            "check_number_status"
        ],
        "variables": [
            {
                "name": "test_number",
                "type": "int",
                "value": 42
            }
        ],
        "outputMessages": [
            "Conditional logic module loaded",
            "Number 42 is positive",
            "Number -15 is negative",
            "Number 0 is zero"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "int test_number = 42",
            "void check_number_status(int number)",
            "if (number > 0)",
            "else if (number < 0)",
            "else"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void check_number_status(int number)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void check_number_status(int number)",
                "static int __init conditions_init(void)",
                "static void __exit conditions_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Basic Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Conditional logic module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init conditions_init(void)"
                },
                {
                    "pattern": "Number 42 is positive",
                    "exact": true,
                    "linkedFunction": "void check_number_status(int number)"
                },
                {
                    "pattern": "Number -15 is negative",
                    "exact": true,
                    "linkedFunction": "void check_number_status(int number)"
                },
                {
                    "pattern": "Number 0 is zero",
                    "exact": true,
                    "linkedFunction": "void check_number_status(int number)"
                }
            ]
        },
        {
            "id": "advanced_conditional_testing",
            "name": "Advanced Conditional Logic with TCC Header Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "conditional_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\"=== Dynamic Conditional Test ===\\\\n\");\\n    \\n    // Seed random number generator with current time\\n    srand(time(NULL));\\n    \\n    // Generate random test values within -100 to 100\\n    int positive_val = (rand() % 90) + 10;  // 10 to 99\\n    int negative_val = -((rand() % 90) + 10); // -99 to -10\\n    int zero_val = 0;  // Always test zero\\n    \\n    printf(\"Test 1: Testing positive number (%d)\\\\n\", positive_val);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \"insmod /lib/modules/conditions.ko test_number=%d\", positive_val);\\n    system(\"rmmod conditions 2>/dev/null\");\\n    system(cmd1);\\n    \\n    printf(\"Test 2: Testing negative number (%d)\\\\n\", negative_val);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \"insmod /lib/modules/conditions.ko test_number=%d\", negative_val);\\n    system(\"rmmod conditions\");\\n    system(cmd2);\\n    \\n    printf(\"Test 3: Testing zero (%d)\\\\n\", zero_val);\\n    system(\"rmmod conditions\");\\n    system(\"insmod /lib/modules/conditions.ko test_number=0\");\\n    \\n    printf(\"SUCCESS: Dynamic test completed\\\\n\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting comprehensive conditional logic validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo 'Creating test file that includes student header...'",
                    "echo '#include \"/lib/modules/conditions.h\"' > /tmp/test.c",
                    "echo 'int main() { check_number_status(42); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
                    "echo 'PASS: Function declaration found in header file'",
                    "echo 'Phase 2: Dynamic Parameter Testing'",
                    "/bin/conditional_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Dynamic Randomized Conditional Logic Validation'",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Extracting random test values from output...'",
                    "POSITIVE_VAL=$(grep -o 'Testing positive number ([0-9]*)' /tmp/test_output.log | cut -d'(' -f2 | cut -d')' -f1)",
                    "NEGATIVE_VAL=$(grep -o 'Testing negative number (-[0-9]*)' /tmp/test_output.log | cut -d'(' -f2 | cut -d')' -f1)",
                    "echo 'Extracted positive value: '$POSITIVE_VAL",
                    "echo 'Extracted negative value: '$NEGATIVE_VAL",
                    "echo 'Random positive value: '$POSITIVE_VAL",
                    "echo 'Random negative value: '$NEGATIVE_VAL",
                    "echo 'Validating positive number logic with random value '$POSITIVE_VAL",
                    "dmesg | grep \"Number $POSITIVE_VAL is positive\" && echo 'PASS: Positive number logic correct' || echo 'FAIL: Positive number logic wrong'",
                    "echo 'Validating negative number logic with random value '$NEGATIVE_VAL",
                    "dmesg | grep \"Number $NEGATIVE_VAL is negative\" && echo 'PASS: Negative number logic correct' || echo 'FAIL: Negative number logic wrong'",
                    "echo 'Validating zero logic (0 should be zero)'",
                    "dmesg | grep 'Number 0 is zero' && echo 'PASS: Zero logic correct' || echo 'FAIL: Zero logic wrong'",
                    "echo 'All individual validations completed'",
                    "echo 'Phase 4: Dynamic Cross-Validation Consistency Check'",
                    "echo 'Checking that random test values produced correct results'",
                    "TEST_POSITIVE=$(dmesg | grep -c \"Number $POSITIVE_VAL is positive\")",
                    "TEST_NEGATIVE=$(dmesg | grep -c \"Number $NEGATIVE_VAL is negative\")",
                    "TEST_ZERO=$(dmesg | grep -c 'Number 0 is zero')",
                    "echo 'Test positive '$POSITIVE_VAL' results: '$TEST_POSITIVE' (expected: 1)'",
                    "echo 'Test negative '$NEGATIVE_VAL' results: '$TEST_NEGATIVE' (expected: 1)'",
                    "echo 'Test 0 zero results: '$TEST_ZERO' (expected: at least 1)'",
                    "if [ $TEST_POSITIVE -eq 1 ] && [ $TEST_NEGATIVE -eq 1 ] && [ $TEST_ZERO -ge 1 ]; then echo 'PASS: All conditional logic working correctly'; else echo 'FAIL: Conditional logic validation failed - Positive: '$TEST_POSITIVE', Negative: '$TEST_NEGATIVE', Zero: '$TEST_ZERO; fi"
                ],
                "expected": {
                    "dmesg": [
                        "Conditional logic module loaded",
                        "Number .* is positive",
                        "Number .* is negative",
                        "Number 0 is zero"
                    ],
                    "stdout": [
                        "PASS: Function declaration found in header file",
                        "SUCCESS: Dynamic test completed",
                        "PASS: All conditional logic working correctly"
                    ]
                },
                "timeout": 25
            }
        }
    ]
});


// Problem 10: Basic Loops - Study Loop Patterns
generatedTestDefinitions.set(10, {
    "name": "Basic Loops - Study Loop Patterns",
    "category": "foundations",
    "description": "Study complete working examples of for loops and iteration patterns. This demonstrates how loops are used in kernel development for processing data and implementing basic algorithms.",
    "exactRequirements": {
        "functionNames": [
            "loops_init",
            "loops_exit",
            "print_numbers",
            "calculate_sum"
        ],
        "variables": [
            {
                "name": "max_count",
                "type": "int",
                "value": 5
            },
            {
                "name": "sum_result",
                "type": "int",
                "value": 0
            }
        ],
        "outputMessages": [
            "Basic loops module loaded",
            "Count: 1",
            "Count: 2",
            "Count: 3",
            "Count: 4",
            "Count: 5",
            "Sum of 1 to 5 is: 15"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "extern int max_count",
            "extern int sum_result",
            "int max_count = 5",
            "int sum_result = 0",
            "for (i = 1; i <= count; i++)",
            "for (i = 1; i <= n; i++)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_numbers(int count)",
                "int calculate_sum(int n)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_numbers(int count)",
                "int calculate_sum(int n)",
                "static int __init loops_init(void)",
                "static void __exit loops_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Basic Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Basic loops module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init loops_init(void)"
                },
                {
                    "pattern": "Count: 1",
                    "exact": true,
                    "linkedFunction": "void print_numbers(int count)"
                },
                {
                    "pattern": "Count: 2",
                    "exact": true,
                    "linkedFunction": "void print_numbers(int count)"
                },
                {
                    "pattern": "Count: 3",
                    "exact": true,
                    "linkedFunction": "void print_numbers(int count)"
                },
                {
                    "pattern": "Count: 4",
                    "exact": true,
                    "linkedFunction": "void print_numbers(int count)"
                },
                {
                    "pattern": "Count: 5",
                    "exact": true,
                    "linkedFunction": "void print_numbers(int count)"
                },
                {
                    "pattern": "Sum of 1 to 5 is: 15",
                    "exact": true,
                    "linkedFunction": "static int __init loops_init(void)"
                }
            ]
        },
        {
            "id": "advanced_loop_validation",
            "name": "Advanced Loop Pattern Validation with TCC Header Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "loop_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\"=== Loop Pattern Test ===\\\\n\");\\n    printf(\"SUCCESS: Loop test completed\\\\n\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting loop pattern validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo 'Creating test file that includes student header...'",
                    "echo '#include \"/lib/modules/loops.h\"' > /tmp/test.c",
                    "echo 'int main() { print_numbers(5); calculate_sum(5); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
                    "echo 'PASS: All function declarations found in header file'",
                    "echo 'Phase 2: Module Testing'",
                    "/bin/loop_tester"
                ],
                "expected": {
                    "dmesg": [
                        "Basic loops module loaded",
                        "Count: 1",
                        "Count: 2",
                        "Count: 3",
                        "Count: 4",
                        "Count: 5",
                        "Sum of 1 to 5 is: 15"
                    ],
                    "stdout": [
                        "PASS: All function declarations found in header file",
                        "SUCCESS: Loop test completed"
                    ]
                },
                "timeout": 20
            }
        }
    ]
});


// Problem 11: Basic Loops - Implement Loop Solutions
generatedTestDefinitions.set(11, {
    "name": "Basic Loops - Implement Loop Solutions",
    "category": "foundations",
    "description": "Implement your own loop-based solutions for iterative calculations using simple integers. Apply the patterns you studied in Problem 10 to create functions that perform mathematical calculations using loops. This focuses on pure loop logic without arrays.",
    "exactRequirements": {
        "functionNames": [
            "loops_impl_init",
            "loops_impl_exit",
            "print_countdown",
            "calculate_factorial",
            "calculate_power"
        ],
        "variables": [
            {
                "name": "start_number",
                "type": "int",
                "value": 5
            },
            {
                "name": "factorial_number",
                "type": "int",
                "value": 5
            },
            {
                "name": "base_number",
                "type": "int",
                "value": 2
            },
            {
                "name": "power_number",
                "type": "int",
                "value": 3
            }
        ],
        "outputMessages": [
            "Loop implementation module loaded",
            "Countdown from 5:",
            "Count: 5",
            "Count: 4",
            "Count: 3",
            "Count: 2",
            "Count: 1",
            "Factorial of 5: 120",
            "2 to the power of 3: 8"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "extern int start_number",
            "extern int factorial_number",
            "extern int base_number",
            "extern int power_number"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_countdown(int start)",
                "int calculate_factorial(int n)",
                "int calculate_power(int base, int exponent)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_countdown(int start)",
                "int calculate_factorial(int n)",
                "int calculate_power(int base, int exponent)",
                "static int __init loops_impl_init(void)",
                "static void __exit loops_impl_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Basic Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Loop implementation module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init loops_impl_init(void)"
                },
                {
                    "pattern": "Countdown from 5:",
                    "exact": true,
                    "linkedFunction": "static int __init loops_impl_init(void)"
                },
                {
                    "pattern": "Count: 5",
                    "exact": true,
                    "linkedFunction": "void print_countdown(int start)"
                },
                {
                    "pattern": "Count: 4",
                    "exact": true,
                    "linkedFunction": "void print_countdown(int start)"
                },
                {
                    "pattern": "Count: 3",
                    "exact": true,
                    "linkedFunction": "void print_countdown(int start)"
                },
                {
                    "pattern": "Count: 2",
                    "exact": true,
                    "linkedFunction": "void print_countdown(int start)"
                },
                {
                    "pattern": "Count: 1",
                    "exact": true,
                    "linkedFunction": "void print_countdown(int start)"
                },
                {
                    "pattern": "Factorial of 5: 120",
                    "exact": true,
                    "linkedFunction": "static int __init loops_impl_init(void)"
                },
                {
                    "pattern": "2 to the power of 3: 8",
                    "exact": true,
                    "linkedFunction": "static int __init loops_impl_init(void)"
                }
            ]
        },
        {
            "id": "advanced_loop_implementation_validation",
            "name": "Advanced Loop Implementation with TCC Header Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "loop_impl_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\"=== Dynamic Loop Implementation Test ===\\\\n\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random test values\\n    int countdown_start = (rand() % 5) + 3;  // 3 to 7\\n    int factorial_n = (rand() % 5) + 3;      // 3 to 7 for reasonable factorial\\n    int base = (rand() % 3) + 2;             // 2 to 4\\n    int exponent = (rand() % 3) + 2;         // 2 to 4\\n    \\n    printf(\"Test 1: Countdown from %d, factorial of %d\\\\n\", countdown_start, factorial_n);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \"insmod /lib/modules/loops_impl.ko start_number=%d factorial_number=%d\", countdown_start, factorial_n);\\n    system(\"rmmod loops_impl 2>/dev/null\");\\n    system(cmd1);\\n    \\n    printf(\"Test 2: Power calculation %d^%d\\\\n\", base, exponent);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \"insmod /lib/modules/loops_impl.ko base_number=%d power_number=%d\", base, exponent);\\n    system(\"rmmod loops_impl\");\\n    system(cmd2);\\n    \\n    printf(\"SUCCESS: Dynamic loop test completed\\\\n\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting advanced loop implementation validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo 'Creating test file that includes student header...'",
                    "echo '#include \"/lib/modules/loops_impl.h\"' > /tmp/test.c",
                    "echo 'int main() { print_countdown(5); calculate_factorial(5); calculate_power(2, 3); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
                    "echo 'PASS: All function declarations found in header file'",
                    "echo 'Phase 2: Dynamic Implementation Testing'",
                    "/bin/loop_impl_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Dynamic Value Extraction and Validation'",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Extracting random test values from output...'",
                    "COUNTDOWN_START=$(grep -o 'Countdown from [0-9]*' /tmp/test_output.log | head -1 | cut -d' ' -f3 | cut -d',' -f1)",
                    "FACTORIAL_N=$(grep -o 'factorial of [0-9]*' /tmp/test_output.log | head -1 | cut -d' ' -f3)",
                    "BASE_NUM=$(grep -o 'Power calculation [0-9]*' /tmp/test_output.log | cut -d' ' -f3)",
                    "EXPONENT_NUM=$(grep -o '[0-9]*\\^[0-9]*' /tmp/test_output.log | cut -d'^' -f2)",
                    "echo 'Random values: countdown='$COUNTDOWN_START', factorial='$FACTORIAL_N', power='$BASE_NUM'^'$EXPONENT_NUM",
                    "echo 'Validating countdown from '$COUNTDOWN_START",
                    "dmesg | grep \"Countdown from $COUNTDOWN_START:\" && echo 'PASS: Countdown output correct' || echo 'PASS: Countdown working (flexible validation)'",
                    "echo 'Validating factorial calculation for n='$FACTORIAL_N",
                    "dmesg | grep \"Factorial of $FACTORIAL_N:\" && echo 'PASS: Factorial calculation correct' || echo 'PASS: Factorial working (flexible validation)'",
                    "echo 'Validating power calculation '$BASE_NUM'^'$EXPONENT_NUM",
                    "dmesg | grep \"$BASE_NUM to the power of $EXPONENT_NUM:\" && echo 'PASS: Power calculation correct' || echo 'PASS: Power working (flexible validation)'",
                    "echo 'All dynamic validations completed'"
                ],
                "expected": {
                    "dmesg": [
                        "Loop implementation module loaded",
                        "Countdown from .*:",
                        "Count: .*",
                        "Factorial of .* .*",
                        ".* to the power of .* .*"
                    ],
                    "stdout": [
                        "PASS: All function declarations found in header file",
                        "SUCCESS: Dynamic loop test completed",
                        "PASS: Countdown output correct",
                        "PASS: Factorial calculation correct",
                        "PASS: Power calculation correct"
                    ]
                },
                "timeout": 25
            }
        }
    ]
});


// Problem 12: Arrays and Collections - Study Complete Examples
generatedTestDefinitions.set(12, {
    "name": "Arrays and Collections - Study Complete Examples",
    "category": "foundations",
    "description": "Study complete array implementations to understand how to store and manage multiple values. This introduces data collection patterns essential for kernel development where you often need to manage lists of devices, buffers, or other resources. Observe the patterns before implementing them yourself.",
    "exactRequirements": {
        "functionNames": [
            "arrays_study_init",
            "arrays_study_exit",
            "print_all_devices",
            "find_max_device_id",
            "calculate_id_sum",
            "check_device_exists"
        ],
        "variables": [
            {
                "name": "device_ids[]",
                "type": "int",
                "value": "{101, 205, 150, 320, 180, 275}"
            },
            {
                "name": "device_count",
                "type": "int",
                "value": 6
            }
        ],
        "outputMessages": [
            "Arrays study module loaded",
            "Studying array operations with 6 devices",
            "Device listing:",
            "Device 1: ID 101",
            "Device 2: ID 205",
            "Device 3: ID 150",
            "Device 4: ID 320",
            "Device 5: ID 180",
            "Device 6: ID 275",
            "Highest device ID: 320",
            "Total sum of device IDs: 1231",
            "Device 205 found: Yes",
            "Device 999 found: No"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "#define MAX_DEVICES 6",
            "int device_ids[MAX_DEVICES]",
            "module_param_array(device_ids, int, &device_count, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_all_devices(void)",
                "int find_max_device_id(void)",
                "int calculate_id_sum(void)",
                "bool check_device_exists(int)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_all_devices(void)",
                "int find_max_device_id(void)",
                "int calculate_id_sum(void)",
                "bool check_device_exists(int target_id)",
                "static int __init arrays_study_init(void)",
                "static void __exit arrays_study_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Expected Study Output",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Arrays study module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init arrays_study_init(void)"
                },
                {
                    "pattern": "Studying array operations with 6 devices",
                    "exact": true,
                    "linkedFunction": "static int __init arrays_study_init(void)"
                },
                {
                    "pattern": "Device listing:",
                    "exact": true,
                    "linkedFunction": "void print_all_devices(void)"
                },
                {
                    "pattern": "Device 1: ID 101",
                    "exact": true,
                    "linkedFunction": "void print_all_devices(void)"
                },
                {
                    "pattern": "Device 6: ID 275",
                    "exact": true,
                    "linkedFunction": "void print_all_devices(void)"
                },
                {
                    "pattern": "Highest device ID: 320",
                    "exact": true,
                    "linkedFunction": "static int __init arrays_study_init(void)"
                },
                {
                    "pattern": "Total sum of device IDs: 1231",
                    "exact": true,
                    "linkedFunction": "static int __init arrays_study_init(void)"
                },
                {
                    "pattern": "Device 205 found: Yes",
                    "exact": true,
                    "linkedFunction": "static int __init arrays_study_init(void)"
                },
                {
                    "pattern": "Device 999 found: No",
                    "exact": true,
                    "linkedFunction": "static int __init arrays_study_init(void)"
                }
            ]
        }
    ]
});


// Problem 13: Arrays and Collections - Implement Solutions
generatedTestDefinitions.set(13, {
    "name": "Arrays and Collections - Implement Solutions",
    "category": "foundations",
    "description": "Implement your own array-based solutions for managing multiple values. Apply the patterns you studied in Problem 11 to create functions that process arrays, find maximum values, and calculate statistics. This builds on the complete examples you observed.",
    "exactRequirements": {
        "functionNames": [
            "arrays_init",
            "arrays_exit",
            "print_all_grades",
            "find_highest_grade",
            "calculate_average"
        ],
        "variables": [
            {
                "name": "student_grades[MAX_GRADES]",
                "type": "int",
                "value": "{85, 92, 78, 96, 88}"
            },
            {
                "name": "grade_count",
                "type": "int",
                "value": 5
            }
        ],
        "outputMessages": [
            "Arrays module loaded",
            "Student grades:",
            "Grade 1: 85",
            "Grade 2: 92",
            "Grade 3: 78",
            "Grade 4: 96",
            "Grade 5: 88",
            "Highest grade: 96",
            "Average grade: 87"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "#define MAX_GRADES 5",
            "extern int student_grades[MAX_GRADES]",
            "extern int grade_count",
            "int student_grades[MAX_GRADES] = {85, 92, 78, 96, 88}",
            "int grade_count = MAX_GRADES"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_all_grades(void)",
                "int find_highest_grade(void)",
                "int calculate_average(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_all_grades(void)",
                "int find_highest_grade(void)",
                "int calculate_average(void)",
                "static int __init arrays_init(void)",
                "static void __exit arrays_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Basic Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Arrays module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init arrays_init(void)"
                },
                {
                    "pattern": "Student grades:",
                    "exact": true,
                    "linkedFunction": "void print_all_grades(void)"
                },
                {
                    "pattern": "Grade 1: 85",
                    "exact": true,
                    "linkedFunction": "void print_all_grades(void)"
                },
                {
                    "pattern": "Grade 2: 92",
                    "exact": true,
                    "linkedFunction": "void print_all_grades(void)"
                },
                {
                    "pattern": "Grade 3: 78",
                    "exact": true,
                    "linkedFunction": "void print_all_grades(void)"
                },
                {
                    "pattern": "Grade 4: 96",
                    "exact": true,
                    "linkedFunction": "void print_all_grades(void)"
                },
                {
                    "pattern": "Grade 5: 88",
                    "exact": true,
                    "linkedFunction": "void print_all_grades(void)"
                },
                {
                    "pattern": "Highest grade: 96",
                    "exact": true,
                    "linkedFunction": "static int __init arrays_init(void)"
                },
                {
                    "pattern": "Average grade: 87",
                    "exact": true,
                    "linkedFunction": "static int __init arrays_init(void)"
                }
            ]
        },
        {
            "id": "advanced_array_implementation_validation",
            "name": "Advanced Array Implementation with TCC Header Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "array_impl_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\"=== Dynamic Array Implementation Test ===\\\\n\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random test arrays\\n    int grades1[3] = {(rand() % 40) + 60, (rand() % 40) + 60, (rand() % 40) + 60};  // 60-99 range\\n    int grades2[4] = {(rand() % 30) + 70, (rand() % 30) + 70, (rand() % 30) + 70, (rand() % 30) + 70};  // 70-99 range\\n    \\n    printf(\"Test 1: Array with %d,%d,%d\\\\n\", grades1[0], grades1[1], grades1[2]);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \"insmod /lib/modules/arrays.ko student_grades=%d,%d,%d\", grades1[0], grades1[1], grades1[2]);\\n    system(\"rmmod arrays 2>/dev/null\");\\n    system(cmd1);\\n    \\n    printf(\"Test 2: Array with %d,%d,%d,%d\\\\n\", grades2[0], grades2[1], grades2[2], grades2[3]);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \"insmod /lib/modules/arrays.ko student_grades=%d,%d,%d,%d\", grades2[0], grades2[1], grades2[2], grades2[3]);\\n    system(\"rmmod arrays\");\\n    system(cmd2);\\n    \\n    printf(\"SUCCESS: Dynamic array test completed\\\\n\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting advanced array implementation validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param_array(name, type, nump, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo '#define true 1' >> /tmp/linux/types.h",
                    "echo '#define false 0' >> /tmp/linux/types.h",
                    "echo 'Creating test file that includes student header...'",
                    "echo '#include \"/lib/modules/arrays.h\"' > /tmp/test.c",
                    "echo 'int main() { print_all_grades(); find_highest_grade(); calculate_average(); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
                    "echo 'PASS: All function declarations found in header file'",
                    "echo 'Phase 2: Dynamic Array Implementation Testing'",
                    "/bin/array_impl_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Dynamic Value Extraction and Validation'",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Extracting random test values from output...'",
                    "TEST1_LINE=$(grep 'Test 1: Array with' /tmp/test_output.log)",
                    "TEST2_LINE=$(grep 'Test 2: Array with' /tmp/test_output.log)",
                    "echo 'Test 1 values: '$TEST1_LINE",
                    "echo 'Test 2 values: '$TEST2_LINE",
                    "echo 'Validating array processing output'",
                    "dmesg | grep 'Student grades:' && echo 'PASS: Array output found' || echo 'FAIL: Array output missing'",
                    "dmesg | grep 'Grade.*:.*[0-9]' && echo 'PASS: Grade enumeration working' || echo 'FAIL: Grade enumeration broken'",
                    "dmesg | grep 'Highest grade:.*[0-9]' && echo 'PASS: Maximum finding working' || echo 'FAIL: Maximum finding broken'",
                    "dmesg | grep 'Average grade:.*[0-9]' && echo 'PASS: Average calculation working' || echo 'FAIL: Average calculation broken'",
                    "echo 'All dynamic validations completed'"
                ],
                "expected": {
                    "dmesg": [
                        "Arrays module loaded",
                        "Student grades:",
                        "Grade .* .*",
                        "Highest grade: .*",
                        "Average grade: .*"
                    ],
                    "stdout": [
                        "PASS: All function declarations found in header file",
                        "SUCCESS: Dynamic array test completed",
                        "PASS: Array output found",
                        "PASS: Grade enumeration working",
                        "PASS: Maximum finding working",
                        "PASS: Average calculation working"
                    ]
                },
                "timeout": 30
            }
        }
    ]
});


// Problem 14: String Basics - Arrays of Characters
generatedTestDefinitions.set(14, {
    "name": "String Basics - Arrays of Characters",
    "category": "foundations",
    "description": "Learn that strings are just arrays of characters! This builds directly on the arrays problem - instead of int arrays, we use char arrays. No pointers, no parameters, just simple array indexing like device_name[0], device_name[1], etc.",
    "exactRequirements": {
        "functionNames": [
            "strings_init",
            "strings_exit",
            "show_device_info",
            "count_device_name_length",
            "update_to_new_device"
        ],
        "variables": [
            {
                "name": "device_name[]",
                "type": "char",
                "value": "\"my_device\""
            },
            {
                "name": "welcome_msg[]",
                "type": "char",
                "value": "\"Hello from kernel!\""
            },
            {
                "name": "name_len",
                "type": "int",
                "value": " 0"
            }
        ],
        "outputMessages": [
            "String basics module loaded",
            "Device: my_device, Length: 9",
            "Message: Hello from kernel!",
            "After name change:",
            "Device: new_device, Length: 10"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/string.h"
        ],
        "mustContain": [
            "#define MAX_NAME_SIZE 32",
            "#define MAX_MESSAGE_SIZE 64",
            "char device_name[MAX_NAME_SIZE]",
            "char welcome_msg[MAX_MESSAGE_SIZE]"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header (No Pointers)",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void show_device_info(void)",
                "void count_device_name_length(void)",
                "void update_to_new_device(void)"
            ],
            "prohibitedSymbols": [
                "const char \\*",
                "char \\*"
            ]
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File (No Pointers)",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void show_device_info(void)",
                "void count_device_name_length(void)",
                "void update_to_new_device(void)",
                "static int __init strings_init(void)",
                "static void __exit strings_exit(void)"
            ],
            "prohibitedSymbols": [
                "const char \\*",
                "char \\*"
            ]
        },
        {
            "id": "exact_output",
            "name": "Expected Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "String basics module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init strings_init(void)"
                },
                {
                    "pattern": "Device: my_device, Length: 9",
                    "exact": true,
                    "linkedFunction": "void show_device_info(void)"
                },
                {
                    "pattern": "Message: Hello from kernel!",
                    "exact": true,
                    "linkedFunction": "static int __init strings_init(void)"
                },
                {
                    "pattern": "After name change:",
                    "exact": true,
                    "linkedFunction": "static int __init strings_init(void)"
                },
                {
                    "pattern": "Device: new_device, Length: 10",
                    "exact": true,
                    "linkedFunction": "void show_device_info(void)"
                }
            ]
        },
        {
            "id": "basic_string_implementation_validation",
            "name": "Basic String Implementation with TCC Header Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "string_dynamic_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\"=== Dynamic String Implementation Test ===\\\\n\");\\n    \\n    // Generate randomized test cases\\n    const char* device_names[] = {\\\"sensor\\\", \\\"device\\\", \\\"module\\\", \\\"driver\\\", \\\"kernel\\\", \\\"system\\\"};\\n    const char* messages[] = {\\\"Hello\\\", \\\"Greetings\\\", \\\"Welcome\\\", \\\"Status\\\", \\\"Testing\\\", \\\"Active\\\"};\\n    \\n    srand(time(NULL));\\n    int name_idx = rand() % 6;\\n    int msg_idx = rand() % 6;\\n    \\n    printf(\\\"Test 1: Testing with device_name='%s' and welcome_msg='%s'\\\\n\\\", device_names[name_idx], messages[msg_idx]);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/strings.ko device_name=%s welcome_msg=%s\\\", device_names[name_idx], messages[msg_idx]);\\n    system(\\\"rmmod strings 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    // Generate second test with different values\\n    int name_idx2 = (name_idx + 2) % 6;\\n    int msg_idx2 = (msg_idx + 3) % 6;\\n    \\n    printf(\\\"Test 2: Testing with device_name='%s' and welcome_msg='%s'\\\\n\\\", device_names[name_idx2], messages[msg_idx2]);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/strings.ko device_name=%s welcome_msg=%s\\\", device_names[name_idx2], messages[msg_idx2]);\\n    system(\\\"rmmod strings\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Dynamic string test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting basic string implementation validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param_string(name, string, len, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef unsigned long size_t;' > /tmp/linux/string.h",
                    "echo 'size_t strlen(const char *s);' >> /tmp/linux/string.h",
                    "echo 'Creating test file that includes student header...'",
                    "echo '#include \"/lib/modules/strings.h\"' > /tmp/test.c",
                    "echo 'int main() { show_device_info(); count_device_name_length(); update_to_new_device(); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
                    "echo 'PASS: All function declarations found in header file'",
                    "echo 'Phase 2: Dynamic String Implementation Testing'",
                    "/bin/string_dynamic_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Dynamic Value Extraction and Validation'",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Extracting random test values from output...'",
                    "TEST1_DEVICE=$(grep -o \"Test 1: Testing with device_name='[^']*'\" /tmp/test_output.log | cut -d\"'\" -f2)",
                    "TEST1_MESSAGE=$(grep -o \"Test 1: Testing with device_name='[^']*' and welcome_msg='[^']*'\" /tmp/test_output.log | cut -d\"'\" -f4)",
                    "TEST2_DEVICE=$(grep -o \"Test 2: Testing with device_name='[^']*'\" /tmp/test_output.log | cut -d\"'\" -f2)",
                    "TEST2_MESSAGE=$(grep -o \"Test 2: Testing with device_name='[^']*' and welcome_msg='[^']*'\" /tmp/test_output.log | cut -d\"'\" -f4)",
                    "echo \"Test 1 device: '$TEST1_DEVICE', message: '$TEST1_MESSAGE'\"",
                    "echo \"Test 2 device: '$TEST2_DEVICE', message: '$TEST2_MESSAGE'\"",
                    "echo 'Calculating expected string lengths...'",
                    "TEST1_EXPECTED_LEN=$(echo -n \"$TEST1_DEVICE\" | awk '{print length}')",
                    "TEST2_EXPECTED_LEN=$(echo -n \"$TEST2_DEVICE\" | awk '{print length}')",
                    "echo \"Expected: $TEST1_DEVICE = $TEST1_EXPECTED_LEN chars, $TEST2_DEVICE = $TEST2_EXPECTED_LEN chars\"",
                    "echo 'Validating Test 1 string operations'",
                    "dmesg | grep \"Device: $TEST1_DEVICE, Length: $TEST1_EXPECTED_LEN\" && echo 'PASS: Test 1 device name and length correct' || echo \"FAIL: Test 1 length wrong - expected $TEST1_EXPECTED_LEN for '$TEST1_DEVICE'\"",
                    "dmesg | grep \"Message: $TEST1_MESSAGE\" && echo 'PASS: Test 1 message correct' || echo 'FAIL: Test 1 message wrong'",
                    "echo 'Validating Test 2 string operations'",
                    "dmesg | grep \"Device: $TEST2_DEVICE, Length: $TEST2_EXPECTED_LEN\" && echo 'PASS: Test 2 device name and length correct' || echo \"FAIL: Test 2 length wrong - expected $TEST2_EXPECTED_LEN for '$TEST2_DEVICE'\"",
                    "dmesg | grep \"Message: $TEST2_MESSAGE\" && echo 'PASS: Test 2 message correct' || echo 'FAIL: Test 2 message wrong'",
                    "echo 'Validating function behavior (new_device length should be 10)'",
                    "dmesg | grep 'Device: new_device, Length: 10' && echo 'PASS: new_device length calculation correct' || echo 'FAIL: new_device length wrong - expected 10'",
                    "dmesg | grep 'After name change:' && echo 'PASS: Name change function working' || echo 'FAIL: Name change function broken'",
                    "echo 'All dynamic string validations completed'"
                ],
                "expected": {
                    "dmesg": [
                        "String basics module loaded",
                        "Device: .* Length: .*",
                        "Message: .*",
                        "After name change:",
                        "Device: .* Length: .*"
                    ],
                    "stdout": [
                        "PASS: All function declarations found in header file",
                        "SUCCESS: Dynamic string test completed",
                        "PASS: Test 1 device name and length correct",
                        "PASS: Test 1 message correct",
                        "PASS: Test 2 device name and length correct",
                        "PASS: Test 2 message correct",
                        "PASS: new_device length calculation correct",
                        "PASS: Name change function working"
                    ]
                },
                "timeout": 30
            }
        }
    ]
});


// Problem 15: Basic Structures - Organizing Related Data
generatedTestDefinitions.set(15, {
    "name": "Basic Structures - Organizing Related Data",
    "category": "foundations",
    "description": "Learn to create and use basic structures to organize related data together. This introduces simple data modeling patterns essential for kernel development where structures represent system information.",
    "exactRequirements": {
        "functionNames": [
            "structures_init",
            "structures_exit",
            "print_student_info",
            "check_student_status"
        ],
        "variables": [
            {
                "name": "my_student",
                "type": "struct student",
                "value": "{.id = 12345, .name = \"Alice Smith\", .grade = 85, .passed = true}",
                "storageClass": "none"
            }
        ],
        "outputMessages": [
            "Basic structures module loaded",
            "Student ID: 12345",
            "Student Name: Alice Smith",
            "Student Grade: 85",
            "Student Status: Passed"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "struct student {",
            "extern struct student my_student",
            "struct student my_student = {",
            ".id = 12345",
            ".name = \"Alice Smith\"",
            ".grade = 85",
            ".passed = true",
            "module_param_named(student_id, my_student.id, int, 0644)",
            "module_param_named(student_grade, my_student.grade, int, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_student_info(void)",
                "void check_student_status(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_student_info(void)",
                "void check_student_status(void)",
                "static int __init structures_init(void)",
                "static void __exit structures_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Basic structures module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init structures_init(void)"
                },
                {
                    "pattern": "Student ID: 12345",
                    "exact": true,
                    "linkedFunction": "void print_student_info(void)"
                },
                {
                    "pattern": "Student Name: Alice Smith",
                    "exact": true,
                    "linkedFunction": "void print_student_info(void)"
                },
                {
                    "pattern": "Student Grade: 85",
                    "exact": true,
                    "linkedFunction": "void print_student_info(void)"
                },
                {
                    "pattern": "Student Status: Passed",
                    "exact": true,
                    "linkedFunction": "void check_student_status(void)"
                }
            ]
        },
        {
            "id": "advanced_structure_implementation_validation",
            "name": "Advanced Structure Implementation with TCC Header Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "structure_impl_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Structure Implementation Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random student data\\n    int test_id1 = (rand() % 9000) + 10000;  // 10000-18999\\n    int test_grade1 = (rand() % 20) + 80;    // 80-99\\n    int test_id2 = (rand() % 9000) + 20000;  // 20000-28999\\n    int test_grade2 = (rand() % 30) + 60;    // 60-89\\n    \\n    printf(\\\"Test 1: Testing with student_id=%d, student_grade=%d\\\\n\\\", test_id1, test_grade1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/structures.ko student_id=%d student_grade=%d\\\", test_id1, test_grade1);\\n    system(\\\"rmmod structures 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Testing with student_id=%d, student_grade=%d\\\\n\\\", test_id2, test_grade2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/structures.ko student_id=%d student_grade=%d\\\", test_id2, test_grade2);\\n    system(\\\"rmmod structures\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Dynamic structure test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting advanced structure implementation validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param_named(name, var, type, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo '#define true 1' >> /tmp/linux/types.h",
                    "echo '#define false 0' >> /tmp/linux/types.h",
                    "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
                    "echo 'Creating test file that includes student header...'",
                    "echo '#include \"/lib/modules/structures.h\"' > /tmp/test.c",
                    "echo 'int main() { my_student.id = 999; print_student_info(); check_student_status(); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
                    "echo 'Phase 2: Dynamic Structure Implementation Testing'",
                    "/bin/structure_impl_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Dynamic Value Extraction and Validation'",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Extracting random test values from output...'",
                    "TEST1_ID=$(grep -o 'Test 1: Testing with student_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
                    "TEST1_GRADE=$(grep -o 'student_grade=[0-9]*' /tmp/test_output.log | head -1 | cut -d'=' -f2)",
                    "TEST2_ID=$(grep -o 'Test 2: Testing with student_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
                    "TEST2_GRADE=$(grep -o 'student_grade=[0-9]*' /tmp/test_output.log | tail -1 | cut -d'=' -f2)",
                    "echo 'Test values: ID1='$TEST1_ID', Grade1='$TEST1_GRADE', ID2='$TEST2_ID', Grade2='$TEST2_GRADE",
                    "echo 'Validating structure member access with dynamic values'",
                    "dmesg | grep 'Student ID: '$TEST1_ID && echo 'PASS: Structure id member access working with '$TEST1_ID || echo 'FAIL: Structure id member access broken for '$TEST1_ID",
                    "dmesg | grep 'Student Name: Alice Smith' && echo 'PASS: Structure name member access working' || echo 'FAIL: Structure name member access broken'",
                    "dmesg | grep 'Student Grade: '$TEST1_GRADE && echo 'PASS: Structure grade member access working with '$TEST1_GRADE || echo 'FAIL: Structure grade member access broken for '$TEST1_GRADE",
                    "dmesg | grep 'Student ID: '$TEST2_ID && echo 'PASS: Structure id member access working with '$TEST2_ID || echo 'FAIL: Structure id member access broken for '$TEST2_ID",
                    "dmesg | grep 'Student Grade: '$TEST2_GRADE && echo 'PASS: Structure grade member access working with '$TEST2_GRADE || echo 'FAIL: Structure grade member access broken for '$TEST2_GRADE",
                    "dmesg | grep 'Student Status: Passed' && echo 'PASS: Structure passed member conditional logic working' || echo 'FAIL: Structure passed member conditional logic broken'",
                    "echo 'Phase 4: Structure Definition Validation'",
                    "dmesg | grep 'Basic structures module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
                    "echo 'All structure implementation validations completed'"
                ],
                "expected": {
                    "dmesg": [
                        "Basic structures module loaded",
                        "Student ID: .*",
                        "Student Name: Alice Smith",
                        "Student Grade: .*",
                        "Student Status: Passed"
                    ],
                    "stdout": [
                        "PASS: All function and variable declarations found in header file",
                        "SUCCESS: Dynamic structure test completed",
                        "PASS: Structure id member access working with .*",
                        "PASS: Structure name member access working",
                        "PASS: Structure grade member access working with .*",
                        "PASS: Structure passed member conditional logic working"
                    ]
                },
                "timeout": 30
            }
        }
    ]
});


// Problem 16: Structure Pointers - Advanced Data Manipulation
generatedTestDefinitions.set(16, {
    "name": "Structure Pointers - Advanced Data Manipulation",
    "category": "foundations",
    "description": "Learn essential pointer concepts by working with pointers to structures. Focus on arrow operator (->), address-of operator (&), and passing structures to functions by reference.",
    "exactRequirements": {
        "functionNames": [
            "struct_pointers_init",
            "struct_pointers_exit",
            "print_device_info",
            "update_device_count",
            "activate_device"
        ],
        "variables": [
            {
                "name": "my_device",
                "type": "struct device_info",
                "value": "{.device_name = \"sensor01\", .device_id = 1001, .is_active = false, .data_count = 0}",
                "storageClass": "none"
            }
        ],
        "outputMessages": [
            "Structure pointers module loaded",
            "Initial Device Information:",
            "Device Name: sensor01",
            "Device ID: 1001",
            "Device Active: 0",
            "Data Count: 0",
            "Device sensor01 count updated to: 5",
            "Device sensor01 activated",
            "Final Device Information:",
            "Device Name: sensor01",
            "Device ID: 1001",
            "Device Active: 1",
            "Data Count: 5"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "struct device_info {",
            "extern struct device_info my_device",
            "struct device_info my_device = {",
            "&my_device",
            "module_param_named(device_id, my_device.device_id, int, 0644)",
            "module_param_named(data_count, my_device.data_count, int, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_device_info(struct device_info *dev)",
                "void update_device_count(struct device_info *dev, int new_count)",
                "void activate_device(struct device_info *dev)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_device_info(struct device_info *dev)",
                "void update_device_count(struct device_info *dev, int new_count)",
                "void activate_device(struct device_info *dev)",
                "static int __init struct_pointers_init(void)",
                "static void __exit struct_pointers_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Structure pointers module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init struct_pointers_init(void)"
                },
                {
                    "pattern": "Initial Device Information:",
                    "exact": true,
                    "linkedFunction": "static int __init struct_pointers_init(void)"
                },
                {
                    "pattern": "Device Name: sensor01",
                    "exact": true,
                    "linkedFunction": "void print_device_info(struct device_info *dev)"
                },
                {
                    "pattern": "Device ID: 1001",
                    "exact": true,
                    "linkedFunction": "void print_device_info(struct device_info *dev)"
                },
                {
                    "pattern": "Device Active: 0",
                    "exact": true,
                    "linkedFunction": "void print_device_info(struct device_info *dev)"
                },
                {
                    "pattern": "Data Count: 0",
                    "exact": true,
                    "linkedFunction": "void print_device_info(struct device_info *dev)"
                },
                {
                    "pattern": "Device sensor01 count updated to: 5",
                    "exact": true,
                    "linkedFunction": "void update_device_count(struct device_info *dev, int new_count)"
                },
                {
                    "pattern": "Device sensor01 activated",
                    "exact": true,
                    "linkedFunction": "void activate_device(struct device_info *dev)"
                },
                {
                    "pattern": "Final Device Information:",
                    "exact": true,
                    "linkedFunction": "static int __init struct_pointers_init(void)"
                },
                {
                    "pattern": "Device Name: sensor01",
                    "exact": true,
                    "linkedFunction": "void print_device_info(struct device_info *dev)"
                },
                {
                    "pattern": "Device ID: 1001",
                    "exact": true,
                    "linkedFunction": "void print_device_info(struct device_info *dev)"
                },
                {
                    "pattern": "Device Active: 1",
                    "exact": true,
                    "linkedFunction": "void print_device_info(struct device_info *dev)"
                },
                {
                    "pattern": "Data Count: 5",
                    "exact": true,
                    "linkedFunction": "void print_device_info(struct device_info *dev)"
                }
            ]
        },
        {
            "id": "advanced_pointer_structure_validation",
            "name": "Advanced Pointer Structure Implementation with TCC Header Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "pointer_struct_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Pointer Structure Implementation Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random device data\\n    int test_id1 = (rand() % 9000) + 2000;  // 2000-10999\\n    int test_count1 = (rand() % 10) + 1;    // 1-10\\n    int test_id2 = (rand() % 9000) + 5000;  // 5000-13999\\n    int test_count2 = (rand() % 20) + 5;    // 5-24\\n    \\n    printf(\\\"Test 1: Testing with device_id=%d, data_count=%d\\\\n\\\", test_id1, test_count1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/struct_pointers.ko device_id=%d data_count=%d\\\", test_id1, test_count1);\\n    system(\\\"rmmod struct_pointers 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Testing with device_id=%d, data_count=%d\\\\n\\\", test_id2, test_count2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/struct_pointers.ko device_id=%d data_count=%d\\\", test_id2, test_count2);\\n    system(\\\"rmmod struct_pointers\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Dynamic pointer structure test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting advanced pointer structure implementation validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo '#define true 1' >> /tmp/linux/types.h",
                    "echo '#define false 0' >> /tmp/linux/types.h",
                    "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
                    "echo 'Creating test file that includes pointer structure header...'",
                    "echo '#include \"/lib/modules/struct_pointers.h\"' > /tmp/test.c",
                    "echo 'int main() { my_device.device_id = 888; print_device_info(&my_device); update_device_count(&my_device, 10); activate_device(&my_device); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
                    "echo 'Phase 2: Dynamic Pointer Structure Implementation Testing'",
                    "/bin/pointer_struct_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Dynamic Value Extraction and Validation'",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Extracting random test values from output...'",
                    "TEST1_ID=$(grep -o 'Test 1: Testing with device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
                    "TEST1_COUNT=$(grep -o 'data_count=[0-9]*' /tmp/test_output.log | head -1 | cut -d'=' -f2)",
                    "TEST2_ID=$(grep -o 'Test 2: Testing with device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
                    "TEST2_COUNT=$(grep -o 'data_count=[0-9]*' /tmp/test_output.log | tail -1 | cut -d'=' -f2)",
                    "echo 'Test values: ID1='$TEST1_ID', Count1='$TEST1_COUNT', ID2='$TEST2_ID', Count2='$TEST2_COUNT",
                    "echo 'Validating pointer-based structure member access with dynamic values'",
                    "dmesg | grep 'Device ID: '$TEST1_ID && echo 'PASS: Pointer access to device_id working with '$TEST1_ID || echo 'FAIL: Pointer access to device_id broken for '$TEST1_ID",
                    "dmesg | grep 'Device Name: sensor01' && echo 'PASS: Pointer access to device_name working' || echo 'FAIL: Pointer access to device_name broken'",
                    "dmesg | grep 'Data Count: '$TEST1_COUNT && echo 'PASS: Initial data_count from module param '$TEST1_COUNT || echo 'FAIL: Module parameter data_count not working'",
                    "dmesg | grep 'Device ID: '$TEST2_ID && echo 'PASS: Pointer access to device_id working with '$TEST2_ID || echo 'FAIL: Pointer access to device_id broken for '$TEST2_ID",
                    "echo 'Phase 3.1: Function Logic Validation'",
                    "dmesg | grep 'Device sensor01 count updated to: 5' && echo 'PASS: update_device_count function message works' || echo 'FAIL: update_device_count message broken'",
                    "dmesg | grep 'Data Count: 5' && echo 'PASS: update_device_count actually modified struct data_count to 5' || echo 'FAIL: update_device_count function logic broken - struct not modified'",
                    "dmesg | grep 'Device sensor01 activated' && echo 'PASS: activate_device function message works' || echo 'FAIL: activate_device message broken'",
                    "dmesg | grep 'Device Active: 1' && echo 'PASS: activate_device actually modified struct is_active to true' || echo 'FAIL: activate_device function logic broken - struct not modified'",
                    "echo 'Phase 3.2: Final State Validation'",
                    "dmesg | grep 'Final Device Information:' && echo 'PASS: Final print_device_info called' || echo 'FAIL: Final print_device_info not called'",
                    "dmesg | grep 'Data Count: 5' && echo 'PASS: Final state data_count is correct' || echo 'FAIL: Final data_count wrong'",
                    "dmesg | grep 'Device Active: 1' && echo 'PASS: Final state is_active is correct' || echo 'FAIL: Final is_active wrong'",
                    "echo 'Phase 4: Structure Definition Validation'",
                    "dmesg | grep 'Structure pointers module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
                    "echo 'All pointer structure implementation validations completed'"
                ],
                "expected": {
                    "dmesg": [
                        "Structure pointers module loaded",
                        "Device Name: sensor01",
                        "Device ID: .*",
                        "Data Count: .*",
                        "Device sensor01 count updated to: 5",
                        "Device sensor01 activated",
                        "Device Active: 1"
                    ],
                    "stdout": [
                        "PASS: All function and variable declarations found in header file",
                        "SUCCESS: Dynamic pointer structure test completed",
                        "PASS: Pointer access to device_id working with .*",
                        "PASS: Pointer access to device_name working",
                        "PASS: Initial data_count from module param .*",
                        "PASS: update_device_count function message works",
                        "PASS: update_device_count actually modified struct data_count to 5",
                        "PASS: activate_device function message works",
                        "PASS: activate_device actually modified struct is_active to true",
                        "PASS: Final print_device_info called",
                        "PASS: Final state data_count is correct",
                        "PASS: Final state is_active is correct"
                    ]
                },
                "timeout": 15
            }
        }
    ]
});


// Problem 17: Typedef - Cleaner Type Definitions
generatedTestDefinitions.set(17, {
    "name": "Typedef - Cleaner Type Definitions",
    "category": "foundations",
    "description": "Learn to create cleaner, more readable code using typedef. Instead of writing 'struct device_info my_device', you can simply write 'Device my_device'. This introduces type aliasing - a fundamental concept for writing professional, maintainable kernel code.",
    "exactRequirements": {
        "functionNames": [
            "typedef_basics_init",
            "typedef_basics_exit",
            "print_device_details",
            "update_device_status",
            "check_device_state"
        ],
        "variables": [
            {
                "name": "my_device",
                "type": "Device",
                "value": "{.device_id = 12345, .name = \"sensor01\", .status_code = 200, .is_active = true}",
                "storageClass": "none"
            }
        ],
        "outputMessages": [
            "Typedef basics module loaded",
            "Initial Device Information:",
            "Device ID: 12345",
            "Device Name: sensor01",
            "Status Code: 200",
            "Device State: ACTIVE",
            "Status updated to: 404",
            "After status update:",
            "Device ID: 12345",
            "Device Name: sensor01",
            "Status Code: 404",
            "Device State: INACTIVE"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "typedef struct {",
            "} Device;",
            "extern Device my_device",
            "Device my_device = {",
            "module_param_named(device_id, my_device.device_id, int, 0644)",
            "module_param_named(status_code, my_device.status_code, int, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_device_details(void)",
                "void update_device_status(int new_status)",
                "void check_device_state(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_device_details(void)",
                "void update_device_status(int new_status)",
                "void check_device_state(void)",
                "static int __init typedef_basics_init(void)",
                "static void __exit typedef_basics_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Typedef basics module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init typedef_basics_init(void)"
                },
                {
                    "pattern": "Initial Device Information:",
                    "exact": true,
                    "linkedFunction": "static int __init typedef_basics_init(void)"
                },
                {
                    "pattern": "Device ID: 12345",
                    "exact": true,
                    "linkedFunction": "void print_device_details(void)"
                },
                {
                    "pattern": "Device Name: sensor01",
                    "exact": true,
                    "linkedFunction": "void print_device_details(void)"
                },
                {
                    "pattern": "Status Code: 200",
                    "exact": true,
                    "linkedFunction": "void print_device_details(void)"
                },
                {
                    "pattern": "Device State: ACTIVE",
                    "exact": true,
                    "linkedFunction": "void check_device_state(void)"
                },
                {
                    "pattern": "Status updated to: 404",
                    "exact": true,
                    "linkedFunction": "void update_device_status(int new_status)"
                },
                {
                    "pattern": "After status update:",
                    "exact": true,
                    "linkedFunction": "static int __init typedef_basics_init(void)"
                },
                {
                    "pattern": "Device ID: 12345",
                    "exact": true,
                    "linkedFunction": "void print_device_details(void)"
                },
                {
                    "pattern": "Device Name: sensor01",
                    "exact": true,
                    "linkedFunction": "void print_device_details(void)"
                },
                {
                    "pattern": "Status Code: 404",
                    "exact": true,
                    "linkedFunction": "void print_device_details(void)"
                },
                {
                    "pattern": "Device State: INACTIVE",
                    "exact": true,
                    "linkedFunction": "void check_device_state(void)"
                }
            ]
        },
        {
            "id": "advanced_typedef_implementation_validation",
            "name": "Advanced Typedef Implementation with TCC Header Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "typedef_dynamic_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Typedef Implementation Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random device data\\n    int test_id1 = (rand() % 9000) + 10000;     // 10000-18999\\n    int test_status1 = (rand() % 2) ? 200 : 404; // 200 or 404\\n    int test_id2 = (rand() % 9000) + 20000;     // 20000-28999\\n    int test_status2 = (rand() % 2) ? 200 : 500; // 200 or 500\\n    \\n    printf(\\\"Test 1: Testing with device_id=%d, status_code=%d\\\\n\\\", test_id1, test_status1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/typedef_basics.ko device_id=%d status_code=%d\\\", test_id1, test_status1);\\n    system(\\\"rmmod typedef_basics 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Testing with device_id=%d, status_code=%d\\\\n\\\", test_id2, test_status2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/typedef_basics.ko device_id=%d status_code=%d\\\", test_id2, test_status2);\\n    system(\\\"rmmod typedef_basics\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Dynamic typedef test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting advanced typedef implementation validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param_named(name, var, type, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo '#define true 1' >> /tmp/linux/types.h",
                    "echo '#define false 0' >> /tmp/linux/types.h",
                    "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
                    "echo 'Creating test file that includes typedef header...'",
                    "echo '#include \"/lib/modules/typedef_basics.h\"' > /tmp/test.c",
                    "echo 'int main() { my_device.device_id = 999; print_device_details(); update_device_status(500); check_device_state(); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or typedef declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and typedef declarations found in header file'; fi",
                    "echo 'Phase 2: Dynamic Typedef Implementation Testing'",
                    "/bin/typedef_dynamic_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Dynamic Value Extraction and Validation'",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Extracting random test values from output...'",
                    "TEST1_ID=$(grep -o 'Test 1: Testing with device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
                    "TEST1_STATUS=$(grep -o 'status_code=[0-9]*' /tmp/test_output.log | head -1 | cut -d'=' -f2)",
                    "TEST2_ID=$(grep -o 'Test 2: Testing with device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
                    "TEST2_STATUS=$(grep -o 'status_code=[0-9]*' /tmp/test_output.log | tail -1 | cut -d'=' -f2)",
                    "echo 'Test values: ID1='$TEST1_ID', Status1='$TEST1_STATUS', ID2='$TEST2_ID', Status2='$TEST2_STATUS",
                    "echo 'Validating typedef-based structure member access with dynamic values'",
                    "dmesg | grep 'Device ID: '$TEST1_ID && echo 'PASS: Typedef structure member access working with '$TEST1_ID || echo 'FAIL: Typedef structure member access broken for '$TEST1_ID",
                    "dmesg | grep 'Device Name: sensor01' && echo 'PASS: Typedef string member access working' || echo 'FAIL: Typedef string member access broken'",
                    "dmesg | grep 'Status Code: '$TEST1_STATUS && echo 'PASS: Typedef status member access working with '$TEST1_STATUS || echo 'FAIL: Typedef status member access broken for '$TEST1_STATUS",
                    "dmesg | grep 'Device ID: '$TEST2_ID && echo 'PASS: Typedef structure member access working with '$TEST2_ID || echo 'FAIL: Typedef structure member access broken for '$TEST2_ID",
                    "dmesg | grep 'Status Code: '$TEST2_STATUS && echo 'PASS: Typedef status member access working with '$TEST2_STATUS || echo 'FAIL: Typedef status member access broken for '$TEST2_STATUS",
                    "echo 'Phase 3.1: Function Logic Validation'",
                    "dmesg | grep 'Status updated to: 404' && echo 'PASS: update_device_status function message works' || echo 'FAIL: update_device_status message broken'",
                    "dmesg | grep 'Status Code: 404' && echo 'PASS: update_device_status actually modified typedef structure member' || echo 'FAIL: update_device_status function logic broken - structure not modified'",
                    "dmesg | grep 'Device State: INACTIVE' && echo 'PASS: check_device_state function using typedef member correctly' || echo 'FAIL: check_device_state not using typedef structure member'",
                    "echo 'Phase 3.2: Final State Validation'",
                    "dmesg | grep 'After status update:' && echo 'PASS: Final print_device_details called' || echo 'FAIL: Final print_device_details not called'",
                    "dmesg | grep 'Status Code: 404' && echo 'PASS: Final state shows correct typedef member modification' || echo 'FAIL: Final state typedef member modification broken'",
                    "dmesg | grep 'Device State: INACTIVE' && echo 'PASS: Final state shows correct conditional logic' || echo 'FAIL: Final state conditional logic broken'",
                    "echo 'Phase 4: Typedef Definition Validation'",
                    "dmesg | grep 'Typedef basics module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
                    "echo 'All typedef implementation validations completed'"
                ],
                "expected": {
                    "dmesg": [
                        "Typedef basics module loaded",
                        "Device ID: .*",
                        "Device Name: sensor01",
                        "Status Code: .*",
                        "Device State: ACTIVE",
                        "Status updated to: 404"
                    ],
                    "stdout": [
                        "PASS: All function and typedef declarations found in header file",
                        "SUCCESS: Dynamic typedef test completed",
                        "PASS: Typedef structure member access working with .*",
                        "PASS: Typedef string member access working",
                        "PASS: Typedef status member access working with .*",
                        "PASS: update_device_status function message works",
                        "PASS: update_device_status actually modified typedef structure member",
                        "PASS: check_device_state function using typedef member correctly",
                        "PASS: Final print_device_details called",
                        "PASS: Final state shows correct typedef member modification",
                        "PASS: Final state shows correct conditional logic"
                    ]
                },
                "timeout": 15
            }
        }
    ]
});


// Problem 18: Dynamic Memory - kmalloc and kfree Essentials
generatedTestDefinitions.set(18, {
    "name": "Dynamic Memory - kmalloc and kfree Essentials",
    "category": "foundations",
    "description": "Master the essential dynamic memory pattern: kmalloc(sizeof(Device), GFP_KERNEL) to allocate and kfree() to clean up. Learn the fundamental runtime allocation pattern used throughout kernel development.",
    "exactRequirements": {
        "functionNames": [
            "dynamic_memory_init",
            "dynamic_memory_exit",
            "create_device",
            "print_device_info",
            "cleanup_device"
        ],
        "variables": [
            {
                "name": "my_device",
                "type": "Device *",
                "value": "NULL",
                "storageClass": "none"
            }
        ],
        "outputMessages": [
            "Dynamic memory module loaded",
            "Learning kmalloc and kfree!",
            "Creating device with ID: 1001",
            "Device allocated successfully!",
            "=== Device Info ===",
            "Device ID: 1001",
            "Status: 200",
            "Active: YES",
            "Dynamic memory module unloading",
            "Device memory freed",
            "Module unloaded cleanly"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h",
            "linux/slab.h",
            "linux/string.h"
        ],
        "mustContain": [
            "kmalloc(sizeof(Device), GFP_KERNEL)",
            "kfree(my_device)",
            "if (!my_device)",
            "my_device = NULL",
            "module_param(device_id, int, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "Device* create_device(int id)",
                "void print_device_info(Device* dev)",
                "void cleanup_device(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "Device* create_device(int id)",
                "void print_device_info(Device* dev)",
                "void cleanup_device(void)",
                "static int __init dynamic_memory_init(void)",
                "static void __exit dynamic_memory_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Dynamic memory module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init dynamic_memory_init(void)"
                },
                {
                    "pattern": "Learning kmalloc and kfree!",
                    "exact": true,
                    "linkedFunction": "static int __init dynamic_memory_init(void)"
                },
                {
                    "pattern": "Creating device with ID: 1001",
                    "exact": true,
                    "linkedFunction": "Device* create_device(int id)"
                },
                {
                    "pattern": "Device allocated successfully!",
                    "exact": true,
                    "linkedFunction": "Device* create_device(int id)"
                },
                {
                    "pattern": "=== Device Info ===",
                    "exact": true,
                    "linkedFunction": "void print_device_info(Device* dev)"
                },
                {
                    "pattern": "Device ID: 1001",
                    "exact": true,
                    "linkedFunction": "void print_device_info(Device* dev)"
                },
                {
                    "pattern": "Status: 200",
                    "exact": true,
                    "linkedFunction": "void print_device_info(Device* dev)"
                },
                {
                    "pattern": "Active: YES",
                    "exact": true,
                    "linkedFunction": "void print_device_info(Device* dev)"
                },
                {
                    "pattern": "Dynamic memory module unloading",
                    "exact": true,
                    "linkedFunction": "static void __exit dynamic_memory_exit(void)"
                },
                {
                    "pattern": "Device memory freed",
                    "exact": true,
                    "linkedFunction": "void cleanup_device(void)"
                },
                {
                    "pattern": "Module unloaded cleanly",
                    "exact": true,
                    "linkedFunction": "static void __exit dynamic_memory_exit(void)"
                }
            ]
        },
        {
            "id": "advanced_dynamic_memory_validation",
            "name": "Advanced Dynamic Memory Implementation with TCC Header Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "memory_dynamic_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Memory Anti-Hardcoding Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random device IDs\\n    int test_device_id1 = (rand() % 9000) + 1000;   // 1000-9999\\n    int test_device_id2 = (rand() % 5000) + 20000;  // 20000-24999\\n    \\n    printf(\\\"Test 1: Testing kmalloc with device_id=%d\\\\n\\\", test_device_id1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/dynamic_memory.ko device_id=%d\\\", test_device_id1);\\n    system(\\\"rmmod dynamic_memory 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Testing kmalloc with device_id=%d\\\\n\\\", test_device_id2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/dynamic_memory.ko device_id=%d\\\", test_device_id2);\\n    system(\\\"rmmod dynamic_memory\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Anti-hardcoding memory test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting advanced dynamic memory implementation validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
                    "echo '#define true 1' >> /tmp/linux/types.h",
                    "echo '#define false 0' >> /tmp/linux/types.h",
                    "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
                    "echo '#define MAX_DEVICES 5' >> /tmp/linux/types.h",
                    "echo '#define GFP_KERNEL 0' > /tmp/linux/slab.h",
                    "echo '#define ENOMEM 12' >> /tmp/linux/slab.h",
                    "echo 'void *kmalloc(size_t size, int flags);' >> /tmp/linux/slab.h",
                    "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
                    "echo 'Creating test file that includes dynamic memory header...'",
                    "echo '#include \"/lib/modules/dynamic_memory.h\"' > /tmp/test.c",
                    "echo 'int main() { create_device(123); print_device_info(my_device); cleanup_device(); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
                    "echo 'Phase 2: Anti-Hardcoding Dynamic Memory Testing'",
                    "/bin/memory_dynamic_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Random Value Extraction and Validation'",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Extracting random test values from output...'",
                    "DEVICE_ID1=$(grep -o 'Test 1: Testing kmalloc with device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
                    "DEVICE_ID2=$(grep -o 'Test 2: Testing kmalloc with device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
                    "echo 'Extracted values: DEVICE_ID1='$DEVICE_ID1', DEVICE_ID2='$DEVICE_ID2",
                    "if [ -z \"$DEVICE_ID1\" ] || [ -z \"$DEVICE_ID2\" ]; then echo 'FAIL: Could not extract random test values'; else echo 'PASS: Random values extracted successfully'; fi",
                    "echo 'Phase 4: Anti-Hardcoding Memory Allocation Validation'",
                    "echo 'Validating kmalloc with random device ID '$DEVICE_ID1",
                    "dmesg | grep \"Creating device with ID: $DEVICE_ID1\" && echo 'PASS: Device creation with random ID working' || echo 'FAIL: Device creation with random ID broken'",
                    "dmesg | grep \"Device allocated successfully!\" && echo 'PASS: kmalloc allocation working' || echo 'FAIL: kmalloc allocation broken'",
                    "dmesg | grep \"Device ID: $DEVICE_ID1\" && echo 'PASS: Device data access working with '$DEVICE_ID1 || echo 'FAIL: Device data access broken'",
                    "echo 'Validating kmalloc with random device ID '$DEVICE_ID2",
                    "dmesg | grep \"Creating device with ID: $DEVICE_ID2\" && echo 'PASS: Device creation with random ID working' || echo 'FAIL: Device creation with random ID broken'",
                    "dmesg | grep \"Device ID: $DEVICE_ID2\" && echo 'PASS: Device data access working with '$DEVICE_ID2 || echo 'FAIL: Device data access broken'",
                    "echo 'Phase 5: Memory Cleanup Validation'",
                    "dmesg | grep 'Device memory freed' && echo 'PASS: kfree cleanup working' || echo 'FAIL: kfree cleanup broken'",
                    "dmesg | grep 'Module unloaded cleanly' && echo 'PASS: Complete cleanup working' || echo 'FAIL: Complete cleanup broken'",
                    "echo 'Phase 6: Function Logic Validation'",
                    "dmesg | grep 'Learning kmalloc and kfree!' && echo 'PASS: Module messaging working' || echo 'FAIL: Module messaging broken'",
                    "dmesg | grep 'Active: YES' && echo 'PASS: Device status working' || echo 'FAIL: Device status broken'",
                    "echo 'Phase 7: Final Validation Summary'",
                    "echo 'All phases completed successfully - kmalloc/kfree pattern verified'",
                    "echo 'PASS: All anti-hardcoding memory validation successful'"
                ],
                "expected": {
                    "dmesg": [
                        "Dynamic memory module loaded",
                        "Learning kmalloc and kfree!",
                        "Creating device with ID: .*",
                        "Device allocated successfully!",
                        "Device ID: .*",
                        "Active: YES",
                        "Device memory freed",
                        "Module unloaded cleanly"
                    ],
                    "stdout": [
                        "PASS: All function and variable declarations found in header file",
                        "SUCCESS: Anti-hardcoding memory test completed",
                        "PASS: Random values extracted successfully",
                        "PASS: Device creation with random ID working",
                        "PASS: kmalloc allocation working",
                        "PASS: Device data access working",
                        "PASS: kfree cleanup working",
                        "PASS: Complete cleanup working",
                        "PASS: All anti-hardcoding memory validation successful"
                    ]
                },
                "timeout": 15
            }
        }
    ]
});


// Problem 19: Pointer Casting - Multi-Level Type Conversion Mastery
generatedTestDefinitions.set(19, {
    "name": "Pointer Casting - Multi-Level Type Conversion Mastery",
    "category": "foundations",
    "description": "Master multi-level pointer casting chains: void* → generic_record* → sensor_record*. Learn the exact patterns used in production kernel parsers for safe type conversion and record processing.",
    "exactRequirements": {
        "functionNames": [
            "pointer_casting_init",
            "pointer_casting_exit",
            "process_generic_record",
            "extract_sensor_data",
            "extract_device_data",
            "print_record_info"
        ],
        "variables": [
            {
                "name": "current_record",
                "type": "generic_record *",
                "value": "NULL",
                "storageClass": "none"
            },
            {
                "name": "sensor_data",
                "type": "sensor_record *",
                "value": "NULL",
                "storageClass": "none"
            },
            {
                "name": "device_data",
                "type": "device_record *",
                "value": "NULL",
                "storageClass": "none"
            }
        ],
        "outputMessages": [
            "Pointer casting module loaded",
            "Sensor Record Extracted",
            "Sensor ID: 1001",
            "Sensor Name: temperature_01",
            "Measurement: 257",
            "Current Record Info:",
            "Record Type: 1",
            "Record Subtype: 1",
            "Record Length: 52",
            "Pointer casting module unloaded"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "generic_record *rec = (generic_record *)raw_record",
            "sensor_record *sensor = (sensor_record *)rec",
            "device_record *device = (device_record *)rec",
            "current_record = rec",
            "sensor_data = sensor",
            "device_data = device",
            "if (rec->header.rec_type == SENSOR_RECORD)",
            "module_param(test_record_type, int, 0644)",
            "module_param(test_sensor_id, int, 0644)",
            "module_param(test_measurement, int, 0644)",
            "module_param(test_device_id, int, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void process_generic_record(void *raw_record)",
                "void extract_sensor_data(generic_record *rec)",
                "void extract_device_data(generic_record *rec)",
                "void print_record_info(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void process_generic_record(void *raw_record)",
                "void extract_sensor_data(generic_record *rec)",
                "void extract_device_data(generic_record *rec)",
                "void print_record_info(void)",
                "static int __init pointer_casting_init(void)",
                "static void __exit pointer_casting_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Pointer casting module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init pointer_casting_init(void)"
                },
                {
                    "pattern": "Sensor Record Extracted",
                    "exact": true,
                    "linkedFunction": "void extract_sensor_data(generic_record *rec)"
                },
                {
                    "pattern": "Sensor ID: 1001",
                    "exact": true,
                    "linkedFunction": "void extract_sensor_data(generic_record *rec)"
                },
                {
                    "pattern": "Sensor Name: temperature_01",
                    "exact": true,
                    "linkedFunction": "void extract_sensor_data(generic_record *rec)"
                },
                {
                    "pattern": "Measurement: 257",
                    "exact": true,
                    "linkedFunction": "void extract_sensor_data(generic_record *rec)"
                },
                {
                    "pattern": "Current Record Info:",
                    "exact": true,
                    "linkedFunction": "void print_record_info(void)"
                },
                {
                    "pattern": "Record Type: 1",
                    "exact": true,
                    "linkedFunction": "void print_record_info(void)"
                },
                {
                    "pattern": "Record Subtype: 1",
                    "exact": true,
                    "linkedFunction": "void print_record_info(void)"
                },
                {
                    "pattern": "Record Length: 52",
                    "exact": true,
                    "linkedFunction": "void print_record_info(void)"
                },
                {
                    "pattern": "Pointer casting module unloaded",
                    "exact": true,
                    "linkedFunction": "static void __exit pointer_casting_exit(void)"
                }
            ]
        },
        {
            "id": "advanced_casting_validation",
            "name": "Advanced Multi-Level Casting Implementation with Anti-Hardcoding Protection",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "casting_dynamic_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Anti-Hardcoding Casting Test ===\\\\n\\\");\\n    \\n    // Seed random number generator with current time\\n    srand(time(NULL));\\n    \\n    // Generate unpredictable sensor test values\\n    int random_sensor_id = (rand() % 9000) + 1000;  // 1000-9999\\n    int random_measurement = (rand() % 500) + 100;   // 100-599\\n    \\n    // Generate unpredictable device test values\\n    int random_device_id = (rand() % 8000) + 2000;  // 2000-9999\\n    \\n    printf(\\\"Test 1: Random sensor casting (ID=%d, measurement=%d)\\\\n\\\", random_sensor_id, random_measurement);\\n    printf(\\\"Test 2: Random device casting (ID=%d)\\\\n\\\", random_device_id);\\n    \\n    // Test sensor record casting with random values\\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod pointer_casting 2>/dev/null\\\");\\n    \\n    char cmd1[512];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/pointer_casting.ko test_record_type=1 test_sensor_id=%d test_measurement=%d\\\", random_sensor_id, random_measurement);\\n    printf(\\\"DEBUG: Sensor command: %s\\\\n\\\", cmd1);\\n    system(cmd1);\\n    \\n    \\n    // Test device record casting with random values\\n    printf(\\\"DEBUG: Switching to device test...\\\\n\\\");\\n    system(\\\"rmmod pointer_casting\\\");\\n    \\n    char cmd2[512];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/pointer_casting.ko test_record_type=2 test_device_id=%d\\\", random_device_id);\\n    printf(\\\"DEBUG: Device command: %s\\\\n\\\", cmd2);\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Anti-hardcoding casting test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting advanced multi-level casting implementation validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo 'typedef unsigned char uint8_t;' >> /tmp/linux/types.h",
                    "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
                    "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
                    "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
                    "echo '#define true 1' >> /tmp/linux/types.h",
                    "echo '#define false 0' >> /tmp/linux/types.h",
                    "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
                    "echo 'Creating test file that includes casting header...'",
                    "echo '#include \"/lib/modules/pointer_casting.h\"' > /tmp/test.c",
                    "echo 'int main() { current_record->header.rec_type = 1; process_generic_record((void*)0); extract_sensor_data((generic_record*)0); extract_device_data((generic_record*)0); print_record_info(); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
                    "echo 'Phase 2: Anti-Hardcoding Dynamic Casting Test'",
                    "/bin/casting_dynamic_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Random Value Extraction and Validation'",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Extracting random test values from output...'",
                    "SENSOR_ID=$(grep -o 'Random sensor casting (ID=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
                    "SENSOR_MEASUREMENT=$(grep -o 'measurement=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
                    "DEVICE_ID=$(grep -o 'Random device casting (ID=[0-9]*)' /tmp/test_output.log | cut -d'=' -f2 | cut -d')' -f1)",
                    "echo 'Extracted values: SENSOR_ID='$SENSOR_ID', MEASUREMENT='$SENSOR_MEASUREMENT', DEVICE_ID='$DEVICE_ID",
                    "if [ -z \"$SENSOR_ID\" ] || [ -z \"$SENSOR_MEASUREMENT\" ] || [ -z \"$DEVICE_ID\" ]; then echo 'FAIL: Could not extract random test values'; else echo 'PASS: Random values extracted successfully'; fi",
                    "echo 'Phase 4: Anti-Hardcoding Validation with Random Values'",
                    "echo 'Validating sensor casting with random ID '$SENSOR_ID",
                    "dmesg | grep \"Sensor ID: $SENSOR_ID\" && echo 'PASS: Sensor casting with random ID working' || echo 'FAIL: Sensor casting with random ID broken'",
                    "echo 'Validating sensor measurement with random value '$SENSOR_MEASUREMENT",
                    "dmesg | grep \"Measurement: $SENSOR_MEASUREMENT\" && echo 'PASS: Sensor measurement with random value working' || echo 'FAIL: Sensor measurement with random value broken'",
                    "echo 'Validating device casting with random ID '$DEVICE_ID",
                    "dmesg | grep \"Device ID: $DEVICE_ID\" && echo 'PASS: Device casting with random ID working' || echo 'FAIL: Device casting with random ID broken'",
                    "echo 'Phase 5: Static Field Validation (Non-Randomized Fields)'",
                    "dmesg | grep 'Sensor Name: temperature_01' && echo 'PASS: Sensor name field access working' || echo 'FAIL: Sensor name field access broken'",
                    "dmesg | grep 'Device Status: operational' && echo 'PASS: Device status field access working' || echo 'FAIL: Device status field access broken'",
                    "echo 'Phase 6: Casting Logic and Record Type Validation'",
                    "dmesg | grep 'Sensor Record Extracted' && echo 'PASS: Sensor extraction logic working' || echo 'FAIL: Sensor extraction logic broken'",
                    "dmesg | grep 'Device Record Extracted' && echo 'PASS: Device extraction logic working' || echo 'FAIL: Device extraction logic broken'",
                    "dmesg | grep 'Current Record Info:' && echo 'PASS: Record info display working' || echo 'FAIL: Record info display broken'",
                    "echo 'Phase 7: Final Validation Summary'",
                    "echo 'All phases completed successfully - anti-hardcoding protection verified'",
                    "echo 'PASS: All anti-hardcoding casting validation successful'"
                ],
                "expected": {
                    "dmesg": [
                        "Pointer casting module loaded",
                        "Sensor Record Extracted",
                        "Sensor ID: .*",
                        "Sensor Name: temperature_01",
                        "Measurement: .*",
                        "Device Record Extracted",
                        "Device ID: .*",
                        "Device Status: operational",
                        "Current Record Info:",
                        "Record Type: .*"
                    ],
                    "stdout": [
                        "PASS: All function and variable declarations found in header file",
                        "SUCCESS: Anti-hardcoding casting test completed",
                        "PASS: Random values extracted successfully",
                        "PASS: Sensor casting with random ID working",
                        "PASS: Sensor measurement with random value working",
                        "PASS: Device casting with random ID working",
                        "PASS: Sensor name field access working",
                        "PASS: Device status field access working",
                        "PASS: Sensor extraction logic working",
                        "PASS: Device extraction logic working",
                        "PASS: Record info display working",
                        "PASS: All anti-hardcoding casting validation successful"
                    ]
                },
                "timeout": 15
            }
        }
    ]
});


// Problem 20: Function Pointers - Advanced Callback and Dispatch Systems
generatedTestDefinitions.set(20, {
    "name": "Function Pointers - Advanced Callback and Dispatch Systems",
    "category": "foundations",
    "description": "Master function pointer typedefs and dispatch tables used in production kernel code. Learn to create callback systems, register handlers dynamically, and implement dispatch tables like those used in device drivers and protocol parsers. This teaches advanced C patterns essential for understanding complex kernel architectures.",
    "exactRequirements": {
        "functionNames": [
            "function_pointers_init",
            "function_pointers_exit",
            "register_record_handler",
            "process_record_with_dispatch",
            "call_status_callback",
            "display_handler_table"
        ],
        "variables": [
            {
                "name": "handler_table",
                "type": "dispatch_entry[MAX_HANDLERS]",
                "value": "{{0}}",
                "storageClass": "none"
            },
            {
                "name": "registered_handlers",
                "type": "int",
                "value": "0",
                "storageClass": "none"
            },
            {
                "name": "active_processor",
                "type": "record_processor_t",
                "value": "NULL",
                "storageClass": "none"
            },
            {
                "name": "active_error_handler",
                "type": "error_handler_t",
                "value": "NULL",
                "storageClass": "none"
            },
            {
                "name": "active_status_callback",
                "type": "status_callback_t",
                "value": "NULL",
                "storageClass": "none"
            }
        ],
        "outputMessages": [
            "Function pointers module loaded",
            "Registered SENSOR record handler",
            "Registered DEVICE record handler",
            "Handler Table Status:",
            "Registered handlers: 2/5",
            "Testing dispatch with record type: 1, ID: 1001",
            "Found handler for record type: 1",
            "Processing sensor record ID: 1001",
            "Sensor data processed successfully",
            "Sensor Status [Type 1]: processing_complete",
            "Sensor Status [Type 1]: module_init_complete",
            "Function pointers module unloaded"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h",
            "linux/slab.h"
        ],
        "mustContain": [
            "handler_table[slot].record_type = record_type",
            "handler_table[slot].processor = processor",
            "handler_table[slot].error_handler = error_handler",
            "active_processor = handler_table[i].processor",
            "active_error_handler = handler_table[i].error_handler",
            "active_status_callback = handler_table[i].status_callback",
            "handler_table[i].processor(record_data, record_id)",
            "handler_table[i].status_callback(record_type, status_message)",
            "if (registered_handlers >= MAX_HANDLERS)",
            "module_param(test_record_type, int, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int register_record_handler(uint8_t record_type, record_processor_t processor, error_handler_t error_handler)",
                "int process_record_with_dispatch(uint8_t record_type, void *record_data, uint32_t record_id)",
                "void call_status_callback(uint8_t record_type, const char *status_message)",
                "void display_handler_table(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int register_record_handler(uint8_t record_type, record_processor_t processor, error_handler_t error_handler)",
                "int process_record_with_dispatch(uint8_t record_type, void *record_data, uint32_t record_id)",
                "void call_status_callback(uint8_t record_type, const char *status_message)",
                "void display_handler_table(void)",
                "static int __init function_pointers_init(void)",
                "static void __exit function_pointers_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Function pointers module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init function_pointers_init(void)"
                },
                {
                    "pattern": "Registered SENSOR record handler",
                    "exact": true,
                    "linkedFunction": "int register_record_handler(uint8_t record_type, record_processor_t processor, error_handler_t error_handler)"
                },
                {
                    "pattern": "Registered DEVICE record handler",
                    "exact": true,
                    "linkedFunction": "int register_record_handler(uint8_t record_type, record_processor_t processor, error_handler_t error_handler)"
                },
                {
                    "pattern": "Handler Table Status:",
                    "exact": true,
                    "linkedFunction": "void display_handler_table(void)"
                },
                {
                    "pattern": "Registered handlers: 2/5",
                    "exact": true,
                    "linkedFunction": "void display_handler_table(void)"
                },
                {
                    "pattern": "Testing dispatch with record type: 1, ID: 1001",
                    "exact": true,
                    "linkedFunction": "static int __init function_pointers_init(void)"
                },
                {
                    "pattern": "Found handler for record type: 1",
                    "exact": true,
                    "linkedFunction": "int process_record_with_dispatch(uint8_t record_type, void *record_data, uint32_t record_id)"
                },
                {
                    "pattern": "Processing sensor record ID: 1001",
                    "exact": true,
                    "linkedFunction": "int sensor_record_processor(void *record_data, uint32_t record_id)"
                },
                {
                    "pattern": "Sensor data processed successfully",
                    "exact": true,
                    "linkedFunction": "int sensor_record_processor(void *record_data, uint32_t record_id)"
                },
                {
                    "pattern": "Sensor Status [Type 1]: processing_complete",
                    "exact": true,
                    "linkedFunction": "void sensor_status_callback(uint8_t record_type, const char *status)"
                },
                {
                    "pattern": "Sensor Status [Type 1]: module_init_complete",
                    "exact": true,
                    "linkedFunction": "void call_status_callback(uint8_t record_type, const char *status_message)"
                },
                {
                    "pattern": "Function pointers module unloaded",
                    "exact": true,
                    "linkedFunction": "static void __exit function_pointers_exit(void)"
                }
            ]
        },
        {
            "id": "advanced_function_pointer_validation",
            "name": "Advanced Function Pointer Dispatch Implementation with TCC Header Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "function_pointer_dynamic_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Function Pointer Implementation Test ===\\\\n\\\");\\n    \\n    // Test sensor handler dispatch\\n    int test_record_type1 = 1;  // SENSOR_RECORD\\n    printf(\\\"Test 1: Testing sensor handler dispatch with test_record_type=%d\\\\n\\\", test_record_type1);\\n    system(\\\"rmmod function_pointers 2>/dev/null\\\");\\n    system(\\\"insmod /lib/modules/function_pointers.ko test_record_type=1\\\");\\n    \\n    // Test device handler dispatch\\n    int test_record_type2 = 2;  // DEVICE_RECORD\\n    printf(\\\"Test 2: Testing device handler dispatch with test_record_type=%d\\\\n\\\", test_record_type2);\\n    system(\\\"rmmod function_pointers\\\");\\n    system(\\\"insmod /lib/modules/function_pointers.ko test_record_type=2\\\");\\n    \\n    printf(\\\"SUCCESS: Dynamic function pointer test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting advanced function pointer dispatch implementation validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo 'typedef unsigned char uint8_t;' >> /tmp/linux/types.h",
                    "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
                    "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
                    "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
                    "echo '#define true 1' >> /tmp/linux/types.h",
                    "echo '#define false 0' >> /tmp/linux/types.h",
                    "echo '#define MAX_HANDLERS 5' >> /tmp/linux/types.h",
                    "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
                    "echo 'void *kmalloc(size_t size, int flags);' > /tmp/linux/slab.h",
                    "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
                    "echo 'Creating test file that includes function pointers header...'",
                    "echo '#include \"/lib/modules/function_pointers.h\"' > /tmp/test.c",
                    "echo 'int main() { handler_table[0].record_type = 1; register_record_handler(1, (record_processor_t)0, (error_handler_t)0); process_record_with_dispatch(1, (void*)0, 1001); call_status_callback(1, \"test\"); display_handler_table(); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
                    "echo 'Phase 2: Dynamic Function Pointer Implementation Testing'",
                    "/bin/function_pointer_dynamic_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Function Pointer Dispatch Validation'",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Phase 3.1: Sensor Function Pointer Dispatch'",
                    "dmesg | grep 'Processing sensor record ID: 1001' && echo 'PASS: Sensor function pointer dispatch working' || echo 'FAIL: Sensor function pointer dispatch broken'",
                    "dmesg | grep 'Sensor data processed successfully' && echo 'PASS: Sensor processor function called successfully' || echo 'FAIL: Sensor processor function not called'",
                    "echo 'Phase 3.2: Device Function Pointer Dispatch'",
                    "dmesg | grep 'Processing device record ID: 1001' && echo 'PASS: Device function pointer dispatch working' || echo 'FAIL: Device function pointer dispatch broken'",
                    "dmesg | grep 'Device data processed successfully' && echo 'PASS: Device processor function called successfully' || echo 'FAIL: Device processor function not called'",
                    "echo 'Phase 3.3: Handler Registration Validation'",
                    "dmesg | grep 'Registered SENSOR record handler' && echo 'PASS: Sensor handler registration working' || echo 'FAIL: Sensor handler registration broken'",
                    "dmesg | grep 'Registered DEVICE record handler' && echo 'PASS: Device handler registration working' || echo 'FAIL: Device handler registration broken'",
                    "dmesg | grep 'Found handler for record type:' && echo 'PASS: Handler lookup working' || echo 'FAIL: Handler lookup broken'",
                    "echo 'Phase 3.4: Callback System Validation'",
                    "dmesg | grep 'Status.*processing_complete' && echo 'PASS: Status callback working' || echo 'FAIL: Status callback broken'",
                    "dmesg | grep 'Status.*module_init_complete' && echo 'PASS: Manual status callback working' || echo 'FAIL: Manual status callback broken'",
                    "echo 'Phase 3.5: Dispatch Table Validation'",
                    "dmesg | grep 'Handler Table Status:' && echo 'PASS: Handler table display working' || echo 'FAIL: Handler table display broken'",
                    "dmesg | grep 'Registered handlers: 2/5' && echo 'PASS: Handler count tracking working' || echo 'FAIL: Handler count tracking broken'",
                    "echo 'Phase 4: Module Validation'",
                    "dmesg | grep 'Function pointers module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
                    "dmesg | grep 'Function pointers module unloaded' && echo 'PASS: Module cleanup working' || echo 'FAIL: Module cleanup broken'",
                    "echo 'All function pointer dispatch implementation validations completed'"
                ],
                "expected": {
                    "dmesg": [
                        "Function pointers module loaded",
                        "Registered SENSOR record handler",
                        "Registered DEVICE record handler",
                        "Handler Table Status:",
                        "Registered handlers: 2/5",
                        "Processing sensor record ID: .*",
                        "Processing device record ID: .*",
                        "Sensor data processed successfully",
                        "Device data processed successfully"
                    ],
                    "stdout": [
                        "PASS: All function and variable declarations found in header file",
                        "SUCCESS: Dynamic function pointer test completed",
                        "PASS: Sensor function pointer dispatch working",
                        "PASS: Sensor processor function called successfully",
                        "PASS: Device function pointer dispatch working",
                        "PASS: Device processor function called successfully",
                        "PASS: Sensor handler registration working",
                        "PASS: Device handler registration working",
                        "PASS: Handler lookup working",
                        "PASS: Status callback working",
                        "PASS: Manual status callback working",
                        "PASS: Handler table display working",
                        "PASS: Handler count tracking working"
                    ]
                },
                "timeout": 15
            }
        }
    ]
});


// Problem 79: Secure String Handling - Modern Kernel Text Operations
generatedTestDefinitions.set(79, {
    "name": "Secure String Handling - Modern Kernel Text Operations",
    "category": "foundations",
    "description": "Learn modern, secure string handling in kernel space using current best practices. Master strscpy(), snprintf(), and safe string operations essential for handling device names, user messages, and configuration data in kernel modules.",
    "exactRequirements": {
        "functionNames": [
            "strings_init",
            "strings_exit",
            "display_device_info",
            "update_device_name",
            "format_status_message",
            "validate_string_input"
        ],
        "variables": [
            {
                "name": "device_name",
                "type": "char[]",
                "value": "\"sensor_001\""
            },
            {
                "name": "status_message",
                "type": "char[]",
                "value": "\"initializing\""
            },
            {
                "name": "name_length",
                "type": "int",
                "value": 0
            }
        ],
        "outputMessages": [
            "Secure string handling module loaded",
            "Device: sensor_001 (Length: 10)",
            "Status: initializing",
            "Device name updated successfully",
            "Device: updated_sensor (Length: 14)",
            "Status: Device updated_sensor is active"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h",
            "linux/string.h"
        ],
        "mustContain": [
            "#define MAX_DEVICE_NAME 32",
            "#define MAX_STATUS_MSG 64",
            "extern char device_name[MAX_DEVICE_NAME]",
            "extern char status_message[MAX_STATUS_MSG]",
            "module_param_string(device_name, device_name, MAX_DEVICE_NAME, 0644)",
            "module_param_string(status_message, status_message, MAX_STATUS_MSG, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void display_device_info(void)",
                "ssize_t update_device_name(const char *new_name)",
                "int format_status_message(const char *status)",
                "int validate_string_input(const char *input)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void display_device_info(void)",
                "ssize_t update_device_name(const char *new_name)",
                "int format_status_message(const char *status)",
                "int validate_string_input(const char *input)",
                "static int __init strings_init(void)",
                "static void __exit strings_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "advanced_string_implementation_validation",
            "name": "Advanced String Implementation with TCC Header Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "string_impl_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\"=== Dynamic String Implementation Test ===\\\\n\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random device names and statuses\\n    const char* device_prefixes[] = {\"sensor\", \"actuator\", \"controller\", \"monitor\"};\\n    const char* statuses[] = {\"active\", \"idle\", \"error\", \"maintenance\", \"ready\"};\\n    \\n    int device_idx = rand() % 4;\\n    int device_num = (rand() % 100) + 1;\\n    int status_idx = rand() % 5;\\n    \\n    char device_name[32];\\n    snprintf(device_name, sizeof(device_name), \"%s_%03d\", device_prefixes[device_idx], device_num);\\n    \\n    printf(\"Test 1: Device name '%s' with status '%s'\\\\n\", device_name, statuses[status_idx]);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \"insmod /lib/modules/strings.ko device_name=%s status_message=%s\", device_name, statuses[status_idx]);\\n    system(\"rmmod strings 2>/dev/null\");\\n    system(cmd1);\\n    \\n    // Second test with different values\\n    device_idx = rand() % 4;\\n    device_num = (rand() % 100) + 1;\\n    status_idx = rand() % 5;\\n    snprintf(device_name, sizeof(device_name), \"%s_%03d\", device_prefixes[device_idx], device_num);\\n    \\n    printf(\"Test 2: Device name '%s' with status '%s'\\\\n\", device_name, statuses[status_idx]);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \"insmod /lib/modules/strings.ko device_name=%s status_message=%s\", device_name, statuses[status_idx]);\\n    system(\"rmmod strings\");\\n    system(cmd2);\\n    \\n    printf(\"SUCCESS: Dynamic string test completed\\\\n\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting advanced string implementation validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
                    "echo '#define KERN_WARNING' >> /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param_string(name, string, len, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef long ssize_t;' > /tmp/linux/types.h",
                    "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
                    "echo 'ssize_t strscpy(char *dest, const char *src, size_t count);' > /tmp/linux/string.h",
                    "echo 'int snprintf(char *buf, size_t size, const char *fmt, ...);' >> /tmp/linux/string.h",
                    "echo 'size_t strlen(const char *s);' >> /tmp/linux/string.h",
                    "echo '#define EINVAL 22' > /tmp/linux/errno.h",
                    "echo '#define E2BIG 7' >> /tmp/linux/errno.h",
                    "echo 'Creating test file that includes student header...'",
                    "echo '#include \"/lib/modules/strings.h\"' > /tmp/test.c",
                    "echo 'int main() { display_device_info(); update_device_name(\"test\"); format_status_message(\"active\"); validate_string_input(\"input\"); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
                    "echo 'PASS: All function declarations found in header file'",
                    "echo 'Phase 2: Dynamic String Implementation Testing'",
                    "/bin/string_impl_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Dynamic Value Extraction and Validation'",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Extracting random test values from output...'",
                    "TEST1_LINE=$(grep 'Test 1: Device name' /tmp/test_output.log)",
                    "TEST2_LINE=$(grep 'Test 2: Device name' /tmp/test_output.log)",
                    "echo 'Test 1 values: '$TEST1_LINE",
                    "echo 'Test 2 values: '$TEST2_LINE",
                    "echo 'Validating string operation output'",
                    "dmesg | grep 'Secure string handling module loaded' && echo 'PASS: Module loaded correctly' || echo 'FAIL: Module loading issue'",
                    "dmesg | grep 'Device:.*Length:' && echo 'PASS: Device info display working' || echo 'FAIL: Device info display broken'",
                    "dmesg | grep 'Status:' && echo 'PASS: Status message working' || echo 'FAIL: Status message broken'",
                    "dmesg | grep 'Device name updated successfully' && echo 'PASS: String update working' || echo 'FAIL: String update broken'",
                    "echo 'All dynamic string validations completed'"
                ],
                "expected": {
                    "dmesg": [
                        "Secure string handling module loaded",
                        "Device: .* \\(Length: .*\\)",
                        "Status: .*",
                        "Device name updated successfully"
                    ],
                    "stdout": [
                        "PASS: All function declarations found in header file",
                        "SUCCESS: Dynamic string test completed",
                        "PASS: Module loaded correctly",
                        "PASS: Device info display working",
                        "PASS: Status message working",
                        "PASS: String update working"
                    ]
                },
                "timeout": 35
            }
        }
    ]
});


// Problem 80: Simple Driver - File Creation Challenge
generatedTestDefinitions.set(80, {
    "name": "Simple Driver - File Creation Challenge",
    "category": "drivers",
    "description": "Create a simple kernel driver by implementing missing files. You are given a partial driver structure and need to create the missing source and header files to complete the driver implementation.",
    "exactRequirements": {
        "functionNames": [
            "device_init",
            "device_cleanup",
            "simple_driver_init",
            "simple_driver_exit"
        ],
        "variables": [],
        "outputMessages": [
            "simple_driver: loaded successfully",
            "simple_driver: unloaded"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/fs.h",
            "linux/cdev.h"
        ],
        "mustContain": [
            "alloc_chrdev_region",
            "cdev_init",
            "cdev_add",
            "class_create",
            "device_create"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int device_init(struct simple_driver_data *driver_data)",
                "void device_cleanup(struct simple_driver_data *driver_data)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int device_init(struct simple_driver_data *driver_data)",
                "void device_cleanup(struct simple_driver_data *driver_data)",
                "static int __init simple_driver_init(void)",
                "static void __exit simple_driver_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "driver_functionality",
            "name": "Driver Functionality Test",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "device_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <fcntl.h>\\n#include <unistd.h>\\n#include <string.h>\\n\\n#define DEVICE_PATH \"/dev/simpledev\"\\n\\nint main() {\\n    int fd;\\n    char buffer[256];\\n    ssize_t bytes;\\n    \\n    printf(\"=== Simple Driver Test ===\\\\n\");\\n    \\n    fd = open(DEVICE_PATH, O_RDWR);\\n    if (fd < 0) {\\n        printf(\"INFO: Device not found (this is expected in basic test)\\\\n\");\\n        return 0;\\n    }\\n    \\n    printf(\"SUCCESS: Device opened\\\\n\");\\n    \\n    bytes = write(fd, \"test\", 4);\\n    if (bytes > 0) {\\n        printf(\"SUCCESS: Written %zd bytes\\\\n\", bytes);\\n    }\\n    \\n    close(fd);\\n    printf(\"SUCCESS: Driver test completed\\\\n\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Setting up simple driver test'",
                    "mkdir -p /dev"
                ],
                "testCommands": [
                    "echo 'Creating device node...'",
                    "major=$(grep simpledev /proc/devices | cut -d' ' -f1)",
                    "if [ -z \"$major\" ]; then echo 'ERROR: simpledev not found'; exit 1; fi",
                    "mknod /dev/simpledev c $major 0",
                    "chmod 666 /dev/simpledev",
                    "echo 'Running driver test'",
                    "/bin/device_tester",
                    "echo 'Checking driver registration'",
                    "grep simple_driver /proc/modules 2>/dev/null || echo 'Driver loaded successfully'"
                ],
                "expected": {
                    "dmesg": [
                        "simple_driver.*loaded successfully",
                        "simple_driver.*unloaded"
                    ],
                    "stdout": [
                        "Simple Driver Test",
                        "SUCCESS: Driver test completed"
                    ]
                },
                "timeout": 30
            }
        }
    ]
});


module.exports = generatedTestDefinitions;
