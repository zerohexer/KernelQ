// Auto-generated from problems/ directory
// DO NOT EDIT THIS FILE DIRECTLY - Edit problems/*.json instead
// Generated at: 2025-10-23T17:39:12.205Z

const generatedTestDefinitions = new Map();


// Problem 1: Hello World - Your First Kernel Module
generatedTestDefinitions.set(1, {
    "name": "Hello World - Your First Kernel Module",
    "category": "foundations",
    "description": "Welcome to kernel programming! Create your very first kernel module - a simple \"Hello World\" program that runs inside the Linux kernel. This introduction uses just one file to keep things simple and help you understand the basics before moving to more advanced topics.",
    "exactRequirements": {
        "functionNames": [
            "hello_init",
            "hello_exit"
        ],
        "outputMessages": [
            "Hello World from kernel!",
            "Goodbye from kernel!"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "printk",
            "KERN_INFO"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "static int __init hello_init(void)",
                "static void __exit hello_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "kernel_functionality_test",
            "name": "Kernel Module Functionality Test",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "hello_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\\\"=== Hello World Module Test ===\\\\n\\\");\\n    \\n    printf(\\\"Test: Loading hello module...\\\\n\\\");\\n    system(\\\"insmod /lib/modules/hello.ko\\\");\\n    \\n    printf(\\\"Test: Unloading hello module...\\\\n\\\");\\n    system(\\\"rmmod hello\\\");\\n    \\n    printf(\\\"SUCCESS: Module load/unload completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "testCommands": [
                    "echo 'Testing kernel module compilation and basic functionality...'",
                    "/bin/hello_tester",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Checking for kernel logging functionality...'",
                    "dmesg | grep 'Hello World from kernel' && echo 'PASS: init function logging working' || echo 'FAIL: init function logging missing'",
                    "dmesg | grep 'Goodbye from kernel' && echo 'PASS: exit function logging working' || echo 'FAIL: exit function logging missing'",
                    "echo 'PASS: All kernel functionality tests completed'"
                ],
                "expected": {
                    "dmesg": [
                        "Hello World from kernel!",
                        "Goodbye from kernel!"
                    ],
                    "stdout": [
                        "Hello World Module Test",
                        "SUCCESS: Module load/unload completed",
                        "PASS: All kernel functionality tests completed"
                    ]
                },
                "timeout": 10
            }
        },
        {
            "id": "exact_output",
            "name": "Function-Linked Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Hello World from kernel!",
                    "exact": true,
                    "linkedFunction": "static int __init hello_init(void)"
                },
                {
                    "pattern": "Goodbye from kernel!",
                    "exact": true,
                    "linkedFunction": "static void __exit hello_exit(void)"
                }
            ]
        }
    ]
});


// Problem 2: Hello World - Multi-File Kernel Module
generatedTestDefinitions.set(2, {
    "name": "Hello World - Multi-File Kernel Module",
    "category": "foundations",
    "description": "Create your first multi-file kernel module with a separate header file. This introduces you to kernel module structure with proper file organization. Note: Module init/exit functions are static and don't need header declarations.",
    "exactRequirements": {
        "functionNames": [
            "hello_init",
            "hello_exit"
        ],
        "outputMessages": [
            "Hello from multi-file kernel module!",
            "Goodbye from multi-file kernel module!"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "printk",
            "KERN_INFO"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "header_structure",
            "name": "Header File Structure",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "#ifndef HELLO_H",
                "#define HELLO_H",
                "#endif"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [],
            "prohibitedSymbols": [
                "static.*hello_init",
                "static.*hello_exit"
            ]
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "static int __init hello_init(void)",
                "static void __exit hello_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "multifile_functionality_test",
            "name": "Multi-File Module Functionality Test",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "multifile_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\\\"=== Multi-File Module Test ===\\\\n\\\");\\n    \\n    printf(\\\"Test: Loading multi-file hello module...\\\\n\\\");\\n    system(\\\"insmod /lib/modules/hello.ko\\\");\\n    \\n    printf(\\\"Test: Unloading multi-file hello module...\\\\n\\\");\\n    system(\\\"rmmod hello\\\");\\n    \\n    printf(\\\"SUCCESS: Multi-file module load/unload completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "testCommands": [
                    "echo 'Testing multi-file kernel module functionality...'",
                    "/bin/multifile_tester",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Checking for module information and functionality...'",
                    "dmesg | grep 'Hello from multi-file kernel module' && echo 'PASS: init function with proper message' || echo 'FAIL: init function message missing'",
                    "dmesg | grep 'Goodbye from multi-file kernel module' && echo 'PASS: exit function with proper message' || echo 'FAIL: exit function message missing'",
                    "echo 'PASS: All multi-file functionality tests completed'"
                ],
                "expected": {
                    "dmesg": [
                        "Hello from multi-file kernel module!",
                        "Goodbye from multi-file kernel module!"
                    ],
                    "stdout": [
                        "Multi-File Module Test",
                        "SUCCESS: Multi-file module load/unload completed",
                        "PASS: All multi-file functionality tests completed"
                    ]
                },
                "timeout": 10
            }
        },
        {
            "id": "exact_output",
            "name": "Function-Linked Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Hello from multi-file kernel module!",
                    "exact": true,
                    "linkedFunction": "static int __init hello_init(void)"
                },
                {
                    "pattern": "Goodbye from multi-file kernel module!",
                    "exact": true,
                    "linkedFunction": "static void __exit hello_exit(void)"
                }
            ]
        }
    ]
});


// Problem 3: Create Your First Variable
generatedTestDefinitions.set(3, {
    "name": "Create Your First Variable",
    "category": "foundations",
    "description": "Learn to create variables in kernel modules using proper file structure. You'll work with separate header and C files - a fundamental practice in professional kernel development that builds good coding habits from day one.",
    "exactRequirements": {
        "functionNames": [
            "variables_init",
            "variables_exit"
        ],
        "variables": [
            {
                "name": "my_number",
                "type": "int",
                "value": 42,
                "storageClass": "none"
            }
        ],
        "outputMessages": [
            "Variables module loaded"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "#ifndef VARIABLES_H",
            "#define VARIABLES_H",
            "extern int my_number",
            "int my_number = 42",
            "#include \"variables.h\""
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "header_guards",
            "name": "Proper Header Guards",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "#ifndef VARIABLES_H",
                "#define VARIABLES_H",
                "#endif"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "variable_declaration",
            "name": "Variable Declaration in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "extern int my_number"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "variable_definition",
            "name": "Variable Definition in C File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int my_number = 42"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "static int __init variables_init(void)",
                "static void __exit variables_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "variable_functionality_test",
            "name": "Variable Declaration and Definition Test",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "variable_param_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Variable Parameter Validation Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random test values\\n    int test_val1 = (rand() % 50) + 10;  // 10-59\\n    int test_val2 = (rand() % 50) + 60;  // 60-109\\n    \\n    printf(\\\"Test 1: Loading with my_number=%d\\\\n\\\", test_val1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/variables.ko my_number=%d\\\", test_val1);\\n    system(\\\"rmmod variables 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Loading with my_number=%d\\\\n\\\", test_val2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/variables.ko my_number=%d\\\", test_val2);\\n    system(\\\"rmmod variables\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Variable parameter test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo 'Creating test file that validates extern variable declaration...'",
                    "echo '#include \"/lib/modules/variables.h\"' > /tmp/test.c",
                    "echo 'int main() { my_number = 42; return my_number; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: extern int my_number not properly declared in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
                    "echo 'PASS: extern int my_number found in header file'",
                    "echo 'Phase 2: Dynamic Parameter Testing'",
                    "/bin/variable_param_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Phase 2.1: Variable parameter extraction...'",
                    "TEST_VAL1=$(grep -o 'Test 1: Loading with my_number=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
                    "TEST_VAL2=$(grep -o 'Test 2: Loading with my_number=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
                    "echo 'Test value 1: '$TEST_VAL1",
                    "echo 'Test value 2: '$TEST_VAL2",
                    "echo 'Phase 2.2: Module parameter validation...'",
                    "dmesg | grep 'Variables module loaded' && echo 'PASS: Module loads with parameter' || echo 'FAIL: Module loading failed'",
                    "echo 'Phase 3: Default value validation (must be 42)...'",
                    "rmmod variables 2>/dev/null",
                    "insmod /lib/modules/variables.ko",
                    "sleep 1",
                    "DEFAULT_VALUE=$(cat /sys/module/variables/parameters/my_number 2>/dev/null || echo 'ERROR')",
                    "echo 'Default value from parameter: '$DEFAULT_VALUE",
                    "if [ \"$DEFAULT_VALUE\" = \"42\" ]; then",
                    "    echo 'PASS: Variable initialized to 42 correctly'",
                    "else",
                    "    echo 'FAIL: Variable not initialized to 42 (got: '$DEFAULT_VALUE')'",
                    "fi",
                    "echo 'Phase 4: Value reassignment test (ensuring variable is mutable)...'",
                    "echo 99 > /sys/module/variables/parameters/my_number 2>/dev/null",
                    "NEW_VALUE=$(cat /sys/module/variables/parameters/my_number 2>/dev/null || echo 'ERROR')",
                    "echo 'Value after reassignment: '$NEW_VALUE",
                    "if [ \"$NEW_VALUE\" = \"99\" ]; then",
                    "    echo 'PASS: Variable is mutable and reassignable'",
                    "else",
                    "    echo 'FAIL: Variable is not properly mutable (expected 99, got: '$NEW_VALUE')'",
                    "fi",
                    "echo 'Phase 5: Parameter accessibility validation...'",
                    "ls /sys/module/variables/parameters/my_number >/dev/null 2>&1 && echo 'PASS: Variable exposed as module parameter' || echo 'FAIL: Variable not declared as module parameter'",
                    "echo 'PASS: All variable validation tests completed'"
                ],
                "expected": {
                    "dmesg": [
                        "Variables module loaded",
                        "Variables module unloaded"
                    ],
                    "stdout": [
                        "PASS: extern int my_number found in header file",
                        "Variable Parameter Validation Test",
                        "SUCCESS: Variable parameter test completed",
                        "PASS: Variable initialized to 42 correctly",
                        "PASS: Variable is mutable and reassignable",
                        "PASS: All variable validation tests completed"
                    ]
                },
                "timeout": 10
            }
        },
        {
            "id": "exact_output",
            "name": "Exact Output Message",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Variables module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init variables_init(void)"
                }
            ]
        }
    ]
});


// Problem 4: Use Your Variable
generatedTestDefinitions.set(4, {
    "name": "Use Your Variable",
    "category": "foundations",
    "description": "Learn to use variables by printing them with proper format specifiers. Build on your knowledge of header/C file structure while introducing printk formatting - a crucial skill for kernel debugging.",
    "exactRequirements": {
        "functionNames": [
            "use_vars_init",
            "use_vars_exit"
        ],
        "variables": [
            {
                "name": "my_number",
                "type": "int",
                "value": 42,
                "storageClass": "none"
            }
        ],
        "outputMessages": [
            "Variable usage module loaded",
            "My number is: 42"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "printk(KERN_INFO \"My number is: %d\\n\", my_number)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "static int __init use_vars_init(void)",
                "static void __exit use_vars_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "variable_usage_test",
            "name": "Variable Usage and Formatting Test",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "variable_usage_dynamic_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Variable Usage Dynamic Validation Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random test values\\n    int test_val1 = (rand() % 50) + 10;  // 10-59\\n    int test_val2 = (rand() % 50) + 60;  // 60-109\\n    int test_val3 = (rand() % 20) + 1;   // 1-20\\n    \\n    printf(\\\"Test 1: Testing with my_number=%d\\\\n\\\", test_val1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/use_vars.ko my_number=%d\\\", test_val1);\\n    system(\\\"rmmod use_vars 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Testing with my_number=%d\\\\n\\\", test_val2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/use_vars.ko my_number=%d\\\", test_val2);\\n    system(\\\"rmmod use_vars\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"Test 3: Testing with my_number=%d\\\\n\\\", test_val3);\\n    char cmd3[256];\\n    snprintf(cmd3, sizeof(cmd3), \\\"insmod /lib/modules/use_vars.ko my_number=%d\\\", test_val3);\\n    system(\\\"rmmod use_vars\\\");\\n    system(cmd3);\\n    \\n    printf(\\\"SUCCESS: Variable usage dynamic test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo 'Creating test file that validates extern variable declaration...'",
                    "echo '#include \"/lib/modules/use_vars.h\"' > /tmp/test.c",
                    "echo 'int main() { my_number = 99; return my_number; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: extern int my_number not properly declared in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
                    "echo 'PASS: extern int my_number found in header file'",
                    "echo 'Phase 2: Dynamic Variable Usage Testing'",
                    "/bin/variable_usage_dynamic_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Phase 2.1: Dynamic test value extraction...'",
                    "TEST_VAL1=$(grep -o 'Test 1: Testing with my_number=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
                    "TEST_VAL2=$(grep -o 'Test 2: Testing with my_number=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
                    "TEST_VAL3=$(grep -o 'Test 3: Testing with my_number=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
                    "echo 'Test values: '$TEST_VAL1', '$TEST_VAL2', '$TEST_VAL3",
                    "echo 'Phase 2.2: Basic module functionality check...'",
                    "dmesg | grep 'Variable usage module loaded' && echo 'PASS: use_vars_init function working' || echo 'FAIL: use_vars_init function missing'",
                    "echo 'Phase 3: Dynamic variable usage validation...'",
                    "dmesg | grep \"My number is: $TEST_VAL1\" && echo \"PASS: Variable correctly prints value $TEST_VAL1\" || echo \"FAIL: Variable not used or wrong value (expected $TEST_VAL1)\"",
                    "dmesg | grep \"My number is: $TEST_VAL2\" && echo \"PASS: Variable correctly prints value $TEST_VAL2\" || echo \"FAIL: Variable not used or wrong value (expected $TEST_VAL2)\"",
                    "dmesg | grep \"My number is: $TEST_VAL3\" && echo \"PASS: Variable correctly prints value $TEST_VAL3\" || echo \"FAIL: Variable not used or wrong value (expected $TEST_VAL3)\"",
                    "echo 'Phase 4: Default value validation (must be 42)...'",
                    "rmmod use_vars 2>/dev/null",
                    "insmod /lib/modules/use_vars.ko",
                    "sleep 1",
                    "dmesg | grep 'My number is: 42' && echo 'PASS: Default value 42 correctly displayed' || echo 'FAIL: Default value not 42 or not printed'",
                    "echo 'Phase 5: Module unload check...'",
                    "dmesg | grep 'Variable usage module unloaded' && echo 'PASS: use_vars_exit function working' || echo 'FAIL: use_vars_exit function missing'",
                    "echo 'PASS: All variable usage dynamic validation tests completed'"
                ],
                "expected": {
                    "dmesg": [
                        "Variable usage module loaded",
                        "My number is: .*",
                        "Variable usage module unloaded"
                    ],
                    "stdout": [
                        "PASS: extern int my_number found in header file",
                        "Variable Usage Dynamic Validation Test",
                        "SUCCESS: Variable usage dynamic test completed",
                        "PASS: Default value 42 correctly displayed",
                        "PASS: All variable usage dynamic validation tests completed"
                    ]
                },
                "timeout": 10
            }
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Variable usage module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init use_vars_init(void)"
                },
                {
                    "pattern": "My number is: 42",
                    "exact": true,
                    "linkedFunction": "static int __init use_vars_init(void)"
                }
            ]
        }
    ]
});


// Problem 5: Multiple Variables - Study Complete Example
generatedTestDefinitions.set(5, {
    "name": "Multiple Variables - Study Complete Example",
    "category": "foundations",
    "description": "Study a complete working example with multiple data types. See how int, char, and bool variables work together with proper format specifiers. This example includes advanced module parameter support that will be used in later problems.",
    "exactRequirements": {
        "functionNames": [
            "multi_vars_init",
            "multi_vars_exit",
            "print_student_info"
        ],
        "variables": [
            {
                "name": "student_id",
                "type": "int",
                "value": 12345
            },
            {
                "name": "student_grade",
                "type": "char",
                "value": "'A'"
            },
            {
                "name": "student_passed",
                "type": "bool",
                "value": true
            }
        ],
        "outputMessages": [
            "Multi-variable module loaded",
            "Student ID: 12345",
            "Student Grade: A",
            "Student Passed: 1"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "int student_id = 12345",
            "char student_grade = 'A'",
            "bool student_passed = true",
            "void print_student_info(void)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "multiple_definitions",
            "name": "Multiple Variable Definitions",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int student_id = 12345",
                "char student_grade = 'A'",
                "bool student_passed = true"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_structure",
            "name": "Print Function Implementation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_student_info(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_student_info(void)",
                "static int __init multi_vars_init(void)",
                "static void __exit multi_vars_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_student_info(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Basic Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Multi-variable module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init multi_vars_init(void)"
                },
                {
                    "pattern": "Student Information",
                    "exact": true,
                    "linkedFunction": "void print_student_info(void)"
                },
                {
                    "pattern": "Student ID: 12345",
                    "exact": true,
                    "linkedFunction": "void print_student_info(void)"
                },
                {
                    "pattern": "Student Grade: A",
                    "exact": true,
                    "linkedFunction": "void print_student_info(void)"
                },
                {
                    "pattern": "Student Passed: 1",
                    "exact": true,
                    "linkedFunction": "void print_student_info(void)"
                }
            ]
        },
        {
            "id": "demonstration_test",
            "name": "Study Example with Dynamic Testing",
            "type": "kernel_project_test",
            "critical": false,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "demo_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\"=== Part A Demo Test ===\\\\n\");\\n    printf(\"Demonstrating dynamic module parameters\\\\n\");\\n    \\n    printf(\"Test: Loading with student_id=99999\\\\n\");\\n    system(\"rmmod multi_vars 2>/dev/null\");\\n    system(\"insmod /lib/modules/multi_vars.ko student_id=99999\");\\n    \\n    printf(\"SUCCESS: Demo completed\\\\n\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Demonstrating module parameter functionality'"
                ],
                "testCommands": [
                    "/bin/demo_tester",
                    "echo 'Check: Module parameter works'",
                    "dmesg | grep 'Student ID: 99999' && echo 'DEMO: Parameter worked!' || echo 'INFO: Using default value'"
                ],
                "expected": {
                    "dmesg": [
                        "Multi-variable module loaded"
                    ],
                    "stdout": [
                        "Part A Demo Test",
                        "SUCCESS: Demo completed"
                    ]
                },
                "timeout": 30
            }
        }
    ]
});


// Problem 6: Multiple Variables - Guided Practice
generatedTestDefinitions.set(6, {
    "name": "Multiple Variables - Guided Practice",
    "category": "foundations",
    "description": "Build on Problem 4 by completing a partially implemented solution. Fill in strategic gaps while working with module parameters for dynamic testing. This bridges complete examples to independent creation.",
    "exactRequirements": {
        "functionNames": [
            "practice_vars_init",
            "practice_vars_exit",
            "print_employee_info"
        ],
        "variables": [
            {
                "name": "employee_id",
                "type": "int",
                "value": 67890
            },
            {
                "name": "performance_grade",
                "type": "char",
                "value": "'A'"
            },
            {
                "name": "is_promoted",
                "type": "bool",
                "value": true
            }
        ],
        "outputMessages": [
            "Practice variables module loaded",
            "Employee Information",
            "Employee ID: 67890",
            "Grade: A",
            "Promoted: 1"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "int employee_id = 67890",
            "char performance_grade = 'A'",
            "bool is_promoted = true",
            "void print_employee_info(void)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "variable_completion",
            "name": "Variable Value Completion",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int employee_id = 67890",
                "char performance_grade = 'A'",
                "bool is_promoted = true"
            ],
            "prohibitedSymbols": [
                "_____"
            ]
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_employee_info(void)",
                "static int __init practice_vars_init(void)",
                "static void __exit practice_vars_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_employee_info(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Function-Linked Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Practice variables module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init practice_vars_init(void)"
                },
                {
                    "pattern": "Employee Information",
                    "exact": true,
                    "linkedFunction": "void print_employee_info(void)"
                },
                {
                    "pattern": "Employee ID: 67890",
                    "exact": true,
                    "linkedFunction": "void print_employee_info(void)"
                },
                {
                    "pattern": "Grade: A",
                    "exact": true,
                    "linkedFunction": "void print_employee_info(void)"
                },
                {
                    "pattern": "Promoted: 1",
                    "exact": true,
                    "linkedFunction": "void print_employee_info(void)"
                }
            ]
        },
        {
            "id": "guided_dynamic_testing",
            "name": "Guided Dynamic Testing",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "practice_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\"=== Part B Practice Test ===\\\\n\");\\n    printf(\"Testing guided completion with dynamic values\\\\n\");\\n    \\n    printf(\"Test: Loading with employee_id=88888\\\\n\");\\n    system(\"rmmod practice_vars 2>/dev/null\");\\n    system(\"insmod /lib/modules/practice_vars.ko employee_id=88888\");\\n    \\n    printf(\"SUCCESS: Practice test completed\\\\n\");\\n    printf(\"PASS: Variable completion works\\\\n\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting guided practice testing'"
                ],
                "testCommands": [
                    "/bin/practice_tester",
                    "echo 'Checking dynamic value'",
                    "dmesg | grep 'Employee ID: 88888' && echo 'PASS: Dynamic employee_id worked' || echo 'FAIL: Must use variables, not hardcoded values'"
                ],
                "expected": {
                    "dmesg": [
                        "Practice variables module loaded",
                        "Employee ID: 88888"
                    ],
                    "stdout": [
                        "Part B Practice Test",
                        "SUCCESS: Practice test completed",
                        "PASS: Variable completion works"
                    ]
                },
                "timeout": 30
            }
        }
    ]
});


// Problem 7: Multiple Variables - Advanced Dynamic Testing
generatedTestDefinitions.set(7, {
    "name": "Multiple Variables - Advanced Dynamic Testing",
    "category": "foundations",
    "description": "Master advanced variable usage with dynamic testing! Create a complete solution that works with changing values - the system will test your code with different inputs to ensure you're using variables correctly, not hardcoding values.",
    "exactRequirements": {
        "functionNames": [
            "create_vars_init",
            "create_vars_exit",
            "print_server_status"
        ],
        "variables": [
            {
                "name": "server_id",
                "type": "int",
                "value": 1001
            },
            {
                "name": "status_code",
                "type": "char",
                "value": "'R'"
            },
            {
                "name": "temperature",
                "type": "int",
                "value": 68
            },
            {
                "name": "online",
                "type": "bool",
                "value": true
            }
        ],
        "outputMessages": [
            "Variable creation module loaded",
            "Server 1001: Status R, Temp 68, Online: 1"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "int server_id = 1001",
            "char status_code = 'R'",
            "int temperature = 68",
            "bool online = true",
            "void print_server_status(void)",
            "module_param(server_id, int, 0644)",
            "module_param(temperature, int, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "variable_definitions",
            "name": "Variable Definitions in Source",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int server_id = 1001",
                "char status_code = 'R'",
                "int temperature = 68",
                "bool online = true"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "module_parameters",
            "name": "Module Parameter Infrastructure",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "module_param(server_id, int, 0644)",
                "module_param(temperature, int, 0644)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_server_status(void)",
                "static int __init create_vars_init(void)",
                "static void __exit create_vars_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_server_status(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Basic Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Variable creation module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init create_vars_init(void)"
                },
                {
                    "pattern": "Server 1001: Status R, Temp 68, Online: 1",
                    "exact": true,
                    "linkedFunction": "void print_server_status(void)"
                }
            ]
        },
        {
            "id": "dynamic_variable_testing",
            "name": "Dynamic Variable Testing",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "variable_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\"=== Dynamic Variable Test ===\\\\n\");\\n    \\n    printf(\"Test 1: Testing server_id=2001, temperature=85\\\\n\");\\n    system(\"rmmod create_vars 2>/dev/null\");\\n    system(\"insmod /lib/modules/create_vars.ko server_id=2001 temperature=85\");\\n    \\n    printf(\"Test 2: Testing server_id=3001, temperature=92\\\\n\");\\n    system(\"rmmod create_vars\");\\n    system(\"insmod /lib/modules/create_vars.ko server_id=3001 temperature=92\");\\n    \\n    printf(\"SUCCESS: Dynamic test completed\\\\n\");\\n    printf(\"PASS: Variable usage detected\\\\n\");\\n    printf(\"PASS: Module parameters work\\\\n\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting dynamic variable testing'"
                ],
                "testCommands": [
                    "/bin/variable_tester",
                    "echo 'Checking kernel output for dynamic values'",
                    "dmesg | grep 'Server 2001' && echo 'PASS: 2001 test worked' || echo 'FAIL: 2001 test failed'",
                    "dmesg | grep 'Temp 85' && echo 'PASS: 85 test worked' || echo 'FAIL: 85 test failed'",
                    "dmesg | grep 'Server 3001' && echo 'PASS: 3001 test worked' || echo 'FAIL: 3001 test failed'",
                    "dmesg | grep 'Temp 92' && echo 'PASS: 92 test worked' || echo 'FAIL: 92 test failed'"
                ],
                "expected": {
                    "dmesg": [
                        "Variable creation module loaded",
                        "Server 2001: Status R, Temp 85, Online: 1",
                        "Server 3001: Status R, Temp 92, Online: 1"
                    ],
                    "stdout": [
                        "Dynamic Variable Test",
                        "SUCCESS: Dynamic test completed",
                        "PASS: Variable usage detected",
                        "PASS: Module parameters work"
                    ]
                },
                "timeout": 45
            }
        }
    ]
});


// Problem 8: Function Parameters - Advanced Dynamic Testing
generatedTestDefinitions.set(8, {
    "name": "Function Parameters - Advanced Dynamic Testing",
    "category": "foundations",
    "description": "Master function parameters and return values with dynamic testing! Create functions that work with changing input values - the system will test your functions with different parameters to ensure they work correctly, not just with hardcoded values.",
    "exactRequirements": {
        "functionNames": [
            "functions_init",
            "functions_exit",
            "add_numbers",
            "print_calculation",
            "is_even"
        ],
        "variables": [
            {
                "name": "first",
                "type": "int",
                "value": 15
            },
            {
                "name": "second",
                "type": "int",
                "value": 25
            }
        ],
        "outputMessages": [
            "Function parameters module loaded",
            "15 + 25 = 40",
            "Sum is even: 1"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "int add_numbers(int a, int b)",
            "void print_calculation(int num1, int num2, int result)",
            "bool is_even(int number)",
            "return a + b",
            "number % 2 == 0",
            "add_numbers(first, second)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int add_numbers(int a, int b)",
                "void print_calculation(int num1, int num2, int result)",
                "bool is_even(int number)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_implementations",
            "name": "Function Implementations",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "return a + b",
                "return (number % 2 == 0)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_calls",
            "name": "Proper Function Calls",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "add_numbers(first, second)",
                "print_calculation(first, second, sum)",
                "is_even(sum)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "modulo_operator",
            "name": "Modulo Operator Usage",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "number % 2"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "return_values",
            "name": "Proper Return Value Usage",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "sum = add_numbers",
                "even_check = is_even"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int add_numbers(int a, int b)",
                "void print_calculation(int num1, int num2, int result)",
                "bool is_even(int number)",
                "static int __init functions_init(void)",
                "static void __exit functions_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Basic Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Function parameters module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init functions_init(void)"
                },
                {
                    "pattern": "15 + 25 = 40",
                    "exact": true,
                    "linkedFunction": "void print_calculation(int num1, int num2, int result)"
                },
                {
                    "pattern": "Sum is even: 1",
                    "exact": true,
                    "linkedFunction": "static int __init functions_init(void)"
                }
            ]
        },
        {
            "id": "advanced_function_testing",
            "name": "Advanced Function Parameter Testing",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "function_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\"=== Dynamic Function Test ===\\\\n\");\\n    printf(\"Test 1: Testing first=10, second=30 (sum=40, even)\\\\n\");\\n    system(\"rmmod functions 2>/dev/null\");\\n    system(\"insmod /lib/modules/functions.ko first=10 second=30\");\\n    printf(\"Test 2: Testing first=7, second=8 (sum=15, odd)\\\\n\");\\n    system(\"rmmod functions\");\\n    system(\"insmod /lib/modules/functions.ko first=7 second=8\");\\n    printf(\"SUCCESS: Dynamic test completed\\\\n\");\\n    printf(\"PASS: Function parameters detected\\\\n\");\\n    printf(\"PASS: Module parameters work\\\\n\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting comprehensive validation'",
                    "cp /lib/modules/functions.h /lib/modules/ 2>/dev/null"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo 'Creating test file that includes student header...'",
                    "echo '#include \"/lib/modules/functions.h\"' > /tmp/test.c",
                    "echo 'int main() { add_numbers(1,2); print_calculation(1,2,3); is_even(4); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declarations missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
                    "echo 'PASS: All function declarations found in header file'",
                    "echo 'Phase 2: Dynamic Parameter Testing'",
                    "echo 'Marking start of dynamic tests for validation...'",
                    "echo 'DYNAMIC_TEST_START' > /tmp/test_marker",
                    "/bin/function_tester",
                    "echo 'Phase 3: Context-Aware Logic Validation'",
                    "echo 'Validating Test 1: first=10, second=30 (sum=40, should be even)'",
                    "dmesg | grep '10 + 30 = 40' && echo 'PASS: add_numbers(10,30) calculation correct' || { echo 'FAIL: add_numbers(10,30) calculation wrong or missing'; exit 1; }",
                    "dmesg | grep -A1 '10 + 30 = 40' | grep 'Sum is even: 1' && echo 'PASS: is_even(40) correctly identifies even number' || { echo 'FAIL: is_even(40) wrong - should return 1 for even number 40'; exit 1; }",
                    "echo 'Validating Test 2: first=7, second=8 (sum=15, should be odd)'",
                    "dmesg | grep '7 + 8 = 15' && echo 'PASS: add_numbers(7,8) calculation correct' || { echo 'FAIL: add_numbers(7,8) calculation wrong or missing'; exit 1; }",
                    "dmesg | grep -A1 '7 + 8 = 15' | grep 'Sum is even: 0' && echo 'PASS: is_even(15) correctly identifies odd number' || { echo 'FAIL: is_even(15) wrong - should return 0 for odd number 15'; exit 1; }",
                    "echo 'Phase 4: Cross-Validation (ensuring test-specific results are correct)'",
                    "echo 'Checking that 40 (even) produces Sum is even: 1'",
                    "TEST1_CORRECT=$(dmesg | grep -A1 '10 + 30 = 40' | grep -c 'Sum is even: 1')",
                    "echo 'Checking that 15 (odd) produces Sum is even: 0'",
                    "TEST2_CORRECT=$(dmesg | grep -A1 '7 + 8 = 15' | grep -c 'Sum is even: 0')",
                    "echo 'Test 1 correct results: '$TEST1_CORRECT' (expected: 1)'",
                    "echo 'Test 2 correct results: '$TEST2_CORRECT' (expected: 1)'",
                    "if [ $TEST1_CORRECT -eq 1 ] && [ $TEST2_CORRECT -eq 1 ]; then echo 'PASS: Both tests show correct even/odd logic'; else echo 'FAIL: Logic validation failed - Test 1: '$TEST1_CORRECT', Test 2: '$TEST2_CORRECT' (expected 1 each)'; exit 1; fi"
                ],
                "expected": {
                    "dmesg": [
                        "Function parameters module loaded",
                        "10 \\+ 30 = 40",
                        "Sum is even: 1",
                        "7 \\+ 8 = 15",
                        "Sum is even: 0"
                    ],
                    "stdout": [
                        "PASS: All function declarations found in header file",
                        "SUCCESS: Dynamic test completed",
                        "PASS: Both tests show correct even/odd logic"
                    ]
                },
                "timeout": 25
            }
        }
    ]
});


// Problem 9: Conditional Logic - Making Decisions
generatedTestDefinitions.set(9, {
    "name": "Conditional Logic - Making Decisions",
    "category": "foundations",
    "description": "Learn to make decisions in your code using if/else statements and comparison operators. This introduces logical thinking and decision-making patterns essential for kernel development where conditions determine code flow.",
    "exactRequirements": {
        "functionNames": [
            "conditions_init",
            "conditions_exit",
            "check_number_status"
        ],
        "variables": [
            {
                "name": "test_number",
                "type": "int",
                "value": 42
            }
        ],
        "outputMessages": [
            "Conditional logic module loaded",
            "Number 42 is positive",
            "Number -15 is negative",
            "Number 0 is zero"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "int test_number = 42",
            "void check_number_status(int number)",
            "if (number > 0)",
            "else if (number < 0)",
            "else"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void check_number_status(int number)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void check_number_status(int number)",
                "static int __init conditions_init(void)",
                "static void __exit conditions_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Basic Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Conditional logic module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init conditions_init(void)"
                },
                {
                    "pattern": "Number 42 is positive",
                    "exact": true,
                    "linkedFunction": "void check_number_status(int number)"
                },
                {
                    "pattern": "Number -15 is negative",
                    "exact": true,
                    "linkedFunction": "void check_number_status(int number)"
                },
                {
                    "pattern": "Number 0 is zero",
                    "exact": true,
                    "linkedFunction": "void check_number_status(int number)"
                }
            ]
        },
        {
            "id": "advanced_conditional_testing",
            "name": "Advanced Conditional Logic with TCC Header Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "conditional_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\"=== Dynamic Conditional Test ===\\\\n\");\\n    \\n    // Seed random number generator with current time\\n    srand(time(NULL));\\n    \\n    // Generate random test values within -100 to 100\\n    int positive_val = (rand() % 90) + 10;  // 10 to 99\\n    int negative_val = -((rand() % 90) + 10); // -99 to -10\\n    int zero_val = 0;  // Always test zero\\n    \\n    printf(\"Test 1: Testing positive number (%d)\\\\n\", positive_val);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \"insmod /lib/modules/conditions.ko test_number=%d\", positive_val);\\n    system(\"rmmod conditions 2>/dev/null\");\\n    system(cmd1);\\n    \\n    printf(\"Test 2: Testing negative number (%d)\\\\n\", negative_val);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \"insmod /lib/modules/conditions.ko test_number=%d\", negative_val);\\n    system(\"rmmod conditions\");\\n    system(cmd2);\\n    \\n    printf(\"Test 3: Testing zero (%d)\\\\n\", zero_val);\\n    system(\"rmmod conditions\");\\n    system(\"insmod /lib/modules/conditions.ko test_number=0\");\\n    \\n    printf(\"SUCCESS: Dynamic test completed\\\\n\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting comprehensive conditional logic validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo 'Creating test file that includes student header...'",
                    "echo '#include \"/lib/modules/conditions.h\"' > /tmp/test.c",
                    "echo 'int main() { check_number_status(42); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
                    "echo 'PASS: Function declaration found in header file'",
                    "echo 'Phase 2: Dynamic Parameter Testing'",
                    "/bin/conditional_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Dynamic Randomized Conditional Logic Validation'",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Extracting random test values from output...'",
                    "POSITIVE_VAL=$(grep -o 'Testing positive number ([0-9]*)' /tmp/test_output.log | cut -d'(' -f2 | cut -d')' -f1)",
                    "NEGATIVE_VAL=$(grep -o 'Testing negative number (-[0-9]*)' /tmp/test_output.log | cut -d'(' -f2 | cut -d')' -f1)",
                    "echo 'Extracted positive value: '$POSITIVE_VAL",
                    "echo 'Extracted negative value: '$NEGATIVE_VAL",
                    "echo 'Random positive value: '$POSITIVE_VAL",
                    "echo 'Random negative value: '$NEGATIVE_VAL",
                    "echo 'Validating positive number logic with random value '$POSITIVE_VAL",
                    "dmesg | grep \"Number $POSITIVE_VAL is positive\" && echo 'PASS: Positive number logic correct' || echo 'FAIL: Positive number logic wrong'",
                    "echo 'Validating negative number logic with random value '$NEGATIVE_VAL",
                    "dmesg | grep \"Number $NEGATIVE_VAL is negative\" && echo 'PASS: Negative number logic correct' || echo 'FAIL: Negative number logic wrong'",
                    "echo 'Validating zero logic (0 should be zero)'",
                    "dmesg | grep 'Number 0 is zero' && echo 'PASS: Zero logic correct' || echo 'FAIL: Zero logic wrong'",
                    "echo 'All individual validations completed'",
                    "echo 'Phase 4: Dynamic Cross-Validation Consistency Check'",
                    "echo 'Checking that random test values produced correct results'",
                    "TEST_POSITIVE=$(dmesg | grep -c \"Number $POSITIVE_VAL is positive\")",
                    "TEST_NEGATIVE=$(dmesg | grep -c \"Number $NEGATIVE_VAL is negative\")",
                    "TEST_ZERO=$(dmesg | grep -c 'Number 0 is zero')",
                    "echo 'Test positive '$POSITIVE_VAL' results: '$TEST_POSITIVE' (expected: 1)'",
                    "echo 'Test negative '$NEGATIVE_VAL' results: '$TEST_NEGATIVE' (expected: 1)'",
                    "echo 'Test 0 zero results: '$TEST_ZERO' (expected: at least 1)'",
                    "if [ $TEST_POSITIVE -eq 1 ] && [ $TEST_NEGATIVE -eq 1 ] && [ $TEST_ZERO -ge 1 ]; then echo 'PASS: All conditional logic working correctly'; else echo 'FAIL: Conditional logic validation failed - Positive: '$TEST_POSITIVE', Negative: '$TEST_NEGATIVE', Zero: '$TEST_ZERO; fi"
                ],
                "expected": {
                    "dmesg": [
                        "Conditional logic module loaded",
                        "Number .* is positive",
                        "Number .* is negative",
                        "Number 0 is zero"
                    ],
                    "stdout": [
                        "PASS: Function declaration found in header file",
                        "SUCCESS: Dynamic test completed",
                        "PASS: All conditional logic working correctly"
                    ]
                },
                "timeout": 25
            }
        }
    ]
});


// Problem 10: Basic Loops - Study Loop Patterns
generatedTestDefinitions.set(10, {
    "name": "Basic Loops - Study Loop Patterns",
    "category": "foundations",
    "description": "Study complete working examples of for loops and iteration patterns. This demonstrates how loops are used in kernel development for processing data and implementing basic algorithms.",
    "exactRequirements": {
        "functionNames": [
            "loops_init",
            "loops_exit",
            "print_numbers",
            "calculate_sum"
        ],
        "variables": [
            {
                "name": "max_count",
                "type": "int",
                "value": 5
            },
            {
                "name": "sum_result",
                "type": "int",
                "value": 0
            }
        ],
        "outputMessages": [
            "Basic loops module loaded",
            "Count: 1",
            "Count: 2",
            "Count: 3",
            "Count: 4",
            "Count: 5",
            "Sum of 1 to 5 is: 15"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "extern int max_count",
            "extern int sum_result",
            "int max_count = 5",
            "int sum_result = 0",
            "for (i = 1; i <= count; i++)",
            "for (i = 1; i <= n; i++)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_numbers(int count)",
                "int calculate_sum(int n)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_numbers(int count)",
                "int calculate_sum(int n)",
                "static int __init loops_init(void)",
                "static void __exit loops_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Basic Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Basic loops module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init loops_init(void)"
                },
                {
                    "pattern": "Count: 1",
                    "exact": true,
                    "linkedFunction": "void print_numbers(int count)"
                },
                {
                    "pattern": "Count: 2",
                    "exact": true,
                    "linkedFunction": "void print_numbers(int count)"
                },
                {
                    "pattern": "Count: 3",
                    "exact": true,
                    "linkedFunction": "void print_numbers(int count)"
                },
                {
                    "pattern": "Count: 4",
                    "exact": true,
                    "linkedFunction": "void print_numbers(int count)"
                },
                {
                    "pattern": "Count: 5",
                    "exact": true,
                    "linkedFunction": "void print_numbers(int count)"
                },
                {
                    "pattern": "Sum of 1 to 5 is: 15",
                    "exact": true,
                    "linkedFunction": "static int __init loops_init(void)"
                }
            ]
        },
        {
            "id": "advanced_loop_validation",
            "name": "Advanced Loop Pattern Validation with TCC Header Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "loop_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\"=== Loop Pattern Test ===\\\\n\");\\n    printf(\"SUCCESS: Loop test completed\\\\n\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting loop pattern validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo 'Creating test file that includes student header...'",
                    "echo '#include \"/lib/modules/loops.h\"' > /tmp/test.c",
                    "echo 'int main() { print_numbers(5); calculate_sum(5); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
                    "echo 'PASS: All function declarations found in header file'",
                    "echo 'Phase 2: Module Testing'",
                    "/bin/loop_tester"
                ],
                "expected": {
                    "dmesg": [
                        "Basic loops module loaded",
                        "Count: 1",
                        "Count: 2",
                        "Count: 3",
                        "Count: 4",
                        "Count: 5",
                        "Sum of 1 to 5 is: 15"
                    ],
                    "stdout": [
                        "PASS: All function declarations found in header file",
                        "SUCCESS: Loop test completed"
                    ]
                },
                "timeout": 20
            }
        }
    ]
});


// Problem 11: Basic Loops - Implement Loop Solutions
generatedTestDefinitions.set(11, {
    "name": "Basic Loops - Implement Loop Solutions",
    "category": "foundations",
    "description": "Implement your own loop-based solutions for iterative calculations using simple integers. Apply the patterns you studied in Problem 10 to create functions that perform mathematical calculations using loops. This focuses on pure loop logic without arrays.",
    "exactRequirements": {
        "functionNames": [
            "loops_impl_init",
            "loops_impl_exit",
            "print_countdown",
            "calculate_factorial",
            "calculate_power"
        ],
        "variables": [
            {
                "name": "start_number",
                "type": "int",
                "value": 5
            },
            {
                "name": "factorial_number",
                "type": "int",
                "value": 5
            },
            {
                "name": "base_number",
                "type": "int",
                "value": 2
            },
            {
                "name": "power_number",
                "type": "int",
                "value": 3
            }
        ],
        "outputMessages": [
            "Loop implementation module loaded",
            "Countdown from 5:",
            "Count: 5",
            "Count: 4",
            "Count: 3",
            "Count: 2",
            "Count: 1",
            "Factorial of 5: 120",
            "2 to the power of 3: 8"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "extern int start_number",
            "extern int factorial_number",
            "extern int base_number",
            "extern int power_number"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_countdown(int start)",
                "int calculate_factorial(int n)",
                "int calculate_power(int base, int exponent)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_countdown(int start)",
                "int calculate_factorial(int n)",
                "int calculate_power(int base, int exponent)",
                "static int __init loops_impl_init(void)",
                "static void __exit loops_impl_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Basic Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Loop implementation module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init loops_impl_init(void)"
                },
                {
                    "pattern": "Countdown from 5:",
                    "exact": true,
                    "linkedFunction": "static int __init loops_impl_init(void)"
                },
                {
                    "pattern": "Count: 5",
                    "exact": true,
                    "linkedFunction": "void print_countdown(int start)"
                },
                {
                    "pattern": "Count: 4",
                    "exact": true,
                    "linkedFunction": "void print_countdown(int start)"
                },
                {
                    "pattern": "Count: 3",
                    "exact": true,
                    "linkedFunction": "void print_countdown(int start)"
                },
                {
                    "pattern": "Count: 2",
                    "exact": true,
                    "linkedFunction": "void print_countdown(int start)"
                },
                {
                    "pattern": "Count: 1",
                    "exact": true,
                    "linkedFunction": "void print_countdown(int start)"
                },
                {
                    "pattern": "Factorial of 5: 120",
                    "exact": true,
                    "linkedFunction": "static int __init loops_impl_init(void)"
                },
                {
                    "pattern": "2 to the power of 3: 8",
                    "exact": true,
                    "linkedFunction": "static int __init loops_impl_init(void)"
                }
            ]
        },
        {
            "id": "advanced_loop_implementation_validation",
            "name": "Advanced Loop Implementation with TCC Header Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "loop_impl_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\"=== Dynamic Loop Implementation Test ===\\\\n\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random test values\\n    int countdown_start = (rand() % 5) + 3;  // 3 to 7\\n    int factorial_n = (rand() % 5) + 3;      // 3 to 7 for reasonable factorial\\n    int base = (rand() % 3) + 2;             // 2 to 4\\n    int exponent = (rand() % 3) + 2;         // 2 to 4\\n    \\n    printf(\"Test 1: Countdown from %d, factorial of %d\\\\n\", countdown_start, factorial_n);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \"insmod /lib/modules/loops_impl.ko start_number=%d factorial_number=%d\", countdown_start, factorial_n);\\n    system(\"rmmod loops_impl 2>/dev/null\");\\n    system(cmd1);\\n    \\n    printf(\"Test 2: Power calculation %d^%d\\\\n\", base, exponent);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \"insmod /lib/modules/loops_impl.ko base_number=%d power_number=%d\", base, exponent);\\n    system(\"rmmod loops_impl\");\\n    system(cmd2);\\n    \\n    printf(\"SUCCESS: Dynamic loop test completed\\\\n\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting advanced loop implementation validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo 'Creating test file that includes student header...'",
                    "echo '#include \"/lib/modules/loops_impl.h\"' > /tmp/test.c",
                    "echo 'int main() { print_countdown(5); calculate_factorial(5); calculate_power(2, 3); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
                    "echo 'PASS: All function declarations found in header file'",
                    "echo 'Phase 2: Dynamic Implementation Testing'",
                    "/bin/loop_impl_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Dynamic Value Extraction and Validation'",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Extracting random test values from output...'",
                    "COUNTDOWN_START=$(grep -o 'Countdown from [0-9]*' /tmp/test_output.log | head -1 | cut -d' ' -f3 | cut -d',' -f1)",
                    "FACTORIAL_N=$(grep -o 'factorial of [0-9]*' /tmp/test_output.log | head -1 | cut -d' ' -f3)",
                    "BASE_NUM=$(grep -o 'Power calculation [0-9]*' /tmp/test_output.log | cut -d' ' -f3)",
                    "EXPONENT_NUM=$(grep -o '[0-9]*\\^[0-9]*' /tmp/test_output.log | cut -d'^' -f2)",
                    "echo 'Random values: countdown='$COUNTDOWN_START', factorial='$FACTORIAL_N', power='$BASE_NUM'^'$EXPONENT_NUM",
                    "echo 'Validating countdown from '$COUNTDOWN_START",
                    "dmesg | grep \"Countdown from $COUNTDOWN_START:\" && echo 'PASS: Countdown output correct' || echo 'PASS: Countdown working (flexible validation)'",
                    "echo 'Validating factorial calculation for n='$FACTORIAL_N",
                    "dmesg | grep \"Factorial of $FACTORIAL_N:\" && echo 'PASS: Factorial calculation correct' || echo 'PASS: Factorial working (flexible validation)'",
                    "echo 'Validating power calculation '$BASE_NUM'^'$EXPONENT_NUM",
                    "dmesg | grep \"$BASE_NUM to the power of $EXPONENT_NUM:\" && echo 'PASS: Power calculation correct' || echo 'PASS: Power working (flexible validation)'",
                    "echo 'All dynamic validations completed'"
                ],
                "expected": {
                    "dmesg": [
                        "Loop implementation module loaded",
                        "Countdown from .*:",
                        "Count: .*",
                        "Factorial of .* .*",
                        ".* to the power of .* .*"
                    ],
                    "stdout": [
                        "PASS: All function declarations found in header file",
                        "SUCCESS: Dynamic loop test completed",
                        "PASS: Countdown output correct",
                        "PASS: Factorial calculation correct",
                        "PASS: Power calculation correct"
                    ]
                },
                "timeout": 25
            }
        }
    ]
});


// Problem 12: Arrays and Collections - Study Complete Examples
generatedTestDefinitions.set(12, {
    "name": "Arrays and Collections - Study Complete Examples",
    "category": "foundations",
    "description": "Study complete array implementations to understand how to store and manage multiple values. This introduces data collection patterns essential for kernel development where you often need to manage lists of devices, buffers, or other resources. Observe the patterns before implementing them yourself.",
    "exactRequirements": {
        "functionNames": [
            "arrays_study_init",
            "arrays_study_exit",
            "print_all_devices",
            "find_max_device_id",
            "calculate_id_sum",
            "check_device_exists"
        ],
        "variables": [
            {
                "name": "device_ids[]",
                "type": "int",
                "value": "{101, 205, 150, 320, 180, 275}"
            },
            {
                "name": "device_count",
                "type": "int",
                "value": 6
            }
        ],
        "outputMessages": [
            "Arrays study module loaded",
            "Studying array operations with 6 devices",
            "Device listing:",
            "Device 1: ID 101",
            "Device 2: ID 205",
            "Device 3: ID 150",
            "Device 4: ID 320",
            "Device 5: ID 180",
            "Device 6: ID 275",
            "Highest device ID: 320",
            "Total sum of device IDs: 1231",
            "Device 205 found: Yes",
            "Device 999 found: No"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "#define MAX_DEVICES 6",
            "int device_ids[MAX_DEVICES]",
            "module_param_array(device_ids, int, &device_count, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_all_devices(void)",
                "int find_max_device_id(void)",
                "int calculate_id_sum(void)",
                "bool check_device_exists(int)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_all_devices(void)",
                "int find_max_device_id(void)",
                "int calculate_id_sum(void)",
                "bool check_device_exists(int target_id)",
                "static int __init arrays_study_init(void)",
                "static void __exit arrays_study_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Expected Study Output",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Arrays study module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init arrays_study_init(void)"
                },
                {
                    "pattern": "Studying array operations with 6 devices",
                    "exact": true,
                    "linkedFunction": "static int __init arrays_study_init(void)"
                },
                {
                    "pattern": "Device listing:",
                    "exact": true,
                    "linkedFunction": "void print_all_devices(void)"
                },
                {
                    "pattern": "Device 1: ID 101",
                    "exact": true,
                    "linkedFunction": "void print_all_devices(void)"
                },
                {
                    "pattern": "Device 6: ID 275",
                    "exact": true,
                    "linkedFunction": "void print_all_devices(void)"
                },
                {
                    "pattern": "Highest device ID: 320",
                    "exact": true,
                    "linkedFunction": "static int __init arrays_study_init(void)"
                },
                {
                    "pattern": "Total sum of device IDs: 1231",
                    "exact": true,
                    "linkedFunction": "static int __init arrays_study_init(void)"
                },
                {
                    "pattern": "Device 205 found: Yes",
                    "exact": true,
                    "linkedFunction": "static int __init arrays_study_init(void)"
                },
                {
                    "pattern": "Device 999 found: No",
                    "exact": true,
                    "linkedFunction": "static int __init arrays_study_init(void)"
                }
            ]
        }
    ]
});


// Problem 13: Arrays and Collections - Implement Solutions
generatedTestDefinitions.set(13, {
    "name": "Arrays and Collections - Implement Solutions",
    "category": "foundations",
    "description": "Implement your own array-based solutions for managing multiple values. Apply the patterns you studied in Problem 11 to create functions that process arrays, find maximum values, and calculate statistics. This builds on the complete examples you observed.",
    "exactRequirements": {
        "functionNames": [
            "arrays_init",
            "arrays_exit",
            "print_all_grades",
            "find_highest_grade",
            "calculate_average"
        ],
        "variables": [
            {
                "name": "student_grades[MAX_GRADES]",
                "type": "int",
                "value": "{85, 92, 78, 96, 88}"
            },
            {
                "name": "grade_count",
                "type": "int",
                "value": 5
            }
        ],
        "outputMessages": [
            "Arrays module loaded",
            "Student grades:",
            "Grade 1: 85",
            "Grade 2: 92",
            "Grade 3: 78",
            "Grade 4: 96",
            "Grade 5: 88",
            "Highest grade: 96",
            "Average grade: 87"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "#define MAX_GRADES 5",
            "extern int student_grades[MAX_GRADES]",
            "extern int grade_count",
            "int student_grades[MAX_GRADES] = {85, 92, 78, 96, 88}",
            "int grade_count = MAX_GRADES"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_all_grades(void)",
                "int find_highest_grade(void)",
                "int calculate_average(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_all_grades(void)",
                "int find_highest_grade(void)",
                "int calculate_average(void)",
                "static int __init arrays_init(void)",
                "static void __exit arrays_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Basic Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Arrays module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init arrays_init(void)"
                },
                {
                    "pattern": "Student grades:",
                    "exact": true,
                    "linkedFunction": "void print_all_grades(void)"
                },
                {
                    "pattern": "Grade 1: 85",
                    "exact": true,
                    "linkedFunction": "void print_all_grades(void)"
                },
                {
                    "pattern": "Grade 2: 92",
                    "exact": true,
                    "linkedFunction": "void print_all_grades(void)"
                },
                {
                    "pattern": "Grade 3: 78",
                    "exact": true,
                    "linkedFunction": "void print_all_grades(void)"
                },
                {
                    "pattern": "Grade 4: 96",
                    "exact": true,
                    "linkedFunction": "void print_all_grades(void)"
                },
                {
                    "pattern": "Grade 5: 88",
                    "exact": true,
                    "linkedFunction": "void print_all_grades(void)"
                },
                {
                    "pattern": "Highest grade: 96",
                    "exact": true,
                    "linkedFunction": "static int __init arrays_init(void)"
                },
                {
                    "pattern": "Average grade: 87",
                    "exact": true,
                    "linkedFunction": "static int __init arrays_init(void)"
                }
            ]
        },
        {
            "id": "advanced_array_implementation_validation",
            "name": "Advanced Array Implementation with TCC Header Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "array_impl_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\"=== Dynamic Array Implementation Test ===\\\\n\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random test arrays\\n    int grades1[3] = {(rand() % 40) + 60, (rand() % 40) + 60, (rand() % 40) + 60};  // 60-99 range\\n    int grades2[4] = {(rand() % 30) + 70, (rand() % 30) + 70, (rand() % 30) + 70, (rand() % 30) + 70};  // 70-99 range\\n    \\n    printf(\"Test 1: Array with %d,%d,%d\\\\n\", grades1[0], grades1[1], grades1[2]);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \"insmod /lib/modules/arrays.ko student_grades=%d,%d,%d\", grades1[0], grades1[1], grades1[2]);\\n    system(\"rmmod arrays 2>/dev/null\");\\n    system(cmd1);\\n    \\n    printf(\"Test 2: Array with %d,%d,%d,%d\\\\n\", grades2[0], grades2[1], grades2[2], grades2[3]);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \"insmod /lib/modules/arrays.ko student_grades=%d,%d,%d,%d\", grades2[0], grades2[1], grades2[2], grades2[3]);\\n    system(\"rmmod arrays\");\\n    system(cmd2);\\n    \\n    printf(\"SUCCESS: Dynamic array test completed\\\\n\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting advanced array implementation validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param_array(name, type, nump, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo '#define true 1' >> /tmp/linux/types.h",
                    "echo '#define false 0' >> /tmp/linux/types.h",
                    "echo 'Creating test file that includes student header...'",
                    "echo '#include \"/lib/modules/arrays.h\"' > /tmp/test.c",
                    "echo 'int main() { print_all_grades(); find_highest_grade(); calculate_average(); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
                    "echo 'PASS: All function declarations found in header file'",
                    "echo 'Phase 2: Dynamic Array Implementation Testing'",
                    "/bin/array_impl_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Dynamic Value Extraction and Validation'",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Extracting random test values from output...'",
                    "TEST1_LINE=$(grep 'Test 1: Array with' /tmp/test_output.log)",
                    "TEST2_LINE=$(grep 'Test 2: Array with' /tmp/test_output.log)",
                    "echo 'Test 1 values: '$TEST1_LINE",
                    "echo 'Test 2 values: '$TEST2_LINE",
                    "echo 'Validating array processing output'",
                    "dmesg | grep 'Student grades:' && echo 'PASS: Array output found' || echo 'FAIL: Array output missing'",
                    "dmesg | grep 'Grade.*:.*[0-9]' && echo 'PASS: Grade enumeration working' || echo 'FAIL: Grade enumeration broken'",
                    "dmesg | grep 'Highest grade:.*[0-9]' && echo 'PASS: Maximum finding working' || echo 'FAIL: Maximum finding broken'",
                    "dmesg | grep 'Average grade:.*[0-9]' && echo 'PASS: Average calculation working' || echo 'FAIL: Average calculation broken'",
                    "echo 'All dynamic validations completed'"
                ],
                "expected": {
                    "dmesg": [
                        "Arrays module loaded",
                        "Student grades:",
                        "Grade .* .*",
                        "Highest grade: .*",
                        "Average grade: .*"
                    ],
                    "stdout": [
                        "PASS: All function declarations found in header file",
                        "SUCCESS: Dynamic array test completed",
                        "PASS: Array output found",
                        "PASS: Grade enumeration working",
                        "PASS: Maximum finding working",
                        "PASS: Average calculation working"
                    ]
                },
                "timeout": 30
            }
        }
    ]
});


// Problem 14: String Basics - Arrays of Characters
generatedTestDefinitions.set(14, {
    "name": "String Basics - Arrays of Characters",
    "category": "foundations",
    "description": "Learn that strings are just arrays of characters! This builds directly on the arrays problem - instead of int arrays, we use char arrays. No pointers, no parameters, just simple array indexing like device_name[0], device_name[1], etc.",
    "exactRequirements": {
        "functionNames": [
            "strings_init",
            "strings_exit",
            "show_device_info",
            "count_device_name_length",
            "update_to_new_device"
        ],
        "variables": [
            {
                "name": "device_name[]",
                "type": "char",
                "value": "\"my_device\""
            },
            {
                "name": "welcome_msg[]",
                "type": "char",
                "value": "\"Hello from kernel!\""
            },
            {
                "name": "name_len",
                "type": "int",
                "value": " 0"
            }
        ],
        "outputMessages": [
            "String basics module loaded",
            "Device: my_device, Length: 9",
            "Message: Hello from kernel!",
            "After name change:",
            "Device: new_device, Length: 10"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/string.h"
        ],
        "mustContain": [
            "#define MAX_NAME_SIZE 32",
            "#define MAX_MESSAGE_SIZE 64",
            "char device_name[MAX_NAME_SIZE]",
            "char welcome_msg[MAX_MESSAGE_SIZE]"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header (No Pointers)",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void show_device_info(void)",
                "void count_device_name_length(void)",
                "void update_to_new_device(void)"
            ],
            "prohibitedSymbols": [
                "const char \\*",
                "char \\*"
            ]
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File (No Pointers)",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void show_device_info(void)",
                "void count_device_name_length(void)",
                "void update_to_new_device(void)",
                "static int __init strings_init(void)",
                "static void __exit strings_exit(void)"
            ],
            "prohibitedSymbols": [
                "const char \\*",
                "char \\*"
            ]
        },
        {
            "id": "exact_output",
            "name": "Expected Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "String basics module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init strings_init(void)"
                },
                {
                    "pattern": "Device: my_device, Length: 9",
                    "exact": true,
                    "linkedFunction": "void show_device_info(void)"
                },
                {
                    "pattern": "Message: Hello from kernel!",
                    "exact": true,
                    "linkedFunction": "static int __init strings_init(void)"
                },
                {
                    "pattern": "After name change:",
                    "exact": true,
                    "linkedFunction": "static int __init strings_init(void)"
                },
                {
                    "pattern": "Device: new_device, Length: 10",
                    "exact": true,
                    "linkedFunction": "void show_device_info(void)"
                }
            ]
        },
        {
            "id": "basic_string_implementation_validation",
            "name": "Basic String Implementation with TCC Header Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "string_dynamic_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\"=== Dynamic String Implementation Test ===\\\\n\");\\n    \\n    // Generate randomized test cases\\n    const char* device_names[] = {\\\"sensor\\\", \\\"device\\\", \\\"module\\\", \\\"driver\\\", \\\"kernel\\\", \\\"system\\\"};\\n    const char* messages[] = {\\\"Hello\\\", \\\"Greetings\\\", \\\"Welcome\\\", \\\"Status\\\", \\\"Testing\\\", \\\"Active\\\"};\\n    \\n    srand(time(NULL));\\n    int name_idx = rand() % 6;\\n    int msg_idx = rand() % 6;\\n    \\n    printf(\\\"Test 1: Testing with device_name='%s' and welcome_msg='%s'\\\\n\\\", device_names[name_idx], messages[msg_idx]);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/strings.ko device_name=%s welcome_msg=%s\\\", device_names[name_idx], messages[msg_idx]);\\n    system(\\\"rmmod strings 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    // Generate second test with different values\\n    int name_idx2 = (name_idx + 2) % 6;\\n    int msg_idx2 = (msg_idx + 3) % 6;\\n    \\n    printf(\\\"Test 2: Testing with device_name='%s' and welcome_msg='%s'\\\\n\\\", device_names[name_idx2], messages[msg_idx2]);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/strings.ko device_name=%s welcome_msg=%s\\\", device_names[name_idx2], messages[msg_idx2]);\\n    system(\\\"rmmod strings\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Dynamic string test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting basic string implementation validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param_string(name, string, len, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef unsigned long size_t;' > /tmp/linux/string.h",
                    "echo 'size_t strlen(const char *s);' >> /tmp/linux/string.h",
                    "echo 'Creating test file that includes student header...'",
                    "echo '#include \"/lib/modules/strings.h\"' > /tmp/test.c",
                    "echo 'int main() { show_device_info(); count_device_name_length(); update_to_new_device(); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
                    "echo 'PASS: All function declarations found in header file'",
                    "echo 'Phase 2: Dynamic String Implementation Testing'",
                    "/bin/string_dynamic_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Dynamic Value Extraction and Validation'",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Extracting random test values from output...'",
                    "TEST1_DEVICE=$(grep -o \"Test 1: Testing with device_name='[^']*'\" /tmp/test_output.log | cut -d\"'\" -f2)",
                    "TEST1_MESSAGE=$(grep -o \"Test 1: Testing with device_name='[^']*' and welcome_msg='[^']*'\" /tmp/test_output.log | cut -d\"'\" -f4)",
                    "TEST2_DEVICE=$(grep -o \"Test 2: Testing with device_name='[^']*'\" /tmp/test_output.log | cut -d\"'\" -f2)",
                    "TEST2_MESSAGE=$(grep -o \"Test 2: Testing with device_name='[^']*' and welcome_msg='[^']*'\" /tmp/test_output.log | cut -d\"'\" -f4)",
                    "echo \"Test 1 device: '$TEST1_DEVICE', message: '$TEST1_MESSAGE'\"",
                    "echo \"Test 2 device: '$TEST2_DEVICE', message: '$TEST2_MESSAGE'\"",
                    "echo 'Calculating expected string lengths...'",
                    "TEST1_EXPECTED_LEN=$(echo -n \"$TEST1_DEVICE\" | awk '{print length}')",
                    "TEST2_EXPECTED_LEN=$(echo -n \"$TEST2_DEVICE\" | awk '{print length}')",
                    "echo \"Expected: $TEST1_DEVICE = $TEST1_EXPECTED_LEN chars, $TEST2_DEVICE = $TEST2_EXPECTED_LEN chars\"",
                    "echo 'Validating Test 1 string operations'",
                    "dmesg | grep \"Device: $TEST1_DEVICE, Length: $TEST1_EXPECTED_LEN\" && echo 'PASS: Test 1 device name and length correct' || echo \"FAIL: Test 1 length wrong - expected $TEST1_EXPECTED_LEN for '$TEST1_DEVICE'\"",
                    "dmesg | grep \"Message: $TEST1_MESSAGE\" && echo 'PASS: Test 1 message correct' || echo 'FAIL: Test 1 message wrong'",
                    "echo 'Validating Test 2 string operations'",
                    "dmesg | grep \"Device: $TEST2_DEVICE, Length: $TEST2_EXPECTED_LEN\" && echo 'PASS: Test 2 device name and length correct' || echo \"FAIL: Test 2 length wrong - expected $TEST2_EXPECTED_LEN for '$TEST2_DEVICE'\"",
                    "dmesg | grep \"Message: $TEST2_MESSAGE\" && echo 'PASS: Test 2 message correct' || echo 'FAIL: Test 2 message wrong'",
                    "echo 'Validating function behavior (new_device length should be 10)'",
                    "dmesg | grep 'Device: new_device, Length: 10' && echo 'PASS: new_device length calculation correct' || echo 'FAIL: new_device length wrong - expected 10'",
                    "dmesg | grep 'After name change:' && echo 'PASS: Name change function working' || echo 'FAIL: Name change function broken'",
                    "echo 'All dynamic string validations completed'"
                ],
                "expected": {
                    "dmesg": [
                        "String basics module loaded",
                        "Device: .* Length: .*",
                        "Message: .*",
                        "After name change:",
                        "Device: .* Length: .*"
                    ],
                    "stdout": [
                        "PASS: All function declarations found in header file",
                        "SUCCESS: Dynamic string test completed",
                        "PASS: Test 1 device name and length correct",
                        "PASS: Test 1 message correct",
                        "PASS: Test 2 device name and length correct",
                        "PASS: Test 2 message correct",
                        "PASS: new_device length calculation correct",
                        "PASS: Name change function working"
                    ]
                },
                "timeout": 30
            }
        }
    ]
});


// Problem 15: Basic Pointers - Introduction to Memory Addresses
generatedTestDefinitions.set(15, {
    "name": "Basic Pointers - Introduction to Memory Addresses",
    "category": "foundations",
    "description": "Learn the fundamental concepts of pointers in C. Understand what pointers are, how to declare them, use the address-of operator (&), dereference operator (*), and perform basic operations with integers and arrays through pointers.",
    "exactRequirements": {
        "functionNames": [
            "basic_pointers_init",
            "basic_pointers_exit",
            "print_number_info",
            "modify_through_pointer",
            "print_array_through_pointer"
        ],
        "variables": [
            {
                "name": "number",
                "type": "int",
                "value": "42",
                "storageClass": "none"
            },
            {
                "name": "array",
                "type": "int",
                "value": "{10, 20, 30, 40, 50}",
                "storageClass": "none"
            },
            {
                "name": "number_ptr",
                "type": "int *",
                "value": "NULL",
                "storageClass": "none"
            },
            {
                "name": "array_ptr",
                "type": "int *",
                "value": "NULL",
                "storageClass": "none"
            }
        ],
        "outputMessages": [
            "Basic pointers module loaded",
            "=== Basic Pointer Demonstration ===",
            "Number value: 42",
            "Number address: (____ptrval____)",
            "Pointer value (address it points to): (____ptrval____)",
            "Value through pointer: 42",
            "Modified value through pointer to: 999",
            "Array elements through pointer:",
            "Array element 0: 10",
            "Array element 1: 20",
            "Array element 2: 30",
            "Final number value: 999",
            "Basic pointers module unloaded"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "&number",
            "*number_ptr",
            "number_ptr = &number",
            "array_ptr = array",
            "*(ptr + 1)",
            "*(ptr + 2)",
            "*ptr = new_value",
            "module_param(test_value, int, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_number_info(void)",
                "void modify_through_pointer(int *ptr, int new_value)",
                "void print_array_through_pointer(int *ptr)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_number_info(void)",
                "void modify_through_pointer(int *ptr, int new_value)",
                "void print_array_through_pointer(int *ptr)",
                "static int __init basic_pointers_init(void)",
                "static void __exit basic_pointers_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Basic pointers module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init basic_pointers_init(void)"
                },
                {
                    "pattern": "=== Basic Pointer Demonstration ===",
                    "exact": true,
                    "linkedFunction": "static int __init basic_pointers_init(void)"
                },
                {
                    "pattern": "Number value: 42",
                    "exact": true,
                    "linkedFunction": "void print_number_info(void)"
                },
                {
                    "pattern": "Number address: (____ptrval____)",
                    "exact": true,
                    "linkedFunction": "void print_number_info(void)"
                },
                {
                    "pattern": "Pointer value (address it points to): (____ptrval____)",
                    "exact": true,
                    "linkedFunction": "void print_number_info(void)"
                },
                {
                    "pattern": "Value through pointer: 42",
                    "exact": true,
                    "linkedFunction": "void print_number_info(void)"
                },
                {
                    "pattern": "Modified value through pointer to: 999",
                    "exact": true,
                    "linkedFunction": "void modify_through_pointer(int *ptr, int new_value)"
                },
                {
                    "pattern": "Array elements through pointer:",
                    "exact": true,
                    "linkedFunction": "static int __init basic_pointers_init(void)"
                },
                {
                    "pattern": "Array element 0: 10",
                    "exact": true,
                    "linkedFunction": "void print_array_through_pointer(int *ptr)"
                },
                {
                    "pattern": "Array element 1: 20",
                    "exact": true,
                    "linkedFunction": "void print_array_through_pointer(int *ptr)"
                },
                {
                    "pattern": "Array element 2: 30",
                    "exact": true,
                    "linkedFunction": "void print_array_through_pointer(int *ptr)"
                },
                {
                    "pattern": "Final number value: 999",
                    "exact": true,
                    "linkedFunction": "static int __init basic_pointers_init(void)"
                },
                {
                    "pattern": "Basic pointers module unloaded",
                    "exact": true,
                    "linkedFunction": "static void __exit basic_pointers_exit(void)"
                }
            ]
        },
        {
            "id": "basic_pointer_validation",
            "name": "Basic Pointer Operations with Anti-Hardcoding Protection",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "basic_pointer_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Basic Pointer Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate unpredictable test values\\n    int random_value = (rand() % 900) + 100;  // 100-999\\n    \\n    printf(\\\"Test 1: Random pointer operations (value=%d)\\\\n\\\", random_value);\\n    \\n    // Test with random values\\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod basic_pointers 2>/dev/null\\\");\\n    \\n    char cmd[256];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/basic_pointers.ko test_value=%d\\\", random_value);\\n    printf(\\\"DEBUG: Command: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Anti-hardcoding basic pointer test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting basic pointer implementation validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef unsigned char uint8_t;' > /tmp/linux/types.h",
                    "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
                    "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
                    "echo 'Creating test file that includes basic pointers header...'",
                    "echo '#include \"/lib/modules/basic_pointers.h\"' > /tmp/test.c",
                    "echo 'int main() { number = 123; print_number_info(); modify_through_pointer(&number, 456); print_array_through_pointer(array); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
                    "echo 'Phase 2: Anti-Hardcoding Dynamic Basic Pointer Test'",
                    "/bin/basic_pointer_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Random Value Extraction and Validation'",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Extracting random test values from output...'",
                    "TEST_VALUE=$(grep -o 'Random pointer operations (value=[0-9]*)' /tmp/test_output.log | cut -d'=' -f2 | cut -d')' -f1)",
                    "echo 'Extracted values: TEST_VALUE='$TEST_VALUE",
                    "if [ -z \"$TEST_VALUE\" ]; then echo 'FAIL: Could not extract random test values'; else echo 'PASS: Random values extracted successfully'; fi",
                    "echo 'Phase 4: Anti-Hardcoding Validation with Random Values'",
                    "echo 'Validating basic pointer operations with random value '$TEST_VALUE",
                    "dmesg | grep \"Number value: $TEST_VALUE\" && echo 'PASS: Basic pointer dereference with random value working' || echo 'FAIL: Basic pointer dereference with random value broken'",
                    "echo 'Phase 5: Static Field Validation (Non-Randomized Fields)'",
                    "dmesg | grep 'Modified value through pointer to: 999' && echo 'PASS: Pointer modification working' || echo 'FAIL: Pointer modification broken'",
                    "dmesg | grep 'Array element 0: 10' && echo 'PASS: Array pointer access working' || echo 'FAIL: Array pointer access broken'",
                    "dmesg | grep 'Array element 1: 20' && echo 'PASS: Pointer arithmetic working' || echo 'FAIL: Pointer arithmetic broken'",
                    "dmesg | grep 'Final number value: 999' && echo 'PASS: Pointer modification persistent' || echo 'FAIL: Pointer modification not persistent'",
                    "echo 'Phase 6: Basic Pointer Logic Validation'",
                    "dmesg | grep '=== Basic Pointer Demonstration ===' && echo 'PASS: Module demonstration working' || echo 'FAIL: Module demonstration broken'",
                    "dmesg | grep 'Basic pointers module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
                    "dmesg | grep 'Basic pointers module unloaded' && echo 'PASS: Module cleanup working' || echo 'FAIL: Module cleanup broken'",
                    "echo 'Phase 7: Final Validation Summary'",
                    "echo 'All phases completed successfully - anti-hardcoding basic pointer protection verified'",
                    "echo 'PASS: All anti-hardcoding basic pointer validation successful'"
                ],
                "expected": {
                    "dmesg": [
                        "Basic pointers module loaded",
                        "=== Basic Pointer Demonstration ===",
                        "Number value: .*",
                        "Modified value through pointer to: 999",
                        "Array elements through pointer:",
                        "Array element 0: 10",
                        "Array element 1: 20",
                        "Array element 2: 30",
                        "Final number value: 999",
                        "Basic pointers module unloaded"
                    ],
                    "stdout": [
                        "PASS: All function and variable declarations found in header file",
                        "SUCCESS: Anti-hardcoding basic pointer test completed",
                        "PASS: Random values extracted successfully",
                        "PASS: Basic pointer dereference with random value working",
                        "PASS: Pointer modification working",
                        "PASS: Array pointer access working",
                        "PASS: Pointer arithmetic working",
                        "PASS: Pointer modification persistent",
                        "PASS: Module demonstration working",
                        "PASS: Module initialization working",
                        "PASS: Module cleanup working",
                        "PASS: All anti-hardcoding basic pointer validation successful"
                    ]
                },
                "timeout": 15
            }
        }
    ]
});


// Problem 16: Basic Structures - Organizing Related Data
generatedTestDefinitions.set(16, {
    "name": "Basic Structures - Organizing Related Data",
    "category": "foundations",
    "description": "Learn to create and use basic structures to organize related data together. This introduces simple data modeling patterns essential for kernel development where structures represent system information.",
    "exactRequirements": {
        "functionNames": [
            "structures_init",
            "structures_exit",
            "print_student_info",
            "check_student_status"
        ],
        "variables": [
            {
                "name": "my_student",
                "type": "struct student",
                "value": "{.id = 12345, .name = \"Alice Smith\", .grade = 85, .passed = true}",
                "storageClass": "none"
            }
        ],
        "outputMessages": [
            "Basic structures module loaded",
            "Student ID: 12345",
            "Student Name: Alice Smith",
            "Student Grade: 85",
            "Student Status: Passed"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "struct student {",
            "extern struct student my_student",
            "struct student my_student = {",
            ".id = 12345",
            ".name = \"Alice Smith\"",
            ".grade = 85",
            ".passed = true",
            "module_param_named(student_id, my_student.id, int, 0644)",
            "module_param_named(student_grade, my_student.grade, int, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_student_info(void)",
                "void check_student_status(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_student_info(void)",
                "void check_student_status(void)",
                "static int __init structures_init(void)",
                "static void __exit structures_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Basic structures module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init structures_init(void)"
                },
                {
                    "pattern": "Student ID: 12345",
                    "exact": true,
                    "linkedFunction": "void print_student_info(void)"
                },
                {
                    "pattern": "Student Name: Alice Smith",
                    "exact": true,
                    "linkedFunction": "void print_student_info(void)"
                },
                {
                    "pattern": "Student Grade: 85",
                    "exact": true,
                    "linkedFunction": "void print_student_info(void)"
                },
                {
                    "pattern": "Student Status: Passed",
                    "exact": true,
                    "linkedFunction": "void check_student_status(void)"
                }
            ]
        },
        {
            "id": "advanced_structure_implementation_validation",
            "name": "Advanced Structure Implementation with TCC Header Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "structure_impl_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Structure Implementation Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random student data\\n    int test_id1 = (rand() % 9000) + 10000;  // 10000-18999\\n    int test_grade1 = (rand() % 20) + 80;    // 80-99\\n    int test_id2 = (rand() % 9000) + 20000;  // 20000-28999\\n    int test_grade2 = (rand() % 30) + 60;    // 60-89\\n    \\n    printf(\\\"Test 1: Testing with student_id=%d, student_grade=%d\\\\n\\\", test_id1, test_grade1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/structures.ko student_id=%d student_grade=%d\\\", test_id1, test_grade1);\\n    system(\\\"rmmod structures 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Testing with student_id=%d, student_grade=%d\\\\n\\\", test_id2, test_grade2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/structures.ko student_id=%d student_grade=%d\\\", test_id2, test_grade2);\\n    system(\\\"rmmod structures\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Dynamic structure test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting advanced structure implementation validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param_named(name, var, type, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo '#define true 1' >> /tmp/linux/types.h",
                    "echo '#define false 0' >> /tmp/linux/types.h",
                    "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
                    "echo 'Creating test file that includes student header...'",
                    "echo '#include \"/lib/modules/structures.h\"' > /tmp/test.c",
                    "echo 'int main() { my_student.id = 999; print_student_info(); check_student_status(); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
                    "echo 'Phase 2: Dynamic Structure Implementation Testing'",
                    "/bin/structure_impl_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Dynamic Value Extraction and Validation'",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Extracting random test values from output...'",
                    "TEST1_ID=$(grep -o 'Test 1: Testing with student_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
                    "TEST1_GRADE=$(grep -o 'student_grade=[0-9]*' /tmp/test_output.log | head -1 | cut -d'=' -f2)",
                    "TEST2_ID=$(grep -o 'Test 2: Testing with student_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
                    "TEST2_GRADE=$(grep -o 'student_grade=[0-9]*' /tmp/test_output.log | tail -1 | cut -d'=' -f2)",
                    "echo 'Test values: ID1='$TEST1_ID', Grade1='$TEST1_GRADE', ID2='$TEST2_ID', Grade2='$TEST2_GRADE",
                    "echo 'Validating structure member access with dynamic values'",
                    "dmesg | grep 'Student ID: '$TEST1_ID && echo 'PASS: Structure id member access working with '$TEST1_ID || echo 'FAIL: Structure id member access broken for '$TEST1_ID",
                    "dmesg | grep 'Student Name: Alice Smith' && echo 'PASS: Structure name member access working' || echo 'FAIL: Structure name member access broken'",
                    "dmesg | grep 'Student Grade: '$TEST1_GRADE && echo 'PASS: Structure grade member access working with '$TEST1_GRADE || echo 'FAIL: Structure grade member access broken for '$TEST1_GRADE",
                    "dmesg | grep 'Student ID: '$TEST2_ID && echo 'PASS: Structure id member access working with '$TEST2_ID || echo 'FAIL: Structure id member access broken for '$TEST2_ID",
                    "dmesg | grep 'Student Grade: '$TEST2_GRADE && echo 'PASS: Structure grade member access working with '$TEST2_GRADE || echo 'FAIL: Structure grade member access broken for '$TEST2_GRADE",
                    "dmesg | grep 'Student Status: Passed' && echo 'PASS: Structure passed member conditional logic working' || echo 'FAIL: Structure passed member conditional logic broken'",
                    "echo 'Phase 4: Structure Definition Validation'",
                    "dmesg | grep 'Basic structures module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
                    "echo 'All structure implementation validations completed'"
                ],
                "expected": {
                    "dmesg": [
                        "Basic structures module loaded",
                        "Student ID: .*",
                        "Student Name: Alice Smith",
                        "Student Grade: .*",
                        "Student Status: Passed"
                    ],
                    "stdout": [
                        "PASS: All function and variable declarations found in header file",
                        "SUCCESS: Dynamic structure test completed",
                        "PASS: Structure id member access working with .*",
                        "PASS: Structure name member access working",
                        "PASS: Structure grade member access working with .*",
                        "PASS: Structure passed member conditional logic working"
                    ]
                },
                "timeout": 30
            }
        }
    ]
});


// Problem 17: Structure Pointers - Advanced Data Manipulation
generatedTestDefinitions.set(17, {
    "name": "Structure Pointers - Advanced Data Manipulation",
    "category": "foundations",
    "description": "Learn essential pointer concepts by working with pointers to structures. Focus on arrow operator (->), address-of operator (&), and passing structures to functions by reference.",
    "exactRequirements": {
        "functionNames": [
            "struct_pointers_init",
            "struct_pointers_exit",
            "print_device_info",
            "update_device_count",
            "activate_device"
        ],
        "variables": [
            {
                "name": "my_device",
                "type": "struct device_info",
                "value": "{.device_name = \"sensor01\", .device_id = 1001, .is_active = false, .data_count = 0}",
                "storageClass": "none"
            }
        ],
        "outputMessages": [
            "Structure pointers module loaded",
            "Initial Device Information:",
            "Device Name: sensor01",
            "Device ID: 1001",
            "Device Active: 0",
            "Data Count: 0",
            "Device sensor01 count updated to: 5",
            "Device sensor01 activated",
            "Final Device Information:",
            "Device Name: sensor01",
            "Device ID: 1001",
            "Device Active: 1",
            "Data Count: 5"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "struct device_info {",
            "extern struct device_info my_device",
            "struct device_info my_device = {",
            "&my_device",
            "module_param_named(device_id, my_device.device_id, int, 0644)",
            "module_param_named(data_count, my_device.data_count, int, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_device_info(struct device_info *dev)",
                "void update_device_count(struct device_info *dev, int new_count)",
                "void activate_device(struct device_info *dev)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_device_info(struct device_info *dev)",
                "void update_device_count(struct device_info *dev, int new_count)",
                "void activate_device(struct device_info *dev)",
                "static int __init struct_pointers_init(void)",
                "static void __exit struct_pointers_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Structure pointers module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init struct_pointers_init(void)"
                },
                {
                    "pattern": "Initial Device Information:",
                    "exact": true,
                    "linkedFunction": "static int __init struct_pointers_init(void)"
                },
                {
                    "pattern": "Device Name: sensor01",
                    "exact": true,
                    "linkedFunction": "void print_device_info(struct device_info *dev)"
                },
                {
                    "pattern": "Device ID: 1001",
                    "exact": true,
                    "linkedFunction": "void print_device_info(struct device_info *dev)"
                },
                {
                    "pattern": "Device Active: 0",
                    "exact": true,
                    "linkedFunction": "void print_device_info(struct device_info *dev)"
                },
                {
                    "pattern": "Data Count: 0",
                    "exact": true,
                    "linkedFunction": "void print_device_info(struct device_info *dev)"
                },
                {
                    "pattern": "Device sensor01 count updated to: 5",
                    "exact": true,
                    "linkedFunction": "void update_device_count(struct device_info *dev, int new_count)"
                },
                {
                    "pattern": "Device sensor01 activated",
                    "exact": true,
                    "linkedFunction": "void activate_device(struct device_info *dev)"
                },
                {
                    "pattern": "Final Device Information:",
                    "exact": true,
                    "linkedFunction": "static int __init struct_pointers_init(void)"
                },
                {
                    "pattern": "Device Name: sensor01",
                    "exact": true,
                    "linkedFunction": "void print_device_info(struct device_info *dev)"
                },
                {
                    "pattern": "Device ID: 1001",
                    "exact": true,
                    "linkedFunction": "void print_device_info(struct device_info *dev)"
                },
                {
                    "pattern": "Device Active: 1",
                    "exact": true,
                    "linkedFunction": "void print_device_info(struct device_info *dev)"
                },
                {
                    "pattern": "Data Count: 5",
                    "exact": true,
                    "linkedFunction": "void print_device_info(struct device_info *dev)"
                }
            ]
        },
        {
            "id": "advanced_pointer_structure_validation",
            "name": "Advanced Pointer Structure Implementation with TCC Header Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "pointer_struct_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Pointer Structure Implementation Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random device data\\n    int test_id1 = (rand() % 9000) + 2000;  // 2000-10999\\n    int test_count1 = (rand() % 10) + 1;    // 1-10\\n    int test_id2 = (rand() % 9000) + 5000;  // 5000-13999\\n    int test_count2 = (rand() % 20) + 5;    // 5-24\\n    \\n    printf(\\\"Test 1: Testing with device_id=%d, data_count=%d\\\\n\\\", test_id1, test_count1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/struct_pointers.ko device_id=%d data_count=%d\\\", test_id1, test_count1);\\n    system(\\\"rmmod struct_pointers 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Testing with device_id=%d, data_count=%d\\\\n\\\", test_id2, test_count2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/struct_pointers.ko device_id=%d data_count=%d\\\", test_id2, test_count2);\\n    system(\\\"rmmod struct_pointers\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Dynamic pointer structure test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting advanced pointer structure implementation validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo '#define true 1' >> /tmp/linux/types.h",
                    "echo '#define false 0' >> /tmp/linux/types.h",
                    "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
                    "echo 'Creating test file that includes pointer structure header...'",
                    "echo '#include \"/lib/modules/struct_pointers.h\"' > /tmp/test.c",
                    "echo 'int main() { my_device.device_id = 888; print_device_info(&my_device); update_device_count(&my_device, 10); activate_device(&my_device); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
                    "echo 'Phase 2: Dynamic Pointer Structure Implementation Testing'",
                    "/bin/pointer_struct_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Dynamic Value Extraction and Validation'",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Extracting random test values from output...'",
                    "TEST1_ID=$(grep -o 'Test 1: Testing with device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
                    "TEST1_COUNT=$(grep -o 'data_count=[0-9]*' /tmp/test_output.log | head -1 | cut -d'=' -f2)",
                    "TEST2_ID=$(grep -o 'Test 2: Testing with device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
                    "TEST2_COUNT=$(grep -o 'data_count=[0-9]*' /tmp/test_output.log | tail -1 | cut -d'=' -f2)",
                    "echo 'Test values: ID1='$TEST1_ID', Count1='$TEST1_COUNT', ID2='$TEST2_ID', Count2='$TEST2_COUNT",
                    "echo 'Validating pointer-based structure member access with dynamic values'",
                    "dmesg | grep 'Device ID: '$TEST1_ID && echo 'PASS: Pointer access to device_id working with '$TEST1_ID || echo 'FAIL: Pointer access to device_id broken for '$TEST1_ID",
                    "dmesg | grep 'Device Name: sensor01' && echo 'PASS: Pointer access to device_name working' || echo 'FAIL: Pointer access to device_name broken'",
                    "dmesg | grep 'Data Count: '$TEST1_COUNT && echo 'PASS: Initial data_count from module param '$TEST1_COUNT || echo 'FAIL: Module parameter data_count not working'",
                    "dmesg | grep 'Device ID: '$TEST2_ID && echo 'PASS: Pointer access to device_id working with '$TEST2_ID || echo 'FAIL: Pointer access to device_id broken for '$TEST2_ID",
                    "echo 'Phase 3.1: Function Logic Validation'",
                    "dmesg | grep 'Device sensor01 count updated to: 5' && echo 'PASS: update_device_count function message works' || echo 'FAIL: update_device_count message broken'",
                    "dmesg | grep 'Data Count: 5' && echo 'PASS: update_device_count actually modified struct data_count to 5' || echo 'FAIL: update_device_count function logic broken - struct not modified'",
                    "dmesg | grep 'Device sensor01 activated' && echo 'PASS: activate_device function message works' || echo 'FAIL: activate_device message broken'",
                    "dmesg | grep 'Device Active: 1' && echo 'PASS: activate_device actually modified struct is_active to true' || echo 'FAIL: activate_device function logic broken - struct not modified'",
                    "echo 'Phase 3.2: Final State Validation'",
                    "dmesg | grep 'Final Device Information:' && echo 'PASS: Final print_device_info called' || echo 'FAIL: Final print_device_info not called'",
                    "dmesg | grep 'Data Count: 5' && echo 'PASS: Final state data_count is correct' || echo 'FAIL: Final data_count wrong'",
                    "dmesg | grep 'Device Active: 1' && echo 'PASS: Final state is_active is correct' || echo 'FAIL: Final is_active wrong'",
                    "echo 'Phase 4: Structure Definition Validation'",
                    "dmesg | grep 'Structure pointers module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
                    "echo 'All pointer structure implementation validations completed'"
                ],
                "expected": {
                    "dmesg": [
                        "Structure pointers module loaded",
                        "Device Name: sensor01",
                        "Device ID: .*",
                        "Data Count: .*",
                        "Device sensor01 count updated to: 5",
                        "Device sensor01 activated",
                        "Device Active: 1"
                    ],
                    "stdout": [
                        "PASS: All function and variable declarations found in header file",
                        "SUCCESS: Dynamic pointer structure test completed",
                        "PASS: Pointer access to device_id working with .*",
                        "PASS: Pointer access to device_name working",
                        "PASS: Initial data_count from module param .*",
                        "PASS: update_device_count function message works",
                        "PASS: update_device_count actually modified struct data_count to 5",
                        "PASS: activate_device function message works",
                        "PASS: activate_device actually modified struct is_active to true",
                        "PASS: Final print_device_info called",
                        "PASS: Final state data_count is correct",
                        "PASS: Final state is_active is correct"
                    ]
                },
                "timeout": 15
            }
        }
    ]
});


// Problem 18: Typedef - Cleaner Type Definitions
generatedTestDefinitions.set(18, {
    "name": "Typedef - Cleaner Type Definitions",
    "category": "foundations",
    "description": "Learn to create cleaner, more readable code using typedef. Instead of writing 'struct device_info my_device', you can simply write 'Device my_device'. This introduces type aliasing - a fundamental concept for writing professional, maintainable kernel code.",
    "exactRequirements": {
        "functionNames": [
            "typedef_basics_init",
            "typedef_basics_exit",
            "print_device_details",
            "update_device_status",
            "check_device_state"
        ],
        "variables": [
            {
                "name": "my_device",
                "type": "Device",
                "value": "{.device_id = 12345, .name = \"sensor01\", .status_code = 200, .is_active = true}",
                "storageClass": "none"
            }
        ],
        "outputMessages": [
            "Typedef basics module loaded",
            "Initial Device Information:",
            "Device ID: 12345",
            "Device Name: sensor01",
            "Status Code: 200",
            "Device State: ACTIVE",
            "Status updated to: 404",
            "After status update:",
            "Device ID: 12345",
            "Device Name: sensor01",
            "Status Code: 404",
            "Device State: INACTIVE"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "typedef struct {",
            "} Device;",
            "extern Device my_device",
            "Device my_device = {",
            "module_param_named(device_id, my_device.device_id, int, 0644)",
            "module_param_named(status_code, my_device.status_code, int, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_device_details(void)",
                "void update_device_status(int new_status)",
                "void check_device_state(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_device_details(void)",
                "void update_device_status(int new_status)",
                "void check_device_state(void)",
                "static int __init typedef_basics_init(void)",
                "static void __exit typedef_basics_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Typedef basics module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init typedef_basics_init(void)"
                },
                {
                    "pattern": "Initial Device Information:",
                    "exact": true,
                    "linkedFunction": "static int __init typedef_basics_init(void)"
                },
                {
                    "pattern": "Device ID: 12345",
                    "exact": true,
                    "linkedFunction": "void print_device_details(void)"
                },
                {
                    "pattern": "Device Name: sensor01",
                    "exact": true,
                    "linkedFunction": "void print_device_details(void)"
                },
                {
                    "pattern": "Status Code: 200",
                    "exact": true,
                    "linkedFunction": "void print_device_details(void)"
                },
                {
                    "pattern": "Device State: ACTIVE",
                    "exact": true,
                    "linkedFunction": "void check_device_state(void)"
                },
                {
                    "pattern": "Status updated to: 404",
                    "exact": true,
                    "linkedFunction": "void update_device_status(int new_status)"
                },
                {
                    "pattern": "After status update:",
                    "exact": true,
                    "linkedFunction": "static int __init typedef_basics_init(void)"
                },
                {
                    "pattern": "Device ID: 12345",
                    "exact": true,
                    "linkedFunction": "void print_device_details(void)"
                },
                {
                    "pattern": "Device Name: sensor01",
                    "exact": true,
                    "linkedFunction": "void print_device_details(void)"
                },
                {
                    "pattern": "Status Code: 404",
                    "exact": true,
                    "linkedFunction": "void print_device_details(void)"
                },
                {
                    "pattern": "Device State: INACTIVE",
                    "exact": true,
                    "linkedFunction": "void check_device_state(void)"
                }
            ]
        },
        {
            "id": "advanced_typedef_implementation_validation",
            "name": "Advanced Typedef Implementation with TCC Header Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "typedef_dynamic_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Typedef Implementation Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random device data\\n    int test_id1 = (rand() % 9000) + 10000;     // 10000-18999\\n    int test_status1 = (rand() % 2) ? 200 : 404; // 200 or 404\\n    int test_id2 = (rand() % 9000) + 20000;     // 20000-28999\\n    int test_status2 = (rand() % 2) ? 200 : 500; // 200 or 500\\n    \\n    printf(\\\"Test 1: Testing with device_id=%d, status_code=%d\\\\n\\\", test_id1, test_status1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/typedef_basics.ko device_id=%d status_code=%d\\\", test_id1, test_status1);\\n    system(\\\"rmmod typedef_basics 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Testing with device_id=%d, status_code=%d\\\\n\\\", test_id2, test_status2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/typedef_basics.ko device_id=%d status_code=%d\\\", test_id2, test_status2);\\n    system(\\\"rmmod typedef_basics\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Dynamic typedef test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting advanced typedef implementation validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param_named(name, var, type, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo '#define true 1' >> /tmp/linux/types.h",
                    "echo '#define false 0' >> /tmp/linux/types.h",
                    "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
                    "echo 'Creating test file that includes typedef header...'",
                    "echo '#include \"/lib/modules/typedef_basics.h\"' > /tmp/test.c",
                    "echo 'int main() { my_device.device_id = 999; print_device_details(); update_device_status(500); check_device_state(); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or typedef declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and typedef declarations found in header file'; fi",
                    "echo 'Phase 2: Dynamic Typedef Implementation Testing'",
                    "/bin/typedef_dynamic_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Dynamic Value Extraction and Validation'",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Extracting random test values from output...'",
                    "TEST1_ID=$(grep -o 'Test 1: Testing with device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
                    "TEST1_STATUS=$(grep -o 'status_code=[0-9]*' /tmp/test_output.log | head -1 | cut -d'=' -f2)",
                    "TEST2_ID=$(grep -o 'Test 2: Testing with device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
                    "TEST2_STATUS=$(grep -o 'status_code=[0-9]*' /tmp/test_output.log | tail -1 | cut -d'=' -f2)",
                    "echo 'Test values: ID1='$TEST1_ID', Status1='$TEST1_STATUS', ID2='$TEST2_ID', Status2='$TEST2_STATUS",
                    "echo 'Validating typedef-based structure member access with dynamic values'",
                    "dmesg | grep 'Device ID: '$TEST1_ID && echo 'PASS: Typedef structure member access working with '$TEST1_ID || echo 'FAIL: Typedef structure member access broken for '$TEST1_ID",
                    "dmesg | grep 'Device Name: sensor01' && echo 'PASS: Typedef string member access working' || echo 'FAIL: Typedef string member access broken'",
                    "dmesg | grep 'Status Code: '$TEST1_STATUS && echo 'PASS: Typedef status member access working with '$TEST1_STATUS || echo 'FAIL: Typedef status member access broken for '$TEST1_STATUS",
                    "dmesg | grep 'Device ID: '$TEST2_ID && echo 'PASS: Typedef structure member access working with '$TEST2_ID || echo 'FAIL: Typedef structure member access broken for '$TEST2_ID",
                    "dmesg | grep 'Status Code: '$TEST2_STATUS && echo 'PASS: Typedef status member access working with '$TEST2_STATUS || echo 'FAIL: Typedef status member access broken for '$TEST2_STATUS",
                    "echo 'Phase 3.1: Function Logic Validation'",
                    "dmesg | grep 'Status updated to: 404' && echo 'PASS: update_device_status function message works' || echo 'FAIL: update_device_status message broken'",
                    "dmesg | grep 'Status Code: 404' && echo 'PASS: update_device_status actually modified typedef structure member' || echo 'FAIL: update_device_status function logic broken - structure not modified'",
                    "dmesg | grep 'Device State: INACTIVE' && echo 'PASS: check_device_state function using typedef member correctly' || echo 'FAIL: check_device_state not using typedef structure member'",
                    "echo 'Phase 3.2: Final State Validation'",
                    "dmesg | grep 'After status update:' && echo 'PASS: Final print_device_details called' || echo 'FAIL: Final print_device_details not called'",
                    "dmesg | grep 'Status Code: 404' && echo 'PASS: Final state shows correct typedef member modification' || echo 'FAIL: Final state typedef member modification broken'",
                    "dmesg | grep 'Device State: INACTIVE' && echo 'PASS: Final state shows correct conditional logic' || echo 'FAIL: Final state conditional logic broken'",
                    "echo 'Phase 4: Typedef Definition Validation'",
                    "dmesg | grep 'Typedef basics module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
                    "echo 'All typedef implementation validations completed'"
                ],
                "expected": {
                    "dmesg": [
                        "Typedef basics module loaded",
                        "Device ID: .*",
                        "Device Name: sensor01",
                        "Status Code: .*",
                        "Device State: ACTIVE",
                        "Status updated to: 404"
                    ],
                    "stdout": [
                        "PASS: All function and typedef declarations found in header file",
                        "SUCCESS: Dynamic typedef test completed",
                        "PASS: Typedef structure member access working with .*",
                        "PASS: Typedef string member access working",
                        "PASS: Typedef status member access working with .*",
                        "PASS: update_device_status function message works",
                        "PASS: update_device_status actually modified typedef structure member",
                        "PASS: check_device_state function using typedef member correctly",
                        "PASS: Final print_device_details called",
                        "PASS: Final state shows correct typedef member modification",
                        "PASS: Final state shows correct conditional logic"
                    ]
                },
                "timeout": 15
            }
        }
    ]
});


// Problem 19: Dynamic Memory - WHEN and WHY to Use kmalloc
generatedTestDefinitions.set(19, {
    "name": "Dynamic Memory - WHEN and WHY to Use kmalloc",
    "category": "foundations",
    "description": "Master the decision-making process for dynamic vs static memory allocation in kernel development. Learn WHEN kmalloc is required (runtime-determined sizes, persistent memory, returning pointers) and WHY static allocation fails in these scenarios. Understand the kmalloc/kfree lifecycle pattern used throughout the Linux kernel.",
    "exactRequirements": {
        "functionNames": [
            "dynamic_memory_init",
            "dynamic_memory_exit",
            "allocate_devices",
            "initialize_device",
            "print_device_info",
            "cleanup_devices"
        ],
        "variables": [
            {
                "name": "device_array",
                "type": "Device *",
                "value": "NULL",
                "storageClass": "none"
            },
            {
                "name": "device_count",
                "type": "int",
                "value": "3",
                "storageClass": "none"
            }
        ],
        "outputMessages": [
            "Dynamic memory module loaded",
            "Runtime device count: 3",
            "Allocating 3 devices...",
            "Successfully allocated 3 devices",
            "Initializing 3 devices...",
            "Device 1000 initialized",
            "Device 1001 initialized",
            "Device 1002 initialized",
            "Printing device information...",
            "Device 0:",
            "=== Device Info ===",
            "Device ID: 1000",
            "Status: 200",
            "Active: YES",
            "Device 1:",
            "Device ID: 1001",
            "Device 2:",
            "Device ID: 1002",
            "Dynamic allocation demonstration completed",
            "Dynamic memory module unloading",
            "Freeing 3 devices...",
            "All devices freed",
            "Module unloaded cleanly"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h",
            "linux/slab.h"
        ],
        "mustContain": [
            "kmalloc(sizeof(Device) * count, GFP_KERNEL)",
            "kfree(device_array)",
            "if (!device_array)",
            "device_array = NULL",
            "module_param(device_count, int, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int allocate_devices(int count)",
                "void initialize_device(Device *dev, int id)",
                "void print_device_info(Device *dev)",
                "void cleanup_devices(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int allocate_devices(int count)",
                "void initialize_device(Device *dev, int id)",
                "void print_device_info(Device *dev)",
                "void cleanup_devices(void)",
                "static int __init dynamic_memory_init(void)",
                "static void __exit dynamic_memory_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages with Function Linkage",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Dynamic memory module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init dynamic_memory_init(void)"
                },
                {
                    "pattern": "Runtime device count:",
                    "exact": false,
                    "linkedFunction": "static int __init dynamic_memory_init(void)"
                },
                {
                    "pattern": "Allocating",
                    "exact": false,
                    "linkedFunction": "int allocate_devices(int count)"
                },
                {
                    "pattern": "Successfully allocated",
                    "exact": false,
                    "linkedFunction": "int allocate_devices(int count)"
                },
                {
                    "pattern": "Initializing",
                    "exact": false,
                    "linkedFunction": "static int __init dynamic_memory_init(void)"
                },
                {
                    "pattern": "Device 1000 initialized",
                    "exact": true,
                    "linkedFunction": "void initialize_device(Device *dev, int id)"
                },
                {
                    "pattern": "Printing device information...",
                    "exact": true,
                    "linkedFunction": "static int __init dynamic_memory_init(void)"
                },
                {
                    "pattern": "Device 0:",
                    "exact": true,
                    "linkedFunction": "static int __init dynamic_memory_init(void)"
                },
                {
                    "pattern": "=== Device Info ===",
                    "exact": true,
                    "linkedFunction": "void print_device_info(Device *dev)"
                },
                {
                    "pattern": "Device ID: 1000",
                    "exact": true,
                    "linkedFunction": "void print_device_info(Device *dev)"
                },
                {
                    "pattern": "Status: 200",
                    "exact": true,
                    "linkedFunction": "void print_device_info(Device *dev)"
                },
                {
                    "pattern": "Active: YES",
                    "exact": true,
                    "linkedFunction": "void print_device_info(Device *dev)"
                },
                {
                    "pattern": "Dynamic allocation demonstration completed",
                    "exact": true,
                    "linkedFunction": "static int __init dynamic_memory_init(void)"
                },
                {
                    "pattern": "Dynamic memory module unloading",
                    "exact": true,
                    "linkedFunction": "static void __exit dynamic_memory_exit(void)"
                },
                {
                    "pattern": "Freeing",
                    "exact": false,
                    "linkedFunction": "void cleanup_devices(void)"
                },
                {
                    "pattern": "All devices freed",
                    "exact": true,
                    "linkedFunction": "void cleanup_devices(void)"
                },
                {
                    "pattern": "Module unloaded cleanly",
                    "exact": true,
                    "linkedFunction": "static void __exit dynamic_memory_exit(void)"
                }
            ]
        },
        {
            "id": "advanced_dynamic_memory_validation",
            "name": "Advanced Dynamic Memory Implementation with TCC Header Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "memory_dynamic_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Runtime-Determined Size Allocation Test ===\\\\n\\\");\\n    \\n    srand(time(NULL));\\n    \\n    // Test different device counts (runtime-determined)\\n    int test_count1 = (rand() % 3) + 2;  // 2-4 devices\\n    int test_count2 = (rand() % 4) + 5;  // 5-8 devices\\n    \\n    printf(\\\"Test 1: Allocating %d devices (runtime size)\\\\n\\\", test_count1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/dynamic_memory.ko device_count=%d\\\", test_count1);\\n    system(\\\"rmmod dynamic_memory 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Allocating %d devices (runtime size)\\\\n\\\", test_count2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/dynamic_memory.ko device_count=%d\\\", test_count2);\\n    system(\\\"rmmod dynamic_memory\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Runtime-sized allocation test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting advanced dynamic memory implementation validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
                    "echo '#define true 1' >> /tmp/linux/types.h",
                    "echo '#define false 0' >> /tmp/linux/types.h",
                    "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
                    "echo '#define MAX_DEVICES 5' >> /tmp/linux/types.h",
                    "echo '#define GFP_KERNEL 0' > /tmp/linux/slab.h",
                    "echo '#define ENOMEM 12' >> /tmp/linux/slab.h",
                    "echo 'void *kmalloc(size_t size, int flags);' >> /tmp/linux/slab.h",
                    "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
                    "echo 'Creating test file that includes dynamic memory header...'",
                    "echo '#include \"/lib/modules/dynamic_memory.h\"' > /tmp/test.c",
                    "echo 'int main() { allocate_devices(3); initialize_device(&device_array[0], 1000); print_device_info(&device_array[0]); cleanup_devices(); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
                    "echo 'Phase 2: Runtime-Determined Size Allocation Testing'",
                    "/bin/memory_dynamic_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Extract Runtime Device Counts'",
                    "sleep 1",
                    "echo 'Extracting runtime device counts from test output...'",
                    "COUNT1=$(grep -o 'Test 1: Allocating [0-9]*' /tmp/test_output.log | cut -d' ' -f4)",
                    "COUNT2=$(grep -o 'Test 2: Allocating [0-9]*' /tmp/test_output.log | cut -d' ' -f4)",
                    "echo 'Extracted runtime counts: COUNT1='$COUNT1', COUNT2='$COUNT2",
                    "if [ -z \"$COUNT1\" ] || [ -z \"$COUNT2\" ]; then echo 'FAIL: Could not extract runtime counts'; else echo 'PASS: Runtime device counts extracted successfully'; fi",
                    "echo 'Phase 4: Single Array Allocation Validation'",
                    "echo 'Validating single array allocation...'",
                    "dmesg | grep -E '(Allocating|allocated)' && echo 'PASS: Array allocation initiated' || echo 'FAIL: Array allocation broken'",
                    "dmesg | grep -E '(Successfully allocated|allocated)' && echo 'PASS: Array allocation successful' || echo 'FAIL: Array allocation broken'",
                    "echo 'Phase 5: Runtime Device Count Validation'",
                    "echo 'Validating with runtime count '$COUNT1' devices...'",
                    "dmesg | grep \"Runtime device count: $COUNT1\" && echo 'PASS: Runtime count '$COUNT1' detected' || echo 'FAIL: Runtime count detection broken'",
                    "dmesg | grep -E '(Allocating|allocated)' && echo 'PASS: Correct device count allocation' || echo 'FAIL: Wrong device count'",
                    "dmesg | grep -E '(Successfully|allocated)' && echo 'PASS: All devices allocated' || echo 'FAIL: Allocation incomplete'",
                    "echo 'Phase 6: Device Initialization Validation'",
                    "dmesg | grep 'Device 1000 initialized' && echo 'PASS: Device initialization working' || echo 'FAIL: Device initialization broken'",
                    "dmesg | grep 'Device ID: 1000' && echo 'PASS: First device data correct' || echo 'FAIL: First device data wrong'",
                    "dmesg | grep 'Status: 200' && echo 'PASS: Device status field correct' || echo 'FAIL: Device status wrong'",
                    "dmesg | grep 'Active: YES' && echo 'PASS: Device boolean field correct' || echo 'FAIL: Device boolean wrong'",
                    "echo 'Phase 7: Cleanup Validation'",
                    "dmesg | grep -E '(Freeing|free)' && echo 'PASS: Cleanup initiated' || echo 'FAIL: Cleanup not initiated'",
                    "dmesg | grep 'All devices freed' && echo 'PASS: Cleanup successful' || echo 'FAIL: Cleanup broken'",
                    "dmesg | grep 'Module unloaded cleanly' && echo 'PASS: Complete cleanup successful' || echo 'FAIL: Module unload broken'",
                    "echo 'Phase 8: Final Validation Summary'",
                    "echo 'PASS: All runtime-determined allocation validation successful'"
                ],
                "expected": {
                    "dmesg": [
                        "Dynamic memory module loaded",
                        "Runtime device count: .*",
                        "Allocat",
                        "Initializing.*devices",
                        "Device 1000 initialized",
                        "Device ID: 1000",
                        "Status: 200",
                        "Active: YES",
                        "Freeing",
                        "All devices freed",
                        "Module unloaded cleanly"
                    ],
                    "stdout": [
                        "PASS: All function and variable declarations found in header file",
                        "SUCCESS: Runtime-sized allocation test completed",
                        "PASS: Runtime device counts extracted successfully",
                        "PASS: Array allocation initiated",
                        "PASS: Array allocation successful",
                        "PASS: Runtime count.*detected",
                        "PASS: Correct device count allocation",
                        "PASS: All devices allocated",
                        "PASS: Device initialization working",
                        "PASS: First device data correct",
                        "PASS: Device status field correct",
                        "PASS: Device boolean field correct",
                        "PASS: Cleanup initiated",
                        "PASS: Cleanup successful",
                        "PASS: Complete cleanup successful",
                        "PASS: All runtime-determined allocation validation successful"
                    ]
                },
                "timeout": 15
            }
        }
    ]
});


// Problem 20: Pointer Casting - Multi-Level Type Conversion Mastery
generatedTestDefinitions.set(20, {
    "name": "Pointer Casting - Multi-Level Type Conversion Mastery",
    "category": "foundations",
    "description": "Master multi-level pointer casting chains: void* → generic_record* → sensor_record*. Learn the exact patterns used in production kernel parsers for safe type conversion and record processing.",
    "exactRequirements": {
        "functionNames": [
            "pointer_casting_init",
            "pointer_casting_exit",
            "process_generic_record",
            "extract_sensor_data",
            "extract_device_data",
            "print_record_info"
        ],
        "variables": [
            {
                "name": "current_record",
                "type": "generic_record *",
                "value": "NULL",
                "storageClass": "none"
            },
            {
                "name": "sensor_data",
                "type": "sensor_record *",
                "value": "NULL",
                "storageClass": "none"
            },
            {
                "name": "device_data",
                "type": "device_record *",
                "value": "NULL",
                "storageClass": "none"
            }
        ],
        "outputMessages": [
            "Pointer casting module loaded",
            "Sensor Record Extracted",
            "Sensor ID: 1001",
            "Sensor Name: temperature_01",
            "Measurement: 257",
            "Current Record Info:",
            "Record Type: 1",
            "Record Subtype: 1",
            "Record Length: 48",
            "Device Record Extracted",
            "Device ID: 2001",
            "Device Status: operational",
            "Active: true",
            "Current Record Info:",
            "Record Type: 2",
            "Record Subtype: 1",
            "Record Length: 52",
            "Pointer casting module unloaded"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "generic_record *rec = (generic_record *)raw_record",
            "sensor_record *sensor = (sensor_record *)rec",
            "device_record *device = (device_record *)rec",
            "current_record = rec",
            "sensor_data = sensor",
            "device_data = device",
            "if (rec->header.rec_type == SENSOR_RECORD)",
            "module_param(test_record_type, int, 0644)",
            "module_param(test_sensor_id, int, 0644)",
            "module_param(test_measurement, int, 0644)",
            "module_param(test_device_id, int, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void process_generic_record(void *raw_record)",
                "void extract_sensor_data(generic_record *rec)",
                "void extract_device_data(generic_record *rec)",
                "void print_record_info(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void process_generic_record(void *raw_record)",
                "void extract_sensor_data(generic_record *rec)",
                "void extract_device_data(generic_record *rec)",
                "void print_record_info(void)",
                "static int __init pointer_casting_init(void)",
                "static void __exit pointer_casting_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Pointer casting module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init pointer_casting_init(void)"
                },
                {
                    "pattern": "Sensor Record Extracted",
                    "exact": true,
                    "linkedFunction": "void extract_sensor_data(generic_record *rec)"
                },
                {
                    "pattern": "Sensor ID: 1001",
                    "exact": true,
                    "linkedFunction": "void extract_sensor_data(generic_record *rec)"
                },
                {
                    "pattern": "Sensor Name: temperature_01",
                    "exact": true,
                    "linkedFunction": "void extract_sensor_data(generic_record *rec)"
                },
                {
                    "pattern": "Measurement: 257",
                    "exact": true,
                    "linkedFunction": "void extract_sensor_data(generic_record *rec)"
                },
                {
                    "pattern": "Current Record Info:",
                    "exact": true,
                    "linkedFunction": "void print_record_info(void)"
                },
                {
                    "pattern": "Record Type: 1",
                    "exact": true,
                    "linkedFunction": "void print_record_info(void)"
                },
                {
                    "pattern": "Record Subtype: 1",
                    "exact": true,
                    "linkedFunction": "void print_record_info(void)"
                },
                {
                    "pattern": "Record Length: 48",
                    "exact": true,
                    "linkedFunction": "void print_record_info(void)"
                },
                {
                    "pattern": "Device Record Extracted",
                    "exact": true,
                    "linkedFunction": "void extract_device_data(generic_record *rec)"
                },
                {
                    "pattern": "Device ID: 2001",
                    "exact": true,
                    "linkedFunction": "void extract_device_data(generic_record *rec)"
                },
                {
                    "pattern": "Device Status: operational",
                    "exact": true,
                    "linkedFunction": "void extract_device_data(generic_record *rec)"
                },
                {
                    "pattern": "Active: true",
                    "exact": true,
                    "linkedFunction": "void extract_device_data(generic_record *rec)"
                },
                {
                    "pattern": "Current Record Info:",
                    "exact": true,
                    "linkedFunction": "void print_record_info(void)"
                },
                {
                    "pattern": "Record Type: 2",
                    "exact": true,
                    "linkedFunction": "void print_record_info(void)"
                },
                {
                    "pattern": "Record Subtype: 1",
                    "exact": true,
                    "linkedFunction": "void print_record_info(void)"
                },
                {
                    "pattern": "Record Length: 52",
                    "exact": true,
                    "linkedFunction": "void print_record_info(void)"
                },
                {
                    "pattern": "Pointer casting module unloaded",
                    "exact": true,
                    "linkedFunction": "static void __exit pointer_casting_exit(void)"
                }
            ]
        },
        {
            "id": "advanced_casting_validation",
            "name": "Advanced Multi-Level Casting Implementation with Anti-Hardcoding Protection",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "casting_dynamic_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Anti-Hardcoding Casting Test ===\\\\n\\\");\\n    \\n    // Seed random number generator with current time\\n    srand(time(NULL));\\n    \\n    // Generate unpredictable sensor test values\\n    int random_sensor_id = (rand() % 9000) + 1000;  // 1000-9999\\n    int random_measurement = (rand() % 500) + 100;   // 100-599\\n    \\n    // Generate unpredictable device test values\\n    int random_device_id = (rand() % 8000) + 2000;  // 2000-9999\\n    \\n    printf(\\\"Test 1: Random sensor casting (ID=%d, measurement=%d)\\\\n\\\", random_sensor_id, random_measurement);\\n    printf(\\\"Test 2: Random device casting (ID=%d)\\\\n\\\", random_device_id);\\n    \\n    // Test sensor record casting with random values\\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod pointer_casting 2>/dev/null\\\");\\n    \\n    char cmd1[512];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/pointer_casting.ko test_record_type=1 test_sensor_id=%d test_measurement=%d\\\", random_sensor_id, random_measurement);\\n    printf(\\\"DEBUG: Sensor command: %s\\\\n\\\", cmd1);\\n    system(cmd1);\\n    \\n    \\n    // Test device record casting with random values\\n    printf(\\\"DEBUG: Switching to device test...\\\\n\\\");\\n    system(\\\"rmmod pointer_casting\\\");\\n    \\n    char cmd2[512];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/pointer_casting.ko test_record_type=2 test_device_id=%d\\\", random_device_id);\\n    printf(\\\"DEBUG: Device command: %s\\\\n\\\", cmd2);\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Anti-hardcoding casting test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting advanced multi-level casting implementation validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo 'typedef unsigned char uint8_t;' >> /tmp/linux/types.h",
                    "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
                    "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
                    "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
                    "echo '#define true 1' >> /tmp/linux/types.h",
                    "echo '#define false 0' >> /tmp/linux/types.h",
                    "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
                    "echo 'Creating test file that includes casting header...'",
                    "echo '#include \"/lib/modules/pointer_casting.h\"' > /tmp/test.c",
                    "echo 'int main() { current_record->header.rec_type = 1; process_generic_record((void*)0); extract_sensor_data((generic_record*)0); extract_device_data((generic_record*)0); print_record_info(); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
                    "echo 'Phase 2: Anti-Hardcoding Dynamic Casting Test'",
                    "/bin/casting_dynamic_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Random Value Extraction and Validation'",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Extracting random test values from output...'",
                    "SENSOR_ID=$(grep -o 'Random sensor casting (ID=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
                    "SENSOR_MEASUREMENT=$(grep -o 'measurement=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
                    "DEVICE_ID=$(grep -o 'Random device casting (ID=[0-9]*)' /tmp/test_output.log | cut -d'=' -f2 | cut -d')' -f1)",
                    "echo 'Extracted values: SENSOR_ID='$SENSOR_ID', MEASUREMENT='$SENSOR_MEASUREMENT', DEVICE_ID='$DEVICE_ID",
                    "if [ -z \"$SENSOR_ID\" ] || [ -z \"$SENSOR_MEASUREMENT\" ] || [ -z \"$DEVICE_ID\" ]; then echo 'FAIL: Could not extract random test values'; else echo 'PASS: Random values extracted successfully'; fi",
                    "echo 'Phase 4: Anti-Hardcoding Validation with Random Values'",
                    "echo 'Validating sensor casting with random ID '$SENSOR_ID",
                    "dmesg | grep \"Sensor ID: $SENSOR_ID\" && echo 'PASS: Sensor casting with random ID working' || echo 'FAIL: Sensor casting with random ID broken'",
                    "echo 'Validating sensor measurement with random value '$SENSOR_MEASUREMENT",
                    "dmesg | grep \"Measurement: $SENSOR_MEASUREMENT\" && echo 'PASS: Sensor measurement with random value working' || echo 'FAIL: Sensor measurement with random value broken'",
                    "echo 'Validating device casting with random ID '$DEVICE_ID",
                    "dmesg | grep \"Device ID: $DEVICE_ID\" && echo 'PASS: Device casting with random ID working' || echo 'FAIL: Device casting with random ID broken'",
                    "echo 'Phase 5: Static Field Validation (Non-Randomized Fields)'",
                    "dmesg | grep 'Sensor Name: temperature_01' && echo 'PASS: Sensor name field access working' || echo 'FAIL: Sensor name field access broken'",
                    "dmesg | grep 'Device Status: operational' && echo 'PASS: Device status field access working' || echo 'FAIL: Device status field access broken'",
                    "echo 'Phase 6: Casting Logic and Record Type Validation'",
                    "dmesg | grep 'Sensor Record Extracted' && echo 'PASS: Sensor extraction logic working' || echo 'FAIL: Sensor extraction logic broken'",
                    "dmesg | grep 'Device Record Extracted' && echo 'PASS: Device extraction logic working' || echo 'FAIL: Device extraction logic broken'",
                    "dmesg | grep 'Current Record Info:' && echo 'PASS: Record info display working' || echo 'FAIL: Record info display broken'",
                    "echo 'Phase 7: Final Validation Summary'",
                    "echo 'All phases completed successfully - anti-hardcoding protection verified'",
                    "echo 'PASS: All anti-hardcoding casting validation successful'"
                ],
                "expected": {
                    "dmesg": [
                        "Pointer casting module loaded",
                        "Sensor Record Extracted",
                        "Sensor ID: .*",
                        "Sensor Name: temperature_01",
                        "Measurement: .*",
                        "Device Record Extracted",
                        "Device ID: .*",
                        "Device Status: operational",
                        "Current Record Info:",
                        "Record Type: .*"
                    ],
                    "stdout": [
                        "PASS: All function and variable declarations found in header file",
                        "SUCCESS: Anti-hardcoding casting test completed",
                        "PASS: Random values extracted successfully",
                        "PASS: Sensor casting with random ID working",
                        "PASS: Sensor measurement with random value working",
                        "PASS: Device casting with random ID working",
                        "PASS: Sensor name field access working",
                        "PASS: Device status field access working",
                        "PASS: Sensor extraction logic working",
                        "PASS: Device extraction logic working",
                        "PASS: Record info display working",
                        "PASS: All anti-hardcoding casting validation successful"
                    ]
                },
                "timeout": 15
            }
        }
    ]
});


// Problem 21: Function Pointers - Runtime-Unknown Type Dispatch
generatedTestDefinitions.set(21, {
    "name": "Function Pointers - Runtime-Unknown Type Dispatch",
    "category": "foundations",
    "description": "Master function pointers by handling RUNTIME-UNKNOWN event types! Learn WHAT function pointers are, HOW they work, WHY they're necessary (not just convenient), and WHEN they're required vs overkill. Build an extensible callback system where handlers are registered dynamically from EXTERNAL MODULES - proving function pointers handle types that DON'T EXIST at compile time. Handler modules load dynamically, making if-else IMPOSSIBLE. This is the exact pattern Linux uses for interrupt handlers, filesystem operations, and driver registration.",
    "exactRequirements": {
        "functionNames": [
            "function_dispatch_init",
            "function_dispatch_exit",
            "register_event_handler",
            "dispatch_event",
            "show_registered_handlers"
        ],
        "variables": [
            {
                "name": "event_ops_table",
                "type": "event_operations",
                "value": "[MAX_HANDLERS]",
                "storageClass": "none"
            },
            {
                "name": "registered_handler_count",
                "type": "int",
                "value": 0,
                "storageClass": "none"
            }
        ],
        "outputMessages": [
            "Function dispatch core module loaded",
            "Waiting for handler modules to register",
            "Event dispatch system ready",
            "handler module loaded",
            "Registered handler",
            "Registered Event Handlers",
            "Total registered handlers:",
            "Dispatching to Runtime-Unknown Types",
            "Will dispatch to",
            "Dispatching to type",
            "Final Handler Statistics",
            "Function dispatch demonstration complete"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "event_ops_table[event_type].handler = handler",
            "event_ops_table[event_type].handler(event_type, data, size)",
            "if (event_ops_table[event_type].handler == NULL)",
            "event_ops_table[event_type].event_count++",
            "registered_handler_count++",
            "EXPORT_SYMBOL(register_event_handler)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void register_event_handler(uint8_t event_type, event_handler_t handler, const char* name)",
                "void dispatch_event(uint8_t event_type, void* data, uint32_t size)",
                "void show_registered_handlers(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void register_event_handler(uint8_t event_type, event_handler_t handler, const char* name)",
                "void dispatch_event(uint8_t event_type, void* data, uint32_t size)",
                "void show_registered_handlers(void)",
                "static int __init function_dispatch_init(void)",
                "static void __exit function_dispatch_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "callback_registration_implementation",
            "name": "Callback Registration Implementation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "event_ops_table[event_type].handler = handler",
                "registered_handler_count++"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_pointer_dispatch",
            "name": "Function Pointer Dispatch (No If-Else)",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "event_ops_table[event_type].handler(event_type, data, size)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "export_symbol_check",
            "name": "EXPORT_SYMBOL for Cross-Module Access",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "EXPORT_SYMBOL(register_event_handler)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Function dispatch core module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init function_dispatch_init(void)"
                },
                {
                    "pattern": "Waiting for handler modules to register",
                    "exact": true,
                    "linkedFunction": "static int __init function_dispatch_init(void)"
                },
                {
                    "pattern": "Event dispatch system ready",
                    "exact": true,
                    "linkedFunction": "static int __init function_dispatch_init(void)"
                },
                {
                    "pattern": ".*handler module loaded",
                    "exact": false,
                    "linkedFunction": "Handler module init functions"
                },
                {
                    "pattern": "Registered handler .* for event type [0-9]+",
                    "exact": false,
                    "linkedFunction": "void register_event_handler(uint8_t event_type, event_handler_t handler, const char* name)"
                },
                {
                    "pattern": "Registered Event Handlers",
                    "exact": true,
                    "linkedFunction": "void show_registered_handlers(void)"
                },
                {
                    "pattern": "Total registered handlers: [0-9]+",
                    "exact": false,
                    "linkedFunction": "void show_registered_handlers(void)"
                },
                {
                    "pattern": "Dispatching to Runtime-Unknown Types",
                    "exact": true,
                    "linkedFunction": "test_dispatch module"
                },
                {
                    "pattern": "Will dispatch to [0-9]+ different event types",
                    "exact": false,
                    "linkedFunction": "test_dispatch module"
                },
                {
                    "pattern": "Dispatching to type [0-9]+",
                    "exact": false,
                    "linkedFunction": "test_dispatch module"
                },
                {
                    "pattern": "\\[(Sensor|Motor|Status|Network|Storage) Handler\\] Processing event type [0-9]+, data size: [0-9]+",
                    "exact": false,
                    "linkedFunction": "void dispatch_event(uint8_t event_type, void* data, uint32_t size)"
                },
                {
                    "pattern": "Final Handler Statistics",
                    "exact": true,
                    "linkedFunction": "test_dispatch module"
                },
                {
                    "pattern": "Function dispatch demonstration complete",
                    "exact": true,
                    "linkedFunction": "test_dispatch module"
                }
            ]
        },
        {
            "id": "multi_module_dispatch_validation",
            "name": "Multi-Module Dynamic Dispatch (Proves External Module Integration)",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "multi_module_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\\\"=== Multi-Module Handler Integration Test ===\\\\n\\\");\\n    \\n    srand(time(NULL));\\n    \\n    /* Generate random handler module selection (2-4 modules) */\\n    const char *handlers[] = {\\\"handler_sensor\\\", \\\"handler_motor\\\", \\\"handler_status\\\", \\\"handler_network\\\", \\\"handler_storage\\\"};\\n    int num_handlers = (rand() % 3) + 2;\\n    int selected[5] = {0};\\n    \\n    printf(\\\"Step 1: Randomly selecting %d handler modules to load...\\\\n\\\", num_handlers);\\n    \\n    for(int i = 0; i < num_handlers; i++) {\\n        int idx;\\n        do { idx = rand() % 5; } while(selected[idx]);\\n        selected[idx] = 1;\\n        printf(\\\"  - Will load %s.ko\\\\n\\\", handlers[idx]);\\n    }\\n    \\n    /* Generate dispatch sequence */\\n    int dispatch_count = (rand() % 3) + 3;\\n    int dispatch_types[8];\\n    \\n    printf(\\\"\\\\nStep 2: Generating %d random dispatches...\\\\n\\\", dispatch_count);\\n    for(int i = 0; i < dispatch_count; i++) {\\n        int attempts = 0;\\n        do {\\n            dispatch_types[i] = rand() % 5;\\n            attempts++;\\n        } while (!selected[dispatch_types[i]] && attempts < 20);\\n        if (selected[dispatch_types[i]]) {\\n            printf(\\\"  - Dispatch %d: type %d\\\\n\\\", i+1, dispatch_types[i]);\\n        } else {\\n            dispatch_count = i;\\n            break;\\n        }\\n    }\\n    \\n    printf(\\\"\\\\nTest configuration: %d handlers, %d dispatches\\\\n\\\", num_handlers, dispatch_count);\\n    \\n    /* Build dispatch types string */\\n    char types_str[128] = \\\"\\\";\\n    for(int i = 0; i < dispatch_count; i++) {\\n        char buf[16];\\n        snprintf(buf, sizeof(buf), \\\"%s%d\\\", i > 0 ? \\\",\\\" : \\\"\\\", dispatch_types[i]);\\n        strcat(types_str, buf);\\n    }\\n    \\n    /* Unload any existing modules */\\n    system(\\\"rmmod test_dispatch 2>/dev/null\\\");\\n    system(\\\"rmmod handler_sensor handler_motor handler_status handler_network handler_storage 2>/dev/null\\\");\\n    system(\\\"rmmod function_dispatch 2>/dev/null\\\");\\n    \\n    /* Load core module */\\n    printf(\\\"\\\\nStep 3: Loading core module...\\\\n\\\");\\n    system(\\\"insmod /lib/modules/function_dispatch.ko\\\");\\n    \\n    /* Load selected handler modules */\\n    printf(\\\"Step 4: Loading selected handler modules...\\\\n\\\");\\n    for(int i = 0; i < 5; i++) {\\n        if (selected[i]) {\\n            char cmd[256];\\n            snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/%s.ko\\\", handlers[i]);\\n            printf(\\\"  - Loading %s.ko\\\\n\\\", handlers[i]);\\n            system(cmd);\\n        }\\n    }\\n    \\n    /* Load test dispatch module */\\n    printf(\\\"Step 5: Running dispatch test...\\\\n\\\");\\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/test_dispatch.ko test_dispatch_types=%s\\\", types_str);\\n    system(cmd);\\n    \\n    printf(\\\"\\\\nSUCCESS: Multi-module dispatch test completed!\\\\n\\\");\\n    printf(\\\"This PROVES function pointers handle external module functions!\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting multi-module external handler validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: TCC Header Validation'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define EXPORT_SYMBOL(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef unsigned char uint8_t;' > /tmp/linux/types.h",
                    "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
                    "echo 'void* memset(void* s, int c, unsigned long n);' > /tmp/linux/string.h",
                    "echo '#include \"/lib/modules/function_dispatch.h\"' > /tmp/test.c",
                    "echo 'int main() { register_event_handler(1, (event_handler_t)0, \"test\"); dispatch_event(1, (void*)0, 128); show_registered_handlers(); return 0; }' >> /tmp/test.c",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing'; cat /tmp/tcc_error.log; else echo 'PASS: All declarations found'; fi",
                    "",
                    "echo 'Phase 2: Multi-Module Integration Test'",
                    "/bin/multi_module_tester > /tmp/test_output.log 2>&1",
                    "cat /tmp/test_output.log",
                    "sleep 1",
                    "",
                    "echo 'Phase 3: Verify Core Module Loaded'",
                    "dmesg | grep 'Function dispatch core module loaded' && echo 'PASS: Core module loaded' || echo 'FAIL: Core module not loaded'",
                    "dmesg | grep 'Event dispatch system ready' && echo 'PASS: System initialized' || echo 'FAIL: System not ready'",
                    "",
                    "echo 'Phase 4: Verify Handler Modules Registered'",
                    "REGISTERED_COUNT=$(dmesg | grep -c 'Registered handler')",
                    "echo 'Handler modules registered: '$REGISTERED_COUNT",
                    "if [ \"$REGISTERED_COUNT\" -ge 2 ]; then echo 'PASS: Multiple handler modules registered'; else echo 'FAIL: Too few handlers'; fi",
                    "",
                    "echo 'Phase 5: Validate External Module Dispatch (THE CRITICAL TEST!)'",
                    "SENSOR_CALLS=$(dmesg | grep -c '\\[Sensor Handler\\] Processing')",
                    "MOTOR_CALLS=$(dmesg | grep -c '\\[Motor Handler\\] Processing')",
                    "STATUS_CALLS=$(dmesg | grep -c '\\[Status Handler\\] Processing')",
                    "NETWORK_CALLS=$(dmesg | grep -c '\\[Network Handler\\] Processing')",
                    "STORAGE_CALLS=$(dmesg | grep -c '\\[Storage Handler\\] Processing')",
                    "TOTAL_CALLS=$((SENSOR_CALLS + MOTOR_CALLS + STATUS_CALLS + NETWORK_CALLS + STORAGE_CALLS))",
                    "echo 'External handler calls: Sensor='$SENSOR_CALLS', Motor='$MOTOR_CALLS', Status='$STATUS_CALLS', Network='$NETWORK_CALLS', Storage='$STORAGE_CALLS",
                    "echo 'Total external calls: '$TOTAL_CALLS",
                    "if [ \"$TOTAL_CALLS\" -ge 3 ]; then echo 'PASS: External module functions called via function pointers'; else echo 'FAIL: External handlers not called'; fi",
                    "",
                    "echo 'Phase 6: Verify Statistics Tracking'",
                    "dmesg | grep 'Final Handler Statistics' && echo 'PASS: Statistics tracking working' || echo 'FAIL: Missing statistics'",
                    "dmesg | grep 'called [1-9][0-9]* times' && echo 'PASS: Event counters updated' || echo 'PASS: Event counters initialized'",
                    "",
                    "echo 'Phase 7: Critical Validation - Proves If-Else Impossible'",
                    "echo ''",
                    "echo '========================================='",
                    "echo 'CRITICAL SUCCESS: This test PROVES that:'",
                    "echo '1. Handler functions in EXTERNAL .ko modules'",
                    "echo '2. Core module CANNOT use if-else (linker error!)'",
                    "echo '3. Function pointers are REQUIRED (not optional!)'",
                    "echo '4. Dynamic module loading works like real kernel'",
                    "echo '========================================='",
                    "echo ''",
                    "echo 'PASS: All multi-module external handler validation successful'"
                ],
                "expected": {
                    "dmesg": [
                        "Function dispatch core module loaded",
                        "Waiting for handler modules to register",
                        "Event dispatch system ready",
                        ".* handler module loaded",
                        "Registered handler .* for event type [0-9]*",
                        "Dispatching to Runtime-Unknown Types",
                        "Will dispatch to [0-9]+ different event types",
                        "Dispatching to type [0-9]+",
                        "\\[(Sensor|Motor|Status|Network|Storage) Handler\\] Processing event type [0-9]*",
                        "Final Handler Statistics",
                        "Function dispatch demonstration complete"
                    ],
                    "stdout": [
                        "PASS: All declarations found",
                        "SUCCESS: Multi-module dispatch test completed",
                        "PASS: Core module loaded",
                        "PASS: System initialized",
                        "PASS: Multiple handler modules registered",
                        "PASS: External module functions called via function pointers",
                        "PASS: Statistics tracking working",
                        "PASS: All multi-module external handler validation successful"
                    ]
                },
                "timeout": 30
            }
        }
    ]
});


// Problem 22: Pointer Arithmetic - Buffer Navigation Fundamentals
generatedTestDefinitions.set(22, {
    "name": "Pointer Arithmetic - Buffer Navigation Fundamentals",
    "category": "foundations",
    "description": "Master pointer arithmetic fundamentals and double pointer concepts. Learn to navigate through memory buffers, advance pointers sequentially, and understand the building blocks needed for binary data processing in Problem 22.",
    "exactRequirements": {
        "functionNames": [
            "pointer_arithmetic_init",
            "pointer_arithmetic_exit",
            "advance_pointer",
            "read_uint32_and_advance",
            "read_uint16_and_advance",
            "traverse_buffer",
            "print_buffer_status"
        ],
        "variables": [
            {
                "name": "current_position",
                "type": "uint8_t *",
                "value": "NULL",
                "storageClass": "none"
            },
            {
                "name": "total_bytes_read",
                "type": "int",
                "value": "0",
                "storageClass": "none"
            }
        ],
        "outputMessages": [
            "Pointer arithmetic module loaded",
            "Starting pointer arithmetic demonstration",
            "Test 1: Reading uint32_t from buffer",
            "Read uint32_t: 1",
            "Test 2: Reading uint16_t from buffer",
            "Read uint16_t: 255",
            "Test 3: Advancing pointer by 4 bytes",
            "Test 4: Traversing entire buffer",
            "Position 0: 0x01",
            "Position 1: 0x00",
            "Pointer arithmetic demonstration completed",
            "Pointer arithmetic module unloaded"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "*ptr += bytes",
            "*(uint32_t*)(*ptr)",
            "*ptr += 4",
            "*(uint16_t*)(*ptr)",
            "*ptr += 2",
            "uint8_t *buffer_ptr = buffer",
            "buffer_ptr++",
            "read_uint32_and_advance(&current_position)",
            "read_uint16_and_advance(&current_position)",
            "advance_pointer(&current_position",
            "module_param(test_advance_bytes, int, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void advance_pointer(uint8_t **ptr, int bytes)",
                "uint32_t read_uint32_and_advance(uint8_t **ptr)",
                "uint16_t read_uint16_and_advance(uint8_t **ptr)",
                "void traverse_buffer(uint8_t *buffer, size_t size)",
                "void print_buffer_status(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void advance_pointer(uint8_t **ptr, int bytes)",
                "uint32_t read_uint32_and_advance(uint8_t **ptr)",
                "uint16_t read_uint16_and_advance(uint8_t **ptr)",
                "void traverse_buffer(uint8_t *buffer, size_t size)",
                "void print_buffer_status(void)",
                "static int __init pointer_arithmetic_init(void)",
                "static void __exit pointer_arithmetic_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Pointer arithmetic module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init pointer_arithmetic_init(void)"
                },
                {
                    "pattern": "Starting pointer arithmetic demonstration",
                    "exact": true,
                    "linkedFunction": "static int __init pointer_arithmetic_init(void)"
                },
                {
                    "pattern": "Test 1: Reading uint32_t from buffer",
                    "exact": true,
                    "linkedFunction": "static int __init pointer_arithmetic_init(void)"
                },
                {
                    "pattern": "Read uint32_t: 1",
                    "exact": true,
                    "linkedFunction": "uint32_t read_uint32_and_advance(uint8_t **ptr)"
                },
                {
                    "pattern": "Test 2: Reading uint16_t from buffer",
                    "exact": true,
                    "linkedFunction": "static int __init pointer_arithmetic_init(void)"
                },
                {
                    "pattern": "Read uint16_t: 255",
                    "exact": true,
                    "linkedFunction": "uint16_t read_uint16_and_advance(uint8_t **ptr)"
                },
                {
                    "pattern": "Test 3: Advancing pointer by 4 bytes",
                    "exact": true,
                    "linkedFunction": "static int __init pointer_arithmetic_init(void)"
                },
                {
                    "pattern": "Test 4: Traversing entire buffer",
                    "exact": true,
                    "linkedFunction": "static int __init pointer_arithmetic_init(void)"
                },
                {
                    "pattern": "Position 0: 0x01",
                    "exact": true,
                    "linkedFunction": "void traverse_buffer(uint8_t *buffer, size_t size)"
                },
                {
                    "pattern": "Position 1: 0x00",
                    "exact": true,
                    "linkedFunction": "void traverse_buffer(uint8_t *buffer, size_t size)"
                },
                {
                    "pattern": "Pointer arithmetic demonstration completed",
                    "exact": true,
                    "linkedFunction": "static int __init pointer_arithmetic_init(void)"
                },
                {
                    "pattern": "Pointer arithmetic module unloaded",
                    "exact": true,
                    "linkedFunction": "static void __exit pointer_arithmetic_exit(void)"
                }
            ]
        },
        {
            "id": "advanced_pointer_arithmetic_validation",
            "name": "Advanced Pointer Arithmetic with Anti-Hardcoding Protection",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "pointer_arithmetic_dynamic_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Anti-Hardcoding Pointer Arithmetic Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate unpredictable test values\\n    int random_advance_bytes = (rand() % 4) + 2;  // 2-5 bytes\\n    \\n    printf(\\\"Test 1: Random pointer advancement (bytes=%d)\\\\n\\\", random_advance_bytes);\\n    \\n    // Test with random values\\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod pointer_arithmetic 2>/dev/null\\\");\\n    \\n    char cmd[256];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/pointer_arithmetic.ko test_advance_bytes=%d\\\", random_advance_bytes);\\n    printf(\\\"DEBUG: Command: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Anti-hardcoding pointer arithmetic test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting advanced pointer arithmetic implementation validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef unsigned char uint8_t;' > /tmp/linux/types.h",
                    "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
                    "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
                    "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
                    "echo '#define BUFFER_SIZE 16' >> /tmp/linux/types.h",
                    "echo 'Creating test file that includes pointer arithmetic header...'",
                    "echo '#include \"/lib/modules/pointer_arithmetic.h\"' > /tmp/test.c",
                    "echo 'int main() { uint8_t *ptr; current_position = (uint8_t*)0; advance_pointer(&ptr, 4); read_uint32_and_advance(&ptr); read_uint16_and_advance(&ptr); traverse_buffer((uint8_t*)0, 16); print_buffer_status(); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
                    "echo 'Phase 2: Anti-Hardcoding Dynamic Pointer Arithmetic Test'",
                    "/bin/pointer_arithmetic_dynamic_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Random Value Extraction and Validation'",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Extracting random test values from output...'",
                    "ADVANCE_BYTES=$(grep -o 'Random pointer advancement (bytes=[0-9]*)' /tmp/test_output.log | cut -d'=' -f2 | cut -d')' -f1)",
                    "echo 'Extracted values: ADVANCE_BYTES='$ADVANCE_BYTES",
                    "if [ -z \"$ADVANCE_BYTES\" ]; then echo 'FAIL: Could not extract random test values'; else echo 'PASS: Random values extracted successfully'; fi",
                    "echo 'Phase 4: Anti-Hardcoding Validation with Random Values'",
                    "echo 'Validating pointer advancement with random value '$ADVANCE_BYTES",
                    "dmesg | grep \"Test 3: Advancing pointer by $ADVANCE_BYTES bytes\" && echo 'PASS: Pointer advancement with random value working' || echo 'FAIL: Pointer advancement with random value broken'",
                    "echo 'Phase 5: Static Field Validation (Non-Randomized Fields)'",
                    "dmesg | grep 'Read uint32_t: 1' && echo 'PASS: uint32_t reading working' || echo 'FAIL: uint32_t reading broken'",
                    "dmesg | grep 'Read uint16_t: 255' && echo 'PASS: uint16_t reading working' || echo 'FAIL: uint16_t reading broken'",
                    "dmesg | grep 'Position 0: 0x01' && echo 'PASS: Buffer traversal working' || echo 'FAIL: Buffer traversal broken'",
                    "echo 'Phase 6: Pointer Arithmetic Logic Validation'",
                    "dmesg | grep 'Starting pointer arithmetic demonstration' && echo 'PASS: Module demonstration working' || echo 'FAIL: Module demonstration broken'",
                    "dmesg | grep 'Pointer arithmetic module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
                    "dmesg | grep 'Pointer arithmetic module unloaded' && echo 'PASS: Module cleanup working' || echo 'FAIL: Module cleanup broken'",
                    "echo 'Phase 7: Final Validation Summary'",
                    "echo 'All phases completed successfully - anti-hardcoding pointer arithmetic protection verified'",
                    "echo 'PASS: All anti-hardcoding pointer arithmetic validation successful'"
                ],
                "expected": {
                    "dmesg": [
                        "Pointer arithmetic module loaded",
                        "Starting pointer arithmetic demonstration",
                        "Test 1: Reading uint32_t from buffer",
                        "Read uint32_t: 1",
                        "Test 2: Reading uint16_t from buffer",
                        "Read uint16_t: 255",
                        "Test 3: Advancing pointer by .* bytes",
                        "Test 4: Traversing entire buffer",
                        "Position 0: 0x01",
                        "Position 1: 0x00",
                        "Pointer arithmetic demonstration completed",
                        "Pointer arithmetic module unloaded"
                    ],
                    "stdout": [
                        "PASS: All function and variable declarations found in header file",
                        "SUCCESS: Anti-hardcoding pointer arithmetic test completed",
                        "PASS: Random values extracted successfully",
                        "PASS: Pointer advancement with random value working",
                        "PASS: uint32_t reading working",
                        "PASS: uint16_t reading working",
                        "PASS: Buffer traversal working",
                        "PASS: Module demonstration working",
                        "PASS: Module initialization working",
                        "PASS: Module cleanup working",
                        "PASS: All anti-hardcoding pointer arithmetic validation successful"
                    ]
                },
                "timeout": 15
            }
        }
    ]
});


// Problem 23: STDF Binary Parser - Production Semiconductor Data Processing
generatedTestDefinitions.set(23, {
    "name": "STDF Binary Parser - Production Semiconductor Data Processing",
    "category": "foundations",
    "description": "Master STDF (Standard Test Data Format) parsing using real production patterns. Learn header/data separation, record type dispatch, and multi-record processing exactly as used in semiconductor test systems and libstdf parsers.",
    "exactRequirements": {
        "functionNames": [
            "stdf_parser_init",
            "stdf_parser_exit",
            "parse_stdf_header",
            "read_uint8_from_buffer",
            "read_uint32_from_buffer",
            "read_uint16_from_buffer",
            "read_string_from_buffer",
            "parse_ptr_record",
            "parse_mpr_record",
            "parse_stdf_record_from_buffer",
            "parse_stdf_file_buffer",
            "print_stdf_record"
        ],
        "variables": [
            {
                "name": "parsed_record",
                "type": "stdf_record *",
                "value": "NULL",
                "storageClass": "none"
            },
            {
                "name": "test_buffer",
                "type": "uint8_t *",
                "value": "NULL",
                "storageClass": "none"
            }
        ],
        "outputMessages": [
            "STDF parser module loaded",
            "Created STDF buffer: type=0x15, test_num=1001, result=255",
            "STDF Record Header:",
            "Record Length: 26",
            "Record Type: 0x15",
            "Record Subtype: 0x10",
            "PTR Record Fields:",
            "TEST_NUM: 1001",
            "HEAD_NUM: 1",
            "SITE_NUM: 1",
            "TEST_FLG: 0x00",
            "RESULT: 255",
            "TEST_TXT: Voltage_Test",
            "STDF Record Header:",
            "Record Length: 22",
            "Record Type: 0x16",
            "Record Subtype: 0x10",
            "MPR Record Fields:",
            "TEST_NUM: 1002",
            "HEAD_NUM: 1",
            "SITE_NUM: 1",
            "RTN_ICNT: 3",
            "RTN_RSLT[0]: 100",
            "RTN_RSLT[1]: 101",
            "RTN_RSLT[2]: 102",
            "STDF Record Header:",
            "Record Length: 27",
            "Record Type: 0x15",
            "Record Subtype: 0x10",
            "PTR Record Fields:",
            "TEST_NUM: 1003",
            "HEAD_NUM: 1",
            "SITE_NUM: 1",
            "TEST_FLG: 0x00",
            "RESULT: 256",
            "TEST_TXT: Current_Test2",
            "STDF file processing complete: 3 records parsed",
            "STDF parser module unloaded"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h",
            "linux/slab.h",
            "linux/string.h"
        ],
        "mustContain": [
            "parse_stdf_header(&buffer_pos)",
            "read_uint8_from_buffer(&buffer_pos)",
            "*(uint32_t*)(*buffer_ptr)",
            "*buffer_ptr += 4",
            "*(uint16_t*)(*buffer_ptr)",
            "*buffer_ptr += 2",
            "switch (record->header.rec_type)",
            "case REC_PTR:",
            "case REC_MPR:",
            "record->data",
            "kmalloc",
            "kfree",
            "while (current_pos < buffer_end)",
            "current_pos += 4 + record->header.rec_length",
            "parse_stdf_file_buffer(test_buffer, buffer_size)",
            "module_param(test_record_type, int, 0644)",
            "module_param(test_num, int, 0644)",
            "module_param(test_result, int, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "stdf_header* parse_stdf_header(uint8_t **buffer_ptr)",
                "uint8_t read_uint8_from_buffer(uint8_t **buffer_ptr)",
                "uint32_t read_uint32_from_buffer(uint8_t **buffer_ptr)",
                "uint16_t read_uint16_from_buffer(uint8_t **buffer_ptr)",
                "char* read_string_from_buffer(uint8_t **buffer_ptr, uint8_t *out_length)",
                "ptr_record* parse_ptr_record(uint8_t *data, uint16_t length)",
                "mpr_record* parse_mpr_record(uint8_t *data, uint16_t length)",
                "stdf_record* parse_stdf_record_from_buffer(uint8_t *raw_buffer)",
                "int parse_stdf_file_buffer(uint8_t *buffer, size_t total_size)",
                "void print_stdf_record(stdf_record *record)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "stdf_header* parse_stdf_header(uint8_t **buffer_ptr)",
                "uint8_t read_uint8_from_buffer(uint8_t **buffer_ptr)",
                "uint32_t read_uint32_from_buffer(uint8_t **buffer_ptr)",
                "uint16_t read_uint16_from_buffer(uint8_t **buffer_ptr)",
                "char* read_string_from_buffer(uint8_t **buffer_ptr, uint8_t *out_length)",
                "ptr_record* parse_ptr_record(uint8_t *data, uint16_t length)",
                "mpr_record* parse_mpr_record(uint8_t *data, uint16_t length)",
                "stdf_record* parse_stdf_record_from_buffer(uint8_t *raw_buffer)",
                "int parse_stdf_file_buffer(uint8_t *buffer, size_t total_size)",
                "void print_stdf_record(stdf_record *record)",
                "static int __init stdf_parser_init(void)",
                "static void __exit stdf_parser_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "STDF parser module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init stdf_parser_init(void)"
                },
                {
                    "pattern": "Created STDF buffer: type=0x15, test_num=1001, result=255",
                    "exact": true,
                    "linkedFunction": "static int __init stdf_parser_init(void)"
                },
                {
                    "pattern": "STDF Record Header:",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "Record Length: 26",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "Record Type: 0x15",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "Record Subtype: 0x10",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "PTR Record Fields:",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "TEST_NUM: 1001",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "HEAD_NUM: 1",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "SITE_NUM: 1",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "TEST_FLG: 0x00",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "RESULT: 255",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "TEST_TXT: Voltage_Test",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "STDF Record Header:",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "Record Length: 22",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "Record Type: 0x16",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "Record Subtype: 0x10",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "MPR Record Fields:",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "TEST_NUM: 1002",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "HEAD_NUM: 1",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "SITE_NUM: 1",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "RTN_ICNT: 3",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "RTN_RSLT[0]: 100",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "RTN_RSLT[1]: 101",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "RTN_RSLT[2]: 102",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "STDF Record Header:",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "Record Length: 27",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "Record Type: 0x15",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "Record Subtype: 0x10",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "PTR Record Fields:",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "TEST_NUM: 1003",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "HEAD_NUM: 1",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "SITE_NUM: 1",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "TEST_FLG: 0x00",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "RESULT: 256",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "TEST_TXT: Current_Test2",
                    "exact": true,
                    "linkedFunction": "void print_stdf_record(stdf_record *record)"
                },
                {
                    "pattern": "STDF file processing complete: 3 records parsed",
                    "exact": true,
                    "linkedFunction": "static int __init stdf_parser_init(void)"
                },
                {
                    "pattern": "STDF parser module unloaded",
                    "exact": true,
                    "linkedFunction": "static void __exit stdf_parser_exit(void)"
                }
            ]
        },
        {
            "id": "advanced_stdf_parsing_validation",
            "name": "Advanced STDF Parsing with Anti-Hardcoding Protection",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "stdf_parsing_dynamic_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Anti-Hardcoding STDF Parsing Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate unpredictable test values\\n    int random_record_type = (rand() % 2) ? 0x15 : 0x16;  // PTR or MPR\\n    int random_test_num = (rand() % 9000) + 1000;         // 1000-9999\\n    int random_result = (rand() % 500) + 100;             // 100-599\\n    \\n    printf(\\\"Test 1: Random STDF parsing (type=0x%02x, test_num=%d, result=%d)\\\\n\\\", random_record_type, random_test_num, random_result);\\n    \\n    // Test with random values\\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod stdf_parser 2>/dev/null\\\");\\n    \\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/stdf_parser.ko test_record_type=%d test_num=%d test_result=%d\\\", random_record_type, random_test_num, random_result);\\n    printf(\\\"DEBUG: Command: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Anti-hardcoding STDF parsing test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting advanced STDF parsing implementation validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef unsigned char uint8_t;' > /tmp/linux/types.h",
                    "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
                    "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
                    "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
                    "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
                    "echo '#define MAX_RESULTS 8' >> /tmp/linux/types.h",
                    "echo '#define REC_PTR 0x15' >> /tmp/linux/types.h",
                    "echo '#define REC_MPR 0x16' >> /tmp/linux/types.h",
                    "echo 'void* kmalloc(size_t size, int flags);' > /tmp/linux/slab.h",
                    "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
                    "echo '#define GFP_KERNEL 0' >> /tmp/linux/slab.h",
                    "echo 'void* memcpy(void *dest, const void *src, size_t n);' >> /tmp/linux/slab.h",
                    "echo 'size_t strlen(const char *s);' >> /tmp/linux/slab.h",
                    "echo 'void* memcpy(void *dest, const void *src, size_t n);' > /tmp/linux/string.h",
                    "echo 'size_t strlen(const char *s);' >> /tmp/linux/string.h",
                    "echo 'char* strcpy(char *dest, const char *src);' >> /tmp/linux/string.h",
                    "echo 'Creating test file that includes STDF parsing header...'",
                    "echo '#include \"/lib/modules/stdf_parser.h\"' > /tmp/test.c",
                    "echo 'int main() { uint8_t *buf; uint8_t len; size_t size = 89; parsed_record = (stdf_record*)0; parse_stdf_header(&buf); read_uint8_from_buffer(&buf); read_uint32_from_buffer(&buf); read_uint16_from_buffer(&buf); read_string_from_buffer(&buf, &len); parse_ptr_record(buf, 26); parse_mpr_record(buf, 22); parse_stdf_record_from_buffer(buf); parse_stdf_file_buffer(buf, size); print_stdf_record((stdf_record*)0); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
                    "echo 'Phase 2: Anti-Hardcoding Dynamic STDF Parsing Test'",
                    "/bin/stdf_parsing_dynamic_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Random Value Extraction and Validation'",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Extracting random test values from output...'",
                    "RECORD_TYPE=$(grep -o 'Random STDF parsing (type=0x[0-9a-f]*' /tmp/test_output.log | cut -d'=' -f2)",
                    "TEST_NUM=$(grep -o 'test_num=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
                    "RESULT=$(grep -o 'result=[0-9]*)' /tmp/test_output.log | cut -d'=' -f2 | cut -d')' -f1)",
                    "echo 'Extracted values: RECORD_TYPE='$RECORD_TYPE', TEST_NUM='$TEST_NUM', RESULT='$RESULT",
                    "if [ -z \"$RECORD_TYPE\" ] || [ -z \"$TEST_NUM\" ] || [ -z \"$RESULT\" ]; then echo 'FAIL: Could not extract random test values'; else echo 'PASS: Random values extracted successfully'; fi",
                    "echo 'Phase 4: Anti-Hardcoding Validation with Random Values'",
                    "echo 'Validating STDF record type parsing with random value '$RECORD_TYPE",
                    "dmesg | grep \"Record Type: $RECORD_TYPE\" && echo 'PASS: STDF record type parsing with random value working' || echo 'FAIL: STDF record type parsing with random value broken'",
                    "echo 'Validating TEST_NUM parsing with random value '$TEST_NUM",
                    "dmesg | grep \"TEST_NUM: $TEST_NUM\" && echo 'PASS: TEST_NUM parsing with random value working' || echo 'FAIL: TEST_NUM parsing with random value broken'",
                    "echo 'Validating RESULT parsing with random value '$RESULT",
                    "dmesg | grep \"RESULT: $RESULT\" && echo 'PASS: RESULT parsing with random value working' || echo 'FAIL: RESULT parsing with random value broken'",
                    "echo 'Phase 5: Static Field Validation (Non-Randomized Fields)'",
                    "dmesg | grep 'STDF Record Header:' && echo 'PASS: STDF header parsing working' || echo 'FAIL: STDF header parsing broken'",
                    "dmesg | grep 'HEAD_NUM: 1' && echo 'PASS: HEAD_NUM parsing working' || echo 'FAIL: HEAD_NUM parsing broken'",
                    "dmesg | grep 'SITE_NUM: 1' && echo 'PASS: SITE_NUM parsing working' || echo 'FAIL: SITE_NUM parsing broken'",
                    "echo 'Phase 6: STDF Architecture Validation'",
                    "dmesg | grep 'PTR Record Fields:' && echo 'PASS: PTR record dispatch working' || echo 'FAIL: PTR record dispatch broken'",
                    "dmesg | grep 'MPR Record Fields:' && echo 'PASS: MPR record dispatch working' || echo 'FAIL: MPR record dispatch broken'",
                    "dmesg | grep 'RTN_ICNT: 3' && echo 'PASS: MPR array count parsing working' || echo 'FAIL: MPR array count parsing broken'",
                    "dmesg | grep 'RTN_RSLT\\[0\\]: 100' && echo 'PASS: MPR array element parsing working' || echo 'FAIL: MPR array element parsing broken'",
                    "dmesg | grep 'STDF file processing complete: 3 records parsed' && echo 'PASS: Multi-record processing working' || echo 'FAIL: Multi-record processing broken'",
                    "dmesg | grep 'STDF parser module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
                    "dmesg | grep 'STDF parser module unloaded' && echo 'PASS: Module cleanup working' || echo 'FAIL: Module cleanup broken'",
                    "echo 'Phase 7: Final Validation Summary'",
                    "echo 'All phases completed successfully - anti-hardcoding STDF parsing protection verified'",
                    "echo 'PASS: All anti-hardcoding STDF parsing validation successful'"
                ],
                "expected": {
                    "dmesg": [
                        "STDF parser module loaded",
                        "Created STDF buffer: type=.*, test_num=.*, result=.*",
                        "STDF Record Header:",
                        "Record Length: .*",
                        "Record Type: .*",
                        "Record Subtype: .*",
                        "PTR Record Fields:",
                        "TEST_NUM: .*",
                        "HEAD_NUM: .*",
                        "SITE_NUM: .*",
                        "TEST_FLG: .*",
                        "RESULT: .*",
                        "TEST_TXT: .*",
                        "MPR Record Fields:",
                        "RTN_ICNT: .*",
                        "RTN_RSLT\\[.*\\]: .*",
                        "STDF file processing complete: .* records parsed",
                        "STDF parser module unloaded"
                    ],
                    "stdout": [
                        "PASS: All function and variable declarations found in header file",
                        "SUCCESS: Anti-hardcoding STDF parsing test completed",
                        "PASS: Random values extracted successfully",
                        "PASS: STDF record type parsing with random value working",
                        "PASS: TEST_NUM parsing with random value working",
                        "PASS: RESULT parsing with random value working",
                        "PASS: STDF header parsing working",
                        "PASS: HEAD_NUM parsing working",
                        "PASS: SITE_NUM parsing working",
                        "PASS: PTR record dispatch working",
                        "PASS: MPR record dispatch working",
                        "PASS: MPR array count parsing working",
                        "PASS: MPR array element parsing working",
                        "PASS: Multi-record processing working",
                        "PASS: Module initialization working",
                        "PASS: Module cleanup working",
                        "PASS: All anti-hardcoding STDF parsing validation successful"
                    ]
                },
                "timeout": 15
            }
        }
    ]
});


// Problem 24: Preprocessor Macros - Kernel-Style Code Generation
generatedTestDefinitions.set(24, {
    "name": "Preprocessor Macros - Kernel-Style Code Generation",
    "category": "foundations",
    "description": "Master essential preprocessor macros for kernel development. Learn #define constants, bit flag macros, function-like macros, and conditional compilation patterns used throughout Linux kernel code.",
    "exactRequirements": {
        "functionNames": [
            "macro_processor_init",
            "macro_processor_exit",
            "test_macro_constants",
            "test_version_and_flags",
            "test_conditional_compilation",
            "print_device_info"
        ],
        "variables": [
            {
                "name": "test_device",
                "type": "device_info",
                "storageClass": "none"
            }
        ],
        "outputMessages": [
            "Macro processor module loaded",
            "Testing macro constants:",
            "DEVICE_TYPE_SENSOR = 1",
            "DEVICE_TYPE_MOTOR = 2",
            "MAX_DEVICE_NAME = 32",
            "Testing bit flags and version:",
            "STATUS_ONLINE = 0x01",
            "STATUS_READY = 0x02",
            "Created version:",
            "Combined flags: 0x03",
            "Testing conditional compilation:",
            "Debug mode is enabled",
            "Device: Temperature Sensor",
            "Macro demonstration completed",
            "Macro processor module unloaded"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "#define DEVICE_TYPE_SENSOR 1",
            "#define DEVICE_TYPE_MOTOR 2",
            "#define STATUS_ONLINE (1 << 0)",
            "#define STATUS_READY (1 << 1)",
            "#define MAX_DEVICE_NAME 32",
            "#define MAKE_VERSION(major, minor) (((major) << 16) | (minor))",
            "#ifdef DEBUG_MODE",
            "#define DEBUG_PRINT(fmt, ...) printk(KERN_DEBUG fmt, ##__VA_ARGS__)",
            "#else",
            "#define DEBUG_PRINT(fmt, ...)",
            "#endif",
            "MAKE_VERSION(test_major_version, test_minor_version)",
            "DEBUG_PRINT(",
            "STATUS_ONLINE | STATUS_READY",
            "module_param(test_device_type, int, 0644)",
            "module_param(test_major_version, int, 0644)",
            "module_param(test_minor_version, int, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void test_macro_constants(void)",
                "void test_version_and_flags(void)",
                "void test_conditional_compilation(void)",
                "void print_device_info(device_info *device)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "macro_definitions",
            "name": "Macro Definitions in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "#define DEVICE_TYPE_SENSOR 1",
                "#define DEVICE_TYPE_MOTOR 2",
                "#define STATUS_ONLINE (1 << 0)",
                "#define STATUS_READY (1 << 1)",
                "#define MAX_DEVICE_NAME 32",
                "#define MAKE_VERSION",
                "#define DEBUG_PRINT"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void test_macro_constants(void)",
                "void test_version_and_flags(void)",
                "void test_conditional_compilation(void)",
                "void print_device_info(device_info *device)",
                "static int __init macro_processor_init(void)",
                "static void __exit macro_processor_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Macro processor module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init macro_processor_init(void)"
                },
                {
                    "pattern": "Testing macro constants:",
                    "exact": true,
                    "linkedFunction": "void test_macro_constants(void)"
                },
                {
                    "pattern": "DEVICE_TYPE_SENSOR = 1",
                    "exact": true,
                    "linkedFunction": "void test_macro_constants(void)"
                },
                {
                    "pattern": "DEVICE_TYPE_MOTOR = 2",
                    "exact": true,
                    "linkedFunction": "void test_macro_constants(void)"
                },
                {
                    "pattern": "MAX_DEVICE_NAME = 32",
                    "exact": true,
                    "linkedFunction": "void test_macro_constants(void)"
                },
                {
                    "pattern": "Testing bit flags and version:",
                    "exact": true,
                    "linkedFunction": "void test_version_and_flags(void)"
                },
                {
                    "pattern": "STATUS_ONLINE = 0x01",
                    "exact": true,
                    "linkedFunction": "void test_version_and_flags(void)"
                },
                {
                    "pattern": "STATUS_READY = 0x02",
                    "exact": true,
                    "linkedFunction": "void test_version_and_flags(void)"
                },
                {
                    "pattern": "Combined flags: 0x03",
                    "exact": true,
                    "linkedFunction": "void test_version_and_flags(void)"
                },
                {
                    "pattern": "Testing conditional compilation:",
                    "exact": true,
                    "linkedFunction": "void test_conditional_compilation(void)"
                },
                {
                    "pattern": "Debug mode is enabled",
                    "exact": true,
                    "linkedFunction": "void test_conditional_compilation(void)"
                },
                {
                    "pattern": "Device: Temperature Sensor",
                    "exact": true,
                    "linkedFunction": "void print_device_info(device_info *device)"
                },
                {
                    "pattern": "Macro demonstration completed",
                    "exact": true,
                    "linkedFunction": "static int __init macro_processor_init(void)"
                },
                {
                    "pattern": "Macro processor module unloaded",
                    "exact": true,
                    "linkedFunction": "static void __exit macro_processor_exit(void)"
                }
            ]
        },
        {
            "id": "simplified_macro_validation",
            "name": "Simplified Macro Processing with Anti-Hardcoding Protection",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "macro_dynamic_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Macro Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate test values\\n    int random_device_type = ((rand() % 2) + 1);  // 1 or 2\\n    int random_major = (rand() % 5) + 1;          // 1-5\\n    int random_minor = (rand() % 10) + 1;         // 1-10\\n    \\n    printf(\\\"Random macro test (device=%d, ver=%d.%d)\\\\n\\\", random_device_type, random_major, random_minor);\\n    \\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod macro_processor 2>/dev/null\\\");\\n    \\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/macro_processor.ko test_device_type=%d test_major_version=%d test_minor_version=%d\\\", random_device_type, random_major, random_minor);\\n    printf(\\\"DEBUG: Command: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Macro test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting simplified macro validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: TCC Header Validation'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define KERN_DEBUG' >> /tmp/linux/kernel.h",
                    "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef unsigned char uint8_t;' > /tmp/linux/types.h",
                    "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
                    "echo '#include \"/lib/modules/macro_processor.h\"' > /tmp/test.c",
                    "echo 'int main() { device_info dev; test_macro_constants(); test_version_and_flags(); test_conditional_compilation(); print_device_info(&dev); return 0; }' >> /tmp/test.c",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or macro definition missing'; cat /tmp/tcc_error.log; else echo 'PASS: All declarations found in header'; fi",
                    "echo 'Phase 2: Dynamic Macro Test'",
                    "/bin/macro_dynamic_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Macro Validation'",
                    "sleep 1",
                    "dmesg | grep 'DEVICE_TYPE_SENSOR = 1' && echo 'PASS: Device constants working' || echo 'FAIL: Device constants broken'",
                    "dmesg | grep 'STATUS_ONLINE = 0x01' && echo 'PASS: Bit flags working' || echo 'FAIL: Bit flags broken'",
                    "dmesg | grep 'Combined flags: 0x03' && echo 'PASS: Flag combination working' || echo 'FAIL: Flag combination broken'",
                    "dmesg | grep 'Debug mode is enabled' && echo 'PASS: Conditional compilation working' || echo 'FAIL: Conditional compilation broken'",
                    "dmesg | grep 'Testing macro constants:' && echo 'PASS: Constant testing working' || echo 'FAIL: Constant testing broken'",
                    "dmesg | grep 'Testing bit flags and version:' && echo 'PASS: Version testing working' || echo 'FAIL: Version testing broken'",
                    "dmesg | grep 'Macro processor module loaded' && echo 'PASS: Module loading working' || echo 'FAIL: Module loading broken'",
                    "echo 'PASS: All macro validation successful'"
                ],
                "expected": {
                    "dmesg": [
                        "Macro processor module loaded",
                        "Testing macro constants:",
                        "DEVICE_TYPE_SENSOR = 1",
                        "DEVICE_TYPE_MOTOR = 2",
                        "MAX_DEVICE_NAME = 32",
                        "Testing bit flags and version:",
                        "STATUS_ONLINE = 0x01",
                        "STATUS_READY = 0x02",
                        "Created version: .*",
                        "Combined flags: 0x03",
                        "Testing conditional compilation:",
                        "Debug mode is enabled",
                        "Device: Temperature Sensor",
                        "Macro demonstration completed",
                        "Macro processor module unloaded"
                    ],
                    "stdout": [
                        "PASS: All declarations found in header",
                        "SUCCESS: Macro test completed",
                        "PASS: Device constants working",
                        "PASS: Bit flags working",
                        "PASS: Flag combination working",
                        "PASS: Conditional compilation working",
                        "PASS: Constant testing working",
                        "PASS: Version testing working",
                        "PASS: Module loading working",
                        "PASS: All macro validation successful"
                    ]
                },
                "timeout": 15
            }
        }
    ]
});


// Problem 25: Enums and X-Macros - Managing Related Constants
generatedTestDefinitions.set(25, {
    "name": "Enums and X-Macros - Managing Related Constants",
    "category": "foundations",
    "description": "Master enums for grouped constants and X-macros for sophisticated code generation. Learn to define data once and generate multiple related structures automatically - a powerful pattern used throughout Linux kernel development.",
    "exactRequirements": {
        "functionNames": [
            "enum_processor_init",
            "enum_processor_exit",
            "test_basic_enums",
            "test_manual_approach",
            "test_xmacro_generation",
            "demonstrate_synchronization",
            "print_device_config"
        ],
        "variables": [
            {
                "name": "test_config",
                "type": "device_config",
                "storageClass": "none"
            },
            {
                "name": "device_type_names",
                "type": "const char*",
                "value": "[]",
                "storageClass": "none"
            },
            {
                "name": "device_type_ids",
                "type": "const uint16_t",
                "value": "[]",
                "storageClass": "none"
            },
            {
                "name": "xmacro_device_names",
                "type": "const char*",
                "value": "[]",
                "storageClass": "none"
            },
            {
                "name": "xmacro_device_ids",
                "type": "const uint16_t",
                "value": "[]",
                "storageClass": "none"
            }
        ],
        "outputMessages": [
            "Enum processor module loaded",
            "Testing enum and X-macro concepts",
            "Testing basic enums:",
            "DEVICE_OFFLINE = 0",
            "DEVICE_ONLINE = 1",
            "DEVICE_ERROR = 2",
            "PRIORITY_LOW = 1",
            "PRIORITY_MEDIUM = 5",
            "PRIORITY_HIGH = 10",
            "Testing manual approach:",
            "TYPE_SENSOR name:",
            "TYPE_MOTOR name:",
            "TYPE_LED name:",
            "TYPE_SENSOR ID:",
            "TYPE_MOTOR ID:",
            "Testing X-macro generation:",
            "XDEV_SENSOR = 0",
            "XDEV_MOTOR = 1",
            "XDEV_LED = 2",
            "XDEV_DISPLAY = 3",
            "XDEV_SENSOR name:",
            "XDEV_DISPLAY name:",
            "XDEV_SENSOR ID:",
            "XDEV_DISPLAY ID:",
            "Demonstrating automatic synchronization:",
            "Total devices in X-macro table:",
            "Selected device type",
            "Device name:",
            "Device ID:",
            "Device Configuration:",
            "Enum and X-macro demonstration completed",
            "Enum processor module unloaded"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "enum device_state",
            "DEVICE_OFFLINE",
            "DEVICE_ONLINE",
            "DEVICE_ERROR",
            "enum priority",
            "PRIORITY_LOW = 1",
            "PRIORITY_MEDIUM = 5",
            "PRIORITY_HIGH = 10",
            "enum device_type",
            "TYPE_SENSOR",
            "TYPE_MOTOR",
            "TYPE_LED",
            "#define DEVICE_TABLE(X)",
            "X(SENSOR,",
            "X(MOTOR,",
            "X(LED,",
            "X(DISPLAY,",
            "enum xmacro_device_type",
            "#define MAKE_ENUM(name, desc, id) XDEV_##name,",
            "DEVICE_TABLE(MAKE_ENUM)",
            "#undef MAKE_ENUM",
            "xmacro_device_names",
            "#define MAKE_STRING(name, desc, id) desc,",
            "DEVICE_TABLE(MAKE_STRING)",
            "#undef MAKE_STRING",
            "xmacro_device_ids",
            "#define MAKE_ID(name, desc, id) id,",
            "DEVICE_TABLE(MAKE_ID)",
            "#undef MAKE_ID",
            "device_type_names[TYPE_SENSOR]",
            "device_type_ids[TYPE_SENSOR]",
            "xmacro_device_names[XDEV_SENSOR]",
            "xmacro_device_ids[XDEV_SENSOR]",
            "sizeof(xmacro_device_names)",
            "module_param(test_device_type, int, 0644)",
            "module_param(test_priority, int, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void test_basic_enums(void)",
                "void test_manual_approach(void)",
                "void test_xmacro_generation(void)",
                "void demonstrate_synchronization(void)",
                "void print_device_config(device_config *config)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "enum_definitions",
            "name": "Enum Definitions in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "enum device_state",
                "enum priority",
                "enum device_type",
                "enum xmacro_device_type",
                "DEVICE_OFFLINE",
                "DEVICE_ONLINE",
                "DEVICE_ERROR",
                "PRIORITY_LOW",
                "PRIORITY_MEDIUM",
                "PRIORITY_HIGH",
                "TYPE_SENSOR",
                "TYPE_MOTOR",
                "TYPE_LED",
                "XDEV_SENSOR",
                "XDEV_MOTOR",
                "XDEV_LED",
                "XDEV_DISPLAY"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "xmacro_patterns",
            "name": "X-Macro Pattern Implementation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "#define DEVICE_TABLE(X)",
                "#define MAKE_ENUM",
                "DEVICE_TABLE(MAKE_ENUM)",
                "#undef MAKE_ENUM",
                "#define MAKE_STRING",
                "DEVICE_TABLE(MAKE_STRING)",
                "#undef MAKE_STRING",
                "#define MAKE_ID",
                "DEVICE_TABLE(MAKE_ID)",
                "#undef MAKE_ID"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void test_basic_enums(void)",
                "void test_manual_approach(void)",
                "void test_xmacro_generation(void)",
                "void demonstrate_synchronization(void)",
                "void print_device_config(device_config *config)",
                "static int __init enum_processor_init(void)",
                "static void __exit enum_processor_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Enum processor module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init enum_processor_init(void)"
                },
                {
                    "pattern": "Testing enum and X-macro concepts",
                    "exact": true,
                    "linkedFunction": "static int __init enum_processor_init(void)"
                },
                {
                    "pattern": "Testing basic enums:",
                    "exact": true,
                    "linkedFunction": "void test_basic_enums(void)"
                },
                {
                    "pattern": "DEVICE_OFFLINE = 0",
                    "exact": true,
                    "linkedFunction": "void test_basic_enums(void)"
                },
                {
                    "pattern": "DEVICE_ONLINE = 1",
                    "exact": true,
                    "linkedFunction": "void test_basic_enums(void)"
                },
                {
                    "pattern": "DEVICE_ERROR = 2",
                    "exact": true,
                    "linkedFunction": "void test_basic_enums(void)"
                },
                {
                    "pattern": "PRIORITY_LOW = 1",
                    "exact": true,
                    "linkedFunction": "void test_basic_enums(void)"
                },
                {
                    "pattern": "PRIORITY_MEDIUM = 5",
                    "exact": true,
                    "linkedFunction": "void test_basic_enums(void)"
                },
                {
                    "pattern": "PRIORITY_HIGH = 10",
                    "exact": true,
                    "linkedFunction": "void test_basic_enums(void)"
                },
                {
                    "pattern": "Testing manual approach:",
                    "exact": true,
                    "linkedFunction": "void test_manual_approach(void)"
                },
                {
                    "pattern": "Testing X-macro generation:",
                    "exact": true,
                    "linkedFunction": "void test_xmacro_generation(void)"
                },
                {
                    "pattern": "XDEV_SENSOR = 0",
                    "exact": true,
                    "linkedFunction": "void test_xmacro_generation(void)"
                },
                {
                    "pattern": "XDEV_MOTOR = 1",
                    "exact": true,
                    "linkedFunction": "void test_xmacro_generation(void)"
                },
                {
                    "pattern": "XDEV_LED = 2",
                    "exact": true,
                    "linkedFunction": "void test_xmacro_generation(void)"
                },
                {
                    "pattern": "XDEV_DISPLAY = 3",
                    "exact": true,
                    "linkedFunction": "void test_xmacro_generation(void)"
                },
                {
                    "pattern": "Demonstrating automatic synchronization:",
                    "exact": true,
                    "linkedFunction": "void demonstrate_synchronization(void)"
                },
                {
                    "pattern": "Device Configuration:",
                    "exact": true,
                    "linkedFunction": "void print_device_config(device_config *config)"
                },
                {
                    "pattern": "Enum and X-macro demonstration completed",
                    "exact": true,
                    "linkedFunction": "static int __init enum_processor_init(void)"
                },
                {
                    "pattern": "Enum processor module unloaded",
                    "exact": true,
                    "linkedFunction": "static void __exit enum_processor_exit(void)"
                }
            ]
        },
        {
            "id": "enum_xmacro_validation",
            "name": "Enum and X-Macro Dynamic Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "enum_dynamic_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Enum and X-Macro Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate test values\\n    int random_device_type = (rand() % 3);     // 0, 1, or 2 (TYPE_SENSOR, TYPE_MOTOR, TYPE_LED)\\n    int random_priority = ((rand() % 3) == 0) ? 1 : ((rand() % 3) == 1) ? 5 : 10;  // 1, 5, or 10\\n    \\n    printf(\\\"Random enum test (device=%d, priority=%d)\\\\n\\\", random_device_type, random_priority);\\n    \\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod enum_processor 2>/dev/null\\\");\\n    \\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/enum_processor.ko test_device_type=%d test_priority=%d\\\", random_device_type, random_priority);\\n    printf(\\\"DEBUG: Command: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Enum test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting enum and X-macro validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: TCC Header Validation'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef unsigned char uint8_t;' > /tmp/linux/types.h",
                    "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
                    "echo '#include \"/lib/modules/enum_processor.h\"' > /tmp/test.c",
                    "echo 'int main() { device_config config; test_basic_enums(); test_manual_approach(); test_xmacro_generation(); demonstrate_synchronization(); print_device_config(&config); return 0; }' >> /tmp/test.c",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or enum definition missing'; cat /tmp/tcc_error.log; else echo 'PASS: All declarations found in header'; fi",
                    "echo 'Phase 2: Dynamic Enum Test'",
                    "/bin/enum_dynamic_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Enum and X-Macro Validation'",
                    "sleep 1",
                    "dmesg | grep 'DEVICE_OFFLINE = 0' && echo 'PASS: Basic enum values working' || echo 'FAIL: Basic enum values broken'",
                    "dmesg | grep 'PRIORITY_LOW = 1' && echo 'PASS: Custom enum values working' || echo 'FAIL: Custom enum values broken'",
                    "dmesg | grep 'PRIORITY_MEDIUM = 5' && echo 'PASS: Custom enum values working' || echo 'FAIL: Custom enum values broken'",
                    "dmesg | grep 'PRIORITY_HIGH = 10' && echo 'PASS: Custom enum values working' || echo 'FAIL: Custom enum values broken'",
                    "dmesg | grep 'XDEV_SENSOR = 0' && echo 'PASS: X-macro enum generation working' || echo 'FAIL: X-macro enum generation broken'",
                    "dmesg | grep 'XDEV_DISPLAY = 3' && echo 'PASS: X-macro enum generation working' || echo 'FAIL: X-macro enum generation broken'",
                    "dmesg | grep 'Total devices in X-macro table:' && echo 'PASS: X-macro synchronization working' || echo 'FAIL: X-macro synchronization broken'",
                    "dmesg | grep 'Testing basic enums:' && echo 'PASS: Basic enum testing working' || echo 'FAIL: Basic enum testing broken'",
                    "dmesg | grep 'Testing manual approach:' && echo 'PASS: Manual approach testing working' || echo 'FAIL: Manual approach testing broken'",
                    "dmesg | grep 'Testing X-macro generation:' && echo 'PASS: X-macro generation testing working' || echo 'FAIL: X-macro generation testing broken'",
                    "dmesg | grep 'Enum processor module loaded' && echo 'PASS: Module loading working' || echo 'FAIL: Module loading broken'",
                    "echo 'PASS: All enum and X-macro validation successful'"
                ],
                "expected": {
                    "dmesg": [
                        "Enum processor module loaded",
                        "Testing enum and X-macro concepts",
                        "Testing basic enums:",
                        "DEVICE_OFFLINE = 0",
                        "DEVICE_ONLINE = 1",
                        "DEVICE_ERROR = 2",
                        "PRIORITY_LOW = 1",
                        "PRIORITY_MEDIUM = 5",
                        "PRIORITY_HIGH = 10",
                        "Testing manual approach:",
                        "TYPE_SENSOR name: .*",
                        "TYPE_MOTOR name: .*",
                        "TYPE_LED name: .*",
                        "TYPE_SENSOR ID: .*",
                        "TYPE_MOTOR ID: .*",
                        "Testing X-macro generation:",
                        "XDEV_SENSOR = 0",
                        "XDEV_MOTOR = 1",
                        "XDEV_LED = 2",
                        "XDEV_DISPLAY = 3",
                        "XDEV_SENSOR name: .*",
                        "XDEV_DISPLAY name: .*",
                        "XDEV_SENSOR ID: .*",
                        "XDEV_DISPLAY ID: .*",
                        "Demonstrating automatic synchronization:",
                        "Total devices in X-macro table: .*",
                        "Selected device type .*",
                        "Device name: .*",
                        "Device ID: .*",
                        "Device Configuration:",
                        "Enum and X-macro demonstration completed",
                        "Enum processor module unloaded"
                    ],
                    "stdout": [
                        "PASS: All declarations found in header",
                        "SUCCESS: Enum test completed",
                        "PASS: Basic enum values working",
                        "PASS: Custom enum values working",
                        "PASS: X-macro enum generation working",
                        "PASS: X-macro synchronization working",
                        "PASS: Basic enum testing working",
                        "PASS: Manual approach testing working",
                        "PASS: X-macro generation testing working",
                        "PASS: Module loading working",
                        "PASS: All enum and X-macro validation successful"
                    ]
                },
                "timeout": 30
            }
        }
    ]
});


// Problem 26: Linked Lists - Kernel List Patterns
generatedTestDefinitions.set(26, {
    "name": "Linked Lists - Kernel List Patterns",
    "category": "foundations",
    "description": "Master linked lists through two approaches: implement basic operations manually to understand fundamentals, then use real Linux kernel list macros. Learn the essential data structure pattern used throughout kernel development.",
    "exactRequirements": {
        "functionNames": [
            "linked_lists_init",
            "linked_lists_exit",
            "manual_init_list",
            "manual_add_device",
            "manual_remove_device",
            "manual_is_empty",
            "manual_traverse_list",
            "kernel_add_device",
            "kernel_traverse_list",
            "find_device_by_id",
            "count_total_devices",
            "cleanup_all_devices"
        ],
        "variables": [
            {
                "name": "manual_device_list",
                "type": "struct list_head",
                "storageClass": "none"
            },
            {
                "name": "kernel_device_list",
                "type": "struct list_head",
                "storageClass": "none"
            }
        ],
        "outputMessages": [
            "Linked lists module loaded",
            "Testing manual list operations",
            "Manually added device: TempSensor (ID: 1001)",
            "Manually added device: MotorCtrl (ID: 1002)",
            "Manually added device: LEDStrip (ID: 1003)",
            "Manual list empty: 0",
            "Manual traversal - Device: LEDStrip (ID: 1003, Status: 0)",
            "Manual traversal - Device: MotorCtrl (ID: 1002, Status: 1)",
            "Manual traversal - Device: TempSensor (ID: 1001, Status: 1)",
            "Manually removed device: MotorCtrl (ID: 1002)",
            "Testing kernel macro operations",
            "Kernel added device: TempSensor (ID: 1001)",
            "Kernel added device: MotorCtrl (ID: 1002)",
            "Kernel added device: LEDStrip (ID: 1003)",
            "Kernel traversal - Device: LEDStrip (ID: 1003, Status: 0)",
            "Kernel traversal - Device: MotorCtrl (ID: 1002, Status: 1)",
            "Kernel traversal - Device: TempSensor (ID: 1001, Status: 1)",
            "Found device: TempSensor (ID: 1001)",
            "Total devices in kernel list: 3",
            "Linked list demonstration completed",
            "Linked lists module unloading",
            "Cleaned up device: LEDStrip",
            "Cleaned up device: MotorCtrl",
            "Cleaned up device: TempSensor",
            "Linked lists module unloaded"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h",
            "linux/slab.h",
            "linux/list.h"
        ],
        "mustContain": [
            "head->next = head",
            "head->prev = head",
            "dev->list.next = head->next",
            "dev->list.prev = head",
            "head->next->prev = &dev->list",
            "head->next = &dev->list",
            "dev->list.prev->next = dev->list.next",
            "dev->list.next->prev = dev->list.prev",
            "head->next == head",
            "pos = head->next; pos != head; pos = pos->next",
            "list_add(&dev->list, &kernel_device_list)",
            "list_for_each_entry(",
            "list_for_each_entry_safe(",
            "list_del(",
            "kfree(",
            "INIT_LIST_HEAD(",
            "module_param(test_device_id, int, 0644)",
            "module_param(test_device_count, int, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void manual_init_list(struct list_head *head)",
                "void manual_add_device(struct device_entry *dev, struct list_head *head)",
                "void manual_remove_device(struct device_entry *dev)",
                "int manual_is_empty(struct list_head *head)",
                "void manual_traverse_list(struct list_head *head)",
                "void kernel_add_device(struct device_entry *dev)",
                "void kernel_traverse_list(void)",
                "struct device_entry* find_device_by_id(int device_id)",
                "int count_total_devices(void)",
                "void cleanup_all_devices(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void manual_init_list(struct list_head *head)",
                "void manual_add_device(struct device_entry *dev, struct list_head *head)",
                "void manual_remove_device(struct device_entry *dev)",
                "int manual_is_empty(struct list_head *head)",
                "void manual_traverse_list(struct list_head *head)",
                "void kernel_add_device(struct device_entry *dev)",
                "void kernel_traverse_list(void)",
                "struct device_entry* find_device_by_id(int device_id)",
                "int count_total_devices(void)",
                "void cleanup_all_devices(void)",
                "static int __init linked_lists_init(void)",
                "static void __exit linked_lists_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Linked lists module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init linked_lists_init(void)"
                },
                {
                    "pattern": "Testing manual list operations",
                    "exact": true,
                    "linkedFunction": "static int __init linked_lists_init(void)"
                },
                {
                    "pattern": "Manually added device: TempSensor (ID: 1001)",
                    "exact": true,
                    "linkedFunction": "void manual_add_device(struct device_entry *dev, struct list_head *head)"
                },
                {
                    "pattern": "Manually added device: MotorCtrl (ID: 1002)",
                    "exact": true,
                    "linkedFunction": "void manual_add_device(struct device_entry *dev, struct list_head *head)"
                },
                {
                    "pattern": "Manually added device: LEDStrip (ID: 1003)",
                    "exact": true,
                    "linkedFunction": "void manual_add_device(struct device_entry *dev, struct list_head *head)"
                },
                {
                    "pattern": "Manual list empty: 0",
                    "exact": true,
                    "linkedFunction": "static int __init linked_lists_init(void)"
                },
                {
                    "pattern": "Manual traversal - Device: LEDStrip (ID: 1003, Status: 0)",
                    "exact": true,
                    "linkedFunction": "void manual_traverse_list(struct list_head *head)"
                },
                {
                    "pattern": "Manual traversal - Device: MotorCtrl (ID: 1002, Status: 1)",
                    "exact": true,
                    "linkedFunction": "void manual_traverse_list(struct list_head *head)"
                },
                {
                    "pattern": "Manual traversal - Device: TempSensor (ID: 1001, Status: 1)",
                    "exact": true,
                    "linkedFunction": "void manual_traverse_list(struct list_head *head)"
                },
                {
                    "pattern": "Manually removed device: MotorCtrl (ID: 1002)",
                    "exact": true,
                    "linkedFunction": "void manual_remove_device(struct device_entry *dev)"
                },
                {
                    "pattern": "Testing kernel macro operations",
                    "exact": true,
                    "linkedFunction": "static int __init linked_lists_init(void)"
                },
                {
                    "pattern": "Kernel added device: TempSensor (ID: 1001)",
                    "exact": true,
                    "linkedFunction": "void kernel_add_device(struct device_entry *dev)"
                },
                {
                    "pattern": "Kernel added device: MotorCtrl (ID: 1002)",
                    "exact": true,
                    "linkedFunction": "void kernel_add_device(struct device_entry *dev)"
                },
                {
                    "pattern": "Kernel added device: LEDStrip (ID: 1003)",
                    "exact": true,
                    "linkedFunction": "void kernel_add_device(struct device_entry *dev)"
                },
                {
                    "pattern": "Kernel traversal - Device: LEDStrip (ID: 1003, Status: 0)",
                    "exact": true,
                    "linkedFunction": "void kernel_traverse_list(void)"
                },
                {
                    "pattern": "Kernel traversal - Device: MotorCtrl (ID: 1002, Status: 1)",
                    "exact": true,
                    "linkedFunction": "void kernel_traverse_list(void)"
                },
                {
                    "pattern": "Kernel traversal - Device: TempSensor (ID: 1001, Status: 1)",
                    "exact": true,
                    "linkedFunction": "void kernel_traverse_list(void)"
                },
                {
                    "pattern": "Found device: TempSensor (ID: 1001)",
                    "exact": true,
                    "linkedFunction": "static int __init linked_lists_init(void)"
                },
                {
                    "pattern": "Total devices in kernel list: 3",
                    "exact": true,
                    "linkedFunction": "static int __init linked_lists_init(void)"
                },
                {
                    "pattern": "Linked list demonstration completed",
                    "exact": true,
                    "linkedFunction": "static int __init linked_lists_init(void)"
                },
                {
                    "pattern": "Linked lists module unloading",
                    "exact": true,
                    "linkedFunction": "static void __exit linked_lists_exit(void)"
                },
                {
                    "pattern": "Cleaned up device: LEDStrip",
                    "exact": true,
                    "linkedFunction": "void cleanup_all_devices(void)"
                },
                {
                    "pattern": "Cleaned up device: MotorCtrl",
                    "exact": true,
                    "linkedFunction": "void cleanup_all_devices(void)"
                },
                {
                    "pattern": "Cleaned up device: TempSensor",
                    "exact": true,
                    "linkedFunction": "void cleanup_all_devices(void)"
                },
                {
                    "pattern": "Linked lists module unloaded",
                    "exact": true,
                    "linkedFunction": "static void __exit linked_lists_exit(void)"
                }
            ]
        },
        {
            "id": "advanced_linked_list_validation",
            "name": "Advanced Linked List Implementation with Anti-Hardcoding Protection",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "linked_list_dynamic_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Anti-Hardcoding Linked List Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate unpredictable test values\\n    int random_device_id = (rand() % 9000) + 1000;  // 1000-9999\\n    int random_device_count = (rand() % 3) + 2;     // 2-4 devices\\n    \\n    printf(\\\"Test 1: Random linked list operations (device_id=%d, count=%d)\\\\n\\\", random_device_id, random_device_count);\\n    \\n    // Test with random values\\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod linked_lists 2>/dev/null\\\");\\n    \\n    char cmd[256];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/linked_lists.ko test_device_id=%d test_device_count=%d\\\", random_device_id, random_device_count);\\n    printf(\\\"DEBUG: Command: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Anti-hardcoding linked list test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting advanced linked list implementation validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef unsigned char uint8_t;' > /tmp/linux/types.h",
                    "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
                    "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
                    "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
                    "echo '#define MAX_DEVICE_NAME 16' >> /tmp/linux/types.h",
                    "echo 'void* kmalloc(size_t size, int flags);' > /tmp/linux/slab.h",
                    "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
                    "echo '#define GFP_KERNEL 0' >> /tmp/linux/slab.h",
                    "echo 'struct list_head { struct list_head *next, *prev; };' > /tmp/linux/list.h",
                    "echo '#define INIT_LIST_HEAD(ptr) do { (ptr)->next = (ptr); (ptr)->prev = (ptr); } while (0)' >> /tmp/linux/list.h",
                    "echo '#define list_add(new, head) do { (new)->next = (head)->next; (new)->prev = (head); (head)->next->prev = (new); (head)->next = (new); } while (0)' >> /tmp/linux/list.h",
                    "echo '#define list_for_each_entry(pos, head, member) for (pos = container_of((head)->next, typeof(*pos), member); &pos->member != (head); pos = container_of(pos->member.next, typeof(*pos), member))' >> /tmp/linux/list.h",
                    "echo '#define list_for_each_entry_safe(pos, n, head, member) for (pos = container_of((head)->next, typeof(*pos), member), n = container_of(pos->member.next, typeof(*pos), member); &pos->member != (head); pos = n, n = container_of(n->member.next, typeof(*n), member))' >> /tmp/linux/list.h",
                    "echo '#define list_del(entry) do { (entry)->next->prev = (entry)->prev; (entry)->prev->next = (entry)->next; } while (0)' >> /tmp/linux/list.h",
                    "echo '#define container_of(ptr, type, member) ((type *)((char *)(ptr) - offsetof(type, member)))' >> /tmp/linux/list.h",
                    "echo '#define offsetof(type, member) ((size_t) &((type *)0)->member)' >> /tmp/linux/list.h",
                    "echo 'Creating test file that includes linked lists header...'",
                    "echo '#include \"/lib/modules/linked_lists.h\"' > /tmp/test.c",
                    "echo 'int main() { struct list_head head; struct device_entry *dev; manual_init_list(&head); manual_add_device(dev, &head); manual_remove_device(dev); manual_is_empty(&head); manual_traverse_list(&head); kernel_add_device(dev); kernel_traverse_list(); find_device_by_id(1001); count_total_devices(); cleanup_all_devices(); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
                    "echo 'Phase 2: Anti-Hardcoding Dynamic Linked List Test'",
                    "/bin/linked_list_dynamic_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Random Value Extraction and Validation'",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Extracting random test values from output...'",
                    "DEVICE_ID=$(grep -o 'Random linked list operations (device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
                    "DEVICE_COUNT=$(grep -o 'count=[0-9]*)' /tmp/test_output.log | cut -d'=' -f2 | cut -d')' -f1)",
                    "echo 'Extracted values: DEVICE_ID='$DEVICE_ID', DEVICE_COUNT='$DEVICE_COUNT",
                    "if [ -z \"$DEVICE_ID\" ] || [ -z \"$DEVICE_COUNT\" ]; then echo 'FAIL: Could not extract random test values'; else echo 'PASS: Random values extracted successfully'; fi",
                    "echo 'Phase 4: Anti-Hardcoding Validation with Random Values'",
                    "echo 'Validating linked list operations with random device ID '$DEVICE_ID",
                    "dmesg | grep \"TempSensor (ID: $DEVICE_ID)\" && echo 'PASS: Linked list operations with random device ID working' || echo 'FAIL: Linked list operations with random device ID broken'",
                    "echo 'Phase 5: Linked List Implementation Validation'",
                    "dmesg | grep 'Manually added device:' && echo 'PASS: Manual add operations working' || echo 'FAIL: Manual add operations broken'",
                    "dmesg | grep 'Manual traversal - Device:' && echo 'PASS: Manual traversal working' || echo 'FAIL: Manual traversal broken'",
                    "dmesg | grep 'Manually removed device:' && echo 'PASS: Manual remove operations working' || echo 'FAIL: Manual remove operations broken'",
                    "dmesg | grep 'Kernel added device:' && echo 'PASS: Kernel macro operations working' || echo 'FAIL: Kernel macro operations broken'",
                    "dmesg | grep 'Kernel traversal - Device:' && echo 'PASS: Kernel traversal working' || echo 'FAIL: Kernel traversal broken'",
                    "echo 'Phase 6: Advanced List Operations Validation'",
                    "dmesg | grep 'Found device:' && echo 'PASS: Device search working' || echo 'FAIL: Device search broken'",
                    "dmesg | grep 'Total devices in kernel list: 3' && echo 'PASS: Device counting working' || echo 'FAIL: Device counting broken'",
                    "dmesg | grep 'Cleaned up device:' && echo 'PASS: Device cleanup working' || echo 'FAIL: Device cleanup broken'",
                    "echo 'Phase 7: Module Operations Validation'",
                    "dmesg | grep 'Linked lists module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
                    "dmesg | grep 'Linked lists module unloaded' && echo 'PASS: Module cleanup working' || echo 'FAIL: Module cleanup broken'",
                    "echo 'All linked list implementation validations completed'"
                ],
                "expected": {
                    "dmesg": [
                        "Linked lists module loaded",
                        "Testing manual list operations",
                        "Manually added device: .*",
                        "Manual list empty: 0",
                        "Manual traversal - Device: .*",
                        "Manually removed device: .*",
                        "Testing kernel macro operations",
                        "Kernel added device: .*",
                        "Kernel traversal - Device: .*",
                        "Found device: .*",
                        "Total devices in kernel list: .*",
                        "Linked list demonstration completed",
                        "Linked lists module unloading",
                        "Cleaned up device: .*",
                        "Linked lists module unloaded"
                    ],
                    "stdout": [
                        "PASS: All function and variable declarations found in header file",
                        "SUCCESS: Anti-hardcoding linked list test completed",
                        "PASS: Random values extracted successfully",
                        "PASS: Linked list operations with random device ID working",
                        "PASS: Manual add operations working",
                        "PASS: Manual traversal working",
                        "PASS: Manual remove operations working",
                        "PASS: Kernel macro operations working",
                        "PASS: Kernel traversal working",
                        "PASS: Device search working",
                        "PASS: Device counting working",
                        "PASS: Device cleanup working",
                        "PASS: Module initialization working",
                        "PASS: Module cleanup working"
                    ]
                },
                "timeout": 15
            }
        }
    ]
});


// Problem 27: Error Handling - Kernel Resilience Patterns
generatedTestDefinitions.set(27, {
    "name": "Error Handling - Kernel Resilience Patterns",
    "category": "foundations",
    "description": "Master essential error handling patterns for robust kernel programming. Learn standard error codes, proper cleanup patterns, and defensive programming techniques that prevent crashes and memory leaks.",
    "exactRequirements": {
        "functionNames": [
            "error_handler_init",
            "error_handler_exit",
            "validate_device_id",
            "allocate_device_buffer",
            "initialize_device",
            "cleanup_device",
            "get_error_message",
            "process_device_operation"
        ],
        "variables": [
            {
                "name": "global_device",
                "type": "struct test_device",
                "storageClass": "none"
            },
            {
                "name": "test_device_id",
                "type": "int",
                "value": "100",
                "storageClass": "none"
            },
            {
                "name": "test_buffer_size",
                "type": "int",
                "value": "512",
                "storageClass": "none"
            }
        ],
        "outputMessages": [
            "Error handler module loaded",
            "Testing error handling with device_id=100, buffer_size=512",
            "Device ID 100 is valid",
            "Allocated buffer of size 512",
            "Device 100 initialized successfully",
            "Device operation completed successfully",
            "All operations completed successfully",
            "Error handler module unloading",
            "Device cleaned up",
            "Error handler module unloaded"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h",
            "linux/slab.h",
            "linux/errno.h"
        ],
        "mustContain": [
            "kmalloc",
            "kfree",
            "-EINVAL",
            "-ENOMEM",
            "-EBUSY",
            "-ENODEV",
            "module_param(test_device_id, int, 0644)",
            "module_param(test_buffer_size, int, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int validate_device_id(int device_id)",
                "int allocate_device_buffer(struct test_device *dev, size_t size)",
                "int initialize_device(struct test_device *dev, int device_id, size_t buffer_size)",
                "void cleanup_device(struct test_device *dev)",
                "const char* get_error_message(int error_code)",
                "int process_device_operation(int device_id, size_t buffer_size)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int validate_device_id(int device_id)",
                "int allocate_device_buffer(struct test_device *dev, size_t size)",
                "int initialize_device(struct test_device *dev, int device_id, size_t buffer_size)",
                "void cleanup_device(struct test_device *dev)",
                "const char* get_error_message(int error_code)",
                "int process_device_operation(int device_id, size_t buffer_size)",
                "static int __init error_handler_init(void)",
                "static void __exit error_handler_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Error handler module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init error_handler_init(void)"
                },
                {
                    "pattern": "Testing error handling with device_id=100, buffer_size=512",
                    "exact": true,
                    "linkedFunction": "static int __init error_handler_init(void)"
                },
                {
                    "pattern": "Device ID 100 is valid",
                    "exact": true,
                    "linkedFunction": "int validate_device_id(int device_id)"
                },
                {
                    "pattern": "Allocated buffer of size 512",
                    "exact": true,
                    "linkedFunction": "int allocate_device_buffer(struct test_device *dev, size_t size)"
                },
                {
                    "pattern": "Device 100 initialized successfully",
                    "exact": true,
                    "linkedFunction": "int initialize_device(struct test_device *dev, int device_id, size_t buffer_size)"
                },
                {
                    "pattern": "Device operation completed successfully",
                    "exact": true,
                    "linkedFunction": "int process_device_operation(int device_id, size_t buffer_size)"
                },
                {
                    "pattern": "All operations completed successfully",
                    "exact": true,
                    "linkedFunction": "static int __init error_handler_init(void)"
                },
                {
                    "pattern": "Error handler module unloading",
                    "exact": true,
                    "linkedFunction": "static void __exit error_handler_exit(void)"
                },
                {
                    "pattern": "Device cleaned up",
                    "exact": true,
                    "linkedFunction": "void cleanup_device(struct test_device *dev)"
                },
                {
                    "pattern": "Error handler module unloaded",
                    "exact": true,
                    "linkedFunction": "static void __exit error_handler_exit(void)"
                }
            ]
        },
        {
            "id": "simple_error_handling_validation",
            "name": "Simple Error Handling Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "error_handling_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Error Handling Test ===\\\\n\\\");\\n    \\n    srand(time(NULL));\\n    \\n    int random_device_id = (rand() % 500) + 50;   // 50-549\\n    int random_buffer_size = (rand() % 700) + 300; // 300-999\\n    \\n    printf(\\\"Test: device_id=%d, buffer_size=%d\\\\n\\\", random_device_id, random_buffer_size);\\n    \\n    system(\\\"rmmod error_handler 2>/dev/null\\\");\\n    \\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/error_handler.ko test_device_id=%d test_buffer_size=%d\\\", random_device_id, random_buffer_size);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Error handling test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting simple error handling validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: TCC Header Validation'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef unsigned long size_t;' > /tmp/linux/types.h",
                    "echo '#define MAX_BUFFER_SIZE 1024' >> /tmp/linux/types.h",
                    "echo 'void* kmalloc(size_t size, int flags);' > /tmp/linux/slab.h",
                    "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
                    "echo '#define GFP_KERNEL 0' >> /tmp/linux/slab.h",
                    "echo '#define EINVAL 22' > /tmp/linux/errno.h",
                    "echo '#define ENOMEM 12' >> /tmp/linux/errno.h",
                    "echo '#define EBUSY 16' >> /tmp/linux/errno.h",
                    "echo '#define ENODEV 19' >> /tmp/linux/errno.h",
                    "echo '#define ENOSYS 38' >> /tmp/linux/errno.h",
                    "echo '#include \"/lib/modules/error_handler.h\"' > /tmp/test.c",
                    "echo 'int main() { struct test_device dev; validate_device_id(100); allocate_device_buffer(&dev, 512); initialize_device(&dev, 100, 512); cleanup_device(&dev); get_error_message(-22); process_device_operation(100, 512); return 0; }' >> /tmp/test.c",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing'; cat /tmp/tcc_error.log; else echo 'PASS: All declarations found'; fi",
                    "echo 'Phase 2: Dynamic Error Handling Test'",
                    "/bin/error_handling_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Error Handling Validation'",
                    "sleep 1",
                    "dmesg | grep 'Error handler module loaded' && echo 'PASS: Module loading' || echo 'FAIL: Module loading'",
                    "dmesg | grep 'Device ID .* is valid' && echo 'PASS: Device validation' || echo 'FAIL: Device validation'",
                    "dmesg | grep 'Allocated buffer of size' && echo 'PASS: Buffer allocation' || echo 'FAIL: Buffer allocation'",
                    "dmesg | grep 'Device .* initialized successfully' && echo 'PASS: Device initialization' || echo 'FAIL: Device initialization'",
                    "dmesg | grep 'Device operation completed successfully' && echo 'PASS: Operation completion' || echo 'FAIL: Operation completion'",
                    "dmesg | grep 'All operations completed successfully' && echo 'PASS: All operations' || echo 'FAIL: All operations'",
                    "dmesg | grep 'Device cleaned up' && echo 'PASS: Cleanup' || echo 'FAIL: Cleanup'",
                    "dmesg | grep 'Error handler module unloaded' && echo 'PASS: Module unloading' || echo 'FAIL: Module unloading'",
                    "echo 'PASS: All error handling validation successful'"
                ],
                "expected": {
                    "dmesg": [
                        "Error handler module loaded",
                        "Testing error handling with device_id=.*, buffer_size=.*",
                        "Device ID .* is valid",
                        "Allocated buffer of size .*",
                        "Device .* initialized successfully",
                        "Device operation completed successfully",
                        "All operations completed successfully",
                        "Error handler module unloading",
                        "Device cleaned up",
                        "Error handler module unloaded"
                    ],
                    "stdout": [
                        "PASS: All declarations found",
                        "SUCCESS: Error handling test completed",
                        "PASS: Module loading",
                        "PASS: Device validation",
                        "PASS: Buffer allocation",
                        "PASS: Device initialization",
                        "PASS: Operation completion",
                        "PASS: All operations",
                        "PASS: Cleanup",
                        "PASS: Module unloading",
                        "PASS: All error handling validation successful"
                    ]
                },
                "timeout": 30
            }
        }
    ]
});


// Problem 28: Advanced X-Macros - Multi-Target Code Generation
generatedTestDefinitions.set(28, {
    "name": "Advanced X-Macros - Multi-Target Code Generation",
    "category": "foundations",
    "description": "Master advanced X-macro patterns for sophisticated code generation. Learn to create single-source tables that auto-generate multiple related structures: enums, function stubs, switch statements, if-else chains, struct arrays, and function pointer tables. This powerful kernel programming technique is used extensively in driver registration, system call tables (SYSCALL_DEFINEx), tracepoint generation (TRACE_EVENT), and device management - eliminating repetitive code and preventing synchronization errors.",
    "exactRequirements": {
        "functionNames": [
            "driver_registry_init",
            "driver_registry_exit",
            "initialize_driver",
            "cleanup_driver",
            "detect_driver_by_code",
            "count_drivers_by_flag",
            "print_driver_table",
            "get_driver_name"
        ],
        "variables": [
            {
                "name": "driver_table[]",
                "type": "struct driver_info",
                "value": "{\n    DRIVER_TABLE(MAKE_INFO)\n}",
                "storageClass": "none"
            },
            {
                "name": "ops_table[]",
                "type": "struct driver_ops",
                "value": "{\n    DRIVER_TABLE(MAKE_OPS)\n}",
                "storageClass": "none"
            },
            {
                "name": "driver_count",
                "type": "const int",
                "value": "sizeof(driver_table) / sizeof(driver_table[0])",
                "storageClass": "none"
            }
        ],
        "outputMessages": [
            "Driver registry module loaded",
            "Total drivers registered: 5",
            "Driver: SERIAL_USB (Type: 0x0100, Flags: 0x03)",
            "Driver: SERIAL_UART (Type: 0x0101, Flags: 0x00)",
            "Driver: GPIO_PIN (Type: 0x0200, Flags: 0x00)",
            "Driver: GPIO_LED (Type: 0x0201, Flags: 0x00)",
            "Driver: SPI_FLASH (Type: 0x0300, Flags: 0x01)",
            "Testing driver initialization with type 0",
            "Initializing SERIAL_USB driver",
            "Type code: 0x0100",
            "Flags: 0x03",
            "Driver initialization succeeded",
            "Testing type detection with code 0x0100",
            "Detected driver: SERIAL_USB",
            "Testing flag counting with flag",
            "Drivers with flag",
            "Cleaning up SERIAL_USB driver",
            "Type code: 0x0100",
            "Driver registry demonstration completed",
            "Driver registry module unloaded"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h"
        ],
        "mustContain": [
            "#define DRIVER_TABLE(X)",
            "X(SERIAL_USB, 0x0100, init_usb_serial, cleanup_usb_serial, DRV_HOTPLUG | DRV_IRQ)",
            "X(SERIAL_UART, 0x0101, init_uart_serial, cleanup_uart_serial, DRV_STATIC)",
            "X(GPIO_PIN, 0x0200, init_gpio_pin, cleanup_gpio_pin, DRV_STATIC)",
            "X(GPIO_LED, 0x0201, init_gpio_led, cleanup_gpio_led, DRV_STATIC)",
            "X(SPI_FLASH, 0x0300, init_spi_flash, cleanup_spi_flash, DRV_HOTPLUG)",
            "#define MAKE_ENUM(name, ...) DRV_##name,",
            "enum driver_type",
            "DRIVER_TABLE(MAKE_ENUM)",
            "#undef MAKE_ENUM",
            "#define MAKE_INIT_DECL(name, code, init, cleanup, flags)",
            "int init(void);",
            "DRIVER_TABLE(MAKE_INIT_DECL)",
            "#undef MAKE_INIT_DECL",
            "#define MAKE_CLEANUP_DECL(name, code, init, cleanup, flags)",
            "void cleanup(void);",
            "DRIVER_TABLE(MAKE_CLEANUP_DECL)",
            "#undef MAKE_CLEANUP_DECL",
            "#define MAKE_INIT_FUNC(name, code, init, cleanup, flags)",
            "int init(void)",
            "printk.*#name",
            "Type code.*0x%04x.*code",
            "Flags.*0x%02x.*flags",
            "DRIVER_TABLE(MAKE_INIT_FUNC)",
            "#undef MAKE_INIT_FUNC",
            "#define MAKE_CLEANUP_FUNC(name, code, init, cleanup, flags)",
            "void cleanup(void)",
            "DRIVER_TABLE(MAKE_CLEANUP_FUNC)",
            "#undef MAKE_CLEANUP_FUNC",
            "#define MAKE_INFO",
            "DRIVER_TABLE(MAKE_INFO)",
            "#define MAKE_OPS",
            "DRIVER_TABLE(MAKE_OPS)",
            "#define MAKE_INIT_CASE",
            "case DRV_##name: return init();",
            "DRIVER_TABLE(MAKE_INIT_CASE)",
            "#define MAKE_CLEANUP_CASE",
            "case DRV_##name: cleanup(); break;",
            "DRIVER_TABLE(MAKE_CLEANUP_CASE)",
            "#define MAKE_DETECT",
            "if (type_code == code) return DRV_##name;",
            "DRIVER_TABLE(MAKE_DETECT)",
            "sizeof(driver_table) / sizeof(driver_table[0])",
            "driver_table[i].flags & flag",
            "module_param(test_driver_type, int, 0644)",
            "module_param(test_type_code, int, 0644)",
            "module_param(test_flag, int, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int initialize_driver(enum driver_type type)",
                "void cleanup_driver(enum driver_type type)",
                "enum driver_type detect_driver_by_code(uint16_t type_code)",
                "int count_drivers_by_flag(uint32_t flag)",
                "void print_driver_table(void)",
                "const char* get_driver_name(enum driver_type type)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "xmacro_table_definition",
            "name": "X-Macro Table with 5 Parameters",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "#define DRIVER_TABLE(X)",
                "X(SERIAL_USB,",
                "X(SERIAL_UART,",
                "X(GPIO_PIN,",
                "X(GPIO_LED,",
                "X(SPI_FLASH,"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "enum_generation",
            "name": "Enum Generation from X-Macro",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "#define MAKE_ENUM",
                "enum driver_type",
                "DRIVER_TABLE(MAKE_ENUM)",
                "#undef MAKE_ENUM"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "struct_array_generation",
            "name": "Struct Array Generation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "#define MAKE_INFO",
                "struct driver_info driver_table",
                "DRIVER_TABLE(MAKE_INFO)",
                "#define MAKE_OPS",
                "struct driver_ops ops_table",
                "DRIVER_TABLE(MAKE_OPS)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "switch_generation",
            "name": "Switch Statement Generation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "#define MAKE_INIT_CASE",
                "case DRV_",
                "DRIVER_TABLE(MAKE_INIT_CASE)",
                "#define MAKE_CLEANUP_CASE",
                "DRIVER_TABLE(MAKE_CLEANUP_CASE)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "ifelse_generation",
            "name": "If-Else Chain Generation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "#define MAKE_DETECT",
                "if (type_code == code)",
                "DRIVER_TABLE(MAKE_DETECT)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_declaration_generation",
            "name": "Function Declaration Auto-Generation in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "#define MAKE_INIT_DECL(name, code, init, cleanup, flags)",
                "int init(void);",
                "DRIVER_TABLE(MAKE_INIT_DECL)",
                "#undef MAKE_INIT_DECL",
                "#define MAKE_CLEANUP_DECL(name, code, init, cleanup, flags)",
                "void cleanup(void);",
                "DRIVER_TABLE(MAKE_CLEANUP_DECL)",
                "#undef MAKE_CLEANUP_DECL"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_implementation_generation",
            "name": "Function Implementation Auto-Generation in Source",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "#define MAKE_INIT_FUNC(name, code, init, cleanup, flags)",
                "int init(void)",
                "#name",
                "0x%04x",
                "0x%02x",
                "DRIVER_TABLE(MAKE_INIT_FUNC)",
                "#undef MAKE_INIT_FUNC",
                "#define MAKE_CLEANUP_FUNC(name, code, init, cleanup, flags)",
                "void cleanup(void)",
                "DRIVER_TABLE(MAKE_CLEANUP_FUNC)",
                "#undef MAKE_CLEANUP_FUNC"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Implementations in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int initialize_driver(enum driver_type type)",
                "void cleanup_driver(enum driver_type type)",
                "enum driver_type detect_driver_by_code(uint16_t type_code)",
                "int count_drivers_by_flag(uint32_t flag)",
                "void print_driver_table(void)",
                "const char* get_driver_name(enum driver_type type)",
                "static int __init driver_registry_init(void)",
                "static void __exit driver_registry_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Driver registry module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init driver_registry_init(void)"
                },
                {
                    "pattern": "Total drivers registered: 5",
                    "exact": true,
                    "linkedFunction": "static int __init driver_registry_init(void)"
                },
                {
                    "pattern": "Driver: SERIAL_USB (Type: 0x0100, Flags: 0x03)",
                    "exact": true,
                    "linkedFunction": "void print_driver_table(void)"
                },
                {
                    "pattern": "Driver: SERIAL_UART (Type: 0x0101, Flags: 0x00)",
                    "exact": true,
                    "linkedFunction": "void print_driver_table(void)"
                },
                {
                    "pattern": "Driver: GPIO_PIN (Type: 0x0200, Flags: 0x00)",
                    "exact": true,
                    "linkedFunction": "void print_driver_table(void)"
                },
                {
                    "pattern": "Driver: GPIO_LED (Type: 0x0201, Flags: 0x00)",
                    "exact": true,
                    "linkedFunction": "void print_driver_table(void)"
                },
                {
                    "pattern": "Driver: SPI_FLASH (Type: 0x0300, Flags: 0x01)",
                    "exact": true,
                    "linkedFunction": "void print_driver_table(void)"
                },
                {
                    "pattern": "Testing driver initialization with type 0",
                    "exact": true,
                    "linkedFunction": "static int __init driver_registry_init(void)"
                },
                {
                    "pattern": "Initializing SERIAL_USB driver",
                    "exact": true,
                    "linkedFunction": "int init_usb_serial(void)"
                },
                {
                    "pattern": "Type code: 0x0100",
                    "exact": true,
                    "linkedFunction": "int init_usb_serial(void)"
                },
                {
                    "pattern": "Flags: 0x03",
                    "exact": true,
                    "linkedFunction": "int init_usb_serial(void)"
                },
                {
                    "pattern": "Driver initialization succeeded",
                    "exact": true,
                    "linkedFunction": "static int __init driver_registry_init(void)"
                },
                {
                    "pattern": "Testing type detection with code 0x0100",
                    "exact": true,
                    "linkedFunction": "static int __init driver_registry_init(void)"
                },
                {
                    "pattern": "Detected driver: SERIAL_USB",
                    "exact": true,
                    "linkedFunction": "static int __init driver_registry_init(void)"
                },
                {
                    "pattern": "Cleaning up SERIAL_USB driver",
                    "exact": true,
                    "linkedFunction": "void cleanup_usb_serial(void)"
                },
                {
                    "pattern": "Type code: 0x0100",
                    "exact": true,
                    "linkedFunction": "void cleanup_usb_serial(void)"
                },
                {
                    "pattern": "Driver registry demonstration completed",
                    "exact": true,
                    "linkedFunction": "static int __init driver_registry_init(void)"
                },
                {
                    "pattern": "Driver registry module unloaded",
                    "exact": true,
                    "linkedFunction": "static void __exit driver_registry_exit(void)"
                }
            ]
        },
        {
            "id": "advanced_xmacro_validation",
            "name": "Advanced X-Macro Multi-Target Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "xmacro_dynamic_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Advanced X-Macro Dynamic Test ===\\\\n\\\");\\n    \\n    srand(time(NULL));\\n    \\n    // Test different driver types\\n    int driver_types[] = {0, 1, 2, 3, 4};  // All 5 drivers\\n    int type_codes[] = {0x0100, 0x0101, 0x0200, 0x0201, 0x0300};\\n    int flags[] = {1, 0, 1};  // HOTPLUG=1, STATIC=0\\n    \\n    int random_driver = driver_types[rand() % 5];\\n    int random_code = type_codes[rand() % 5];\\n    int random_flag = flags[rand() % 3];\\n    \\n    printf(\\\"Test: driver_type=%d, type_code=0x%04x, flag=%d\\\\n\\\", random_driver, random_code, random_flag);\\n    \\n    system(\\\"rmmod driver_registry 2>/dev/null\\\");\\n    \\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/driver_registry.ko test_driver_type=%d test_type_code=%d test_flag=%d\\\", random_driver, random_code, random_flag);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: X-macro test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting advanced X-macro validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: TCC Header Validation'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef unsigned short uint16_t;' > /tmp/linux/types.h",
                    "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
                    "echo '#include \"/lib/modules/driver_registry.h\"' > /tmp/test.c",
                    "echo 'int main() { struct driver_info info; struct driver_ops ops; initialize_driver(DRV_SERIAL_USB); cleanup_driver(DRV_SERIAL_USB); detect_driver_by_code(0x0100); count_drivers_by_flag(1); print_driver_table(); get_driver_name(DRV_SERIAL_USB); return 0; }' >> /tmp/test.c",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing'; cat /tmp/tcc_error.log; else echo 'PASS: All declarations found'; fi",
                    "echo 'Phase 2: Dynamic X-Macro Test'",
                    "/bin/xmacro_dynamic_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: X-Macro Function Generation Validation (CRITICAL)'",
                    "sleep 1",
                    "echo 'Extracting test driver type from output...'",
                    "TEST_DRIVER=$(grep -o 'driver_type=[0-9]*' /tmp/test_output.log | head -1 | cut -d'=' -f2)",
                    "echo 'Testing with driver type '$TEST_DRIVER",
                    "echo 'Validating macro-generated function output (must include type code and flags)...'",
                    "dmesg | grep 'Type code: 0x' && echo 'PASS: Functions include type code (proves macro generation)' || echo 'FAIL: Missing type code (manual implementation detected)'",
                    "dmesg | grep 'Flags: 0x' && echo 'PASS: Functions include flags (proves macro generation)' || echo 'FAIL: Missing flags (manual implementation detected)'",
                    "echo 'Validating flag values match DRIVER_TABLE entries...'",
                    "case $TEST_DRIVER in",
                    "  0) dmesg | grep 'Flags: 0x03' && echo 'PASS: USB Serial flags correct (DRV_HOTPLUG|DRV_IRQ=0x03)' || echo 'FAIL: USB Serial flags wrong' ;;",
                    "  1) dmesg | grep 'Flags: 0x00' && echo 'PASS: UART Serial flags correct (DRV_STATIC=0x00)' || echo 'FAIL: UART Serial flags wrong' ;;",
                    "  2) dmesg | grep 'Flags: 0x00' && echo 'PASS: GPIO PIN flags correct (DRV_STATIC=0x00)' || echo 'FAIL: GPIO PIN flags wrong' ;;",
                    "  3) dmesg | grep 'Flags: 0x00' && echo 'PASS: GPIO LED flags correct (DRV_STATIC=0x00)' || echo 'FAIL: GPIO LED flags wrong' ;;",
                    "  4) dmesg | grep 'Flags: 0x01' && echo 'PASS: SPI Flash flags correct (DRV_HOTPLUG=0x01)' || echo 'FAIL: SPI Flash flags wrong' ;;",
                    "esac",
                    "echo 'Phase 4: Multi-Target Generation Validation'",
                    "dmesg | grep 'Driver registry module loaded' && echo 'PASS: Module loading' || echo 'FAIL: Module loading'",
                    "dmesg | grep 'Total drivers registered: 5' && echo 'PASS: Driver count correct' || echo 'FAIL: Driver count wrong'",
                    "dmesg | grep 'Driver: SERIAL_USB' && echo 'PASS: Struct array generation' || echo 'FAIL: Struct array generation'",
                    "dmesg | grep 'Driver: GPIO_PIN' && echo 'PASS: X-macro expansion' || echo 'FAIL: X-macro expansion'",
                    "dmesg | grep 'Initializing.*driver' && echo 'PASS: Switch dispatch working' || echo 'FAIL: Switch dispatch broken'",
                    "dmesg | grep 'Driver initialization succeeded' && echo 'PASS: Function pointer table' || echo 'FAIL: Function pointer table'",
                    "dmesg | grep 'Detected driver:' && echo 'PASS: If-else chain generation' || echo 'FAIL: If-else chain generation'",
                    "dmesg | grep 'Drivers with flag' && echo 'PASS: Flag counting logic' || echo 'FAIL: Flag counting logic'",
                    "dmesg | grep 'Cleaning up.*driver' && echo 'PASS: Cleanup dispatch' || echo 'FAIL: Cleanup dispatch'",
                    "dmesg | grep 'Driver registry demonstration completed' && echo 'PASS: All targets validated' || echo 'FAIL: Some targets missing'",
                    "echo 'PASS: All advanced X-macro validation successful (including function generation)'"
                ],
                "expected": {
                    "dmesg": [
                        "Driver registry module loaded",
                        "Total drivers registered: 5",
                        "Driver: SERIAL_USB.*Type: 0x0100.*Flags: 0x03",
                        "Driver: SERIAL_UART.*Type: 0x0101.*Flags: 0x00",
                        "Driver: GPIO_PIN.*Type: 0x0200.*Flags: 0x00",
                        "Driver: GPIO_LED.*Type: 0x0201.*Flags: 0x00",
                        "Driver: SPI_FLASH.*Type: 0x0300.*Flags: 0x01",
                        "Testing driver initialization with type.*",
                        "Initializing.*driver",
                        "Type code: 0x.*",
                        "Flags: 0x.*",
                        "Driver initialization succeeded",
                        "Testing type detection with code.*",
                        "Detected driver:.*",
                        "Testing flag counting with flag.*",
                        "Drivers with flag.*",
                        "Cleaning up.*driver",
                        "Type code: 0x.*",
                        "Driver registry demonstration completed",
                        "Driver registry module unloaded"
                    ],
                    "stdout": [
                        "PASS: All declarations found",
                        "SUCCESS: X-macro test completed",
                        "PASS: Functions include type code \\(proves macro generation\\)",
                        "PASS: Functions include flags \\(proves macro generation\\)",
                        "PASS:.*flags correct",
                        "PASS: Module loading",
                        "PASS: Driver count correct",
                        "PASS: Struct array generation",
                        "PASS: X-macro expansion",
                        "PASS: Switch dispatch working",
                        "PASS: Function pointer table",
                        "PASS: If-else chain generation",
                        "PASS: Flag counting logic",
                        "PASS: Cleanup dispatch",
                        "PASS: All targets validated",
                        "PASS: All advanced X-macro validation successful \\(including function generation\\)"
                    ]
                },
                "timeout": 30
            }
        }
    ]
});


// Problem 29: Two-Level Memory Allocation - Array of Pointers Pattern
generatedTestDefinitions.set(29, {
    "name": "Two-Level Memory Allocation - Array of Pointers Pattern",
    "category": "foundations",
    "description": "Master the two-level allocation pattern using double pointers in kernel development. Learn to allocate arrays of pointers where each element points to dynamically allocated memory. Understand partial allocation failure recovery, reverse-order cleanup, and when this pattern is required. This prepares you for complex data structures like dynamic vectors and linked lists.",
    "exactRequirements": {
        "functionNames": [
            "dynamic_memory_init",
            "dynamic_memory_exit",
            "allocate_devices",
            "initialize_device",
            "print_device_info",
            "cleanup_devices"
        ],
        "variables": [
            {
                "name": "device_array",
                "type": "Device **",
                "value": "NULL",
                "storageClass": "none"
            },
            {
                "name": "device_count",
                "type": "int",
                "value": "3",
                "storageClass": "none"
            }
        ],
        "outputMessages": [
            "Dynamic memory module loaded",
            "Runtime device count: 3",
            "Allocating 3 devices...",
            "Successfully allocated 3 devices",
            "Initializing 3 devices...",
            "Device 1000 initialized",
            "Device 1001 initialized",
            "Device 1002 initialized",
            "Printing device information...",
            "Device 0:",
            "=== Device Info ===",
            "Device ID: 1000",
            "Status: 200",
            "Active: YES",
            "Device 1:",
            "Device ID: 1001",
            "Device 2:",
            "Device ID: 1002",
            "Dynamic allocation demonstration completed",
            "Dynamic memory module unloading",
            "Freeing 3 devices...",
            "All devices freed",
            "Module unloaded cleanly"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h",
            "linux/slab.h"
        ],
        "mustContain": [
            "kmalloc(sizeof(Device*) * count, GFP_KERNEL)",
            "kmalloc(sizeof(Device), GFP_KERNEL)",
            "kfree(device_array[i])",
            "kfree(device_array)",
            "if (!device_array)",
            "device_array = NULL",
            "module_param(device_count, int, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int allocate_devices(int count)",
                "void initialize_device(Device *dev, int id)",
                "void print_device_info(Device *dev)",
                "void cleanup_devices(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int allocate_devices(int count)",
                "void initialize_device(Device *dev, int id)",
                "void print_device_info(Device *dev)",
                "void cleanup_devices(void)",
                "static int __init dynamic_memory_init(void)",
                "static void __exit dynamic_memory_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages with Function Linkage",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Dynamic memory module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init dynamic_memory_init(void)"
                },
                {
                    "pattern": "Runtime device count:",
                    "exact": false,
                    "linkedFunction": "static int __init dynamic_memory_init(void)"
                },
                {
                    "pattern": "Allocating",
                    "exact": false,
                    "linkedFunction": "int allocate_devices(int count)"
                },
                {
                    "pattern": "Successfully allocated",
                    "exact": false,
                    "linkedFunction": "int allocate_devices(int count)"
                },
                {
                    "pattern": "Initializing",
                    "exact": false,
                    "linkedFunction": "static int __init dynamic_memory_init(void)"
                },
                {
                    "pattern": "Device 1000 initialized",
                    "exact": true,
                    "linkedFunction": "void initialize_device(Device *dev, int id)"
                },
                {
                    "pattern": "Printing device information...",
                    "exact": true,
                    "linkedFunction": "static int __init dynamic_memory_init(void)"
                },
                {
                    "pattern": "Device 0:",
                    "exact": true,
                    "linkedFunction": "static int __init dynamic_memory_init(void)"
                },
                {
                    "pattern": "=== Device Info ===",
                    "exact": true,
                    "linkedFunction": "void print_device_info(Device *dev)"
                },
                {
                    "pattern": "Device ID: 1000",
                    "exact": true,
                    "linkedFunction": "void print_device_info(Device *dev)"
                },
                {
                    "pattern": "Status: 200",
                    "exact": true,
                    "linkedFunction": "void print_device_info(Device *dev)"
                },
                {
                    "pattern": "Active: YES",
                    "exact": true,
                    "linkedFunction": "void print_device_info(Device *dev)"
                },
                {
                    "pattern": "Dynamic allocation demonstration completed",
                    "exact": true,
                    "linkedFunction": "static int __init dynamic_memory_init(void)"
                },
                {
                    "pattern": "Dynamic memory module unloading",
                    "exact": true,
                    "linkedFunction": "static void __exit dynamic_memory_exit(void)"
                },
                {
                    "pattern": "Freeing",
                    "exact": false,
                    "linkedFunction": "void cleanup_devices(void)"
                },
                {
                    "pattern": "All devices freed",
                    "exact": true,
                    "linkedFunction": "void cleanup_devices(void)"
                },
                {
                    "pattern": "Module unloaded cleanly",
                    "exact": true,
                    "linkedFunction": "static void __exit dynamic_memory_exit(void)"
                }
            ]
        },
        {
            "id": "advanced_dynamic_memory_validation",
            "name": "Advanced Dynamic Memory Implementation with TCC Header Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "memory_dynamic_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Runtime-Determined Size Allocation Test ===\\\\n\\\");\\n    \\n    srand(time(NULL));\\n    \\n    // Test different device counts (runtime-determined)\\n    int test_count1 = (rand() % 3) + 2;  // 2-4 devices\\n    int test_count2 = (rand() % 4) + 5;  // 5-8 devices\\n    \\n    printf(\\\"Test 1: Allocating %d devices (runtime size)\\\\n\\\", test_count1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/dynamic_memory.ko device_count=%d\\\", test_count1);\\n    system(\\\"rmmod dynamic_memory 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Allocating %d devices (runtime size)\\\\n\\\", test_count2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/dynamic_memory.ko device_count=%d\\\", test_count2);\\n    system(\\\"rmmod dynamic_memory\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Runtime-sized allocation test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting advanced dynamic memory implementation validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
                    "echo '#define true 1' >> /tmp/linux/types.h",
                    "echo '#define false 0' >> /tmp/linux/types.h",
                    "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
                    "echo '#define MAX_DEVICES 5' >> /tmp/linux/types.h",
                    "echo '#define GFP_KERNEL 0' > /tmp/linux/slab.h",
                    "echo '#define ENOMEM 12' >> /tmp/linux/slab.h",
                    "echo 'void *kmalloc(size_t size, int flags);' >> /tmp/linux/slab.h",
                    "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
                    "echo 'Creating test file that includes dynamic memory header...'",
                    "echo '#include \"/lib/modules/dynamic_memory.h\"' > /tmp/test.c",
                    "echo 'int main() { allocate_devices(3); initialize_device(device_array[0], 1000); print_device_info(device_array[0]); cleanup_devices(); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
                    "echo 'Phase 2: Runtime-Determined Size Allocation Testing'",
                    "/bin/memory_dynamic_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Extract Runtime Device Counts'",
                    "sleep 1",
                    "echo 'Extracting runtime device counts from test output...'",
                    "COUNT1=$(grep -o 'Test 1: Allocating [0-9]*' /tmp/test_output.log | cut -d' ' -f4)",
                    "COUNT2=$(grep -o 'Test 2: Allocating [0-9]*' /tmp/test_output.log | cut -d' ' -f4)",
                    "echo 'Extracted runtime counts: COUNT1='$COUNT1', COUNT2='$COUNT2",
                    "if [ -z \"$COUNT1\" ] || [ -z \"$COUNT2\" ]; then echo 'FAIL: Could not extract runtime counts'; else echo 'PASS: Runtime device counts extracted successfully'; fi",
                    "echo 'Phase 4: Two-Level Allocation Validation (CRITICAL)'",
                    "echo 'Validating Level 1: Array of device pointers allocation...'",
                    "dmesg | grep -E '(Allocating|allocated)' && echo 'PASS: Level 1 allocation (device array) working' || echo 'FAIL: Level 1 allocation broken'",
                    "dmesg | grep -E '(Successfully allocated|allocated)' && echo 'PASS: Two-level allocation successful' || echo 'FAIL: Two-level allocation broken'",
                    "echo 'Phase 5: Runtime Device Count Validation'",
                    "echo 'Validating with runtime count '$COUNT1' devices...'",
                    "dmesg | grep \"Runtime device count: $COUNT1\" && echo 'PASS: Runtime count '$COUNT1' detected' || echo 'FAIL: Runtime count detection broken'",
                    "dmesg | grep -E '(Allocating|allocated)' && echo 'PASS: Correct device count allocation' || echo 'FAIL: Wrong device count'",
                    "dmesg | grep -E '(Successfully|allocated)' && echo 'PASS: All devices allocated' || echo 'FAIL: Allocation incomplete'",
                    "echo 'Phase 6: Device Initialization Validation'",
                    "dmesg | grep 'Device 1000 initialized' && echo 'PASS: Device initialization working' || echo 'FAIL: Device initialization broken'",
                    "dmesg | grep 'Device ID: 1000' && echo 'PASS: First device data correct' || echo 'FAIL: First device data wrong'",
                    "dmesg | grep 'Status: 200' && echo 'PASS: Device status field correct' || echo 'FAIL: Device status wrong'",
                    "dmesg | grep 'Active: YES' && echo 'PASS: Device boolean field correct' || echo 'FAIL: Device boolean wrong'",
                    "echo 'Phase 7: Two-Level Cleanup Validation (CRITICAL)'",
                    "dmesg | grep -E '(Freeing|free)' && echo 'PASS: Cleanup initiated' || echo 'FAIL: Cleanup not initiated'",
                    "dmesg | grep 'All devices freed' && echo 'PASS: Two-level cleanup successful' || echo 'FAIL: Cleanup broken'",
                    "dmesg | grep 'Module unloaded cleanly' && echo 'PASS: Complete cleanup successful' || echo 'FAIL: Module unload broken'",
                    "echo 'Phase 8: Final Validation Summary'",
                    "echo 'PASS: All runtime-determined allocation validation successful'"
                ],
                "expected": {
                    "dmesg": [
                        "Dynamic memory module loaded",
                        "Runtime device count: .*",
                        "Allocat",
                        "Initializing.*devices",
                        "Device 1000 initialized",
                        "Device ID: 1000",
                        "Status: 200",
                        "Active: YES",
                        "Freeing",
                        "All devices freed",
                        "Module unloaded cleanly"
                    ],
                    "stdout": [
                        "PASS: All function and variable declarations found in header file",
                        "SUCCESS: Runtime-sized allocation test completed",
                        "PASS: Runtime device counts extracted successfully",
                        "PASS: Level 1 allocation \\(device array\\) working",
                        "PASS: Two-level allocation successful",
                        "PASS: Runtime count.*detected",
                        "PASS: Correct device count allocation",
                        "PASS: All devices allocated",
                        "PASS: Device initialization working",
                        "PASS: First device data correct",
                        "PASS: Device status field correct",
                        "PASS: Device boolean field correct",
                        "PASS: Cleanup initiated",
                        "PASS: Two-level cleanup successful",
                        "PASS: Complete cleanup successful",
                        "PASS: All runtime-determined allocation validation successful"
                    ]
                },
                "timeout": 15
            }
        }
    ]
});


// Problem 30: Dynamic Vector Implementation - Kernel Memory Management
generatedTestDefinitions.set(30, {
    "name": "Dynamic Vector Implementation - Kernel Memory Management",
    "category": "foundations",
    "description": "Master dynamic memory management by implementing a production-grade generic vector in kernel space. Learn kmalloc/kfree, dynamic array expansion/shrinking, void* generic programming, and memory-safe operations. This problem teaches critical kernel development skills: dynamic memory allocation, capacity management, bounds checking, and proper resource cleanup - patterns used throughout the Linux kernel in data structure implementations.",
    "exactRequirements": {
        "functionNames": [
            "kernel_vector_init",
            "kernel_vector_exit",
            "vector_init",
            "vector_total",
            "vector_add",
            "vector_set",
            "vector_get",
            "vector_delete",
            "vector_free",
            "vector_resize"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/slab.h",
            "linux/types.h"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int vector_init(vector *v)",
                "int vector_total(vector *v)",
                "int vector_add(vector *v, void *item)",
                "int vector_set(vector *v, int index, void *item)",
                "void *vector_get(vector *v, int index)",
                "int vector_delete(vector *v, int index)",
                "void vector_free(vector *v)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Implementations in Source",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int vector_init(vector *v)",
                "int vector_total(vector *v)",
                "int vector_add(vector *v, void *item)",
                "int vector_set(vector *v, int index, void *item)",
                "void *vector_get(vector *v, int index)",
                "int vector_delete(vector *v, int index)",
                "void vector_free(vector *v)",
                "static int vector_resize(vector *v, int capacity)",
                "static int __init kernel_vector_init(void)",
                "static void __exit kernel_vector_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "struct_definition",
            "name": "Vector Structure Definition",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "typedef struct vector",
                "void **items",
                "int capacity",
                "int total"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages with Function Linkage",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Kernel vector module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "Testing with capacity=",
                    "exact": false,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "Test 1: Vector initialization",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "vector_init: Initializing vector",
                    "exact": true,
                    "linkedFunction": "int vector_init(vector *v)"
                },
                {
                    "pattern": "Vector initialized: capacity=4, total=0",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "Test 2: Adding elements",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "vector_add: Adding item",
                    "exact": false,
                    "linkedFunction": "int vector_add(vector *v, void *item)"
                },
                {
                    "pattern": "Added 'first' at index 0",
                    "exact": false,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "Added 'second' at index 1",
                    "exact": false,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "Added 'third' at index 2",
                    "exact": false,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "Test 3: Getting elements",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "Element at index 0: first",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "Element at index 1:",
                    "exact": false,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "Test 4: Setting element",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "vector_set: Setting index 1",
                    "exact": true,
                    "linkedFunction": "int vector_set(vector *v, int index, void *item)"
                },
                {
                    "pattern": "Modified element at index 1: modified",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "Test 5: Deleting element",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "vector_delete: Deleting index",
                    "exact": false,
                    "linkedFunction": "int vector_delete(vector *v, int index)"
                },
                {
                    "pattern": "Deleted element at index",
                    "exact": false,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "Elements after deletion:",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "Test 6: Edge case testing",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "Get invalid index (100): NULL",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "Set invalid index (100): ERROR",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "vector_free: Freeing vector",
                    "exact": true,
                    "linkedFunction": "void vector_free(vector *v)"
                },
                {
                    "pattern": "Vector freed",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "Test 7: Empty vector operations",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "Empty vector initialized (total=0)",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "Get from empty vector (index 0): NULL (correct)",
                    "exact": true,
                    "linkedFunction": "void *vector_get(vector *v, int index)"
                },
                {
                    "pattern": "Delete from empty vector (index 0): ERROR (correct)",
                    "exact": true,
                    "linkedFunction": "int vector_delete(vector *v, int index)"
                },
                {
                    "pattern": "Set on empty vector (index 0): ERROR (correct)",
                    "exact": true,
                    "linkedFunction": "int vector_set(vector *v, int index, void *item)"
                },
                {
                    "pattern": "Empty vector test completed",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "Test 8: NULL pointer handling",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "Add NULL pointer: SUCCESS",
                    "exact": true,
                    "linkedFunction": "int vector_add(vector *v, void *item)"
                },
                {
                    "pattern": "Get NULL pointer: NULL (correct)",
                    "exact": true,
                    "linkedFunction": "void *vector_get(vector *v, int index)"
                },
                {
                    "pattern": "Mixed NULL and valid pointers: total=4",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "NULL pointer test completed",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "Test 9: Capacity shrinking test",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "After adding 16 items: total=16, capacity=16",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "After deleting to 4 items",
                    "exact": false,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "Capacity shrinking test completed",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "Test 10: Add-Delete cycle test",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "Cycle 0: After adding 10, total=10",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "Cycle 0: After deleting 5, total=5",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "After 3 cycles: total=15",
                    "exact": false,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "Add-Delete cycle test completed",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "All comprehensive tests completed",
                    "exact": true,
                    "linkedFunction": "static int __init kernel_vector_init(void)"
                },
                {
                    "pattern": "Kernel vector module unloaded",
                    "exact": true,
                    "linkedFunction": "static void __exit kernel_vector_exit(void)"
                }
            ]
        },
        {
            "id": "comprehensive_vector_validation",
            "name": "Comprehensive Vector Functionality Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "vector_comprehensive_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Comprehensive Vector Functionality Test ===\\\\n\\\");\\n    \\n    srand(time(NULL));\\n    \\n    int test_capacity = 4 + (rand() % 4);\\n    int test_add_count = 5 + (rand() % 6);\\n    int test_delete_index = 1 + (rand() % 3);\\n    \\n    printf(\\\"Test parameters: capacity=%d, add_count=%d, delete_index=%d\\\\n\\\", test_capacity, test_add_count, test_delete_index);\\n    \\n    system(\\\"rmmod kernel_vector 2>/dev/null\\\");\\n    \\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/kernel_vector.ko test_capacity=%d test_add_count=%d test_delete_index=%d\\\", test_capacity, test_add_count, test_delete_index);\\n    printf(\\\"Loading module with: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Vector comprehensive test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting comprehensive vector validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: TCC Header Validation'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef unsigned long size_t;' > /tmp/linux/types.h",
                    "echo 'typedef unsigned char u8;' >> /tmp/linux/types.h",
                    "echo 'typedef unsigned short u16;' >> /tmp/linux/types.h",
                    "echo 'typedef unsigned int u32;' >> /tmp/linux/types.h",
                    "echo '#include <linux/types.h>' > /tmp/linux/slab.h",
                    "echo 'void *kmalloc(unsigned long size, int flags);' >> /tmp/linux/slab.h",
                    "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
                    "echo 'void *krealloc(const void *ptr, unsigned long size, int flags);' >> /tmp/linux/slab.h",
                    "echo '#define GFP_KERNEL 0' >> /tmp/linux/slab.h",
                    "echo '#include \"/lib/modules/kernel_vector.h\"' > /tmp/test.c",
                    "echo 'int main() { vector v; vector_init(&v); vector_add(&v, (void*)0); vector_get(&v, 0); vector_set(&v, 0, (void*)0); vector_delete(&v, 0); vector_free(&v); return 0; }' >> /tmp/test.c",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declarations missing in header'; cat /tmp/tcc_error.log; else echo 'PASS: All function declarations found in header'; fi",
                    "echo 'Phase 2: Dynamic Vector Functionality Testing'",
                    "/bin/vector_comprehensive_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Vector Operation Validation'",
                    "sleep 1",
                    "echo 'Validating vector initialization...'",
                    "dmesg | grep 'Vector initialized: capacity=4, total=0' && echo 'PASS: Vector initialization correct' || echo 'FAIL: Vector initialization wrong'",
                    "echo 'Validating vector add operations...'",
                    "dmesg | grep 'Added .first. at index 0' && echo 'PASS: Vector add working' || echo 'FAIL: Vector add broken'",
                    "dmesg | grep 'Added .second. at index 1' && echo 'PASS: Vector sequential add working' || echo 'FAIL: Vector sequential add broken'",
                    "echo 'Validating vector get operations...'",
                    "dmesg | grep 'Element at index 0: first' && echo 'PASS: Vector get working' || echo 'FAIL: Vector get broken'",
                    "echo 'Validating vector set operations...'",
                    "dmesg | grep 'Modified element at index 1: modified' && echo 'PASS: Vector set working' || echo 'FAIL: Vector set broken'",
                    "echo 'Validating vector delete operations...'",
                    "dmesg | grep 'Deleted element at index' && echo 'PASS: Vector delete working' || echo 'FAIL: Vector delete broken'",
                    "echo 'Phase 4: Extracting Dynamic Test Parameters'",
                    "TEST_ADD_COUNT=$(dmesg | grep -o 'Testing with capacity=[0-9]*, add_count=[0-9]*' | tail -1 | grep -o 'add_count=[0-9]*' | cut -d'=' -f2)",
                    "TEST_DELETE_INDEX=$(dmesg | grep -o 'delete_index=[0-9]*' | tail -1 | cut -d'=' -f2)",
                    "echo 'Extracted: test_add_count='$TEST_ADD_COUNT', test_delete_index='$TEST_DELETE_INDEX",
                    "if [ -z \"$TEST_ADD_COUNT\" ] || [ \"$TEST_ADD_COUNT\" = \"\" ]; then echo 'WARN: Could not extract test_add_count, using default 5'; TEST_ADD_COUNT=5; fi",
                    "if [ -z \"$TEST_DELETE_INDEX\" ] || [ \"$TEST_DELETE_INDEX\" = \"\" ]; then echo 'WARN: Could not extract test_delete_index, using default 2'; TEST_DELETE_INDEX=2; fi",
                    "echo 'Phase 5: Dynamic Capacity Doubling Validation (CRITICAL)'",
                    "echo 'Checking if capacity doubled based on test_add_count='$TEST_ADD_COUNT",
                    "dmesg | grep 'Added.*at index 0.*capacity=4' && echo 'PASS: Initial capacity=4 confirmed' || echo 'FAIL: Initial capacity wrong'",
                    "if [ $TEST_ADD_COUNT -ge 5 ]; then",
                    "  echo 'With add_count='$TEST_ADD_COUNT', expecting capacity doubling 4→8 at 5th element (index 4)...'",
                    "  dmesg | grep 'Added.*at index 4.*total=5, capacity=8' && echo 'PASS: Capacity doubled correctly (4→8) at index 4' || echo 'FAIL: Capacity doubling broken at index 4'",
                    "else",
                    "  echo 'With add_count='$TEST_ADD_COUNT', no doubling expected (less than 5 elements)'",
                    "  dmesg | grep 'Added.*at index.*capacity=4' && echo 'PASS: Capacity remained 4 (no doubling needed)' || echo 'FAIL: Unexpected capacity change'",
                    "fi",
                    "if [ $TEST_ADD_COUNT -ge 9 ]; then",
                    "  echo 'With add_count='$TEST_ADD_COUNT', expecting second doubling 8→16 at 9th element (index 8)...'",
                    "  dmesg | grep 'Added.*at index 8.*total=9, capacity=16' && echo 'PASS: Second capacity doubling (8→16) at index 8' || echo 'FAIL: Second doubling broken'",
                    "fi",
                    "echo 'Phase 6: Dynamic Delete and Element Shifting Validation (CRITICAL)'",
                    "echo 'Verifying delete at index '$TEST_DELETE_INDEX' shifted elements correctly...'",
                    "dmesg | grep 'Deleted element at index '$TEST_DELETE_INDEX && echo 'PASS: Deleted at index '$TEST_DELETE_INDEX' (dynamic)' || echo 'FAIL: Delete at index '$TEST_DELETE_INDEX' failed'",
                    "dmesg | grep 'Elements after deletion:' && echo 'PASS: Post-deletion verification present' || echo 'FAIL: No post-deletion check'",
                    "if [ \"$TEST_ADD_COUNT\" -gt 5 ]; then EXPECTED_TOTAL_AFTER_DELETE=4; else EXPECTED_TOTAL_AFTER_DELETE=$((TEST_ADD_COUNT - 1)); fi",
                    "ACTUAL_TOTAL=$(dmesg | grep 'Deleted element at index.*total=' | tail -1 | grep -o 'total=[0-9]*' | cut -d'=' -f2)",
                    "if [ -n \"$ACTUAL_TOTAL\" ] && [ \"$ACTUAL_TOTAL\" -eq \"$EXPECTED_TOTAL_AFTER_DELETE\" ] 2>/dev/null; then",
                    "  echo 'PASS: Total count correct after delete (expected='$EXPECTED_TOTAL_AFTER_DELETE', actual='$ACTUAL_TOTAL')'",
                    "elif [ -n \"$ACTUAL_TOTAL\" ]; then",
                    "  echo 'INFO: Total after delete: actual='$ACTUAL_TOTAL' (delete successful)'",
                    "else",
                    "  echo 'WARN: Could not verify total count after delete'",
                    "fi",
                    "dmesg | grep -A1 'Elements after deletion:' | grep 'Index 0:' && echo 'PASS: Elements still accessible after delete' || echo 'FAIL: Elements missing after delete'",
                    "echo 'Phase 7: Dynamic Resize Function Validation (CRITICAL)'",
                    "dmesg | grep 'vector_resize:' && echo 'PASS: vector_resize() function called' || echo 'FAIL: vector_resize() never called'",
                    "if [ $TEST_ADD_COUNT -ge 5 ]; then",
                    "  dmesg | grep 'vector_resize: 4 to 8' && echo 'PASS: Resize from 4→8 confirmed (dynamic test)' || echo 'FAIL: Expected resize 4→8 missing'",
                    "fi",
                    "if [ $TEST_ADD_COUNT -ge 9 ]; then",
                    "  dmesg | grep 'vector_resize: 8 to 16' && echo 'PASS: Resize from 8→16 confirmed (dynamic test)' || echo 'FAIL: Expected resize 8→16 missing'",
                    "fi",
                    "RESIZE_COUNT=$(dmesg | grep -c 'vector_resize:')",
                    "EXPECTED_RESIZES=0",
                    "if [ $TEST_ADD_COUNT -ge 5 ]; then EXPECTED_RESIZES=1; fi",
                    "if [ $TEST_ADD_COUNT -ge 9 ]; then EXPECTED_RESIZES=2; fi",
                    "echo 'Expected resizes: '$EXPECTED_RESIZES', Actual resizes: '$RESIZE_COUNT",
                    "if [ $RESIZE_COUNT -ge $EXPECTED_RESIZES ]; then echo 'PASS: Dynamic resizing implemented correctly ('$RESIZE_COUNT' resize(s))'; else echo 'FAIL: Insufficient resizes (expected >='$EXPECTED_RESIZES', got '$RESIZE_COUNT')'; fi",
                    "echo 'Phase 8: Edge Case Validation'",
                    "dmesg | grep 'Get invalid index.*100.*: NULL' && echo 'PASS: Invalid get returns NULL' || echo 'FAIL: Invalid get handling broken'",
                    "dmesg | grep 'Set invalid index.*100.*: ERROR' && echo 'PASS: Invalid set returns ERROR' || echo 'FAIL: Invalid set handling broken'",
                    "echo 'Phase 9: Memory Management Validation'",
                    "dmesg | grep 'vector_free: Freeing vector' && echo 'PASS: vector_free() called' || echo 'FAIL: vector_free() not called'",
                    "dmesg | grep 'Vector freed' && echo 'PASS: Vector cleanup completed' || echo 'FAIL: Vector cleanup broken'",
                    "echo 'Phase 10: Empty Vector Operations Validation (COMPREHENSIVE)'",
                    "dmesg | grep 'Test 7: Empty vector operations' && echo 'PASS: Empty vector test present' || echo 'FAIL: Empty vector test missing'",
                    "dmesg | grep 'Empty vector initialized.*total=0' && echo 'PASS: Empty vector init correct' || echo 'FAIL: Empty vector init wrong'",
                    "dmesg | grep 'Get from empty vector.*NULL.*correct' && echo 'PASS: Empty get returns NULL' || echo 'FAIL: Empty get broken'",
                    "dmesg | grep 'Delete from empty vector.*ERROR.*correct' && echo 'PASS: Empty delete returns ERROR' || echo 'FAIL: Empty delete broken'",
                    "dmesg | grep 'Set on empty vector.*ERROR.*correct' && echo 'PASS: Empty set returns ERROR' || echo 'FAIL: Empty set broken'",
                    "dmesg | grep 'Empty vector test completed' && echo 'PASS: Empty vector comprehensive test passed' || echo 'FAIL: Empty vector test incomplete'",
                    "echo 'Phase 11: NULL Pointer Handling Validation (COMPREHENSIVE)'",
                    "dmesg | grep 'Test 8: NULL pointer handling' && echo 'PASS: NULL test present' || echo 'FAIL: NULL test missing'",
                    "dmesg | grep 'Add NULL pointer: SUCCESS' && echo 'PASS: Can add NULL pointers' || echo 'FAIL: Cannot add NULL'",
                    "dmesg | grep 'Get NULL pointer: NULL.*correct' && echo 'PASS: NULL retrieved correctly' || echo 'FAIL: NULL retrieval broken'",
                    "dmesg | grep 'Mixed NULL and valid pointers: total=4' && echo 'PASS: Mixed NULL/valid storage' || echo 'FAIL: Mixed storage broken'",
                    "dmesg | grep 'Index 0: NULL' && echo 'PASS: NULL at index 0 detected' || echo 'FAIL: NULL detection broken'",
                    "dmesg | grep 'Index 1: valid' && echo 'PASS: Valid pointer after NULL' || echo 'FAIL: Valid after NULL broken'",
                    "dmesg | grep 'NULL pointer test completed' && echo 'PASS: NULL comprehensive test passed' || echo 'FAIL: NULL test incomplete'",
                    "echo 'Phase 12: Capacity Shrinking Validation (COMPREHENSIVE)'",
                    "dmesg | grep 'Test 9: Capacity shrinking test' && echo 'PASS: Shrinking test present' || echo 'FAIL: Shrinking test missing'",
                    "dmesg | grep 'After adding 16 items: total=16, capacity=16' && echo 'PASS: Expanded to capacity=16' || echo 'FAIL: Expansion to 16 wrong'",
                    "dmesg | grep 'After deleting to 4 items.*total=4, capacity=8' && echo 'PASS: Shrinking 16→8 WORKS!' || echo 'INFO: Shrinking not implemented (optional)'",
                    "dmesg | grep 'Capacity shrinking: SUCCESS' && echo 'PASS: Shrinking algorithm implemented' || echo 'INFO: Shrinking optional feature'",
                    "dmesg | grep 'Capacity shrinking test completed' && echo 'PASS: Shrinking test completed' || echo 'FAIL: Shrinking test incomplete'",
                    "echo 'Phase 13: Add-Delete Cycle Validation (COMPREHENSIVE)'",
                    "dmesg | grep 'Test 10: Add-Delete cycle test' && echo 'PASS: Cycle test present' || echo 'FAIL: Cycle test missing'",
                    "dmesg | grep 'Cycle 0: After adding 10, total=10' && echo 'PASS: Cycle 0 add phase' || echo 'FAIL: Cycle 0 add broken'",
                    "dmesg | grep 'Cycle 0: After deleting 5, total=5' && echo 'PASS: Cycle 0 delete phase' || echo 'FAIL: Cycle 0 delete broken'",
                    "dmesg | grep 'Cycle 2: After adding 10' && echo 'PASS: Multiple cycles executed' || echo 'FAIL: Only single cycle'",
                    "dmesg | grep 'After 3 cycles: total=15' && echo 'PASS: Final total correct (3 cycles, +5 each)' || echo 'FAIL: Cycle math wrong'",
                    "dmesg | grep 'Add-Delete cycle test completed' && echo 'PASS: Cycle test passed' || echo 'FAIL: Cycle test incomplete'",
                    "echo 'Phase 14: Comprehensive Test Summary'",
                    "dmesg | grep 'All comprehensive tests completed' && echo 'PASS: All 10 comprehensive tests completed' || echo 'FAIL: Not all tests completed'",
                    "TOTAL_TESTS=$(dmesg | grep -c 'Test [0-9]*:')",
                    "echo 'Total test suites detected: '$TOTAL_TESTS",
                    "if [ $TOTAL_TESTS -ge 10 ]; then echo 'PASS: All 10 test suites present'; else echo 'FAIL: Missing test suites (found '$TOTAL_TESTS'/10)'; fi",
                    "echo '======================================================================'",
                    "echo 'COMPREHENSIVE VALIDATION SUMMARY'",
                    "echo '======================================================================'",
                    "echo 'PASS: Core Operations: init, add, get, set, delete, free'",
                    "echo 'PASS: Dynamic Expansion: Capacity doubling (4->8->16->32...)'",
                    "echo 'PASS: Dynamic Shrinking: Capacity halving at 25% full'",
                    "echo 'PASS: Empty Vector Ops: NULL returns, ERROR codes'",
                    "echo 'PASS: NULL Handling: Store and retrieve NULL pointers'",
                    "echo 'PASS: Cycle Testing: Add-delete patterns'",
                    "echo 'PASS: Edge Cases: Invalid indices, bounds checking'",
                    "echo 'PASS: Memory Management: Proper cleanup, no leaks'",
                    "echo '======================================================================'",
                    "echo 'PASS: All comprehensive vector validation phases completed successfully'"
                ],
                "expected": {
                    "dmesg": [
                        "Kernel vector module loaded",
                        "Testing with capacity=",
                        "Test 1: Vector initialization",
                        "vector_init: Initializing vector",
                        "Vector initialized: capacity=4, total=0",
                        "Test 2: Adding elements",
                        "vector_add: Adding item",
                        "Added 'first' at index 0",
                        "Added 'second' at index 1",
                        "Test 3: Getting elements",
                        "Element at index 0: first",
                        "Test 4: Setting element",
                        "vector_set: Setting index 1",
                        "Modified element at index 1: modified",
                        "Test 5: Deleting element",
                        "vector_delete: Deleting index",
                        "Deleted element at index",
                        "Elements after deletion:",
                        "Test 6: Edge case testing",
                        "Get invalid index.*: NULL",
                        "Set invalid index.*: ERROR",
                        "vector_resize:",
                        "vector_free: Freeing vector",
                        "Vector freed",
                        "Test 7: Empty vector operations",
                        "Empty vector initialized.*total=0",
                        "Get from empty vector.*NULL.*correct",
                        "Delete from empty vector.*ERROR.*correct",
                        "Set on empty vector.*ERROR.*correct",
                        "Empty vector test completed",
                        "Test 8: NULL pointer handling",
                        "Add NULL pointer: SUCCESS",
                        "Get NULL pointer: NULL.*correct",
                        "Mixed NULL and valid pointers: total=4",
                        "Index 0: NULL",
                        "Index 1: valid",
                        "NULL pointer test completed",
                        "Test 9: Capacity shrinking test",
                        "After adding 16 items: total=16, capacity=16",
                        "After deleting to 4 items.*total=4",
                        "Capacity shrinking test completed",
                        "Test 10: Add-Delete cycle test",
                        "Cycle 0: After adding 10, total=10",
                        "Cycle 0: After deleting 5, total=5",
                        "After 3 cycles: total=15",
                        "Add-Delete cycle test completed",
                        "All comprehensive tests completed",
                        "Kernel vector module unloaded"
                    ],
                    "stdout": [
                        "PASS: All function declarations found in header",
                        "SUCCESS: Vector comprehensive test completed",
                        "PASS: Vector initialization correct",
                        "PASS: Vector add working",
                        "PASS: Vector sequential add working",
                        "PASS: Vector get working",
                        "PASS: Vector set working",
                        "PASS: Vector delete working",
                        "Extracted: test_add_count=.*delete_index=",
                        "PASS: Initial capacity=4 confirmed",
                        "Capacity doubled correctly.*at index 4|Capacity remained 4",
                        "PASS: Deleted at index.*dynamic",
                        "PASS: Post-deletion verification present",
                        "Total count correct after delete|Total after delete.*delete successful",
                        "PASS: Elements still accessible after delete",
                        "PASS: vector_resize\\(\\) function called",
                        "Resize from 4.*8 confirmed.*dynamic|Expected resizes: 0",
                        "PASS: Dynamic resizing implemented correctly.*resize",
                        "PASS: Invalid get returns NULL",
                        "PASS: Invalid set returns ERROR",
                        "PASS: vector_free\\(\\) called",
                        "PASS: Vector cleanup completed",
                        "PASS: Empty vector test present",
                        "PASS: Empty vector init correct",
                        "PASS: Empty get returns NULL",
                        "PASS: Empty delete returns ERROR",
                        "PASS: Empty set returns ERROR",
                        "PASS: Empty vector comprehensive test passed",
                        "PASS: NULL test present",
                        "PASS: Can add NULL pointers",
                        "PASS: NULL retrieved correctly",
                        "PASS: Mixed NULL/valid storage",
                        "PASS: NULL at index 0 detected",
                        "PASS: Valid pointer after NULL",
                        "PASS: NULL comprehensive test passed",
                        "PASS: Shrinking test present",
                        "PASS: Expanded to capacity=16",
                        "PASS: Shrinking test completed",
                        "PASS: Cycle test present",
                        "PASS: Cycle 0 add phase",
                        "PASS: Cycle 0 delete phase",
                        "PASS: Multiple cycles executed",
                        "PASS: Final total correct.*3 cycles",
                        "PASS: Cycle test passed",
                        "PASS: All 10 comprehensive tests completed",
                        "Total test suites detected:",
                        "PASS: All 10 test suites present",
                        "COMPREHENSIVE VALIDATION SUMMARY",
                        "PASS: Core Operations:",
                        "PASS: Dynamic Expansion:",
                        "PASS: Dynamic Shrinking:",
                        "PASS: Empty Vector Ops:",
                        "PASS: NULL Handling:",
                        "PASS: Cycle Testing:",
                        "PASS: Edge Cases:",
                        "PASS: Memory Management:",
                        "PASS: All comprehensive vector validation phases completed successfully"
                    ]
                },
                "timeout": 30
            }
        }
    ]
});


// Problem 31: Typed Vector Wrappers - Building Generic Libraries with Macros
generatedTestDefinitions.set(31, {
    "name": "Typed Vector Wrappers - Building Generic Libraries with Macros",
    "category": "foundations",
    "description": "Master macro-based generic programming by creating type-safe wrappers around the generic vector. Learn to build reusable 'template-like' libraries in C using typedef aliases and macros - the exact pattern used in production kernel code like the Linux kernel's list.h and other generic data structures. This problem teaches you to turn void* containers into type-safe interfaces without code duplication.",
    "exactRequirements": {
        "functionNames": [
            "sensor_vector_init",
            "sensor_vector_exit",
            "create_sensor",
            "print_sensor",
            "free_all_sensors"
        ],
        "variables": [
            {
                "name": "test_sensor_count",
                "type": "int",
                "value": 3,
                "storageClass": "none"
            },
            {
                "name": "test_sensor_id_base",
                "type": "int",
                "value": 1000,
                "storageClass": "none"
            }
        ],
        "outputMessages": [
            "Sensor vector module loaded",
            "Testing with 3 sensors starting from ID 1000",
            "Test 1: Initializing sensor vector",
            "Sensor vector initialized",
            "Test 2: Creating and adding sensors",
            "Added sensor ID 1000",
            "Added sensor ID 1001",
            "Added sensor ID 1002",
            "Test 3: Accessing and printing sensors",
            "Sensor ID: 1000",
            "Sensor ID: 1001",
            "Sensor ID: 1002",
            "Test 4: Modifying sensor",
            "Modified sensor at index 0",
            "Sensor ID: 9999",
            "Test 5: Deleting sensor",
            "Deleted sensor",
            "Test 6: Final vector state",
            "Cleaning up all sensors",
            "All tests completed successfully",
            "Sensor vector module unloaded"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/slab.h",
            "linux/types.h",
            "linux/string.h",
            "linux/jiffies.h"
        ],
        "mustContain": [
            "typedef vector sensor_vector",
            "#define SENSOR_VEC_INIT(v) vector_init(&(v))",
            "#define SENSOR_VEC_ADD(v, sensor_ptr) vector_add(&(v), (void*)(sensor_ptr))",
            "#define SENSOR_VEC_GET(v, idx) ((SensorData*)vector_get(&(v), (idx)))",
            "#define SENSOR_VEC_TOTAL(v) vector_total(&(v))",
            "#define SENSOR_VEC_FREE(v) vector_free(&(v))",
            "kmalloc(sizeof(SensorData), GFP_KERNEL)",
            "strscpy(",
            "get_jiffies_64()",
            "for (i = 0; i < SENSOR_VEC_TOTAL(*sv); i++)",
            "kfree(s)",
            "SENSOR_VEC_FREE(*sv)",
            "module_param(test_sensor_count, int, 0644)",
            "module_param(test_sensor_id_base, int, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "SensorData* create_sensor(uint32_t id, const char *name, uint32_t value, const char *unit)",
                "void print_sensor(SensorData *sensor)",
                "void free_all_sensors(sensor_vector *sv)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Implementations in Source",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "SensorData* create_sensor(uint32_t id, const char *name, uint32_t value, const char *unit)",
                "void print_sensor(SensorData *sensor)",
                "void free_all_sensors(sensor_vector *sv)",
                "static int __init sensor_vector_init(void)",
                "static void __exit sensor_vector_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "struct_definition",
            "name": "SensorData Structure Definition",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "typedef struct",
                "uint32_t sensor_id",
                "char sensor_name[MAX_SENSOR_NAME]",
                "uint32_t reading_value",
                "char unit[MAX_SENSOR_UNIT]",
                "uint64_t timestamp",
                "bool is_active"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Sensor vector module loaded",
                    "exact": true,
                    "linkedFunction": "static int __init sensor_vector_init(void)"
                },
                {
                    "pattern": "Testing with 3 sensors starting from ID 1000",
                    "exact": true,
                    "linkedFunction": "static int __init sensor_vector_init(void)"
                },
                {
                    "pattern": "Sensor vector initialized",
                    "exact": true,
                    "linkedFunction": "static int __init sensor_vector_init(void)"
                },
                {
                    "pattern": "Added sensor ID 1000",
                    "exact": false,
                    "linkedFunction": "static int __init sensor_vector_init(void)"
                },
                {
                    "pattern": "Sensor ID: 1000",
                    "exact": true,
                    "linkedFunction": "void print_sensor(SensorData *sensor)"
                },
                {
                    "pattern": "Sensor ID: 9999",
                    "exact": true,
                    "linkedFunction": "void print_sensor(SensorData *sensor)"
                },
                {
                    "pattern": "All tests completed successfully",
                    "exact": true,
                    "linkedFunction": "static int __init sensor_vector_init(void)"
                },
                {
                    "pattern": "Sensor vector module unloaded",
                    "exact": true,
                    "linkedFunction": "static void __exit sensor_vector_exit(void)"
                }
            ]
        },
        {
            "id": "comprehensive_typed_vector_validation",
            "name": "Comprehensive Typed Vector Wrapper Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "sensor_vector_dynamic_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Typed Vector Wrapper Test ===\\\\n\\\");\\n    \\n    srand(time(NULL));\\n    \\n    int random_sensor_count = (rand() % 3) + 2;\\n    int random_id_base = (rand() % 900) + 1000;\\n    \\n    printf(\\\"Test 1: Creating %d sensors with base ID %d\\\\n\\\", random_sensor_count, random_id_base);\\n    \\n    system(\\\"rmmod sensor_vector 2>/dev/null\\\");\\n    system(\\\"rmmod kernel_vector 2>/dev/null\\\");\\n    \\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/kernel_vector.ko && insmod /lib/modules/sensor_vector.ko test_sensor_count=%d test_sensor_id_base=%d\\\", random_sensor_count, random_id_base);\\n    printf(\\\"DEBUG: Command: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Dynamic typed vector test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting comprehensive typed vector wrapper validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: TCC Header Validation'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef int bool;' > /tmp/linux/types.h",
                    "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
                    "echo 'typedef unsigned long long uint64_t;' >> /tmp/linux/types.h",
                    "echo '#define true 1' >> /tmp/linux/types.h",
                    "echo '#define false 0' >> /tmp/linux/types.h",
                    "echo '#define MAX_SENSOR_NAME 32' >> /tmp/linux/types.h",
                    "echo '#define MAX_SENSOR_UNIT 16' >> /tmp/linux/types.h",
                    "echo 'void *kmalloc(unsigned long size, int flags);' > /tmp/linux/slab.h",
                    "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
                    "echo '#define GFP_KERNEL 0' >> /tmp/linux/slab.h",
                    "echo 'unsigned long long get_jiffies_64(void);' > /tmp/linux/jiffies.h",
                    "echo 'char *strscpy(char *dest, const char *src, unsigned long count);' > /tmp/linux/string.h",
                    "echo '#include \"/lib/modules/sensor_vector.h\"' > /tmp/test.c",
                    "echo 'int main() { sensor_vector sv; SensorData *s; SENSOR_VEC_INIT(sv); s = create_sensor(1, \"test\", 314, \"C\"); SENSOR_VEC_ADD(sv, s); print_sensor(s); free_all_sensors(&sv); return 0; }' >> /tmp/test.c",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or macro declarations missing in header'; cat /tmp/tcc_error.log; else echo 'PASS: All function and macro declarations found in header file'; fi",
                    "echo 'Phase 2: Dynamic Typed Vector Testing'",
                    "/bin/sensor_vector_dynamic_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Extract Runtime Values'",
                    "sleep 1",
                    "SENSOR_COUNT=$(grep -o 'Creating [0-9]* sensors' /tmp/test_output.log | grep -o '[0-9]*' | head -1)",
                    "ID_BASE=$(grep -o 'base ID [0-9]*' /tmp/test_output.log | grep -o '[0-9]*' | head -1)",
                    "echo 'Extracted values: SENSOR_COUNT='$SENSOR_COUNT', ID_BASE='$ID_BASE",
                    "if [ -z \"$SENSOR_COUNT\" ] || [ -z \"$ID_BASE\" ]; then echo 'FAIL: Could not extract test values'; else echo 'PASS: Test values extracted successfully'; fi",
                    "echo 'Phase 4: Validate Typedef and Macros'",
                    "dmesg | grep 'Sensor vector initialized' && echo 'PASS: SENSOR_VEC_INIT macro working' || echo 'FAIL: Init macro broken'",
                    "dmesg | grep -E 'Added sensor ID' && echo 'PASS: SENSOR_VEC_ADD macro working' || echo 'FAIL: Add macro broken'",
                    "dmesg | grep 'Sensor ID: '$ID_BASE && echo 'PASS: SENSOR_VEC_GET macro working with dynamic ID' || echo 'FAIL: Get macro broken'",
                    "echo 'Phase 5: Validate Sensor Creation'",
                    "dmesg | grep 'Sensor ID: '$ID_BASE && echo 'PASS: create_sensor() working with dynamic ID' || echo 'FAIL: create_sensor broken'",
                    "ID_PLUS_1=$((ID_BASE + 1))",
                    "dmesg | grep 'Sensor ID: '$ID_PLUS_1 && echo 'PASS: Multiple sensors created correctly' || echo 'FAIL: Multiple sensor creation broken'",
                    "echo 'Phase 6: Validate Printing and Cleanup'",
                    "dmesg | grep 'Name:' && echo 'PASS: print_sensor() implemented' || echo 'FAIL: print_sensor missing'",
                    "dmesg | grep 'Reading:' && echo 'PASS: Sensor reading field printed' || echo 'FAIL: Reading field missing'",
                    "dmesg | grep 'Cleaning up all sensors' && echo 'PASS: free_all_sensors() called' || echo 'FAIL: Cleanup not called'",
                    "echo 'Phase 7: Validate Modified Sensor (ID 9999)'",
                    "dmesg | grep 'Sensor ID: 9999' && echo 'PASS: SENSOR_VEC_SET macro working' || echo 'FAIL: Set macro broken'",
                    "dmesg | grep 'Modified_Sensor' && echo 'PASS: Sensor modification working' || echo 'FAIL: Modification broken'",
                    "echo 'Phase 8: Module System Validation'",
                    "dmesg | grep 'Sensor vector module loaded' && echo 'PASS: Module init working' || echo 'FAIL: Module init broken'",
                    "dmesg | grep 'All tests completed successfully' && echo 'PASS: All tests passed' || echo 'FAIL: Tests incomplete'",
                    "echo 'PASS: All comprehensive typed vector validation completed successfully'"
                ],
                "expected": {
                    "dmesg": [
                        "Sensor vector module loaded",
                        "Testing with.*sensors starting from ID",
                        "Sensor vector initialized",
                        "Added sensor ID",
                        "Sensor ID: .*",
                        "Name: .*",
                        "Reading: .*",
                        "Modified sensor at index 0",
                        "Sensor ID: 9999",
                        "Cleaning up all sensors",
                        "All tests completed successfully",
                        "Sensor vector module unloaded"
                    ],
                    "stdout": [
                        "PASS: All function and macro declarations found in header file",
                        "SUCCESS: Dynamic typed vector test completed",
                        "PASS: Test values extracted successfully",
                        "PASS: SENSOR_VEC_INIT macro working",
                        "PASS: SENSOR_VEC_ADD macro working",
                        "PASS: SENSOR_VEC_GET macro working with dynamic ID",
                        "PASS: create_sensor\\(\\) working with dynamic ID",
                        "PASS: Multiple sensors created correctly",
                        "PASS: print_sensor\\(\\) implemented",
                        "PASS: Sensor reading field printed",
                        "PASS: free_all_sensors\\(\\) called",
                        "PASS: SENSOR_VEC_SET macro working",
                        "PASS: Sensor modification working",
                        "PASS: Module init working",
                        "PASS: All tests passed",
                        "PASS: All comprehensive typed vector validation completed successfully"
                    ]
                },
                "timeout": 20
            }
        }
    ]
});


// Problem 79: Secure String Handling - Modern Kernel Text Operations
generatedTestDefinitions.set(79, {
    "name": "Secure String Handling - Modern Kernel Text Operations",
    "category": "foundations",
    "description": "Learn modern, secure string handling in kernel space using current best practices. Master strscpy(), snprintf(), and safe string operations essential for handling device names, user messages, and configuration data in kernel modules.",
    "exactRequirements": {
        "functionNames": [
            "strings_init",
            "strings_exit",
            "display_device_info",
            "update_device_name",
            "format_status_message",
            "validate_string_input"
        ],
        "variables": [
            {
                "name": "device_name",
                "type": "char[]",
                "value": "\"sensor_001\""
            },
            {
                "name": "status_message",
                "type": "char[]",
                "value": "\"initializing\""
            },
            {
                "name": "name_length",
                "type": "int",
                "value": 0
            }
        ],
        "outputMessages": [
            "Secure string handling module loaded",
            "Device: sensor_001 (Length: 10)",
            "Status: initializing",
            "Device name updated successfully",
            "Device: updated_sensor (Length: 14)",
            "Status: Device updated_sensor is active"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/types.h",
            "linux/string.h"
        ],
        "mustContain": [
            "#define MAX_DEVICE_NAME 32",
            "#define MAX_STATUS_MSG 64",
            "extern char device_name[MAX_DEVICE_NAME]",
            "extern char status_message[MAX_STATUS_MSG]",
            "module_param_string(device_name, device_name, MAX_DEVICE_NAME, 0644)",
            "module_param_string(status_message, status_message, MAX_STATUS_MSG, 0644)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void display_device_info(void)",
                "ssize_t update_device_name(const char *new_name)",
                "int format_status_message(const char *status)",
                "int validate_string_input(const char *input)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void display_device_info(void)",
                "ssize_t update_device_name(const char *new_name)",
                "int format_status_message(const char *status)",
                "int validate_string_input(const char *input)",
                "static int __init strings_init(void)",
                "static void __exit strings_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "advanced_string_implementation_validation",
            "name": "Advanced String Implementation with TCC Header Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "string_impl_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\"=== Dynamic String Implementation Test ===\\\\n\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random device names and statuses\\n    const char* device_prefixes[] = {\"sensor\", \"actuator\", \"controller\", \"monitor\"};\\n    const char* statuses[] = {\"active\", \"idle\", \"error\", \"maintenance\", \"ready\"};\\n    \\n    int device_idx = rand() % 4;\\n    int device_num = (rand() % 100) + 1;\\n    int status_idx = rand() % 5;\\n    \\n    char device_name[32];\\n    snprintf(device_name, sizeof(device_name), \"%s_%03d\", device_prefixes[device_idx], device_num);\\n    \\n    printf(\"Test 1: Device name '%s' with status '%s'\\\\n\", device_name, statuses[status_idx]);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \"insmod /lib/modules/strings.ko device_name=%s status_message=%s\", device_name, statuses[status_idx]);\\n    system(\"rmmod strings 2>/dev/null\");\\n    system(cmd1);\\n    \\n    // Second test with different values\\n    device_idx = rand() % 4;\\n    device_num = (rand() % 100) + 1;\\n    status_idx = rand() % 5;\\n    snprintf(device_name, sizeof(device_name), \"%s_%03d\", device_prefixes[device_idx], device_num);\\n    \\n    printf(\"Test 2: Device name '%s' with status '%s'\\\\n\", device_name, statuses[status_idx]);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \"insmod /lib/modules/strings.ko device_name=%s status_message=%s\", device_name, statuses[status_idx]);\\n    system(\"rmmod strings\");\\n    system(cmd2);\\n    \\n    printf(\"SUCCESS: Dynamic string test completed\\\\n\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting advanced string implementation validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
                    "echo 'Creating minimal kernel header stubs for TCC...'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
                    "echo '#define KERN_WARNING' >> /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define module_param_string(name, string, len, perm)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef long ssize_t;' > /tmp/linux/types.h",
                    "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
                    "echo 'ssize_t strscpy(char *dest, const char *src, size_t count);' > /tmp/linux/string.h",
                    "echo 'int snprintf(char *buf, size_t size, const char *fmt, ...);' >> /tmp/linux/string.h",
                    "echo 'size_t strlen(const char *s);' >> /tmp/linux/string.h",
                    "echo '#define EINVAL 22' > /tmp/linux/errno.h",
                    "echo '#define E2BIG 7' >> /tmp/linux/errno.h",
                    "echo 'Creating test file that includes student header...'",
                    "echo '#include \"/lib/modules/strings.h\"' > /tmp/test.c",
                    "echo 'int main() { display_device_info(); update_device_name(\"test\"); format_status_message(\"active\"); validate_string_input(\"input\"); return 0; }' >> /tmp/test.c",
                    "echo 'Running TCC validation...'",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; exit 1; fi",
                    "echo 'PASS: All function declarations found in header file'",
                    "echo 'Phase 2: Dynamic String Implementation Testing'",
                    "/bin/string_impl_tester > /tmp/test_output.log",
                    "cat /tmp/test_output.log",
                    "echo 'Phase 3: Dynamic Value Extraction and Validation'",
                    "echo 'Adding delay to ensure dmesg messages are written...'",
                    "sleep 1",
                    "echo 'Extracting random test values from output...'",
                    "TEST1_LINE=$(grep 'Test 1: Device name' /tmp/test_output.log)",
                    "TEST2_LINE=$(grep 'Test 2: Device name' /tmp/test_output.log)",
                    "echo 'Test 1 values: '$TEST1_LINE",
                    "echo 'Test 2 values: '$TEST2_LINE",
                    "echo 'Validating string operation output'",
                    "dmesg | grep 'Secure string handling module loaded' && echo 'PASS: Module loaded correctly' || echo 'FAIL: Module loading issue'",
                    "dmesg | grep 'Device:.*Length:' && echo 'PASS: Device info display working' || echo 'FAIL: Device info display broken'",
                    "dmesg | grep 'Status:' && echo 'PASS: Status message working' || echo 'FAIL: Status message broken'",
                    "dmesg | grep 'Device name updated successfully' && echo 'PASS: String update working' || echo 'FAIL: String update broken'",
                    "echo 'All dynamic string validations completed'"
                ],
                "expected": {
                    "dmesg": [
                        "Secure string handling module loaded",
                        "Device: .* \\(Length: .*\\)",
                        "Status: .*",
                        "Device name updated successfully"
                    ],
                    "stdout": [
                        "PASS: All function declarations found in header file",
                        "SUCCESS: Dynamic string test completed",
                        "PASS: Module loaded correctly",
                        "PASS: Device info display working",
                        "PASS: Status message working",
                        "PASS: String update working"
                    ]
                },
                "timeout": 35
            }
        }
    ]
});


// Problem 102: Character Device Counter - Your First Device Driver
generatedTestDefinitions.set(102, {
    "name": "Character Device Counter - Your First Device Driver",
    "category": "kernel_core",
    "description": "Learn the fundamentals of character device drivers by creating a simple counter device. Every time a user reads from /dev/counter, the device returns an incrementing number. This teaches device registration, file operations, and kernel-userspace communication - the foundation for all device drivers including GPU drivers.",
    "exactRequirements": {
        "functionNames": [
            "counter_init",
            "counter_exit",
            "device_open",
            "device_release",
            "device_read"
        ],
        "variables": [
            {
                "name": "counter",
                "type": "int",
                "value": "0",
                "storageClass": "static"
            },
            {
                "name": "device_open_count",
                "type": "int",
                "value": "0",
                "storageClass": "static"
            },
            {
                "name": "fops",
                "type": "struct file_operations",
                "value": "{.owner = THIS_MODULE, .read = device_read, .open = device_open, .release = device_release}",
                "storageClass": "static"
            }
        ],
        "outputMessages": [
            "Counter device registered with major number 240",
            "Create device with: mknod /dev/counter c 240 0",
            "Counter device opened",
            "Counter read: returned 0",
            "Counter read: returned 1",
            "Counter read: returned 2",
            "Counter device closed",
            "Counter device unregistered"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/fs.h",
            "linux/uaccess.h"
        ],
        "mustContain": [
            "register_chrdev",
            "unregister_chrdev",
            "copy_to_user",
            "struct file_operations",
            ".read",
            ".open",
            ".release",
            "THIS_MODULE",
            "device_open_count++",
            "device_open_count--",
            "counter++"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "macro_definitions",
            "name": "Macro Definitions",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "#define DEVICE_NAME \"counter\"",
                "#define MAJOR_NUM 240"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Implementations in Source",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "static int device_open(struct inode *inode, struct file *file)",
                "static int device_release(struct inode *inode, struct file *file)",
                "static ssize_t device_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)",
                "static int __init counter_init(void)",
                "static void __exit counter_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "file_operations_structure",
            "name": "file_operations Structure",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "struct file_operations",
                ".owner = THIS_MODULE",
                ".read = device_read",
                ".open = device_open",
                ".release = device_release"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "device_registration",
            "name": "Device Registration Implementation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "register_chrdev",
                "MAJOR_NUM",
                "DEVICE_NAME",
                "&fops"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "copy_to_user_usage",
            "name": "copy_to_user Implementation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "copy_to_user",
                "buffer",
                "sprintf",
                "Counter:"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Counter device registered with major number 240",
                    "exact": true,
                    "linkedFunction": "static int __init counter_init(void)"
                },
                {
                    "pattern": "Create device with: mknod /dev/counter c 240 0",
                    "exact": true,
                    "linkedFunction": "static int __init counter_init(void)"
                },
                {
                    "pattern": "Counter device opened",
                    "exact": true,
                    "linkedFunction": "int device_open(struct inode *inode, struct file *file)"
                },
                {
                    "pattern": "Counter read: returned 0",
                    "exact": true,
                    "linkedFunction": "ssize_t device_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)"
                },
                {
                    "pattern": "Counter read: returned 1",
                    "exact": true,
                    "linkedFunction": "ssize_t device_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)"
                },
                {
                    "pattern": "Counter read: returned 2",
                    "exact": true,
                    "linkedFunction": "ssize_t device_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)"
                },
                {
                    "pattern": "Counter device closed",
                    "exact": true,
                    "linkedFunction": "int device_release(struct inode *inode, struct file *file)"
                },
                {
                    "pattern": "Counter device unregistered",
                    "exact": true,
                    "linkedFunction": "static void __exit counter_exit(void)"
                }
            ]
        },
        {
            "id": "character_device_integration",
            "name": "Character Device Integration Test",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [
                    {
                        "name": "counter_device_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <fcntl.h>\\n#include <unistd.h>\\n#include <string.h>\\n\\nint main() {\\n    int fd;\\n    char buffer[128];\\n    int bytes_read;\\n    int i;\\n    \\n    printf(\\\"=== Character Device Counter Test ===\\\\n\\\");\\n    \\n    /* Open the device */\\n    printf(\\\"Opening /dev/counter...\\\\n\\\");\\n    fd = open(\\\"/dev/counter\\\", O_RDONLY);\\n    if (fd < 0) {\\n        printf(\\\"ERROR: Failed to open /dev/counter\\\\n\\\");\\n        return 1;\\n    }\\n    printf(\\\"Device opened successfully\\\\n\\\");\\n    \\n    /* Read from device 3 times */\\n    for (i = 0; i < 3; i++) {\\n        memset(buffer, 0, sizeof(buffer));\\n        bytes_read = read(fd, buffer, sizeof(buffer) - 1);\\n        \\n        if (bytes_read < 0) {\\n            printf(\\\"ERROR: Failed to read from device\\\\n\\\");\\n            close(fd);\\n            return 1;\\n        }\\n        \\n        printf(\\\"Read %d bytes: %s\\\", bytes_read, buffer);\\n    }\\n    \\n    /* Close the device */\\n    printf(\\\"Closing device...\\\\n\\\");\\n    close(fd);\\n    printf(\\\"Device closed successfully\\\\n\\\");\\n    \\n    printf(\\\"SUCCESS: All character device operations completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting character device counter validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: TCC Header Validation'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define THIS_MODULE ((struct module *)0)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef long long loff_t;' > /tmp/linux/types.h",
                    "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
                    "echo 'typedef long ssize_t;' >> /tmp/linux/types.h",
                    "echo '#define __user' >> /tmp/linux/types.h",
                    "echo '#include <linux/types.h>' > /tmp/linux/fs.h",
                    "echo 'struct inode { int dummy; };' >> /tmp/linux/fs.h",
                    "echo 'struct file { int dummy; };' >> /tmp/linux/fs.h",
                    "echo 'struct file_operations { void *owner; void *read; void *open; void *release; };' >> /tmp/linux/fs.h",
                    "echo 'int register_chrdev(unsigned int major, const char *name, struct file_operations *fops);' >> /tmp/linux/fs.h",
                    "echo 'void unregister_chrdev(unsigned int major, const char *name);' >> /tmp/linux/fs.h",
                    "echo 'unsigned long copy_to_user(void *to, const void *from, unsigned long n);' > /tmp/linux/uaccess.h",
                    "echo '#define EFAULT 14' >> /tmp/linux/uaccess.h",
                    "echo 'Creating TCC test file to validate header includes...'",
                    "echo '#include \"/lib/modules/counter_dev.h\"' > /tmp/test.c",
                    "echo 'int main() { return 0; }' >> /tmp/test.c",
                    "/usr/bin/tcc -I/tmp -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Header file has errors (check for uncommented function declarations)'; cat /tmp/tcc_error.log; else echo 'PASS: Header file compiles successfully'; fi",
                    "",
                    "echo 'Phase 2: Module Loading and Device Registration'",
                    "insmod /lib/modules/counter_dev.ko",
                    "sleep 1",
                    "",
                    "echo 'Phase 3: Device Registration Validation'",
                    "dmesg | grep 'Counter device registered with major number 240' && echo 'PASS: Device registered successfully' || echo 'FAIL: Device registration message missing'",
                    "dmesg | grep 'Create device with: mknod /dev/counter c 240 0' && echo 'PASS: mknod instruction present' || echo 'FAIL: mknod instruction missing'",
                    "",
                    "echo 'Phase 4: Device Node Creation'",
                    "mknod /dev/counter c 240 0",
                    "ls -l /dev/counter && echo 'PASS: Device node created' || echo 'FAIL: Device node creation failed'",
                    "",
                    "echo 'Phase 5: Character Device Functional Testing'",
                    "/bin/counter_device_tester > /tmp/device_test_output.log 2>&1",
                    "cat /tmp/device_test_output.log",
                    "sleep 1",
                    "",
                    "echo 'Phase 6: Validate Device Operations'",
                    "dmesg | grep 'Counter device opened' && echo 'PASS: Device open working' || echo 'FAIL: Device open broken'",
                    "dmesg | grep 'Counter read: returned 0' && echo 'PASS: First counter read (0) working' || echo 'FAIL: First read broken'",
                    "dmesg | grep 'Counter read: returned 1' && echo 'PASS: Second counter read (1) working' || echo 'FAIL: Second read broken'",
                    "dmesg | grep 'Counter read: returned 2' && echo 'PASS: Third counter read (2) working' || echo 'FAIL: Third read broken'",
                    "dmesg | grep 'Counter device closed' && echo 'PASS: Device release working' || echo 'FAIL: Device release broken'",
                    "",
                    "echo 'Phase 7: Validate Userspace Counter Output'",
                    "grep 'Counter: 0' /tmp/device_test_output.log && echo 'PASS: Userspace received counter 0' || echo 'FAIL: Counter 0 not received'",
                    "grep 'Counter: 1' /tmp/device_test_output.log && echo 'PASS: Userspace received counter 1' || echo 'FAIL: Counter 1 not received'",
                    "grep 'Counter: 2' /tmp/device_test_output.log && echo 'PASS: Userspace received counter 2' || echo 'FAIL: Counter 2 not received'",
                    "grep 'SUCCESS: All character device operations completed' /tmp/device_test_output.log && echo 'PASS: All operations succeeded' || echo 'FAIL: Operations incomplete'",
                    "",
                    "echo 'Phase 8: Module Cleanup'",
                    "rm /dev/counter",
                    "rmmod counter_dev",
                    "sleep 1",
                    "dmesg | grep 'Counter device unregistered' && echo 'PASS: Device unregistered successfully' || echo 'FAIL: Device unregistration message missing'",
                    "",
                    "echo 'PASS: All character device integration tests completed successfully'"
                ],
                "expected": {
                    "dmesg": [
                        "Counter device registered with major number 240",
                        "Create device with: mknod /dev/counter c 240 0",
                        "Counter device opened",
                        "Counter read: returned 0",
                        "Counter read: returned 1",
                        "Counter read: returned 2",
                        "Counter device closed",
                        "Counter device unregistered"
                    ],
                    "stdout": [
                        "PASS: Header file compiles successfully",
                        "PASS: Device registered successfully",
                        "PASS: mknod instruction present",
                        "PASS: Device node created",
                        "Device opened successfully",
                        "Counter: 0",
                        "Counter: 1",
                        "Counter: 2",
                        "Device closed successfully",
                        "SUCCESS: All character device operations completed",
                        "PASS: Device open working",
                        "PASS: First counter read \\(0\\) working",
                        "PASS: Second counter read \\(1\\) working",
                        "PASS: Third counter read \\(2\\) working",
                        "PASS: Device release working",
                        "PASS: Userspace received counter 0",
                        "PASS: Userspace received counter 1",
                        "PASS: Userspace received counter 2",
                        "PASS: All operations succeeded",
                        "PASS: Device unregistered successfully",
                        "PASS: All character device integration tests completed successfully"
                    ]
                },
                "timeout": 30
            }
        }
    ]
});


// Problem 103: Character Device with Write - Bidirectional Communication
generatedTestDefinitions.set(103, {
    "name": "Character Device with Write - Bidirectional Communication",
    "category": "kernel_core",
    "description": "Expand your character device skills by adding write operations. Create a device that stores a message written by the user and returns it when read. This teaches bidirectional kernel-userspace communication, buffer management, and state persistence - essential skills for real device drivers including GPUs. Learn kmalloc/kfree, copy_from_user, and proper resource cleanup.",
    "exactRequirements": {
        "functionNames": [
            "message_init",
            "message_exit",
            "device_open",
            "device_release",
            "device_read",
            "device_write"
        ],
        "variables": [
            {
                "name": "message_buffer",
                "type": "char *",
                "value": "NULL",
                "storageClass": "static"
            },
            {
                "name": "message_size",
                "type": "size_t",
                "value": "0",
                "storageClass": "static"
            },
            {
                "name": "device_open_count",
                "type": "int",
                "value": "0",
                "storageClass": "static"
            },
            {
                "name": "fops",
                "type": "struct file_operations",
                "value": "{.owner = THIS_MODULE, .read = device_read, .write = device_write, .open = device_open, .release = device_release}",
                "storageClass": "static"
            }
        ],
        "outputMessages": [
            "Message device registered with major number 241",
            "Create device with: mknod /dev/message c 241 0",
            "Message device opened",
            "Message written: 13 bytes",
            "Message read: 13 bytes",
            "Message device closed",
            "Message device unregistered"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/fs.h",
            "linux/uaccess.h",
            "linux/slab.h"
        ],
        "mustContain": [
            "register_chrdev(MAJOR_NUM, DEVICE_NAME, &fops)",
            "unregister_chrdev(MAJOR_NUM, DEVICE_NAME)",
            "copy_to_user",
            "copy_from_user",
            "kmalloc",
            "kfree",
            "GFP_KERNEL",
            ".write = device_write",
            "if (message_buffer)",
            "message_size = len"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "macro_definitions",
            "name": "Macro Definitions",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "#define DEVICE_NAME \"message\"",
                "#define MAJOR_NUM 241",
                "#define MAX_MESSAGE_SIZE 1024"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Implementations in Source",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "static int device_open(struct inode *inode, struct file *file)",
                "static int device_release(struct inode *inode, struct file *file)",
                "static ssize_t device_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)",
                "static ssize_t device_write(struct file *file, const char __user *buffer, size_t len, loff_t *offset)",
                "static int __init message_init(void)",
                "static void __exit message_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "file_operations_structure",
            "name": "File Operations Structure with Write",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "static struct file_operations fops",
                ".owner = THIS_MODULE",
                ".read = device_read",
                ".write = device_write",
                ".open = device_open",
                ".release = device_release"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "memory_management_api",
            "name": "Memory Management API Usage",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "kmalloc",
                "kfree",
                "GFP_KERNEL",
                "copy_from_user",
                "copy_to_user",
                "if (message_buffer)",
                "message_buffer = NULL"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Message device registered with major number 241",
                    "exact": true,
                    "linkedFunction": "static int __init message_init(void)"
                },
                {
                    "pattern": "Create device with: mknod /dev/message c 241 0",
                    "exact": true,
                    "linkedFunction": "static int __init message_init(void)"
                },
                {
                    "pattern": "Message device opened",
                    "exact": true,
                    "linkedFunction": "static int device_open(struct inode *inode, struct file *file)"
                },
                {
                    "pattern": "Message written: .* bytes",
                    "exact": false,
                    "linkedFunction": "static ssize_t device_write(struct file *file, const char __user *buffer, size_t len, loff_t *offset)"
                },
                {
                    "pattern": "Message read: .* bytes",
                    "exact": false,
                    "linkedFunction": "static ssize_t device_read(struct file *file, char __user *buffer, size_t len, loff_t *offset)"
                },
                {
                    "pattern": "Message device closed",
                    "exact": true,
                    "linkedFunction": "static int device_release(struct inode *inode, struct file *file)"
                },
                {
                    "pattern": "Message device unregistered",
                    "exact": true,
                    "linkedFunction": "static void __exit message_exit(void)"
                }
            ]
        },
        {
            "id": "comprehensive_message_device_validation",
            "name": "Comprehensive Message Device Write/Read Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "userspaceApps": [],
                "setupCommands": [
                    "echo 'Starting comprehensive message device validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: TCC Header Validation'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define KERN_ALERT' >> /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define THIS_MODULE ((void*)0)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'typedef long long loff_t;' > /tmp/linux/types.h",
                    "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
                    "echo 'typedef long ssize_t;' >> /tmp/linux/types.h",
                    "echo '#define __user' >> /tmp/linux/types.h",
                    "echo '#include <linux/types.h>' > /tmp/linux/fs.h",
                    "echo 'struct inode { int i_rdev; };' >> /tmp/linux/fs.h",
                    "echo 'struct file { void *private_data; };' >> /tmp/linux/fs.h",
                    "echo 'struct file_operations { void *owner; int (*open)(struct inode*, struct file*); int (*release)(struct inode*, struct file*); ssize_t (*read)(struct file*, char*, size_t, loff_t*); ssize_t (*write)(struct file*, const char*, size_t, loff_t*); };' >> /tmp/linux/fs.h",
                    "echo 'int register_chrdev(unsigned int major, const char *name, struct file_operations *fops);' >> /tmp/linux/fs.h",
                    "echo 'void unregister_chrdev(unsigned int major, const char *name);' >> /tmp/linux/fs.h",
                    "echo 'unsigned long copy_to_user(void *to, const void *from, unsigned long n);' > /tmp/linux/uaccess.h",
                    "echo 'unsigned long copy_from_user(void *to, const void *from, unsigned long n);' >> /tmp/linux/uaccess.h",
                    "echo 'void *kmalloc(size_t size, int flags);' > /tmp/linux/slab.h",
                    "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
                    "echo '#define GFP_KERNEL 0' >> /tmp/linux/slab.h",
                    "echo '#include \"/lib/modules/message_dev.h\"' > /tmp/test.c",
                    "echo 'int main() { return 0; }' >> /tmp/test.c",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Header file has compilation errors'; cat /tmp/tcc_error.log; else echo 'PASS: Header file compiles successfully'; fi",
                    "",
                    "echo 'Phase 2: Module Loading and Device Creation'",
                    "insmod /lib/modules/message_dev.ko",
                    "sleep 1",
                    "dmesg | grep 'Message device registered with major number 241' && echo 'PASS: Device registration successful' || echo 'FAIL: Device registration failed'",
                    "dmesg | grep 'Create device with: mknod /dev/message c 241 0' && echo 'PASS: Device creation instructions printed' || echo 'FAIL: Missing instructions'",
                    "",
                    "echo 'Phase 3: Create Device Node'",
                    "mknod /dev/message c 241 0",
                    "chmod 666 /dev/message",
                    "ls -l /dev/message && echo 'PASS: Device node created' || echo 'FAIL: Device node creation failed'",
                    "",
                    "echo 'Phase 4: Write First Message'",
                    "echo -n 'Hello Kernel!' > /dev/message",
                    "sleep 1",
                    "dmesg | grep 'Message written: 13 bytes' && echo 'PASS: First write successful (13 bytes)' || echo 'FAIL: First write failed'",
                    "",
                    "echo 'Phase 5: Read First Message'",
                    "READ_OUTPUT=$(cat /dev/message)",
                    "echo \"Read output: '$READ_OUTPUT'\"",
                    "if [ \"$READ_OUTPUT\" = 'Hello Kernel!' ]; then echo 'PASS: Read returned correct message'; else echo 'FAIL: Read returned wrong message'; fi",
                    "dmesg | grep 'Message read: 13 bytes' && echo 'PASS: Read byte count correct' || echo 'FAIL: Read byte count wrong'",
                    "",
                    "echo 'Phase 6: Write Second Message (Buffer Replacement)'",
                    "echo -n 'New Message' > /dev/message",
                    "sleep 1",
                    "dmesg | grep 'Message written: 11 bytes' && echo 'PASS: Second write successful (11 bytes)' || echo 'FAIL: Second write failed'",
                    "",
                    "echo 'Phase 7: Read Second Message'",
                    "READ_OUTPUT2=$(cat /dev/message)",
                    "echo \"Read output: '$READ_OUTPUT2'\"",
                    "if [ \"$READ_OUTPUT2\" = 'New Message' ]; then echo 'PASS: Read returned updated message'; else echo 'FAIL: Read returned wrong message'; fi",
                    "dmesg | grep 'Message read: 11 bytes' && echo 'PASS: Updated read byte count correct' || echo 'FAIL: Updated read byte count wrong'",
                    "",
                    "echo 'Phase 8: Write Long Message (Size Limit)'",
                    "dd if=/dev/zero bs=1 count=2048 2>/dev/null | tr '\\000' 'A' > /tmp/longmsg",
                    "cat /tmp/longmsg > /dev/message",
                    "sleep 1",
                    "WRITTEN_BYTES=$(dmesg | grep 'Message written:' | tail -1 | grep -o '[0-9]* bytes' | grep -o '[0-9]*')",
                    "if [ \"$WRITTEN_BYTES\" -le 1024 ]; then echo 'PASS: Message size capped at MAX_MESSAGE_SIZE'; else echo 'FAIL: Message size not capped properly'; fi",
                    "",
                    "echo 'Phase 9: Device Open/Close Tracking'",
                    "dmesg | grep 'Message device opened' && echo 'PASS: Device open logged' || echo 'FAIL: Device open not logged'",
                    "dmesg | grep 'Message device closed' && echo 'PASS: Device close logged' || echo 'FAIL: Device close not logged'",
                    "",
                    "echo 'Phase 10: Module Unload and Cleanup'",
                    "rm -f /dev/message",
                    "rmmod message_dev",
                    "sleep 1",
                    "dmesg | grep 'Message device unregistered' && echo 'PASS: Device unregistered successfully' || echo 'FAIL: Device unregistration failed'",
                    "",
                    "echo 'Phase 11: Memory Management Validation'",
                    "dmesg | grep 'kfree' && echo 'INFO: kfree calls detected (good cleanup)' || echo 'INFO: kfree not in logs (expected if optimized)'",
                    "",
                    "echo 'PASS: All comprehensive message device validation phases completed successfully'"
                ],
                "expected": {
                    "dmesg": [
                        "Message device registered with major number 241",
                        "Create device with: mknod /dev/message c 241 0",
                        "Message device opened",
                        "Message written: 13 bytes",
                        "Message read: 13 bytes",
                        "Message written: 11 bytes",
                        "Message read: 11 bytes",
                        "Message device closed",
                        "Message device unregistered"
                    ],
                    "stdout": [
                        "PASS: Header file compiles successfully",
                        "PASS: Device registration successful",
                        "PASS: Device creation instructions printed",
                        "PASS: Device node created",
                        "PASS: First write successful \\(13 bytes\\)",
                        "PASS: Read returned correct message",
                        "PASS: Read byte count correct",
                        "PASS: Second write successful \\(11 bytes\\)",
                        "PASS: Read returned updated message",
                        "PASS: Updated read byte count correct",
                        "PASS: Message size capped at MAX_MESSAGE_SIZE",
                        "PASS: Device open logged",
                        "PASS: Device close logged",
                        "PASS: Device unregistered successfully",
                        "PASS: All comprehensive message device validation phases completed successfully"
                    ]
                },
                "timeout": 30
            }
        }
    ]
});


// Problem 107: Basic PCI GPU Detection - Your First Graphics Driver
generatedTestDefinitions.set(107, {
    "name": "Basic PCI GPU Detection - Your First Graphics Driver",
    "category": "kernel_core",
    "description": "Learn the absolute basics of GPU driver development by detecting a PCI graphics device. This is the first step every GPU driver takes - whether AMD, NVIDIA, or Intel. You'll learn PCI enumeration, vendor/device IDs, and basic PCI device structure.",
    "exactRequirements": {
        "functionNames": [
            "gpu_pci_probe",
            "gpu_pci_remove"
        ],
        "variables": [
            {
                "name": "gpu_pci_table",
                "type": "const struct pci_device_id",
                "value": "[{ PCI_DEVICE(GPU_VENDOR_ID, GPU_DEVICE_ID) }, { 0, }]",
                "storageClass": "static"
            },
            {
                "name": "gpu_pci_driver",
                "type": "struct pci_driver",
                "value": "{.name = \"simple_gpu_driver\", .id_table = gpu_pci_table, .probe = gpu_pci_probe, .remove = gpu_pci_remove}",
                "storageClass": "static"
            }
        ],
        "outputMessages": [
            "GPU Driver: Probing device",
            "GPU Driver: Found at 0000:00:05.0",
            "GPU Driver: Device 1234:1111",
            "GPU Driver: Device initialized successfully",
            "GPU Driver: Removing device",
            "GPU Driver: Device cleanup complete"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/pci.h"
        ],
        "mustContain": [
            "static const struct pci_device_id gpu_pci_table[]",
            "{ PCI_DEVICE(GPU_VENDOR_ID, GPU_DEVICE_ID) }",
            "{ 0, }",
            "MODULE_DEVICE_TABLE(pci, gpu_pci_table)",
            "static struct pci_driver gpu_pci_driver",
            ".name = \"simple_gpu_driver\"",
            ".id_table = gpu_pci_table",
            ".probe = gpu_pci_probe",
            ".remove = gpu_pci_remove",
            "module_pci_driver(gpu_pci_driver)",
            "pci_enable_device(pdev)",
            "pci_disable_device(pdev)",
            "pci_domain_nr(pdev->bus)",
            "PCI_SLOT(pdev->devfn)",
            "PCI_FUNC(pdev->devfn)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "macro_definitions_header",
            "name": "Macro Definitions in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "#define GPU_VENDOR_ID 0x1234",
                "#define GPU_DEVICE_ID 0x1111"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "header_includes",
            "name": "Required Header File Includes",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "#include <linux/module.h>",
                "#include <linux/kernel.h>",
                "#include <linux/init.h>",
                "#include <linux/pci.h>"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "pci_device_table_structure",
            "name": "PCI Device ID Table Structure",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "static const struct pci_device_id gpu_pci_table",
                "PCI_DEVICE",
                "GPU_VENDOR_ID",
                "GPU_DEVICE_ID",
                "{ 0, }",
                "MODULE_DEVICE_TABLE",
                "pci",
                "gpu_pci_table"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "pci_driver_structure",
            "name": "PCI Driver Structure Definition",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "static struct pci_driver gpu_pci_driver",
                ".name",
                "simple_gpu_driver",
                ".id_table",
                "gpu_pci_table",
                ".probe",
                "gpu_pci_probe",
                ".remove",
                "gpu_pci_remove",
                "module_pci_driver",
                "gpu_pci_driver"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "probe_function_implementation",
            "name": "Probe Function Implementation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "static int gpu_pci_probe",
                "struct pci_dev *pdev",
                "const struct pci_device_id *id",
                "pci_enable_device",
                "pci_domain_nr",
                "pdev->bus",
                "PCI_SLOT",
                "PCI_FUNC",
                "pdev->vendor",
                "pdev->device",
                "GPU Driver: Probing device",
                "GPU Driver: Found at",
                "GPU Driver: Device",
                "GPU Driver: Device initialized successfully"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "remove_function_implementation",
            "name": "Remove Function Implementation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "static void gpu_pci_remove",
                "struct pci_dev *pdev",
                "pci_disable_device",
                "GPU Driver: Removing device",
                "GPU Driver: Device cleanup complete"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "pci_api_calls",
            "name": "Required PCI API Function Calls",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "ret = pci_enable_device(pdev)",
                "pci_disable_device(pdev)",
                "pdev->vendor",
                "pdev->device",
                "pdev->bus->number",
                "pdev->devfn"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Signatures in Source File",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)",
                "static void gpu_pci_remove(struct pci_dev *pdev)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages with Function Attribution",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "GPU Driver: Probing device",
                    "exact": true,
                    "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
                },
                {
                    "pattern": "GPU Driver: Found at 0000:00:05.0",
                    "exact": true,
                    "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
                },
                {
                    "pattern": "GPU Driver: Device 1234:1111",
                    "exact": true,
                    "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
                },
                {
                    "pattern": "GPU Driver: Device initialized successfully",
                    "exact": true,
                    "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
                },
                {
                    "pattern": "GPU Driver: Removing device",
                    "exact": true,
                    "linkedFunction": "static void gpu_pci_remove(struct pci_dev *pdev)"
                },
                {
                    "pattern": "GPU Driver: Device cleanup complete",
                    "exact": true,
                    "linkedFunction": "static void gpu_pci_remove(struct pci_dev *pdev)"
                }
            ]
        },
        {
            "id": "pci_gpu_detection_test",
            "name": "PCI GPU Device Detection and Initialization",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "qemuArgs": [
                    "-device",
                    "bochs-display,addr=05.0",
                    "-vga",
                    "none"
                ],
                "userspaceApps": [
                    {
                        "name": "pci_gpu_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n\\nint main() {\\n    printf(\\\"=== PCI GPU Detection Test ===\\\\n\\\");\\n    \\n    printf(\\\"Phase 1: Checking PCI device presence\\\\n\\\");\\n    system(\\\"ls /sys/bus/pci/devices/0000:00:05.0 > /dev/null 2>&1 && echo 'PASS: PCI device found' || echo 'FAIL: PCI device not found'\\\");\\n    \\n    printf(\\\"Phase 2: Loading GPU driver module\\\\n\\\");\\n    system(\\\"insmod /lib/modules/pci_gpu_detect.ko\\\");\\n    system(\\\"sleep 1\\\");\\n    system(\\\"lsmod | grep pci_gpu_detect && echo 'PASS: Module loaded' || echo 'FAIL: Module not loaded'\\\");\\n    \\n    printf(\\\"Phase 3: Checking driver binding\\\\n\\\");\\n    system(\\\"if [ -e /sys/bus/pci/devices/0000:00:05.0/driver ]; then echo 'PASS: Driver bound to device'; else echo 'FAIL: Driver not bound'; fi\\\");\\n    \\n    printf(\\\"SUCCESS: PCI GPU driver test completed\\\\n\\\");\\n    return 0;\\n}"
                    }
                ],
                "setupCommands": [
                    "echo 'Starting PCI GPU detection validation'"
                ],
                "testCommands": [
                    "echo '=== Phase 1: TCC Header Validation ==='",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'struct pci_dev { unsigned short vendor; unsigned short device; struct pci_bus *bus; unsigned int devfn; };' > /tmp/linux/pci.h",
                    "echo 'struct pci_device_id { unsigned int vendor; unsigned int device; };' >> /tmp/linux/pci.h",
                    "echo 'struct pci_bus { int number; };' >> /tmp/linux/pci.h",
                    "echo '#define PCI_DEVICE(vend,dev) .vendor = (vend), .device = (dev)' >> /tmp/linux/pci.h",
                    "echo 'int pci_enable_device(struct pci_dev *dev);' >> /tmp/linux/pci.h",
                    "echo 'void pci_disable_device(struct pci_dev *dev);' >> /tmp/linux/pci.h",
                    "echo 'int pci_domain_nr(struct pci_bus *bus);' >> /tmp/linux/pci.h",
                    "echo '#define PCI_SLOT(devfn) (((devfn) >> 3) & 0x1f)' >> /tmp/linux/pci.h",
                    "echo '#define PCI_FUNC(devfn) ((devfn) & 0x07)' >> /tmp/linux/pci.h",
                    "echo '#include \"/lib/modules/pci_gpu_detect.h\"' > /tmp/test.c",
                    "echo 'int main() { unsigned short vendor = GPU_VENDOR_ID; unsigned short device = GPU_DEVICE_ID; return (vendor == 0x1234 && device == 0x1111) ? 0 : 1; }' >> /tmp/test.c",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Header file validation failed'; cat /tmp/tcc_error.log; else echo 'PASS: Header file includes and macros validated'; fi",
                    "",
                    "echo '=== Phase 2: PCI Device Enumeration Check ==='",
                    "ls /sys/bus/pci/devices/0000:00:05.0 && echo 'PASS: GPU device present on PCI bus' || echo 'FAIL: GPU device not found'",
                    "",
                    "echo '=== Phase 3: Vendor and Device ID Verification ==='",
                    "VENDOR=$(cat /sys/bus/pci/devices/0000:00:05.0/vendor)",
                    "DEVICE=$(cat /sys/bus/pci/devices/0000:00:05.0/device)",
                    "echo \"Detected Vendor: $VENDOR, Device: $DEVICE\"",
                    "if [ \"$VENDOR\" = \"0x1234\" ] && [ \"$DEVICE\" = \"0x1111\" ]; then echo 'PASS: Correct GPU vendor/device IDs'; else echo 'FAIL: Wrong vendor/device IDs'; fi",
                    "",
                    "echo '=== Phase 4: Module Loading and Probe Test ==='",
                    "/bin/pci_gpu_tester",
                    "sleep 1",
                    "",
                    "echo '=== Phase 5: Driver Output Validation ==='",
                    "dmesg | grep 'GPU Driver: Probing device' && echo 'PASS: Probe function called' || echo 'FAIL: Probe not called'",
                    "dmesg | grep 'GPU Driver: Found at 0000:00:05.0' && echo 'PASS: PCI address detection working' || echo 'FAIL: PCI address not detected'",
                    "dmesg | grep 'GPU Driver: Device 1234:1111' && echo 'PASS: Vendor/Device ID detection working' || echo 'FAIL: IDs not detected'",
                    "dmesg | grep 'GPU Driver: Device initialized successfully' && echo 'PASS: PCI device enabled successfully' || echo 'FAIL: Device init failed'",
                    "",
                    "echo '=== All GPU detection tests completed ==='",
                    "echo 'PASS: GPU PCI detection validation successful'"
                ],
                "expected": {
                    "dmesg": [
                        "GPU Driver: Probing device",
                        "GPU Driver: Found at 0000:00:05.0",
                        "GPU Driver: Device 1234:1111",
                        "GPU Driver: Device initialized successfully"
                    ],
                    "stdout": [
                        "PASS: Header file includes and macros validated",
                        "PASS: GPU device present on PCI bus",
                        "PASS: Correct GPU vendor/device IDs",
                        "PASS: PCI device found",
                        "PASS: Module loaded",
                        "PASS: Driver bound to device",
                        "SUCCESS: PCI GPU driver test completed",
                        "PASS: Probe function called",
                        "PASS: PCI address detection working",
                        "PASS: Vendor/Device ID detection working",
                        "PASS: PCI device enabled successfully",
                        "PASS: GPU PCI detection validation successful"
                    ]
                },
                "timeout": 15
            }
        }
    ]
});


// Problem 108: PCI BAR Mapping - Accessing GPU Memory Regions
generatedTestDefinitions.set(108, {
    "name": "PCI BAR Mapping - Accessing GPU Memory Regions",
    "category": "kernel_core",
    "description": "Learn how real GPU drivers map and access device memory. Every GPU driver (AMD amdgpu, NVIDIA nouveau, Intel i915) must map PCI Base Address Registers (BARs) to access GPU memory and registers. You'll learn memory-mapped I/O (MMIO), resource management, and reading GPU hardware registers - the foundation of all GPU operations.",
    "exactRequirements": {
        "functionNames": [
            "gpu_bar_init",
            "gpu_bar_exit",
            "gpu_pci_probe",
            "gpu_pci_remove"
        ],
        "variables": [
            {
                "name": "mmio_base",
                "type": "void __iomem *",
                "value": "NULL",
                "storageClass": "static"
            },
            {
                "name": "fb_base",
                "type": "void __iomem *",
                "value": "NULL",
                "storageClass": "static"
            },
            {
                "name": "mmio_size",
                "type": "resource_size_t",
                "value": "0",
                "storageClass": "static"
            },
            {
                "name": "fb_size",
                "type": "resource_size_t",
                "value": "0",
                "storageClass": "static"
            },
            {
                "name": "gpu_pci_table",
                "type": "const struct pci_device_id",
                "value": "[{ PCI_DEVICE(GPU_VENDOR_ID, GPU_DEVICE_ID) }, { 0, }]",
                "storageClass": "static"
            },
            {
                "name": "gpu_pci_driver",
                "type": "struct pci_driver",
                "value": "{.name = \"gpu_bar_driver\", .id_table = gpu_pci_table, .probe = gpu_pci_probe, .remove = gpu_pci_remove}",
                "storageClass": "static"
            }
        ],
        "outputMessages": [
            "GPU BAR Mapping Driver: Initializing",
            "GPU Driver: Probing device",
            "GPU Driver: BAR 0 (Framebuffer): start=",
            "GPU Driver: BAR 2 (MMIO): start=",
            "GPU Driver: Requested memory regions",
            "GPU Driver: Mapped MMIO at virtual address",
            "GPU Driver: Mapped framebuffer at virtual address",
            "GPU Driver: Hardware register test read:",
            "GPU Driver: All BARs mapped successfully",
            "GPU Driver: Removing device",
            "GPU Driver: Unmapped MMIO and framebuffer",
            "GPU Driver: Released memory regions",
            "GPU BAR Mapping Driver: Exiting"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/pci.h",
            "linux/io.h"
        ],
        "mustContain": [
            "pci_enable_device",
            "pci_resource_start",
            "pci_resource_len",
            "pci_resource_flags",
            "pci_request_regions",
            "ioremap",
            "ioremap_wc",
            "ioread32",
            "iounmap",
            "pci_release_regions",
            "pci_disable_device",
            "GPU_BAR_FRAMEBUFFER",
            "GPU_BAR_MMIO",
            "MMIO_ID_REGISTER",
            "PCI_DEVICE(GPU_VENDOR_ID, GPU_DEVICE_ID)",
            "pci_register_driver",
            "pci_unregister_driver"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "macro_definitions",
            "name": "Macro Definitions in Header",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "#define GPU_VENDOR_ID",
                "0x1234",
                "#define GPU_DEVICE_ID",
                "0x1111",
                "#define GPU_BAR_FRAMEBUFFER",
                "#define GPU_BAR_MMIO",
                "#define MMIO_ID_REGISTER"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_signatures_source",
            "name": "Function Implementations in Source",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)",
                "static void gpu_pci_remove(struct pci_dev *pdev)",
                "static int __init gpu_bar_init(void)",
                "static void __exit gpu_bar_exit(void)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "variable_declarations",
            "name": "Global Variable Declarations",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "static void __iomem *mmio_base",
                "static void __iomem *fb_base",
                "static resource_size_t mmio_size",
                "static resource_size_t fb_size",
                "static const struct pci_device_id gpu_pci_table",
                "static struct pci_driver gpu_pci_driver"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "pci_bar_api_usage",
            "name": "PCI BAR API Functions Usage",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "pci_enable_device",
                "pci_resource_start",
                "pci_resource_len",
                "pci_resource_flags",
                "pci_request_regions",
                "ioremap",
                "ioremap_wc",
                "ioread32",
                "iounmap",
                "pci_release_regions",
                "pci_disable_device"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "bar_macros_usage",
            "name": "BAR Macros Usage in Code",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "GPU_BAR_FRAMEBUFFER",
                "GPU_BAR_MMIO",
                "MMIO_ID_REGISTER"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "GPU BAR Mapping Driver: Initializing",
                    "exact": true,
                    "linkedFunction": "static int __init gpu_bar_init(void)"
                },
                {
                    "pattern": "GPU Driver: Probing device",
                    "exact": true,
                    "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
                },
                {
                    "pattern": "GPU Driver: BAR 0 \\(Framebuffer\\):.*start=0x.*size=.*MB.*flags=0x",
                    "exact": false,
                    "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
                },
                {
                    "pattern": "GPU Driver: BAR 2 \\(MMIO\\):.*start=0x.*size=.*KB.*flags=0x",
                    "exact": false,
                    "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
                },
                {
                    "pattern": "GPU Driver: Requested memory regions",
                    "exact": true,
                    "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
                },
                {
                    "pattern": "GPU Driver: Mapped MMIO at virtual address",
                    "exact": false,
                    "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
                },
                {
                    "pattern": "GPU Driver: Mapped framebuffer at virtual address",
                    "exact": false,
                    "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
                },
                {
                    "pattern": "GPU Driver: Hardware register test read: 0x",
                    "exact": false,
                    "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
                },
                {
                    "pattern": "GPU Driver: All BARs mapped successfully",
                    "exact": true,
                    "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
                },
                {
                    "pattern": "GPU Driver: Removing device",
                    "exact": true,
                    "linkedFunction": "static void gpu_pci_remove(struct pci_dev *pdev)"
                },
                {
                    "pattern": "GPU Driver: Unmapped MMIO and framebuffer",
                    "exact": true,
                    "linkedFunction": "static void gpu_pci_remove(struct pci_dev *pdev)"
                },
                {
                    "pattern": "GPU Driver: Released memory regions",
                    "exact": true,
                    "linkedFunction": "static void gpu_pci_remove(struct pci_dev *pdev)"
                },
                {
                    "pattern": "GPU BAR Mapping Driver: Exiting",
                    "exact": true,
                    "linkedFunction": "static void __exit gpu_bar_exit(void)"
                }
            ]
        },
        {
            "id": "comprehensive_bar_mapping_validation",
            "name": "Comprehensive PCI BAR Mapping and MMIO Access Validation",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "qemuArgs": [
                    "-device",
                    "bochs-display,addr=05.0",
                    "-vga",
                    "none"
                ],
                "userspaceApps": [],
                "setupCommands": [
                    "echo 'Starting comprehensive PCI BAR mapping validation'"
                ],
                "testCommands": [
                    "echo 'Phase 1: TCC Header Validation'",
                    "mkdir -p /tmp/linux",
                    "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
                    "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
                    "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
                    "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
                    "echo '#define MODULE_DEVICE_TABLE(type, table)' >> /tmp/linux/module.h",
                    "echo '#define module_init(x)' >> /tmp/linux/module.h",
                    "echo '#define module_exit(x)' >> /tmp/linux/module.h",
                    "echo '#define __init' > /tmp/linux/init.h",
                    "echo '#define __exit' >> /tmp/linux/init.h",
                    "echo 'struct pci_dev;' > /tmp/linux/pci.h",
                    "echo 'struct pci_device_id { unsigned int vendor; unsigned int device; };' >> /tmp/linux/pci.h",
                    "echo '#define PCI_DEVICE(vend, dev) .vendor = (vend), .device = (dev)' >> /tmp/linux/pci.h",
                    "echo 'int pci_enable_device(struct pci_dev *dev);' >> /tmp/linux/pci.h",
                    "echo 'void pci_disable_device(struct pci_dev *dev);' >> /tmp/linux/pci.h",
                    "echo 'int pci_register_driver(void *drv);' >> /tmp/linux/pci.h",
                    "echo 'void pci_unregister_driver(void *drv);' >> /tmp/linux/pci.h",
                    "echo 'typedef unsigned long long resource_size_t;' >> /tmp/linux/pci.h",
                    "echo 'resource_size_t pci_resource_start(struct pci_dev *dev, int bar);' >> /tmp/linux/pci.h",
                    "echo 'resource_size_t pci_resource_len(struct pci_dev *dev, int bar);' >> /tmp/linux/pci.h",
                    "echo 'unsigned long pci_resource_flags(struct pci_dev *dev, int bar);' >> /tmp/linux/pci.h",
                    "echo 'int pci_request_regions(struct pci_dev *pdev, const char *name);' >> /tmp/linux/pci.h",
                    "echo 'void pci_release_regions(struct pci_dev *pdev);' >> /tmp/linux/pci.h",
                    "echo 'struct pci_driver { const char *name; const struct pci_device_id *id_table; int (*probe)(struct pci_dev *, const struct pci_device_id *); void (*remove)(struct pci_dev *); };' >> /tmp/linux/pci.h",
                    "echo '#define __iomem' > /tmp/linux/io.h",
                    "echo 'typedef unsigned int u32;' >> /tmp/linux/io.h",
                    "echo 'void __iomem *ioremap(unsigned long long phys_addr, unsigned long size);' >> /tmp/linux/io.h",
                    "echo 'void __iomem *ioremap_wc(unsigned long long phys_addr, unsigned long size);' >> /tmp/linux/io.h",
                    "echo 'void iounmap(volatile void __iomem *addr);' >> /tmp/linux/io.h",
                    "echo 'u32 ioread32(const volatile void __iomem *addr);' >> /tmp/linux/io.h",
                    "echo 'void iowrite32(u32 value, volatile void __iomem *addr);' >> /tmp/linux/io.h",
                    "echo '#include \"/lib/modules/pci_bar_map.h\"' > /tmp/test.c",
                    "echo 'int main() { return 0; }' >> /tmp/test.c",
                    "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
                    "TCC_EXIT_CODE=$?",
                    "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Header validation failed'; cat /tmp/tcc_error.log; else echo 'PASS: All declarations found in header file'; fi",
                    "",
                    "echo 'Phase 2: Verify PCI Device Exists'",
                    "ls /sys/bus/pci/devices/ | grep -q '0000:00:05.0' && echo 'PASS: PCI device 0000:00:05.0 exists' || echo 'FAIL: PCI device not found'",
                    "",
                    "echo 'Phase 3: Check PCI Device BARs'",
                    "if [ -f /sys/bus/pci/devices/0000:00:05.0/resource ]; then",
                    "  echo 'PASS: PCI device has resource file'",
                    "  cat /sys/bus/pci/devices/0000:00:05.0/resource",
                    "else",
                    "  echo 'FAIL: No resource file found'",
                    "fi",
                    "",
                    "echo 'Phase 4: Load Module and Verify Probe'",
                    "sleep 1",
                    "insmod /lib/modules/pci_bar_map.ko",
                    "sleep 2",
                    "",
                    "echo 'Phase 5: Validate BAR Mapping in dmesg'",
                    "dmesg | grep 'GPU BAR Mapping Driver: Initializing' && echo 'PASS: Module initialized' || echo 'FAIL: Module init missing'",
                    "dmesg | grep 'GPU Driver: Probing device' && echo 'PASS: Probe function called' || echo 'FAIL: Probe not called'",
                    "dmesg | grep 'GPU Driver: BAR 0 (Framebuffer)' && echo 'PASS: BAR 0 information printed' || echo 'FAIL: BAR 0 info missing'",
                    "dmesg | grep 'GPU Driver: BAR 2 (MMIO)' && echo 'PASS: BAR 2 information printed' || echo 'FAIL: BAR 2 info missing'",
                    "dmesg | grep 'GPU Driver: Requested memory regions' && echo 'PASS: Memory regions requested' || echo 'FAIL: Request regions missing'",
                    "dmesg | grep 'GPU Driver: Mapped MMIO at virtual address' && echo 'PASS: MMIO mapped successfully' || echo 'FAIL: MMIO mapping missing'",
                    "dmesg | grep 'GPU Driver: Mapped framebuffer at virtual address' && echo 'PASS: Framebuffer mapped successfully' || echo 'FAIL: FB mapping missing'",
                    "dmesg | grep 'GPU Driver: Hardware register test read: 0x' && echo 'PASS: Hardware register read from MMIO' || echo 'FAIL: Hardware register read missing'",
                    "dmesg | grep 'GPU Driver: All BARs mapped successfully' && echo 'PASS: All BAR mapping completed' || echo 'FAIL: BAR mapping incomplete'",
                    "",
                    "echo 'Phase 6: Verify Module is Loaded'",
                    "lsmod | grep pci_bar_map && echo 'PASS: Module is loaded' || echo 'FAIL: Module not in lsmod'",
                    "",
                    "echo 'Phase 7: Unload Module and Verify Cleanup'",
                    "rmmod pci_bar_map",
                    "sleep 1",
                    "dmesg | grep 'GPU Driver: Removing device' && echo 'PASS: Remove function called' || echo 'FAIL: Remove not called'",
                    "dmesg | grep 'GPU Driver: Unmapped MMIO and framebuffer' && echo 'PASS: Memory unmapped' || echo 'FAIL: Unmap missing'",
                    "dmesg | grep 'GPU Driver: Released memory regions' && echo 'PASS: Regions released' || echo 'FAIL: Release missing'",
                    "dmesg | grep 'GPU BAR Mapping Driver: Exiting' && echo 'PASS: Module exited cleanly' || echo 'FAIL: Exit missing'",
                    "",
                    "echo 'Phase 8: Verify Module Unloaded'",
                    "lsmod | grep -q pci_bar_map && echo 'FAIL: Module still loaded' || echo 'PASS: Module unloaded successfully'",
                    "",
                    "echo 'PASS: All comprehensive PCI BAR mapping validation completed successfully'"
                ],
                "expected": {
                    "dmesg": [
                        "GPU BAR Mapping Driver: Initializing",
                        "GPU Driver: Probing device",
                        "GPU Driver: BAR 0 \\(Framebuffer\\):.*start=0x.*size=.*MB.*flags=0x",
                        "GPU Driver: BAR 2 \\(MMIO\\):.*start=0x.*size=.*KB.*flags=0x",
                        "GPU Driver: Requested memory regions",
                        "GPU Driver: Mapped MMIO at virtual address",
                        "GPU Driver: Mapped framebuffer at virtual address",
                        "GPU Driver: Hardware register test read: 0x",
                        "GPU Driver: All BARs mapped successfully",
                        "GPU Driver: Removing device",
                        "GPU Driver: Unmapped MMIO and framebuffer",
                        "GPU Driver: Released memory regions",
                        "GPU BAR Mapping Driver: Exiting"
                    ],
                    "stdout": [
                        "PASS: All declarations found in header file",
                        "PASS: PCI device 0000:00:05.0 exists",
                        "PASS: PCI device has resource file",
                        "PASS: Module initialized",
                        "PASS: Probe function called",
                        "PASS: BAR 0 information printed",
                        "PASS: BAR 2 information printed",
                        "PASS: Memory regions requested",
                        "PASS: MMIO mapped successfully",
                        "PASS: Framebuffer mapped successfully",
                        "PASS: Hardware register read from MMIO",
                        "PASS: All BAR mapping completed",
                        "PASS: Module is loaded",
                        "PASS: Remove function called",
                        "PASS: Memory unmapped",
                        "PASS: Regions released",
                        "PASS: Module exited cleanly",
                        "PASS: Module unloaded successfully",
                        "PASS: All comprehensive PCI BAR mapping validation completed successfully"
                    ]
                },
                "timeout": 30
            }
        }
    ]
});


module.exports = generatedTestDefinitions;
