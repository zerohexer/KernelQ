// Auto-generated from problems/ directory
// DO NOT EDIT THIS FILE DIRECTLY - Edit problems/*.json instead
// Generated at: 2025-07-12T13:20:11.964Z

const generatedTestDefinitions = new Map();


// Problem 1: Hello Kernel World
generatedTestDefinitions.set(1, {
    "name": "Hello Kernel World",
    "category": "foundations",
    "description": "Create your first kernel module that prints a greeting message when loaded and a goodbye message when unloaded. This is the traditional 'Hello World' for kernel programming.",
    "exactRequirements": {
        "functionNames": [
            "hello_init",
            "hello_exit"
        ],
        "variables": [],
        "outputMessages": [
            "Hello from the kernel!",
            "Goodbye from the kernel!"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "exact_functions",
            "name": "Exact Function Names",
            "type": "symbol_check",
            "critical": true,
            "expected": [
                "hello_init",
                "hello_exit"
            ]
        },
        {
            "id": "exact_messages",
            "name": "Exact Output Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Hello from the kernel!",
                    "exact": true
                },
                {
                    "pattern": "Goodbye from the kernel!",
                    "exact": true
                }
            ]
        },
        {
            "id": "required_includes",
            "name": "Required Header Files",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "linux/module.h",
                "linux/kernel.h",
                "linux/init.h"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "module_license",
            "name": "GPL License Required",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "MODULE_LICENSE",
                "GPL"
            ],
            "prohibitedSymbols": []
        }
    ]
});


// Problem 2: Variables and Data Types
generatedTestDefinitions.set(2, {
    "name": "Variables and Data Types",
    "category": "foundations",
    "description": "Learn to work with different data types in kernel space. Create variables of different types and print their values using printk. This introduces you to kernel-space variable declaration and printing.",
    "exactRequirements": {
        "functionNames": [
            "datatypes_init",
            "datatypes_exit"
        ],
        "variables": [
            {
                "name": "my_int",
                "type": "int",
                "value": 42
            },
            {
                "name": "my_char",
                "type": "char",
                "value": "'K'"
            },
            {
                "name": "my_bool",
                "type": "bool",
                "value": true
            }
        ],
        "outputMessages": [
            "Integer: 42",
            "Character: K",
            "Boolean: 1"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "printk",
            "KERN_INFO"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "exact_variables",
            "name": "Exact Variable Names and Values",
            "type": "variable_check",
            "critical": true,
            "expected": [
                "my_int",
                "my_char",
                "my_bool"
            ]
        },
        {
            "id": "exact_output",
            "name": "Exact Output Format",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Integer: 42",
                    "exact": true
                },
                {
                    "pattern": "Character: K",
                    "exact": true
                },
                {
                    "pattern": "Boolean: 1",
                    "exact": true
                }
            ]
        },
        {
            "id": "printk_usage",
            "name": "Proper printk Usage",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "printk",
                "KERN_INFO"
            ],
            "prohibitedSymbols": [
                "printf"
            ]
        }
    ]
});


// Problem 3: Variable Declaration and Usage
generatedTestDefinitions.set(3, {
    "name": "Variable Declaration and Usage",
    "category": "foundations",
    "description": "Declare integer and character variables, then print their values using proper format specifiers. The system will test both compilation and runtime output with hidden test cases.",
    "exactRequirements": {
        "functionNames": [
            "variables_init",
            "variables_exit"
        ],
        "variables": [],
        "outputMessages": [
            "Integer value: 42",
            "Character value: K"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "printk",
            "module_init",
            "module_exit"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "required_functions",
            "name": "Required Function Names",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "variables_init",
                "variables_exit"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "variable_declaration",
            "name": "Variable Declaration",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int ",
                "char "
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "printk_formatting",
            "name": "printk Format Specifiers",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "printk",
                "%d",
                "%c"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "module_registration",
            "name": "Module Registration",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "module_init",
                "module_exit"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Format",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Integer value: 42",
                    "exact": true
                },
                {
                    "pattern": "Character value: K",
                    "exact": true
                }
            ]
        }
    ]
});


// Problem 4: Arrays and Loops in Kernel Space
generatedTestDefinitions.set(4, {
    "name": "Arrays and Loops in Kernel Space",
    "category": "foundations",
    "description": "Learn to work with arrays and loops in kernel space. Create an array of integers and use a for loop to print each element. This introduces fundamental C programming concepts in kernel context.",
    "exactRequirements": {
        "functionNames": [
            "arrays_init",
            "arrays_exit"
        ],
        "variables": [
            {
                "name": "numbers",
                "type": "int[]",
                "value": "[10, 20, 30, 40, 50]"
            }
        ],
        "outputMessages": [
            "Element 0: 10",
            "Element 1: 20",
            "Element 2: 30",
            "Element 3: 40",
            "Element 4: 50"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "for",
            "printk"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "array_declaration",
            "name": "Array Declaration",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int numbers[]",
                "numbers",
                "["
            ],
            "prohibitedSymbols": [
                "int data[]",
                "int arr[]",
                "int values[]"
            ]
        },
        {
            "id": "for_loop_usage",
            "name": "For Loop Implementation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "for",
                "i++",
                "i < "
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "exact_output",
            "name": "Exact Output Format",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Element 0: 10",
                    "exact": true
                },
                {
                    "pattern": "Element 1: 20",
                    "exact": true
                },
                {
                    "pattern": "Element 2: 30",
                    "exact": true
                },
                {
                    "pattern": "Element 3: 40",
                    "exact": true
                },
                {
                    "pattern": "Element 4: 50",
                    "exact": true
                }
            ]
        }
    ]
});


// Problem 5: Arithmetic and Comparison Operations
generatedTestDefinitions.set(5, {
    "name": "Arithmetic and Comparison Operations",
    "category": "foundations",
    "description": "Master arithmetic operations (+, -, *, /, %) and comparison operators in kernel programming. Learn to perform calculations and make logical comparisons essential for kernel logic.",
    "exactRequirements": {
        "functionNames": [
            "arithmetic_init",
            "arithmetic_exit"
        ],
        "variables": [
            {
                "name": "a",
                "type": "int",
                "value": 25
            },
            {
                "name": "b",
                "type": "int",
                "value": 7
            },
            {
                "name": "sum",
                "type": "int",
                "value": "calculated"
            },
            {
                "name": "diff",
                "type": "int",
                "value": "calculated"
            },
            {
                "name": "product",
                "type": "int",
                "value": "calculated"
            },
            {
                "name": "quotient",
                "type": "int",
                "value": "calculated"
            },
            {
                "name": "remainder",
                "type": "int",
                "value": "calculated"
            },
            {
                "name": "greater",
                "type": "bool",
                "value": "calculated"
            },
            {
                "name": "equal",
                "type": "bool",
                "value": "calculated"
            },
            {
                "name": "not_equal",
                "type": "bool",
                "value": "calculated"
            }
        ],
        "outputMessages": [
            "Arithmetic Results:",
            "25 \\+ 7 = 32",
            "25 - 7 = 18",
            "25 \\* 7 = 175",
            "25 / 7 = 3",
            "25 % 7 = 4",
            "Comparison Results:",
            "25 > 7: true \\(1\\)",
            "25 == 7: false \\(0\\)",
            "25 != 7: true \\(1\\)"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "a + b",
            "a - b",
            "a * b",
            "a / b",
            "a % b",
            "a > b",
            "a == b",
            "a != b"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "arithmetic_operations",
            "name": "All Arithmetic Operations Present",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "a + b",
                "a - b",
                "a * b",
                "a / b",
                "a % b"
            ],
            "prohibitedSymbols": [
                "32",
                "18",
                "175",
                "3",
                "4"
            ]
        },
        {
            "id": "comparison_operations",
            "name": "All Comparison Operations Present",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "a > b",
                "a == b",
                "a != b"
            ],
            "prohibitedSymbols": [
                "= true",
                "= false",
                "greater = 1",
                "equal = 0"
            ]
        },
        {
            "id": "correct_calculations",
            "name": "Mathematically Correct Results",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "25 \\+ 7 = 32",
                    "exact": false
                },
                {
                    "pattern": "25 - 7 = 18",
                    "exact": true
                },
                {
                    "pattern": "25 \\* 7 = 175",
                    "exact": false
                },
                {
                    "pattern": "25 / 7 = 3",
                    "exact": true
                },
                {
                    "pattern": "25 % 7 = 4",
                    "exact": true
                }
            ]
        },
        {
            "id": "logical_results",
            "name": "Correct Logical Comparison Results",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "25 > 7: true \\(1\\)",
                    "exact": false
                },
                {
                    "pattern": "25 == 7: false \\(0\\)",
                    "exact": false
                },
                {
                    "pattern": "25 != 7: true \\(1\\)",
                    "exact": false
                }
            ]
        },
        {
            "id": "no_hardcoded_results",
            "name": "No Hardcoded Results - Must Calculate",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "="
            ],
            "prohibitedSymbols": [
                "sum = 32",
                "diff = 18",
                "product = 175",
                "quotient = 3",
                "remainder = 4"
            ]
        }
    ]
});


// Problem 6: Functions and Return Values
generatedTestDefinitions.set(6, {
    "name": "Functions and Return Values",
    "category": "foundations",
    "description": "Create custom functions that perform calculations and return values. Learn function declaration, parameter passing, and return values in kernel programming context.",
    "exactRequirements": {
        "functionNames": [
            "functions_init",
            "functions_exit",
            "calculate_sum",
            "find_max"
        ],
        "variables": [
            {
                "name": "a",
                "type": "int",
                "value": 15
            },
            {
                "name": "b",
                "type": "int",
                "value": 25
            }
        ],
        "outputMessages": [
            "Sum of 15 and 25 is: 40",
            "Maximum of 15 and 25 is: 25"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "int calculate_sum",
            "int find_max",
            "return"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_declarations",
            "name": "Function Declarations",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int calculate_sum",
                "int find_max"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "return_statements",
            "name": "Return Statements",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "return"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "correct_calculations",
            "name": "Correct Calculations",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Sum of 15 and 25 is: 40",
                    "exact": true
                },
                {
                    "pattern": "Maximum of 15 and 25 is: 25",
                    "exact": true
                }
            ]
        }
    ]
});


// Problem 7: Conditional Statements and Control Flow
generatedTestDefinitions.set(7, {
    "name": "Conditional Statements and Control Flow",
    "category": "foundations",
    "description": "Master if/else statements and logical operators for control flow in kernel programming. Learn to make decisions and control program execution based on conditions.",
    "exactRequirements": {
        "functionNames": [
            "conditional_init",
            "conditional_exit"
        ],
        "variables": [
            {
                "name": "temperature",
                "type": "int",
                "value": 75
            },
            {
                "name": "humidity",
                "type": "int",
                "value": 60
            },
            {
                "name": "is_summer",
                "type": "bool",
                "value": true
            },
            {
                "name": "age",
                "type": "int",
                "value": 25
            }
        ],
        "outputMessages": [
            "Temperature Check: Moderate weather",
            "Condition Check: Warm and humid",
            "Season Check: Summer conditions",
            "Age Check: Adult"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "if",
            "else",
            "&&",
            "||",
            "!",
            ">=",
            ">"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "if_else_structure",
            "name": "Proper if/else if/else Structure",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "if (",
                "else if",
                "else"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "logical_operators",
            "name": "All Logical Operators Used",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "&&",
                "||",
                "!"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "temperature_conditions",
            "name": "Temperature Range Conditions",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "temperature >= 80",
                "temperature >= 60"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "compound_conditions",
            "name": "Compound Condition Logic",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "temperature > 70 && humidity > 50",
                "is_summer ||"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "nested_conditions",
            "name": "Nested if Statements",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "age >= 18",
                "age >= 65"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "correct_logic_output",
            "name": "Correct Conditional Logic Results",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Temperature Check: Moderate weather",
                    "exact": true
                },
                {
                    "pattern": "Condition Check: Warm and humid",
                    "exact": true
                },
                {
                    "pattern": "Season Check: Summer conditions",
                    "exact": true
                },
                {
                    "pattern": "Age Check: Adult",
                    "exact": true
                }
            ]
        },
        {
            "id": "no_hardcoded_logic",
            "name": "No Hardcoded Results - Must Use Variables",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "temperature",
                "humidity",
                "is_summer",
                "age"
            ],
            "prohibitedSymbols": [
                "if (true)",
                "if (false)",
                "75 >=",
                "60 >"
            ]
        }
    ]
});


// Problem 8: Loop Structures and Iteration Control
generatedTestDefinitions.set(8, {
    "name": "Loop Structures and Iteration Control",
    "category": "foundations",
    "description": "Master different loop types (while, do-while, for) and loop control statements (break, continue) in kernel programming. Essential for iterative operations and data processing.",
    "exactRequirements": {
        "functionNames": [
            "loops_init",
            "loops_exit"
        ],
        "variables": [
            {
                "name": "i",
                "type": "int",
                "value": "iterator"
            },
            {
                "name": "sum",
                "type": "int",
                "value": "calculated"
            },
            {
                "name": "numbers",
                "type": "int[]",
                "value": "{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}"
            },
            {
                "name": "count",
                "type": "int",
                "value": "calculated"
            }
        ],
        "outputMessages": [
            "For loop sum: 55",
            "While loop even count: 5",
            "Do-while found number > 5 at index: 5",
            "Loop control: 2 4 6 8"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "for (",
            "while (",
            "do {",
            "break",
            "continue",
            "sum +=",
            "% 2"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "for_loop_implementation",
            "name": "For Loop with Sum Calculation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "for (",
                "i < 10",
                "i++",
                "sum +=",
                "numbers[i]"
            ],
            "prohibitedSymbols": [
                "sum = 55"
            ]
        },
        {
            "id": "while_loop_implementation",
            "name": "While Loop with Even Count",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "while (",
                "% 2 == 0",
                "count++"
            ],
            "prohibitedSymbols": [
                "count = 5"
            ]
        },
        {
            "id": "do_while_implementation",
            "name": "Do-While Loop Implementation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "do {",
                "} while",
                "> 5"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "break_continue_usage",
            "name": "Break and Continue Statements",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "break",
                "continue"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "correct_calculations",
            "name": "Mathematically Correct Results",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "For loop sum: 55",
                    "exact": true
                },
                {
                    "pattern": "While loop even count: 5",
                    "exact": true
                },
                {
                    "pattern": "Do-while found number > 5 at index: 5",
                    "exact": true
                },
                {
                    "pattern": "Loop control: 2 4 6 8",
                    "exact": true
                }
            ]
        },
        {
            "id": "array_processing",
            "name": "Proper Array Element Access",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "numbers[i]",
                "numbers["
            ],
            "prohibitedSymbols": [
                "numbers[0]",
                "numbers[1]",
                "numbers[2]"
            ]
        },
        {
            "id": "no_hardcoded_results",
            "name": "No Hardcoded Results - Must Calculate",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "+=",
                "++",
                "numbers["
            ],
            "prohibitedSymbols": [
                "sum = 55;",
                "count = 5;"
            ]
        }
    ]
});


// Problem 9: Switch-Case Statements and Multi-way Branching
generatedTestDefinitions.set(9, {
    "name": "Switch-Case Statements and Multi-way Branching",
    "category": "foundations",
    "description": "Master switch-case statements for multi-way branching and understand when to use switch vs if-else. Learn proper use of break statements and default cases.",
    "exactRequirements": {
        "functionNames": [
            "switch_init",
            "switch_exit"
        ],
        "variables": [
            {
                "name": "operation",
                "type": "int",
                "value": 2
            },
            {
                "name": "a",
                "type": "int",
                "value": 15
            },
            {
                "name": "b",
                "type": "int",
                "value": 5
            },
            {
                "name": "result",
                "type": "int",
                "value": "calculated"
            },
            {
                "name": "grade",
                "type": "char",
                "value": "'B'"
            },
            {
                "name": "day",
                "type": "int",
                "value": 3
            }
        ],
        "outputMessages": [
            "Operation 2 result: 10",
            "Grade B: Good",
            "Day 3: Weekday"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "switch (",
            "case",
            "break",
            "default",
            "a + b",
            "a - b",
            "a * b",
            "a / b"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "switch_structure",
            "name": "Proper Switch Statement Structure",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "switch (",
                "case",
                "break",
                "default"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "arithmetic_switch",
            "name": "Arithmetic Operations Switch",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "switch (operation)",
                "case 1",
                "case 2",
                "case 3",
                "case 4"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "character_switch",
            "name": "Character Grade Switch",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "switch (grade)",
                "case 'A'",
                "case 'B'",
                "case 'C'"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "arithmetic_operations",
            "name": "Actual Arithmetic in Cases",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "a + b",
                "a - b",
                "a * b",
                "a / b"
            ],
            "prohibitedSymbols": [
                "result = 10",
                "result = 20",
                "result = 75",
                "result = 3"
            ]
        },
        {
            "id": "break_statements",
            "name": "Proper Break Statement Usage",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "break;"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "default_cases",
            "name": "Default Cases Present",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "default:"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "correct_switch_results",
            "name": "Correct Switch Logic Results",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Operation 2 result: 10",
                    "exact": true
                },
                {
                    "pattern": "Grade B: Good",
                    "exact": true
                },
                {
                    "pattern": "Day 3: Weekday",
                    "exact": true
                }
            ]
        },
        {
            "id": "fall_through_weekday",
            "name": "Fall-through for Weekday Cases",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "case 1",
                "case 2",
                "case 3",
                "case 4",
                "case 5"
            ],
            "prohibitedSymbols": []
        }
    ]
});


// Problem 10: Structures Basics - Part 1: Definition and Usage
generatedTestDefinitions.set(10, {
    "name": "Structures Basics - Part 1: Definition and Usage",
    "category": "foundations",
    "description": "Learn to define and use structures in kernel programming. Understand structure declaration, member access, and initialization. This is fundamental for kernel data structures.",
    "exactRequirements": {
        "functionNames": [
            "structures_init",
            "structures_exit"
        ],
        "variables": [
            {
                "name": "stu",
                "type": "struct student",
                "value": "{101, \"Alice\", 20, 3.8}"
            }
        ],
        "outputMessages": [
            "Student ID: 101",
            "Student Name: Alice",
            "Student Age: 20",
            "Student GPA: 3"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "struct student",
            "int id",
            "char name",
            "int age",
            "float gpa",
            "stu.id",
            "stu.name"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "structure_definition",
            "name": "Structure Definition",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "struct student",
                "int id",
                "char name",
                "int age",
                "float gpa"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "member_access",
            "name": "Member Access with Dot Operator",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "stu.id",
                "stu.name",
                "stu.age",
                "stu.gpa"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "correct_output",
            "name": "Correct Member Values",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Student ID: 101",
                    "exact": true
                },
                {
                    "pattern": "Student Name: Alice",
                    "exact": true
                },
                {
                    "pattern": "Student Age: 20",
                    "exact": true
                },
                {
                    "pattern": "Student GPA: 3",
                    "exact": true
                }
            ]
        }
    ],
    "multiPart": {
        "part": 1,
        "totalParts": 3,
        "nextProblemId": 10,
        "previousProblemId": null
    }
});


// Problem 11: Enums, Constants, and Symbolic Values
generatedTestDefinitions.set(11, {
    "name": "Enums, Constants, and Symbolic Values",
    "category": "foundations",
    "description": "Learn to use enums for named constants and symbolic values. Understand const keyword, #define macros, and proper constant management in kernel programming.",
    "exactRequirements": {
        "functionNames": [
            "enums_init",
            "enums_exit"
        ],
        "variables": [
            {
                "name": "buffer_size",
                "type": "const int",
                "value": 1024
            },
            {
                "name": "driver_name",
                "type": "const char*",
                "value": "test_driver"
            },
            {
                "name": "current_state",
                "type": "enum device_state",
                "value": "DEVICE_READY"
            },
            {
                "name": "allowed_ops",
                "type": "enum operation_type",
                "value": "OP_READ | OP_WRITE"
            },
            {
                "name": "device_count",
                "type": "int",
                "value": 5
            }
        ],
        "outputMessages": [
            "Constants:",
            "MAX_DEVICES: 10",
            "DEVICE_NAME_LEN: 32",
            "Version: 2\\.1",
            "Buffer size: 1024",
            "Driver name: test_driver",
            "Device States:",
            "DEVICE_OFFLINE = 0",
            "DEVICE_READY = 2",
            "Current state: DEVICE_READY \\(2\\)",
            "Device is ready",
            "Can add more devices",
            "Read operation allowed"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "#define MAX_DEVICES",
            "enum device_state",
            "enum operation_type",
            "const int",
            "const char"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "preprocessor_defines",
            "name": "Preprocessor Constant Definitions",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "#define MAX_DEVICES 10",
                "#define DEVICE_NAME_LEN 32",
                "#define VERSION_MAJOR 2"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "enum_definitions",
            "name": "Proper Enum Definitions",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "enum device_state",
                "enum operation_type",
                "DEVICE_OFFLINE",
                "DEVICE_READY",
                "OP_READ = 1"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "const_variables",
            "name": "Const Variable Usage",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "const int buffer_size",
                "const char *driver_name"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "enum_assignments",
            "name": "Enum Variable Assignments",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "= DEVICE_READY",
                "= OP_READ | OP_WRITE"
            ],
            "prohibitedSymbols": [
                "= 2",
                "= 3"
            ]
        },
        {
            "id": "enum_comparisons",
            "name": "Enum Comparisons and Logic",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "== DEVICE_READY",
                "< MAX_DEVICES",
                "& OP_READ"
            ],
            "prohibitedSymbols": [
                "== 2",
                "< 10"
            ]
        },
        {
            "id": "correct_enum_values",
            "name": "Correct Enum Integer Values",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "DEVICE_OFFLINE = 0",
                    "exact": true
                },
                {
                    "pattern": "DEVICE_READY = 2",
                    "exact": true
                },
                {
                    "pattern": "Current state: DEVICE_READY \\(2\\)",
                    "exact": false
                }
            ]
        },
        {
            "id": "constant_usage",
            "name": "Proper Constant Usage",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "MAX_DEVICES: 10",
                    "exact": true
                },
                {
                    "pattern": "Version: 2\\.1",
                    "exact": false
                },
                {
                    "pattern": "Buffer size: 1024",
                    "exact": true
                }
            ]
        },
        {
            "id": "bitwise_enum_ops",
            "name": "Bitwise Operations with Enums",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "OP_READ | OP_WRITE",
                "allowed_ops & OP_READ"
            ],
            "prohibitedSymbols": []
        }
    ]
});


// Problem 12: Kernel Logging with printk and Log Levels
generatedTestDefinitions.set(12, {
    "name": "Kernel Logging with printk and Log Levels",
    "category": "foundations",
    "description": "Master kernel logging using printk with different log levels. Understand when to use each log level and how kernel logging differs from userspace printf.",
    "exactRequirements": {
        "functionNames": [
            "printk_init",
            "printk_exit"
        ],
        "variables": [
            {
                "name": "error_code",
                "type": "int",
                "value": -12
            },
            {
                "name": "device_count",
                "type": "int",
                "value": 3
            },
            {
                "name": "memory_addr",
                "type": "unsigned long",
                "value": "0xdeadbeef"
            }
        ],
        "outputMessages": [
            "Module initialization started",
            "Found 3 devices during initialization",
            "Non-critical error occurred: -12",
            "Debug info: memory_addr=0xdeadbeef, device_count=3",
            "Using pr_info macro for informational message",
            "Using pr_warn macro for warning message",
            "Using pr_err macro for error message",
            "This message is rate-limited"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "printk(KERN_INFO",
            "printk(KERN_NOTICE",
            "printk(KERN_WARNING",
            "printk(KERN_DEBUG",
            "pr_info",
            "pr_warn",
            "pr_err",
            "printk_ratelimited"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "log_level_usage",
            "name": "All Required Log Levels Used",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "KERN_INFO",
                "KERN_NOTICE",
                "KERN_WARNING",
                "KERN_DEBUG"
            ],
            "prohibitedSymbols": [
                "printf"
            ]
        },
        {
            "id": "pr_macro_usage",
            "name": "Modern pr_* Macro Usage",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "pr_info(",
                "pr_warn(",
                "pr_err("
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "format_specifiers",
            "name": "Proper Format Specifier Usage",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "%d",
                "%lx"
            ],
            "prohibitedSymbols": [
                "%s\" for numbers"
            ]
        },
        {
            "id": "rate_limiting",
            "name": "Rate-Limited Printing Usage",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "printk_ratelimited("
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "conditional_logging",
            "name": "Conditional Logging Logic",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "if (device_count >",
                "if (error_code <"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "appropriate_log_levels",
            "name": "Appropriate Log Level Selection",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Module initialization started",
                    "exact": true
                },
                {
                    "pattern": "Found 3 devices during initialization",
                    "exact": true
                },
                {
                    "pattern": "Non-critical error occurred: -12",
                    "exact": true
                }
            ]
        },
        {
            "id": "debug_formatting",
            "name": "Debug Information Formatting",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Debug info: memory_addr=0xdeadbeef, device_count=3",
                    "exact": true
                }
            ]
        },
        {
            "id": "pr_macro_output",
            "name": "pr_* Macro Output",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Using pr_info macro for informational message",
                    "exact": true
                },
                {
                    "pattern": "Using pr_warn macro for warning message",
                    "exact": true
                },
                {
                    "pattern": "Using pr_err macro for error message",
                    "exact": true
                }
            ]
        }
    ]
});


// Problem 13: Structures and Pointers - Part 2: Arrow Operator
generatedTestDefinitions.set(13, {
    "name": "Structures and Pointers - Part 2: Arrow Operator",
    "category": "foundations",
    "description": "Learn to use pointers to structures and the arrow operator. Understand the difference between dot and arrow operators. This builds on Part 1 structure knowledge.",
    "exactRequirements": {
        "functionNames": [
            "structures_pointers_init",
            "structures_pointers_exit"
        ],
        "variables": [
            {
                "name": "stu_ptr",
                "type": "struct student*",
                "value": "&stu"
            }
        ],
        "outputMessages": [
            "Student ID via pointer: 102",
            "Student Name via pointer: Bob",
            "Student Age via pointer: 21",
            "Student GPA via pointer: 3"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "struct student *stu_ptr",
            "stu_ptr->id",
            "stu_ptr->name",
            "stu_ptr->age",
            "stu_ptr->gpa"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "pointer_declaration",
            "name": "Structure Pointer Declaration",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "struct student *stu_ptr",
                "&stu"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "arrow_operator_usage",
            "name": "Arrow Operator Usage",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "stu_ptr->id",
                "stu_ptr->name",
                "stu_ptr->age",
                "stu_ptr->gpa"
            ],
            "prohibitedSymbols": [
                "(*stu_ptr)."
            ]
        },
        {
            "id": "correct_pointer_access",
            "name": "Correct Pointer Access",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Student ID via pointer: 102",
                    "exact": true
                },
                {
                    "pattern": "Student Name via pointer: Bob",
                    "exact": true
                },
                {
                    "pattern": "Student Age via pointer: 21",
                    "exact": true
                },
                {
                    "pattern": "Student GPA via pointer: 3",
                    "exact": true
                }
            ]
        }
    ],
    "multiPart": {
        "part": 2,
        "totalParts": 3,
        "nextProblemId": 11,
        "previousProblemId": 9
    }
});


// Problem 14: Pointers Basics - Part 1: Declaration and Dereferencing
generatedTestDefinitions.set(14, {
    "name": "Pointers Basics - Part 1: Declaration and Dereferencing",
    "category": "foundations",
    "description": "Learn fundamental pointer concepts in kernel programming. Understand pointer declaration, assignment, and dereferencing. This is the first part of the pointer series.",
    "exactRequirements": {
        "functionNames": [
            "pointers_init",
            "pointers_exit"
        ],
        "variables": [
            {
                "name": "num",
                "type": "int",
                "value": 42
            },
            {
                "name": "ptr",
                "type": "int*",
                "value": "&num"
            }
        ],
        "outputMessages": [
            "Direct value: 42",
            "Value through pointer: 42",
            "Address in pointer: (0x[0-9a-fA-F]+|\\(____ptrval____\\))"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "*ptr",
            "&num",
            "int num = 42"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "pointer_declaration",
            "name": "Pointer Declaration",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "*ptr",
                "&num",
                "int num = 42"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "dereferencing",
            "name": "Pointer Dereferencing",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "*ptr"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "correct_output",
            "name": "Correct Output Values",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Direct value: 42",
                    "exact": true
                },
                {
                    "pattern": "Value through pointer: 42",
                    "exact": true
                },
                {
                    "pattern": "Address in pointer: (0x[0-9a-fA-F]+|\\(____ptrval____\\))",
                    "exact": false
                }
            ]
        }
    ],
    "multiPart": {
        "part": 1,
        "totalParts": 3,
        "nextProblemId": 7,
        "previousProblemId": null
    }
});


// Problem 15: Pointers and Arrays - Part 2: Array Traversal with Pointers
generatedTestDefinitions.set(15, {
    "name": "Pointers and Arrays - Part 2: Array Traversal with Pointers",
    "category": "foundations",
    "description": "Learn the relationship between pointers and arrays in kernel programming. Use pointers to traverse arrays and understand pointer arithmetic. This builds on Part 1 pointer knowledge.",
    "exactRequirements": {
        "functionNames": [
            "pointers_arrays_init",
            "pointers_arrays_exit"
        ],
        "variables": [
            {
                "name": "values",
                "type": "int[]",
                "value": "[100, 200, 300, 400, 500]"
            },
            {
                "name": "arr_ptr",
                "type": "int*",
                "value": "values"
            }
        ],
        "outputMessages": [
            "Element 0: 100",
            "Element 1: 200",
            "Element 2: 300",
            "Element 3: 400",
            "Element 4: 500"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "int *arr_ptr",
            "arr_ptr + ",
            "*(arr_ptr"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "array_pointer_setup",
            "name": "Array and Pointer Setup",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int values",
                "int *arr_ptr",
                "values"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "pointer_arithmetic",
            "name": "Pointer Arithmetic Usage",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "arr_ptr + ",
                "*(arr_ptr"
            ],
            "prohibitedSymbols": [
                "values["
            ]
        },
        {
            "id": "correct_traversal",
            "name": "Correct Array Traversal",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Element 0: 100",
                    "exact": true
                },
                {
                    "pattern": "Element 1: 200",
                    "exact": true
                },
                {
                    "pattern": "Element 2: 300",
                    "exact": true
                },
                {
                    "pattern": "Element 3: 400",
                    "exact": true
                },
                {
                    "pattern": "Element 4: 500",
                    "exact": true
                }
            ]
        }
    ],
    "multiPart": {
        "part": 2,
        "totalParts": 3,
        "nextProblemId": 8,
        "previousProblemId": 6
    }
});


// Problem 16: Pointers and Functions - Part 3: Pass by Reference
generatedTestDefinitions.set(16, {
    "name": "Pointers and Functions - Part 3: Pass by Reference",
    "category": "foundations",
    "description": "Master passing pointers to functions to modify values by reference. Learn the difference between pass-by-value and pass-by-reference. This completes the pointer series foundation.",
    "exactRequirements": {
        "functionNames": [
            "pointers_functions_init",
            "pointers_functions_exit",
            "swap_values",
            "double_value"
        ],
        "variables": [
            {
                "name": "x",
                "type": "int",
                "value": 10
            },
            {
                "name": "y",
                "type": "int",
                "value": 20
            },
            {
                "name": "z",
                "type": "int",
                "value": 15
            }
        ],
        "outputMessages": [
            "Before swap: x=10, y=20",
            "Before doubling: z=15",
            "After swap: x=20, y=10",
            "After doubling: z=30"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "void swap_values",
            "void double_value",
            "int *",
            "&x",
            "&y",
            "&z"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_signatures",
            "name": "Correct Function Signatures",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void swap_values",
                "int *a",
                "int *b",
                "void double_value",
                "int *val"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "pointer_parameters",
            "name": "Pointer Parameters Used",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "&x",
                "&y",
                "&z"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "correct_modifications",
            "name": "Values Correctly Modified",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Before swap: x=10, y=20",
                    "exact": true
                },
                {
                    "pattern": "Before doubling: z=15",
                    "exact": true
                },
                {
                    "pattern": "After swap: x=20, y=10",
                    "exact": true
                },
                {
                    "pattern": "After doubling: z=30",
                    "exact": true
                }
            ]
        }
    ],
    "multiPart": {
        "part": 3,
        "totalParts": 3,
        "nextProblemId": 9,
        "previousProblemId": 7
    }
});


// Problem 17: Bitwise Operations and Bit Manipulation
generatedTestDefinitions.set(17, {
    "name": "Bitwise Operations and Bit Manipulation",
    "category": "foundations",
    "description": "Master bitwise operations (&, |, ^, ~, <<, >>) essential for kernel programming, device drivers, and hardware interaction. Learn bit manipulation techniques for flags and registers.",
    "exactRequirements": {
        "functionNames": [
            "bitwise_init",
            "bitwise_exit"
        ],
        "variables": [
            {
                "name": "a",
                "type": "unsigned int",
                "value": "0x5A"
            },
            {
                "name": "b",
                "type": "unsigned int",
                "value": "0x3C"
            },
            {
                "name": "flags",
                "type": "unsigned int",
                "value": "0x00"
            },
            {
                "name": "mask",
                "type": "unsigned int",
                "value": "calculated"
            }
        ],
        "outputMessages": [
            "Bitwise Operations:",
            "0x5A & 0x3C = 0x18",
            "0x5A \\| 0x3C = 0x7E",
            "0x5A \\^ 0x3C = 0x66",
            "~0x5A = 0xFFFFFFA5",
            "0x5A << 2 = 0x168",
            "0x5A >> 2 = 0x16",
            "Flag Operations:",
            "After setting bit 3: 0x8",
            "Bit 3 is set: 1",
            "Extracted bits 2-5: 0x6"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "a & b",
            "a | b",
            "a ^ b",
            "~a",
            "a << 2",
            "a >> 2",
            "1 << 3",
            "&= ~",
            "^="
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "basic_bitwise_ops",
            "name": "All Basic Bitwise Operations",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "a & b",
                "a | b",
                "a ^ b",
                "~a",
                "a << 2",
                "a >> 2"
            ],
            "prohibitedSymbols": [
                "= 0x18",
                "= 0x7E",
                "= 0x66",
                "= 0x168",
                "= 0x16"
            ]
        },
        {
            "id": "bit_manipulation_ops",
            "name": "Bit Set/Clear/Toggle Operations",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "|= (1 << 3)",
                "&= ~(1 << 5)",
                "^= (1 << 7)"
            ],
            "prohibitedSymbols": [
                "flags = 0x8"
            ]
        },
        {
            "id": "bit_checking",
            "name": "Bit Checking Operation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "& (1 << 3)",
                "!= 0"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "mask_operations",
            "name": "Bit Mask and Extraction",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "& mask",
                ">> 2"
            ],
            "prohibitedSymbols": [
                "= 0x6"
            ]
        },
        {
            "id": "hex_format_output",
            "name": "Hexadecimal Format Output",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "0x5A & 0x3C = 0x18",
                    "exact": true
                },
                {
                    "pattern": "0x5A \\| 0x3C = 0x7E",
                    "exact": false
                },
                {
                    "pattern": "0x5A \\^ 0x3C = 0x66",
                    "exact": false
                },
                {
                    "pattern": "0x5A << 2 = 0x168",
                    "exact": true
                },
                {
                    "pattern": "0x5A >> 2 = 0x16",
                    "exact": true
                }
            ]
        },
        {
            "id": "correct_bit_math",
            "name": "Mathematically Correct Bit Operations",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "After setting bit 3: 0x8",
                    "exact": true
                },
                {
                    "pattern": "Bit 3 is set: 1",
                    "exact": true
                },
                {
                    "pattern": "Extracted bits 2-5: 0x6",
                    "exact": true
                }
            ]
        },
        {
            "id": "unsigned_int_usage",
            "name": "Proper Unsigned Integer Usage",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "unsigned int"
            ],
            "prohibitedSymbols": [
                "int a",
                "int b",
                "int flags"
            ]
        }
    ]
});


// Problem 18: String Manipulation and Character Arrays
generatedTestDefinitions.set(18, {
    "name": "String Manipulation and Character Arrays",
    "category": "foundations",
    "description": "Master string handling in kernel space using character arrays and kernel string functions. Learn the difference between string literals, character arrays, and pointers to strings.",
    "exactRequirements": {
        "functionNames": [
            "strings_init",
            "strings_exit"
        ],
        "variables": [
            {
                "name": "str1",
                "type": "char[]",
                "value": "Hello"
            },
            {
                "name": "str2",
                "type": "char[]",
                "value": "World"
            },
            {
                "name": "result",
                "type": "char[]",
                "value": "calculated"
            },
            {
                "name": "dynamic_str",
                "type": "char*",
                "value": "kstrdup_result"
            },
            {
                "name": "literal",
                "type": "const char*",
                "value": "Kernel Programming"
            }
        ],
        "outputMessages": [
            "String Operations:",
            "str1 length: 5",
            "str2 length: 5",
            "literal length: 18",
            "Concatenated: Hello World",
            "strcmp\\(\\\"Hello\\\", \\\"World\\\"\\): -15",
            "Dynamic string: Kernel Programming",
            "First char converted: hello"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/string.h",
            "linux/slab.h"
        ],
        "mustContain": [
            "strlen",
            "strcpy",
            "strcat",
            "strcmp",
            "kstrdup",
            "kfree",
            "str1[0]"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "string_function_usage",
            "name": "All String Functions Used",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "strlen(",
                "strcpy(",
                "strcat(",
                "strcmp("
            ],
            "prohibitedSymbols": [
                "len1 = 5",
                "len2 = 5",
                "total_len = 18"
            ]
        },
        {
            "id": "dynamic_allocation",
            "name": "Dynamic String Allocation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "kstrdup(",
                "GFP_KERNEL",
                "kfree("
            ],
            "prohibitedSymbols": [
                "malloc",
                "free",
                "strdup"
            ]
        },
        {
            "id": "character_manipulation",
            "name": "Character Array Manipulation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "str1[0]",
                ">= 'A'",
                "<= 'Z'",
                "+= 32"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "string_concatenation",
            "name": "Proper String Concatenation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "strcpy(result",
                "strcat(result"
            ],
            "prohibitedSymbols": [
                "result = \"Hello World\""
            ]
        },
        {
            "id": "correct_string_lengths",
            "name": "Correct String Length Calculations",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "str1 length: 5",
                    "exact": true
                },
                {
                    "pattern": "str2 length: 5",
                    "exact": true
                },
                {
                    "pattern": "literal length: 18",
                    "exact": true
                }
            ]
        },
        {
            "id": "string_operations_result",
            "name": "String Operations Results",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Concatenated: Hello World",
                    "exact": true
                },
                {
                    "pattern": "Dynamic string: Kernel Programming",
                    "exact": true
                },
                {
                    "pattern": "First char converted: hello",
                    "exact": true
                }
            ]
        },
        {
            "id": "strcmp_result",
            "name": "strcmp Function Result",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "strcmp\\(\\\"Hello\\\", \\\"World\\\"\\): -15",
                    "exact": false
                }
            ]
        },
        {
            "id": "memory_cleanup",
            "name": "Proper Memory Cleanup",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "if (dynamic_str)",
                "kfree(dynamic_str)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "no_hardcoded_strings",
            "name": "No Hardcoded String Results",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "strlen(",
                "strcat(",
                "strcmp("
            ],
            "prohibitedSymbols": [
                "\"Hello World\"",
                "cmp_result = -15"
            ]
        }
    ]
});


// Problem 19: Macros and Preprocessor Directives
generatedTestDefinitions.set(19, {
    "name": "Macros and Preprocessor Directives",
    "category": "foundations",
    "description": "Master preprocessor macros, conditional compilation, and function-like macros essential for kernel programming. Learn proper macro design and common kernel macro patterns.",
    "exactRequirements": {
        "functionNames": [
            "macros_init",
            "macros_exit"
        ],
        "variables": [
            {
                "name": "a",
                "type": "int",
                "value": 15
            },
            {
                "name": "b",
                "type": "int",
                "value": 25
            },
            {
                "name": "num",
                "type": "int",
                "value": 8
            },
            {
                "name": "my_device",
                "type": "struct device",
                "value": "initialized"
            }
        ],
        "outputMessages": [
            "Macro Constants:",
            "Buffer size: 1024",
            "Max users: 100",
            "Driver version: 1\\.2\\.3",
            "Function Macros:",
            "MIN\\(15, 25\\) = 15",
            "MAX\\(15, 25\\) = 25",
            "SQUARE\\(8\\) = 64",
            "8 is power of 2: 1",
            "Debug message: Module initialized",
            "Device initialized: ID=1, Name=test_device"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "#define BUFFER_SIZE",
            "#define MIN(",
            "#if DEBUG_ENABLED",
            "do {",
            "} while (0)",
            "MIN(a, b)",
            "MAX(a, b)"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "object_like_macros",
            "name": "Object-like Macro Definitions",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "#define BUFFER_SIZE 1024",
                "#define MAX_USERS 100",
                "#define DRIVER_VERSION"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_like_macros",
            "name": "Function-like Macro Definitions",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "#define MIN(a, b)",
                "#define MAX(a, b)",
                "#define SQUARE(x)",
                "#define IS_POWER_OF_2(x)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "conditional_compilation",
            "name": "Conditional Compilation Directives",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "#if DEBUG_ENABLED",
                "#else",
                "#endif"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "variadic_macro",
            "name": "Variadic Macro with ##args",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "##args",
                "fmt, args..."
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "do_while_idiom",
            "name": "do-while(0) Macro Idiom",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "do {",
                "} while (0)",
                "\\\\"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "macro_safety",
            "name": "Safe Macro Implementation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "((a)",
                "((x)",
                "(((x)"
            ],
            "prohibitedSymbols": [
                "#define MIN(a, b) a < b ? a : b"
            ]
        },
        {
            "id": "macro_usage",
            "name": "All Macros Used in Code",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "BUFFER_SIZE",
                "MIN(a, b)",
                "MAX(a, b)",
                "SQUARE(num)",
                "IS_POWER_OF_2(num)",
                "DEBUG_PRINT",
                "INIT_DEVICE"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "correct_macro_results",
            "name": "Correct Macro Calculation Results",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Buffer size: 1024",
                    "exact": true
                },
                {
                    "pattern": "MIN\\(15, 25\\) = 15",
                    "exact": false
                },
                {
                    "pattern": "MAX\\(15, 25\\) = 25",
                    "exact": false
                },
                {
                    "pattern": "SQUARE\\(8\\) = 64",
                    "exact": false
                },
                {
                    "pattern": "8 is power of 2: 1",
                    "exact": true
                }
            ]
        },
        {
            "id": "debug_print_usage",
            "name": "DEBUG_PRINT Macro Usage",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Debug message: Module initialized",
                    "exact": true
                }
            ]
        },
        {
            "id": "multiline_macro_usage",
            "name": "Multi-line Macro Device Initialization",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Device initialized: ID=1, Name=test_device",
                    "exact": true
                }
            ]
        }
    ]
});


// Problem 20: Unions, Type Casting, and Memory Layout
generatedTestDefinitions.set(20, {
    "name": "Unions, Type Casting, and Memory Layout",
    "category": "foundations",
    "description": "Learn unions for overlapping memory layouts and type casting for data conversion. Essential for hardware registers, protocol headers, and low-level kernel programming.",
    "exactRequirements": {
        "functionNames": [
            "unions_init",
            "unions_exit"
        ],
        "variables": [
            {
                "name": "converter",
                "type": "union data_converter",
                "value": "initialized"
            },
            {
                "name": "packet",
                "type": "union packet_header",
                "value": "initialized"
            },
            {
                "name": "generic_ptr",
                "type": "void*",
                "value": "pointer"
            },
            {
                "name": "int_value",
                "type": "int",
                "value": "0x12345678"
            },
            {
                "name": "float_value",
                "type": "float",
                "value": "3.14"
            }
        ],
        "outputMessages": [
            "Union Data Converter:",
            "Full value: 0x12345678",
            "Half values: 0x[0-9a-fA-F]+, 0x[0-9a-fA-F]+",
            "Bytes: 0x[0-9a-fA-F]+, 0x[0-9a-fA-F]+, 0x[0-9a-fA-F]+, 0x[0-9a-fA-F]+",
            "Type Casting:",
            "int to float: [0-9]+\\.[0-9]+",
            "Pointer casting works",
            "Packet Header:",
            "Version: 4, Header Length: 5",
            "Total Length: 1500"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "union data_converter",
            "union packet_header",
            "(float)",
            "(int *)",
            "(char *)",
            "converter.full_value",
            "packet.ip_header"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "union_definitions",
            "name": "Proper Union Definitions",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "union data_converter",
                "union packet_header",
                "unsigned int full_value",
                "unsigned short half_values"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "bit_fields",
            "name": "Bit Field Usage in Union",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "unsigned char b0:4",
                "unsigned char version:4",
                "unsigned char header_len:4"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "type_casting_operations",
            "name": "Type Casting Operations",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "(float)int_value",
                "(int)float_value",
                "(int *)",
                "(char *)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "union_member_access",
            "name": "Union Member Access",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "converter.full_value",
                "converter.half_values",
                "converter.bytes",
                "packet.ip_header"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "overlapping_memory_demo",
            "name": "Overlapping Memory Demonstration",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Full value: 0x12345678",
                    "exact": true
                },
                {
                    "pattern": "Half values: 0x[0-9a-fA-F]+, 0x[0-9a-fA-F]+",
                    "exact": false
                },
                {
                    "pattern": "Bytes: 0x[0-9a-fA-F]+",
                    "exact": false
                }
            ]
        },
        {
            "id": "type_casting_results",
            "name": "Type Casting Results",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "int to float: [0-9]+\\.[0-9]+",
                    "exact": false
                },
                {
                    "pattern": "Pointer casting works",
                    "exact": true
                }
            ]
        },
        {
            "id": "packet_header_fields",
            "name": "Packet Header Field Access",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Version: 4, Header Length: 5",
                    "exact": true
                },
                {
                    "pattern": "Total Length: 1500",
                    "exact": true
                }
            ]
        },
        {
            "id": "no_hardcoded_values",
            "name": "No Hardcoded Union Values",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "converter.full_value =",
                "converter.half_values[",
                "converter.bytes["
            ],
            "prohibitedSymbols": [
                "= 0x1234",
                "= 0x5678",
                "= 0x12"
            ]
        },
        {
            "id": "proper_initialization",
            "name": "Proper Union Initialization",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "= 0x12345678",
                "packet.ip_header.version = 4"
            ],
            "prohibitedSymbols": []
        }
    ]
});


// Problem 21: Variable Scope, Storage Classes, and Lifetime
generatedTestDefinitions.set(21, {
    "name": "Variable Scope, Storage Classes, and Lifetime",
    "category": "foundations",
    "description": "Master variable scope (global, local, static) and storage classes in kernel programming. Understand variable lifetime, initialization, and proper usage patterns for kernel modules.",
    "exactRequirements": {
        "functionNames": [
            "scope_init",
            "scope_exit",
            "increment_static_counter",
            "demonstrate_scope",
            "demonstrate_shadowing"
        ],
        "variables": [
            {
                "name": "global_counter",
                "type": "static int",
                "value": "0"
            },
            {
                "name": "global_buffer",
                "type": "static char[]",
                "value": "array"
            },
            {
                "name": "global_name",
                "type": "const char*",
                "value": "test_module"
            }
        ],
        "outputMessages": [
            "Variable Scope Demonstration:",
            "Global counter: 5",
            "Global buffer: Hello from global",
            "Global name: test_module",
            "Local init: 42",
            "Static vs Local Variables:",
            "Static counter: 1, Local temp: 11",
            "Static counter: 2, Local temp: 11",
            "Static counter: 3, Local temp: 11",
            "Function Scope:",
            "Function scope: param=3, local_var=6",
            "Block scope: param=8, local_var=16, block_var=17",
            "Variable Shadowing:",
            "Outer scope value: 100",
            "Inner scope value: 200",
            "Back to outer scope value: 100"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "static int global_counter",
            "static int static_counter",
            "int local_var",
            "int block_var",
            "if (param >"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "global_variable_declarations",
            "name": "Proper Global Variable Declarations",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "static int global_counter",
                "static char global_buffer",
                "const char *global_name"
            ],
            "prohibitedSymbols": [
                "int global_counter",
                "extern"
            ]
        },
        {
            "id": "static_local_variable",
            "name": "Static Local Variable Usage",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "static int static_counter = 0",
                "static_counter++"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "scope_demonstration",
            "name": "Block Scope Demonstration",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "if (param > 5)",
                "int block_var",
                "block_var = local_var + 1"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "variable_shadowing",
            "name": "Variable Shadowing Implementation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int value = 100",
                "int value = 200"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "static_persistence",
            "name": "Static Variable Persistence",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Static counter: 1, Local temp: 11",
                    "exact": true
                },
                {
                    "pattern": "Static counter: 2, Local temp: 11",
                    "exact": true
                },
                {
                    "pattern": "Static counter: 3, Local temp: 11",
                    "exact": true
                }
            ]
        },
        {
            "id": "block_scope_behavior",
            "name": "Block Scope Variable Behavior",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Function scope: param=3, local_var=6",
                    "exact": true
                },
                {
                    "pattern": "Block scope: param=8, local_var=16, block_var=17",
                    "exact": true
                },
                {
                    "pattern": "Function scope: param=8, local_var=16",
                    "exact": true
                }
            ]
        },
        {
            "id": "shadowing_behavior",
            "name": "Variable Shadowing Behavior",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Outer scope value: 100",
                    "exact": true
                },
                {
                    "pattern": "Inner scope value: 200",
                    "exact": true
                },
                {
                    "pattern": "Back to outer scope value: 100",
                    "exact": true
                }
            ]
        },
        {
            "id": "global_access",
            "name": "Global Variable Access",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Global counter: 5",
                    "exact": true
                },
                {
                    "pattern": "Global buffer: Hello from global",
                    "exact": true
                },
                {
                    "pattern": "Global name: test_module",
                    "exact": true
                }
            ]
        },
        {
            "id": "proper_calculations",
            "name": "Proper Variable Calculations",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "local_var = param * 2",
                "block_var = local_var + 1",
                "local_temp++"
            ],
            "prohibitedSymbols": [
                "local_var = 6",
                "block_var = 17"
            ]
        }
    ]
});


// Problem 22: Stack vs Heap Memory Concepts
generatedTestDefinitions.set(22, {
    "name": "Stack vs Heap Memory Concepts",
    "category": "foundations",
    "description": "Learn the fundamental difference between stack and heap memory allocation in kernel programming. Understand when to use each type and their limitations. This bridges the gap between simple variables and dynamic memory allocation.",
    "exactRequirements": {
        "functionNames": [
            "memory_concepts_init",
            "memory_concepts_exit",
            "demonstrate_stack_memory",
            "demonstrate_stack_limitations",
            "explain_heap_necessity"
        ],
        "variables": [],
        "outputMessages": [
            "Memory concepts module loaded",
            "Understanding Stack vs Heap Memory",
            "Stack variable: 42",
            "Stack memory: automatic, limited, fast",
            "Stack limitations:",
            "Heap memory needed when:",
            "Next: Learn kmalloc for heap allocation",
            "Memory concepts module unloaded"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "local_var",
            "local_array",
            "sizeof(local_array)"
        ]
    },
    "testCases": [
        {
            "id": "stack_demonstration",
            "name": "Stack Memory Demonstration",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "int local_var = 42",
                "char local_array[256]",
                "sizeof(local_array)"
            ],
            "prohibitedSymbols": [
                "kmalloc",
                "kfree",
                "malloc"
            ]
        },
        {
            "id": "concept_explanation",
            "name": "Memory Concept Explanation",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Stack memory: automatic, limited, fast",
                    "exact": true
                },
                {
                    "pattern": "Heap memory needed when:",
                    "exact": true
                }
            ]
        },
        {
            "id": "educational_comments",
            "name": "Educational Comments Present",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "// Stack Memory:",
                "// Heap Memory:",
                "// WHY: Understanding this is crucial"
            ],
            "prohibitedSymbols": []
        }
    ]
});


// Problem 23: Structures and Functions - Part 3: Passing Structures
generatedTestDefinitions.set(23, {
    "name": "Structures and Functions - Part 3: Passing Structures",
    "category": "foundations",
    "description": "Master passing structures to functions by value and by reference. Learn when to use each approach and understand the performance implications. This completes the structure series.",
    "exactRequirements": {
        "functionNames": [
            "structures_functions_init",
            "structures_functions_exit",
            "print_student_byval",
            "update_gpa"
        ],
        "variables": [
            {
                "name": "stu",
                "type": "struct student",
                "value": "{103, \"Charlie\", 22, 3.2}"
            }
        ],
        "outputMessages": [
            "Original student:",
            "ID: 103, Name: Charlie, Age: 22, GPA: 3",
            "After GPA update:",
            "ID: 103, Name: Charlie, Age: 22, GPA: 3"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "void print_student_byval",
            "struct student s",
            "void update_gpa",
            "struct student *s",
            "s->gpa"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "function_signatures",
            "name": "Correct Function Signatures",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "void print_student_byval",
                "struct student s",
                "void update_gpa",
                "struct student *s",
                "float new_gpa"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "pointer_modification",
            "name": "GPA Modification via Pointer",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "s->gpa",
                "new_gpa"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "correct_behavior",
            "name": "Functions Work Correctly",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Original student:",
                    "exact": true
                },
                {
                    "pattern": "ID: 103, Name: Charlie, Age: 22, GPA: 3",
                    "exact": true
                },
                {
                    "pattern": "After GPA update:",
                    "exact": true
                },
                {
                    "pattern": "ID: 103, Name: Charlie, Age: 22, GPA: 3",
                    "exact": true
                }
            ]
        }
    ],
    "multiPart": {
        "part": 3,
        "totalParts": 3,
        "nextProblemId": 12,
        "previousProblemId": 10
    }
});


// Problem 24: Introduction to Dynamic Memory Allocation
generatedTestDefinitions.set(24, {
    "name": "Introduction to Dynamic Memory Allocation",
    "category": "foundations",
    "description": "Learn your first dynamic memory allocation using kmalloc and kfree. Understand the basic pattern of allocating, using, and freeing memory. This introduces heap memory management in a simple, controlled way.",
    "exactRequirements": {
        "functionNames": [
            "dynamic_memory_init",
            "dynamic_memory_exit",
            "demonstrate_basic_kmalloc",
            "demonstrate_memory_sizes",
            "demonstrate_allocation_failure"
        ],
        "variables": [],
        "outputMessages": [
            "Dynamic memory module loaded",
            "Learning kmalloc and kfree",
            "Dynamic buffer contains: Hello from heap memory!",
            "Memory allocated, used, and freed successfully",
            "Memory allocation sizes:",
            "Always check kmalloc return value!",
            "Remember: Every kmalloc needs a kfree!",
            "Dynamic memory module unloaded"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/slab.h"
        ],
        "mustContain": [
            "kmalloc",
            "kfree",
            "GFP_KERNEL",
            "if (!dynamic_buffer)"
        ]
    },
    "testCases": [
        {
            "id": "basic_kmalloc_usage",
            "name": "Basic kmalloc Usage",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "kmalloc(256, GFP_KERNEL)",
                "if (!dynamic_buffer)",
                "kfree(dynamic_buffer)"
            ],
            "prohibitedSymbols": [
                "malloc",
                "free"
            ]
        },
        {
            "id": "error_checking",
            "name": "Proper Error Checking",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "if (!dynamic_buffer)",
                "return -ENOMEM"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "memory_pattern",
            "name": "Memory Management Pattern",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Memory allocated, used, and freed successfully",
                    "exact": true
                },
                {
                    "pattern": "Pattern: kmalloc -> check -> use -> kfree",
                    "exact": true
                }
            ]
        },
        {
            "id": "required_includes",
            "name": "Required Header Files",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "linux/slab.h"
            ],
            "prohibitedSymbols": []
        }
    ]
});


// Problem 25: Kernel Memory Management - Part 1: kmalloc and kfree
generatedTestDefinitions.set(25, {
    "name": "Kernel Memory Management - Part 1: kmalloc and kfree",
    "category": "foundations",
    "description": "Learn kernel memory allocation using kmalloc and kfree. Understand the difference between kernel and userspace memory management. This is the first part of kernel memory series.",
    "exactRequirements": {
        "functionNames": [
            "kmalloc_init",
            "kmalloc_exit"
        ],
        "variables": [
            {
                "name": "arr",
                "type": "int*",
                "value": "kmalloc_result"
            }
        ],
        "outputMessages": [
            "Memory allocated successfully",
            "arr\\[0\\] = 10",
            "arr\\[1\\] = 20",
            "arr\\[2\\] = 30",
            "arr\\[3\\] = 40",
            "arr\\[4\\] = 50",
            "Memory freed successfully"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/slab.h"
        ],
        "mustContain": [
            "kmalloc",
            "kfree",
            "GFP_KERNEL",
            "sizeof(int)",
            "arr != NULL"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "memory_allocation",
            "name": "Proper Memory Allocation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "kmalloc",
                "5 * sizeof(int)",
                "GFP_KERNEL"
            ],
            "prohibitedSymbols": [
                "malloc"
            ]
        },
        {
            "id": "null_check",
            "name": "NULL Pointer Check",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "arr != NULL",
                "if"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "memory_free",
            "name": "Proper Memory Cleanup",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "kfree",
                "arr"
            ],
            "prohibitedSymbols": [
                "free"
            ]
        },
        {
            "id": "correct_output",
            "name": "Correct Array Values",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Memory allocated successfully",
                    "exact": true
                },
                {
                    "pattern": "arr\\[0\\] = 10",
                    "exact": false
                },
                {
                    "pattern": "arr\\[1\\] = 20",
                    "exact": false
                },
                {
                    "pattern": "arr\\[2\\] = 30",
                    "exact": false
                },
                {
                    "pattern": "arr\\[3\\] = 40",
                    "exact": false
                },
                {
                    "pattern": "arr\\[4\\] = 50",
                    "exact": false
                },
                {
                    "pattern": "Memory freed successfully",
                    "exact": true
                }
            ]
        }
    ],
    "multiPart": {
        "part": 1,
        "totalParts": 3,
        "nextProblemId": 13,
        "previousProblemId": null
    }
});


// Problem 26: Kernel Memory Management - Part 2: Dynamic Strings with kstrdup
generatedTestDefinitions.set(26, {
    "name": "Kernel Memory Management - Part 2: Dynamic Strings with kstrdup",
    "category": "foundations",
    "description": "Learn kernel string management using kstrdup, strlen, and proper string handling. Understand kernel string functions vs userspace equivalents. This builds on Part 1 memory knowledge.",
    "exactRequirements": {
        "functionNames": [
            "kstrings_init",
            "kstrings_exit"
        ],
        "variables": [
            {
                "name": "original",
                "type": "const char*",
                "value": "\"Hello Kernel World\""
            },
            {
                "name": "copy1",
                "type": "char*",
                "value": "kstrdup_result"
            },
            {
                "name": "copy2",
                "type": "char*",
                "value": "kmalloc_result"
            }
        ],
        "outputMessages": [
            "Original: Hello Kernel World",
            "Copy1 \\(kstrdup\\): Hello Kernel World",
            "Copy2 \\(kmalloc\\+strcpy\\): Hello Kernel World",
            "String length: 18",
            "Strings freed successfully"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/slab.h",
            "linux/string.h"
        ],
        "mustContain": [
            "kstrdup",
            "strlen",
            "strcpy",
            "GFP_KERNEL",
            "kfree"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "kstrdup_usage",
            "name": "kstrdup Function Usage",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "kstrdup",
                "original",
                "GFP_KERNEL"
            ],
            "prohibitedSymbols": [
                "strdup"
            ]
        },
        {
            "id": "manual_copy",
            "name": "Manual String Copy with kmalloc",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "kmalloc",
                "strlen",
                "strcpy"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "string_handling",
            "name": "Proper String Handling",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Original: Hello Kernel World",
                    "exact": true
                },
                {
                    "pattern": "Copy1 \\(kstrdup\\): Hello Kernel World",
                    "exact": false
                },
                {
                    "pattern": "Copy2 \\(kmalloc\\+strcpy\\): Hello Kernel World",
                    "exact": false
                },
                {
                    "pattern": "String length: 18",
                    "exact": true
                },
                {
                    "pattern": "Strings freed successfully",
                    "exact": true
                }
            ]
        }
    ],
    "multiPart": {
        "part": 2,
        "totalParts": 3,
        "nextProblemId": 14,
        "previousProblemId": 12
    }
});


// Problem 27: Kernel Memory Management - Part 3: Dynamic Structures
generatedTestDefinitions.set(27, {
    "name": "Kernel Memory Management - Part 3: Dynamic Structures",
    "category": "foundations",
    "description": "Master dynamic allocation of structures in kernel space. Combine structure knowledge with kernel memory management. This completes the kernel memory series and prepares for advanced concepts.",
    "exactRequirements": {
        "functionNames": [
            "kmem_structures_init",
            "kmem_structures_exit"
        ],
        "variables": [
            {
                "name": "dev",
                "type": "struct device_info*",
                "value": "kmalloc_result"
            }
        ],
        "outputMessages": [
            "Device allocated successfully",
            "Device ID: 100",
            "Device Name: eth0",
            "Device Status: 1 \\(active\\)",
            "Device Timestamp: 123456789",
            "Device memory freed successfully"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/slab.h",
            "linux/string.h"
        ],
        "mustContain": [
            "kmalloc",
            "sizeof(struct device_info)",
            "kstrdup",
            "dev->device_id",
            "dev->device_name",
            "kfree"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "structure_allocation",
            "name": "Structure Allocation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "kmalloc",
                "sizeof(struct device_info)",
                "GFP_KERNEL"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "embedded_string_allocation",
            "name": "Embedded String Allocation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "kstrdup",
                "dev->device_name"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "proper_cleanup",
            "name": "Proper Memory Cleanup Order",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "kfree(dev->device_name)",
                "kfree(dev)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "structure_usage",
            "name": "Structure Member Access",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Device allocated successfully",
                    "exact": true
                },
                {
                    "pattern": "Device ID: 100",
                    "exact": true
                },
                {
                    "pattern": "Device Name: eth0",
                    "exact": true
                },
                {
                    "pattern": "Device Status: 1 \\(active\\)",
                    "exact": false
                },
                {
                    "pattern": "Device Timestamp: 123456789",
                    "exact": true
                },
                {
                    "pattern": "Device memory freed successfully",
                    "exact": true
                }
            ]
        }
    ],
    "multiPart": {
        "part": 3,
        "totalParts": 3,
        "nextProblemId": 15,
        "previousProblemId": 13
    }
});


// Problem 28: Module Parameters and Configuration
generatedTestDefinitions.set(28, {
    "name": "Module Parameters and Configuration",
    "category": "foundations",
    "description": "Learn to create configurable kernel modules using module parameters. Understand how to accept configuration from userspace during module loading. This is essential for production kernel modules.",
    "exactRequirements": {
        "functionNames": [
            "modparam_init",
            "modparam_exit"
        ],
        "variables": [
            {
                "name": "debug_level",
                "type": "int",
                "value": 1
            },
            {
                "name": "device_name",
                "type": "char*",
                "value": "default_device"
            },
            {
                "name": "enable_logging",
                "type": "bool",
                "value": true
            }
        ],
        "outputMessages": [
            "Module loaded with parameters:",
            "Debug Level: 1",
            "Device Name: default_device",
            "Logging Enabled: 1"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/moduleparam.h"
        ],
        "mustContain": [
            "module_param",
            "MODULE_PARM_DESC",
            "debug_level",
            "device_name",
            "enable_logging"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "parameter_declarations",
            "name": "Parameter Declarations",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "static int debug_level",
                "static char *device_name",
                "static bool enable_logging"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "module_param_usage",
            "name": "module_param Macro Usage",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "module_param(debug_level",
                "module_param(device_name",
                "module_param(enable_logging"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "parameter_descriptions",
            "name": "Parameter Descriptions",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "MODULE_PARM_DESC"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "parameter_output",
            "name": "Parameter Values Output",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Module loaded with parameters:",
                    "exact": true
                },
                {
                    "pattern": "Debug Level: 1",
                    "exact": true
                },
                {
                    "pattern": "Device Name: default_device",
                    "exact": true
                },
                {
                    "pattern": "Logging Enabled: 1",
                    "exact": true
                }
            ]
        }
    ]
});


// Problem 29: Kernel Error Handling and Return Codes
generatedTestDefinitions.set(29, {
    "name": "Kernel Error Handling and Return Codes",
    "category": "foundations",
    "description": "Learn proper error handling in kernel space using standard Linux error codes. Understand error propagation and cleanup patterns essential for reliable kernel code.",
    "exactRequirements": {
        "functionNames": [
            "error_handling_init",
            "error_handling_exit",
            "allocate_buffer",
            "process_data"
        ],
        "variables": [
            {
                "name": "buffer",
                "type": "char*",
                "value": "allocation_result"
            },
            {
                "name": "result",
                "type": "int",
                "value": "function_result"
            },
            {
                "name": "size",
                "type": "int",
                "value": 1024
            }
        ],
        "outputMessages": [
            "Buffer allocated successfully \\(1024 bytes\\)",
            "Data processed successfully",
            "Cleanup completed"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/slab.h",
            "linux/errno.h"
        ],
        "mustContain": [
            "ENOMEM",
            "EINVAL",
            "if (",
            "return -",
            "kfree"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "error_code_usage",
            "name": "Standard Error Code Usage",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "-ENOMEM",
                "-EINVAL"
            ],
            "prohibitedSymbols": [
                "return -1",
                "return 1"
            ]
        },
        {
            "id": "error_checking",
            "name": "Proper Error Checking",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "if (",
                "== NULL",
                "!buffer",
                "< 0"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "cleanup_handling",
            "name": "Cleanup on Error Paths",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "kfree"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "success_path",
            "name": "Success Path Output",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Buffer allocated successfully \\(1024 bytes\\)",
                    "exact": false
                },
                {
                    "pattern": "Data processed successfully",
                    "exact": true
                },
                {
                    "pattern": "Cleanup completed",
                    "exact": true
                }
            ]
        }
    ]
});


// Problem 30: Foundation Capstone: Complete Kernel Module
generatedTestDefinitions.set(30, {
    "name": "Foundation Capstone: Complete Kernel Module",
    "category": "foundations",
    "description": "Create a comprehensive kernel module that demonstrates all foundation concepts. This capstone project combines everything learned to build a production-ready kernel module with proper error handling, memory management, and configuration.",
    "exactRequirements": {
        "functionNames": [
            "capstone_init",
            "capstone_exit",
            "create_device",
            "destroy_device",
            "list_devices"
        ],
        "variables": [
            {
                "name": "max_devices",
                "type": "int",
                "value": 5
            },
            {
                "name": "buffer_size",
                "type": "int",
                "value": 1024
            },
            {
                "name": "debug_mode",
                "type": "bool",
                "value": false
            }
        ],
        "outputMessages": [
            "Foundation Capstone Module loaded",
            "Module parameters: max_devices=5, buffer_size=1024, debug_mode=0",
            "Device 1 \\(dev1\\) created successfully",
            "Device 2 \\(dev2\\) created successfully",
            "Device 3 \\(dev3\\) created successfully",
            "Active devices:",
            "Total active devices: 3"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/slab.h",
            "linux/string.h",
            "linux/moduleparam.h",
            "linux/errno.h"
        ],
        "mustContain": [
            "struct kernel_device",
            "create_device",
            "destroy_device",
            "kmalloc",
            "kfree",
            "module_param"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "structure_definition",
            "name": "Complete Structure Definition",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "struct kernel_device",
                "device_id",
                "char *name",
                "int status",
                "void *data_buffer",
                "size_t buffer_size"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "function_implementation",
            "name": "Required Functions Implemented",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "struct kernel_device *create_device",
                "void destroy_device",
                "void list_devices"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "memory_management",
            "name": "Proper Memory Management",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "kmalloc",
                "kstrdup",
                "kfree"
            ],
            "prohibitedSymbols": [
                "malloc",
                "free"
            ]
        },
        {
            "id": "comprehensive_output",
            "name": "Comprehensive Module Output",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Foundation Capstone Module loaded",
                    "exact": true
                },
                {
                    "pattern": "Module parameters: max_devices=5, buffer_size=1024, debug_mode=0",
                    "exact": true
                },
                {
                    "pattern": "Device 1 \\(dev1\\) created successfully",
                    "exact": false
                },
                {
                    "pattern": "Device 2 \\(dev2\\) created successfully",
                    "exact": false
                },
                {
                    "pattern": "Device 3 \\(dev3\\) created successfully",
                    "exact": false
                },
                {
                    "pattern": "Total active devices: 3",
                    "exact": true
                }
            ]
        }
    ]
});


// Problem 31: Comprehensive Foundations Assessment
generatedTestDefinitions.set(31, {
    "name": "Comprehensive Foundations Assessment",
    "category": "foundations",
    "description": "Final comprehensive assessment integrating all foundation concepts: variables, functions, pointers, structures, memory management, control flow, and kernel-specific features. This validates complete mastery of kernel C foundations.",
    "exactRequirements": {
        "functionNames": [
            "assessment_init",
            "assessment_exit",
            "create_student",
            "destroy_student",
            "calculate_statistics",
            "process_grades",
            "enrollment_manager"
        ],
        "variables": [
            {
                "name": "max_capacity",
                "type": "static int",
                "value": 30
            },
            {
                "name": "debug_enabled",
                "type": "static bool",
                "value": false
            },
            {
                "name": "student_list",
                "type": "static struct student**",
                "value": "allocated"
            },
            {
                "name": "student_count",
                "type": "static int",
                "value": "calculated"
            }
        ],
        "outputMessages": [
            "=== Comprehensive Foundations Assessment ===",
            "Module parameters: max_capacity=30, debug_enabled=0",
            "Created student: ID=[0-9]+, Name=[A-Za-z]+, GPA=[0-9]\\.[0-9]+",
            "Processing grades:",
            "Final Statistics: [0-9]+ students, average GPA: [0-9]\\.[0-9]+"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/slab.h",
            "linux/string.h",
            "linux/moduleparam.h",
            "linux/errno.h"
        ],
        "mustContain": [
            "#define MAX_STUDENTS",
            "enum student_status",
            "struct student",
            "union grade_data",
            "kmalloc",
            "kfree",
            "module_param",
            "for (",
            "if (",
            "switch"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "all_structures_defined",
            "name": "All Required Structures Defined",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "enum student_status",
                "struct student",
                "union grade_data"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "memory_management",
            "name": "Proper Memory Management",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "kmalloc(",
                "kfree(",
                "kstrdup(",
                "GFP_KERNEL"
            ],
            "prohibitedSymbols": [
                "malloc",
                "free"
            ]
        },
        {
            "id": "function_implementations",
            "name": "All Functions Implemented",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "struct student *create_student",
                "void destroy_student",
                "void calculate_statistics",
                "void process_grades",
                "int enrollment_manager"
            ],
            "prohibitedSymbols": [
                "return NULL; // Placeholder"
            ]
        },
        {
            "id": "module_parameters",
            "name": "Module Parameters Properly Declared",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "module_param(max_capacity",
                "module_param(debug_enabled",
                "S_IRUGO"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "control_flow_usage",
            "name": "All Control Flow Structures Used",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "for (",
                "while (",
                "if (",
                "switch (",
                "break",
                "continue"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "pointer_operations",
            "name": "Pointer Operations and Dereferencing",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "struct student **",
                "student_list[i]",
                "*avg_gpa",
                "&average_gpa"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "union_bitfield_usage",
            "name": "Union and Bitfield Operations",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "union grade_data",
                "flags.passed",
                "flags.honors",
                "flags.credits"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "error_handling",
            "name": "Comprehensive Error Handling",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "if (!student_list)",
                "return -ENOMEM",
                "return -EIO",
                "pr_err("
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "memory_cleanup",
            "name": "Proper Memory Cleanup",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "destroy_student(student_list[i])",
                "kfree(student_list)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "comprehensive_output",
            "name": "Comprehensive Assessment Output",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "=== Comprehensive Foundations Assessment ===",
                    "exact": true
                },
                {
                    "pattern": "Module parameters: max_capacity=30, debug_enabled=0",
                    "exact": true
                },
                {
                    "pattern": "Created student: ID=[0-9]+",
                    "exact": false
                },
                {
                    "pattern": "Final Statistics: [0-9]+ students",
                    "exact": false
                }
            ]
        }
    ]
});


// Problem 32: Basic Module Lifecycle
generatedTestDefinitions.set(32, {
    "name": "Basic Module Lifecycle",
    "category": "kernel_core",
    "description": "Create a basic kernel module that demonstrates proper module lifecycle management. This module should load cleanly, perform basic initialization, and unload properly with appropriate cleanup. This is fundamental for all kernel development work.",
    "exactRequirements": {
        "functionNames": [
            "basic_module_init",
            "basic_module_exit"
        ],
        "outputMessages": [
            "Basic module loaded successfully",
            "Basic module unloaded cleanly"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h"
        ],
        "mustContain": [
            "module_init",
            "module_exit",
            "MODULE_LICENSE",
            "MODULE_AUTHOR",
            "MODULE_DESCRIPTION",
            "__init",
            "__exit"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "module_structure",
            "name": "Module Structure Check",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "__init",
                "__exit",
                "module_init",
                "module_exit"
            ],
            "prohibitedSymbols": [
                "TODO:",
                "FIXME:",
                "printf",
                "malloc",
                "free"
            ]
        },
        {
            "id": "module_metadata",
            "name": "Module Metadata Check",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "MODULE_LICENSE",
                "MODULE_AUTHOR",
                "MODULE_DESCRIPTION"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "load_message",
            "name": "Module Load Message",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Basic module loaded successfully",
                    "exact": true
                }
            ]
        },
        {
            "id": "unload_message",
            "name": "Module Unload Message",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Basic module unloaded cleanly",
                    "exact": true
                }
            ]
        },
        {
            "id": "function_signatures",
            "name": "Function Signatures",
            "type": "symbol_check",
            "critical": true,
            "expected": [
                "basic_module_init",
                "basic_module_exit"
            ]
        },
        {
            "id": "return_value_check",
            "name": "Proper Return Values",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "return 0"
            ],
            "prohibitedSymbols": [
                "return -1",
                "return 1"
            ]
        }
    ]
});


// Problem 33: Module Parameters and Configuration
generatedTestDefinitions.set(33, {
    "name": "Module Parameters and Configuration",
    "category": "kernel_core",
    "description": "Implement a kernel module that accepts runtime parameters to configure its behavior. This teaches parameter validation, default values, and runtime configuration - essential skills for production kernel modules used at companies like NVIDIA and Intel.",
    "exactRequirements": {
        "functionNames": [
            "param_module_init",
            "param_module_exit"
        ],
        "variables": [
            {
                "name": "debug_level",
                "type": "int",
                "value": 1
            },
            {
                "name": "device_name",
                "type": "char*",
                "value": "mydevice"
            },
            {
                "name": "enable_feature",
                "type": "bool",
                "value": true
            },
            {
                "name": "buffer_size",
                "type": "int",
                "value": 1024
            }
        ],
        "outputMessages": [
            "Module loaded with parameters:",
            "Debug level: 1",
            "Device name: mydevice",
            "Feature enabled: 1",
            "Buffer size: 1024",
            "Module with parameters unloaded"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/moduleparam.h"
        ],
        "mustContain": [
            "module_param",
            "MODULE_PARM_DESC",
            "S_IRUGO"
        ]
    },
    "testCases": [
        {
            "id": "parameter_declarations",
            "name": "Parameter Declarations",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "static int debug_level",
                "static char *device_name",
                "static bool enable_feature",
                "static int buffer_size"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "parameter_registration",
            "name": "Parameter Registration",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "module_param(debug_level",
                "module_param(device_name",
                "module_param(enable_feature",
                "module_param(buffer_size"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "parameter_descriptions",
            "name": "Parameter Descriptions",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "MODULE_PARM_DESC(debug_level",
                "MODULE_PARM_DESC(device_name",
                "MODULE_PARM_DESC(enable_feature",
                "MODULE_PARM_DESC(buffer_size"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "parameter_validation",
            "name": "Parameter Validation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "if (debug_level",
                "if (buffer_size"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "parameter_output",
            "name": "Parameter Value Output",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Debug level: 1",
                    "exact": true
                },
                {
                    "pattern": "Device name: mydevice",
                    "exact": true
                },
                {
                    "pattern": "Feature enabled: 1",
                    "exact": true
                },
                {
                    "pattern": "Buffer size: 1024",
                    "exact": true
                }
            ]
        },
        {
            "id": "power_of_two_validation",
            "name": "Buffer Size Power-of-2 Validation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "is_power_of_2",
                "&",
                "buffer_size - 1"
            ],
            "prohibitedSymbols": []
        }
    ]
});


// Problem 34: Kernel Error Handling Patterns
generatedTestDefinitions.set(34, {
    "name": "Kernel Error Handling Patterns",
    "category": "kernel_core",
    "description": "Master kernel error handling patterns including proper error codes, cleanup on failure, and resource management. This is critical for writing production-quality kernel code that can handle failures gracefully without causing system instability.",
    "exactRequirements": {
        "functionNames": [
            "error_module_init",
            "error_module_exit",
            "allocate_resources",
            "cleanup_resources"
        ],
        "variables": [
            {
                "name": "buffer1",
                "type": "void*"
            },
            {
                "name": "buffer2",
                "type": "void*"
            },
            {
                "name": "proc_entry",
                "type": "struct proc_dir_entry*"
            }
        ],
        "outputMessages": [
            "Error handling module loading...",
            "All resources allocated successfully",
            "Error handling module unloaded"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/slab.h",
            "linux/errno.h",
            "linux/proc_fs.h"
        ],
        "mustContain": [
            "kmalloc",
            "kfree",
            "ENOMEM",
            "EINVAL",
            "proc_create",
            "proc_remove"
        ]
    },
    "testCases": [
        {
            "id": "error_code_usage",
            "name": "Proper Error Code Usage",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "-ENOMEM",
                "-EINVAL",
                "-ENOSYS"
            ],
            "prohibitedSymbols": [
                "return -1",
                "return 1",
                "return 2"
            ]
        },
        {
            "id": "resource_allocation",
            "name": "Resource Allocation Patterns",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "kmalloc(1024",
                "kmalloc(2048",
                "proc_create",
                "GFP_KERNEL"
            ],
            "prohibitedSymbols": [
                "malloc",
                "calloc"
            ]
        },
        {
            "id": "null_pointer_checks",
            "name": "NULL Pointer Checks",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "if (!buffer1)",
                "if (!buffer2)",
                "if (!proc_entry)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "cleanup_patterns",
            "name": "Proper Cleanup Patterns",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "kfree(buffer1)",
                "kfree(buffer2)",
                "proc_remove"
            ],
            "prohibitedSymbols": [
                "free"
            ]
        },
        {
            "id": "cleanup_safety",
            "name": "Safe Cleanup (NULL checks)",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "if (buffer1)",
                "if (buffer2)",
                "if (proc_entry)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "error_propagation",
            "name": "Error Propagation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "return ret",
                "if (ret)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "successful_allocation",
            "name": "Successful Resource Allocation",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "All resources allocated successfully",
                    "exact": true
                }
            ]
        }
    ]
});


// Problem 34: Sysfs Attributes and Kobjects
generatedTestDefinitions.set(34, {
    "name": "Sysfs Attributes and Kobjects",
    "category": "kernel_core",
    "description": "Create a kernel module that exposes configuration and status information through sysfs attributes. This teaches the sysfs interface used extensively in production systems for device configuration, monitoring, and debugging at enterprise kernel development companies.",
    "exactRequirements": {
        "functionNames": [
            "sysfs_module_init",
            "sysfs_module_exit",
            "device_name_show",
            "device_name_store",
            "debug_level_show",
            "debug_level_store",
            "device_enabled_show",
            "device_enabled_store",
            "operation_count_show"
        ],
        "variables": [
            {
                "name": "sysfs_kobj",
                "type": "struct kobject*"
            },
            {
                "name": "device_name",
                "type": "char[]"
            },
            {
                "name": "debug_level",
                "type": "int"
            },
            {
                "name": "device_enabled",
                "type": "bool"
            },
            {
                "name": "operation_count",
                "type": "unsigned long"
            }
        ],
        "outputMessages": [
            "Sysfs module loaded successfully",
            "Sysfs interface created at /sys/kernel/demo_device",
            "Sysfs module unloaded"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/kobject.h",
            "linux/sysfs.h"
        ],
        "mustContain": [
            "kobject_create_and_add",
            "sysfs_create_group",
            "sysfs_remove_group",
            "kobject_put",
            "__ATTR",
            "__ATTR_RO"
        ]
    },
    "testCases": [
        {
            "id": "kobject_creation",
            "name": "Kobject Creation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "kobject_create_and_add",
                "kernel_kobj"
            ],
            "prohibitedSymbols": [
                "kobject_init"
            ]
        },
        {
            "id": "attribute_definitions",
            "name": "Attribute Definitions",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "__ATTR(device_name",
                "__ATTR(debug_level",
                "__ATTR(device_enabled",
                "__ATTR_RO(operation_count"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "sysfs_group_management",
            "name": "Sysfs Group Management",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "sysfs_create_group",
                "sysfs_remove_group",
                "attr_group"
            ],
            "prohibitedSymbols": [
                "sysfs_create_file"
            ]
        },
        {
            "id": "show_store_functions",
            "name": "Show/Store Function Implementation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "sprintf(buf",
                "sscanf(buf",
                "operation_count++",
                "strncpy"
            ],
            "prohibitedSymbols": [
                "strcpy"
            ]
        },
        {
            "id": "input_validation",
            "name": "Input Validation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "if (count >",
                "if (val <",
                "if (val >"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "resource_cleanup",
            "name": "Resource Cleanup",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "kobject_put(sysfs_kobj)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "sysfs_creation_message",
            "name": "Sysfs Creation Message",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Sysfs interface created at /sys/kernel/demo_device",
                    "exact": true
                }
            ]
        }
    ]
});


// Problem 35: Module Dependencies and Symbols
generatedTestDefinitions.set(35, {
    "name": "Module Dependencies and Symbols",
    "category": "kernel_core",
    "description": "Create a kernel module that depends on other modules and exports symbols for use by other modules. This teaches symbol export/import, module dependencies, and inter-module communication patterns used in large kernel subsystems at enterprise companies.",
    "exactRequirements": {
        "functionNames": [
            "dependency_module_init",
            "dependency_module_exit",
            "create_demo_device",
            "destroy_demo_device",
            "get_device_info",
            "get_global_stats"
        ],
        "variables": [
            {
                "name": "global_device",
                "type": "struct demo_device*"
            },
            {
                "name": "device_counter",
                "type": "int"
            },
            {
                "name": "device_mutex",
                "type": "struct mutex"
            }
        ],
        "outputMessages": [
            "Module dependencies demo loaded",
            "Exported symbols: create_demo_device, destroy_demo_device",
            "Device counter: 1",
            "Module dependencies demo unloaded",
            "Final device counter: 0"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/slab.h"
        ],
        "mustContain": [
            "EXPORT_SYMBOL",
            "EXPORT_SYMBOL_GPL",
            "DEFINE_MUTEX",
            "mutex_lock",
            "mutex_unlock",
            "kmalloc",
            "kfree"
        ]
    },
    "testCases": [
        {
            "id": "structure_definition",
            "name": "Structure Definition",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "struct demo_device",
                "char name[32]",
                "int id",
                "bool active",
                "unsigned long created_jiffies"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "symbol_exports",
            "name": "Symbol Exports",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "EXPORT_SYMBOL_GPL(create_demo_device)",
                "EXPORT_SYMBOL_GPL(destroy_demo_device)",
                "EXPORT_SYMBOL(get_device_info)",
                "EXPORT_SYMBOL(get_global_stats)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "mutex_usage",
            "name": "Mutex Usage for Thread Safety",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "DEFINE_MUTEX(device_mutex)",
                "mutex_lock(&device_mutex)",
                "mutex_unlock(&device_mutex)"
            ],
            "prohibitedSymbols": [
                "spin_lock",
                "raw_spin_lock"
            ]
        },
        {
            "id": "memory_management",
            "name": "Memory Management",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "kmalloc(sizeof(struct demo_device)",
                "kfree(dev)",
                "GFP_KERNEL"
            ],
            "prohibitedSymbols": [
                "malloc",
                "free"
            ]
        },
        {
            "id": "input_validation",
            "name": "Input Validation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "if (!name)",
                "if (!dev)",
                "if (!buffer)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "device_initialization",
            "name": "Device Initialization",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "strncpy(dev->name",
                "dev->id = ++device_counter",
                "dev->active = true",
                "dev->created_jiffies = jiffies"
            ],
            "prohibitedSymbols": [
                "strcpy"
            ]
        },
        {
            "id": "exported_symbols_message",
            "name": "Exported Symbols Message",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Exported symbols: create_demo_device, destroy_demo_device",
                    "exact": true
                }
            ]
        }
    ]
});


// Problem 35: Proc Filesystem Interface
generatedTestDefinitions.set(35, {
    "name": "Proc Filesystem Interface",
    "category": "kernel_core",
    "description": "Create a kernel module that implements a /proc interface for exposing kernel module information to userspace. This is fundamental for debugging, monitoring, and configuration in production systems used by enterprise kernel developers.",
    "exactRequirements": {
        "functionNames": [
            "proc_module_init",
            "proc_module_exit",
            "kernel_stats_show",
            "kernel_stats_open",
            "kernel_stats_write"
        ],
        "variables": [
            {
                "name": "proc_entry",
                "type": "struct proc_dir_entry*"
            },
            {
                "name": "info_buffer",
                "type": "char*"
            },
            {
                "name": "access_count",
                "type": "int"
            },
            {
                "name": "last_access_jiffies",
                "type": "unsigned long"
            }
        ],
        "outputMessages": [
            "Proc interface module loaded",
            "Created /proc/kernel_stats",
            "Proc interface module unloaded"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/proc_fs.h",
            "linux/seq_file.h",
            "linux/uaccess.h"
        ],
        "mustContain": [
            "proc_create",
            "proc_remove",
            "seq_printf",
            "single_open",
            "copy_from_user",
            "proc_ops"
        ]
    },
    "testCases": [
        {
            "id": "proc_entry_creation",
            "name": "Proc Entry Creation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "proc_create(PROC_ENTRY_NAME",
                "proc_create(\"kernel_stats\""
            ],
            "prohibitedSymbols": [
                "create_proc_entry"
            ]
        },
        {
            "id": "seq_file_implementation",
            "name": "Seq File Implementation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "seq_printf",
                "single_open",
                "seq_read",
                "seq_lseek",
                "single_release"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "proc_ops_structure",
            "name": "Proc Operations Structure",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "struct proc_ops",
                ".proc_open",
                ".proc_read",
                ".proc_write",
                ".proc_lseek",
                ".proc_release"
            ],
            "prohibitedSymbols": [
                "file_operations"
            ]
        },
        {
            "id": "user_space_interaction",
            "name": "User Space Interaction",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "copy_from_user",
                "__user",
                "access_ok"
            ],
            "prohibitedSymbols": [
                "strcpy",
                "strncpy"
            ]
        },
        {
            "id": "statistics_tracking",
            "name": "Statistics Tracking",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "access_count++",
                "last_access_jiffies = jiffies",
                "seq_printf(m, \"Access count: %d\""
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "resource_cleanup",
            "name": "Resource Cleanup",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "proc_remove",
                "kfree(info_buffer)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "proc_creation_message",
            "name": "Proc Creation Message",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Created /proc/kernel_stats",
                    "exact": true
                }
            ]
        }
    ]
});


// Problem 36: Kernel Debugging and Diagnostics
generatedTestDefinitions.set(36, {
    "name": "Kernel Debugging and Diagnostics",
    "category": "kernel_core",
    "description": "Implement a kernel module with comprehensive debugging, tracing, and diagnostic capabilities. This teaches essential debugging techniques used in production kernel development at companies like Intel, NVIDIA, and Red Hat for troubleshooting complex kernel issues.",
    "exactRequirements": {
        "functionNames": [
            "debug_module_init",
            "debug_module_exit",
            "debug_function_a",
            "debug_function_b",
            "debug_stats_show",
            "debug_stats_open",
            "debug_level_write"
        ],
        "variables": [
            {
                "name": "debug_level",
                "type": "int"
            },
            {
                "name": "debug_dir",
                "type": "struct dentry*"
            },
            {
                "name": "debug_file",
                "type": "struct dentry*"
            },
            {
                "name": "function_calls",
                "type": "unsigned long"
            },
            {
                "name": "error_count",
                "type": "unsigned long"
            }
        ],
        "outputMessages": [
            "Debug module loaded successfully",
            "Debug level: 3, Function calls:",
            "Debugfs interface: /sys/kernel/debug/debug_demo/",
            "Debug module unloaded",
            "Final stats - Calls:"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/debugfs.h"
        ],
        "mustContain": [
            "pr_fmt",
            "pr_info",
            "trace_printk",
            "debugfs_create_dir",
            "debugfs_create_file",
            "debugfs_remove_recursive",
            "seq_printf"
        ]
    },
    "testCases": [
        {
            "id": "debug_levels",
            "name": "Debug Level Definitions",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "#define DEBUG_LEVEL_NONE",
                "#define DEBUG_LEVEL_ERROR",
                "#define DEBUG_LEVEL_WARN",
                "#define DEBUG_LEVEL_INFO",
                "#define DEBUG_LEVEL_DEBUG"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "debug_macro",
            "name": "Debug Print Macro",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "#define debug_print",
                "if (debug_level >= level)",
                "__func__",
                "__LINE__"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "trace_integration",
            "name": "Ftrace Integration",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "trace_printk",
                "debug_function_a: processing",
                "debug_function_b: allocated"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "debugfs_implementation",
            "name": "Debugfs Implementation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "debugfs_create_dir(\"debug_demo\"",
                "debugfs_create_file(\"stats\"",
                "seq_printf(m",
                "single_open"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "error_handling",
            "name": "Error Handling and Statistics",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "error_count++",
                "last_error_jiffies = jiffies",
                "function_calls++"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "parameter_validation",
            "name": "Parameter Validation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "if (!param2)",
                "if (param1 < 0)",
                "if (size == 0)",
                "return -EINVAL"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "debugfs_message",
            "name": "Debugfs Interface Message",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Debugfs interface: /sys/kernel/debug/debug_demo/",
                    "exact": true
                }
            ]
        }
    ]
});


// Problem 37: Workqueues and Timers
generatedTestDefinitions.set(37, {
    "name": "Workqueues and Timers",
    "category": "kernel_core",
    "description": "Implement a kernel module that uses workqueues and timers for asynchronous task execution and periodic operations. This teaches essential kernel concurrency mechanisms used extensively in device drivers and kernel subsystems at enterprise companies.",
    "exactRequirements": {
        "functionNames": [
            "workqueue_module_init",
            "workqueue_module_exit",
            "work_item_handler",
            "delayed_work_handler",
            "timer_callback",
            "stats_proc_show",
            "stats_proc_open"
        ],
        "variables": [
            {
                "name": "periodic_timer",
                "type": "struct timer_list"
            },
            {
                "name": "demo_workqueue",
                "type": "struct workqueue_struct*"
            },
            {
                "name": "delayed_demo_work",
                "type": "struct delayed_work"
            },
            {
                "name": "stats_lock",
                "type": "spinlock_t"
            }
        ],
        "outputMessages": [
            "Workqueue and timer module loaded successfully",
            "Timer interval: 5000 ms, Work delay: 1000 ms",
            "Statistics available at /proc/workqueue_stats",
            "Workqueue and timer module unloaded",
            "Final statistics - Timer:"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/workqueue.h",
            "linux/timer.h"
        ],
        "mustContain": [
            "timer_setup",
            "mod_timer",
            "del_timer_sync",
            "create_singlethread_workqueue",
            "destroy_workqueue",
            "INIT_WORK",
            "INIT_DELAYED_WORK",
            "queue_work",
            "queue_delayed_work",
            "container_of",
            "spin_lock_irqsave",
            "spin_unlock_irqrestore"
        ]
    },
    "testCases": [
        {
            "id": "timer_setup",
            "name": "Timer Setup and Management",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "timer_setup(&periodic_timer, timer_callback, 0)",
                "mod_timer(&periodic_timer",
                "del_timer_sync(&periodic_timer)"
            ],
            "prohibitedSymbols": [
                "init_timer",
                "setup_timer"
            ]
        },
        {
            "id": "workqueue_management",
            "name": "Workqueue Management",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "create_singlethread_workqueue(\"demo_wq\")",
                "destroy_workqueue(demo_workqueue)",
                "flush_workqueue(demo_workqueue)"
            ],
            "prohibitedSymbols": [
                "create_workqueue"
            ]
        },
        {
            "id": "work_initialization",
            "name": "Work Initialization",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "INIT_WORK(&new_item->work, work_item_handler)",
                "INIT_DELAYED_WORK(&delayed_demo_work, delayed_work_handler)",
                "container_of(work, struct work_item_data, work)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "work_scheduling",
            "name": "Work Scheduling",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "queue_work(demo_workqueue",
                "queue_delayed_work(demo_workqueue",
                "cancel_delayed_work_sync(&delayed_demo_work)"
            ],
            "prohibitedSymbols": [
                "schedule_work"
            ]
        },
        {
            "id": "synchronization",
            "name": "Proper Synchronization",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "DEFINE_SPINLOCK(stats_lock)",
                "spin_lock_irqsave(&stats_lock, flags)",
                "spin_unlock_irqrestore(&stats_lock, flags)"
            ],
            "prohibitedSymbols": [
                "mutex_lock"
            ]
        },
        {
            "id": "memory_management",
            "name": "Memory Management in Atomic Context",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "kmalloc(sizeof(*new_item), GFP_ATOMIC)",
                "kfree(item)",
                "kfree(new_item)"
            ],
            "prohibitedSymbols": [
                "GFP_KERNEL"
            ]
        },
        {
            "id": "statistics_message",
            "name": "Statistics Proc Interface",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Statistics available at /proc/workqueue_stats",
                    "exact": true
                }
            ]
        }
    ]
});


// Problem 38: IOCTL Interface Design
generatedTestDefinitions.set(38, {
    "name": "IOCTL Interface Design",
    "category": "kernel_core",
    "description": "Implement a kernel module with a proper IOCTL interface for userspace communication. This teaches advanced userspace-kernel communication patterns used in device drivers and system interfaces at enterprise companies like NVIDIA and Intel.",
    "exactRequirements": {
        "functionNames": [
            "ioctl_module_init",
            "ioctl_module_exit",
            "demo_ioctl",
            "demo_open",
            "demo_release"
        ],
        "variables": [
            {
                "name": "major_number",
                "type": "int"
            },
            {
                "name": "demo_class",
                "type": "struct class*"
            },
            {
                "name": "demo_device",
                "type": "struct device*"
            },
            {
                "name": "device_mutex",
                "type": "struct mutex"
            }
        ],
        "outputMessages": [
            "IOCTL demo module loaded successfully",
            "Device registered: /dev/demo_ioctl",
            "IOCTL commands: GET_CONFIG=",
            "IOCTL demo module unloaded",
            "Final stats - Operations:"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/fs.h",
            "linux/device.h",
            "linux/uaccess.h",
            "linux/ioctl.h"
        ],
        "mustContain": [
            "_IO",
            "_IOR",
            "_IOW",
            "_IOWR",
            "_IOC_TYPE",
            "_IOC_NR",
            "_IOC_DIR",
            "_IOC_SIZE",
            "copy_from_user",
            "copy_to_user",
            "access_ok",
            "register_chrdev",
            "class_create",
            "device_create"
        ]
    },
    "testCases": [
        {
            "id": "ioctl_magic_definition",
            "name": "IOCTL Magic and Commands",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "#define DEMO_IOC_MAGIC",
                "_IOR(DEMO_IOC_MAGIC, 1",
                "_IOW(DEMO_IOC_MAGIC, 2",
                "_IO(DEMO_IOC_MAGIC, 4",
                "_IOWR(DEMO_IOC_MAGIC, 5"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "command_validation",
            "name": "IOCTL Command Validation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "_IOC_TYPE(cmd) != DEMO_IOC_MAGIC",
                "_IOC_NR(cmd) > DEMO_IOC_MAXNR",
                "return -ENOTTY"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "access_checking",
            "name": "User Access Checking",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "access_ok(argp, _IOC_SIZE(cmd))",
                "_IOC_DIR(cmd) & _IOC_READ",
                "_IOC_DIR(cmd) & _IOC_WRITE"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "data_transfer",
            "name": "Safe Data Transfer",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "copy_from_user(&config, argp",
                "copy_to_user(argp, &device_config",
                "copy_to_user(argp, &stats",
                "return -EFAULT"
            ],
            "prohibitedSymbols": [
                "memcpy",
                "strcpy"
            ]
        },
        {
            "id": "input_validation",
            "name": "Input Validation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "if (config.mode < 0 || config.mode > 3)",
                "if (config.threshold < 0",
                "if (!buffer_info.data",
                "return -EINVAL"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "device_registration",
            "name": "Character Device Registration",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "register_chrdev(0, DEVICE_NAME",
                "class_create(THIS_MODULE, CLASS_NAME)",
                "device_create(demo_class"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "device_creation_message",
            "name": "Device Registration Message",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Device registered: /dev/demo_ioctl",
                    "exact": true
                }
            ]
        }
    ]
});


// Problem 39: Advanced Synchronization Primitives
generatedTestDefinitions.set(39, {
    "name": "Advanced Synchronization Primitives",
    "category": "kernel_core",
    "description": "Master advanced kernel synchronization including RCU, completion objects, atomic operations, and memory barriers. This teaches the sophisticated concurrency control mechanisms used in high-performance kernel subsystems at enterprise companies.",
    "exactRequirements": {
        "functionNames": [
            "sync_module_init",
            "sync_module_exit",
            "read_shared_data",
            "update_shared_data",
            "free_shared_data_rcu",
            "reader_thread_fn",
            "writer_thread_fn",
            "monitor_thread_fn",
            "sync_stats_show"
        ],
        "variables": [
            {
                "name": "global_data",
                "type": "struct shared_data __rcu*"
            },
            {
                "name": "update_mutex",
                "type": "struct mutex"
            },
            {
                "name": "stats_lock",
                "type": "spinlock_t"
            },
            {
                "name": "worker_count",
                "type": "atomic_t"
            },
            {
                "name": "config_version",
                "type": "atomic_t"
            }
        ],
        "outputMessages": [
            "Advanced synchronization module loaded successfully",
            "Worker threads: reader, writer, monitor",
            "Statistics available at /proc/sync_stats",
            "Advanced synchronization module unloaded",
            "Final stats - RCU reads:"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/atomic.h",
            "linux/rcupdate.h",
            "linux/completion.h"
        ],
        "mustContain": [
            "rcu_read_lock",
            "rcu_read_unlock",
            "rcu_dereference",
            "rcu_assign_pointer",
            "call_rcu",
            "synchronize_rcu",
            "atomic64_inc",
            "atomic64_read",
            "complete",
            "wait_for_completion",
            "smp_wmb",
            "smp_mb",
            "container_of"
        ]
    },
    "testCases": [
        {
            "id": "rcu_usage",
            "name": "RCU Read-Side Critical Sections",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "rcu_read_lock()",
                "rcu_read_unlock()",
                "rcu_dereference(global_data)",
                "rcu_assign_pointer(global_data, new_data)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "rcu_synchronization",
            "name": "RCU Synchronization and Callbacks",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "call_rcu(&old_data->rcu, free_shared_data_rcu)",
                "synchronize_rcu()",
                "container_of(head, struct shared_data, rcu)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "atomic_operations",
            "name": "Atomic Operations",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "atomic64_inc(&stats",
                "atomic64_read(&stats",
                "atomic_set(&new_data->reference_count, 1)",
                "atomic_inc(&config_version)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "completion_objects",
            "name": "Completion Objects",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "DECLARE_COMPLETION(init_complete)",
                "complete(&init_complete)",
                "wait_for_completion(&init_complete)",
                "wait_for_completion_timeout"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "memory_barriers",
            "name": "Memory Barriers",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "smp_wmb()",
                "smp_mb()",
                "atomic64_inc(&stats.barrier_calls)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "thread_management",
            "name": "Kernel Thread Management",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "kthread_run(reader_thread_fn",
                "kthread_run(writer_thread_fn",
                "kthread_run(monitor_thread_fn",
                "kthread_stop(reader_thread)",
                "kthread_should_stop()"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "statistics_interface",
            "name": "Statistics Proc Interface",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Statistics available at /proc/sync_stats",
                    "exact": true
                }
            ]
        }
    ]
});


// Problem 39: Understanding Concurrency in Kernel
generatedTestDefinitions.set(39, {
    "name": "Understanding Concurrency in Kernel",
    "category": "kernel_core",
    "description": "Learn what concurrency means in kernel programming and why synchronization is critical. Understand multiple execution contexts, race conditions, and the problems that arise when multiple threads access shared data simultaneously.",
    "exactRequirements": {
        "functionNames": [
            "concurrency_init",
            "concurrency_exit",
            "unsafe_thread_function",
            "demonstrate_race_condition",
            "explain_execution_contexts",
            "explain_synchronization_need"
        ],
        "variables": [
            {
                "name": "shared_counter",
                "type": "int"
            },
            {
                "name": "final_expected_value",
                "type": "int"
            }
        ],
        "outputMessages": [
            "Concurrency concepts module loaded",
            "Learning about race conditions and synchronization",
            "=== Demonstrating Race Condition ===",
            "Expected final value: 2000",
            "RACE CONDITION DETECTED!",
            "=== Kernel Execution Contexts ===",
            "=== Why Synchronization is Critical ===",
            "Remember: Shared data needs synchronization!"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/kthread.h",
            "linux/delay.h"
        ],
        "mustContain": [
            "shared_counter++",
            "kthread_run",
            "msleep",
            "IS_ERR"
        ]
    },
    "testCases": [
        {
            "id": "race_condition_demo",
            "name": "Race Condition Demonstration",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "shared_counter++",
                "kthread_run(unsafe_thread_function",
                "msleep(1)"
            ],
            "prohibitedSymbols": [
                "mutex",
                "spinlock",
                "atomic"
            ]
        },
        {
            "id": "execution_contexts",
            "name": "Execution Context Explanation",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "=== Kernel Execution Contexts ===",
                    "exact": true
                },
                {
                    "pattern": "Process Context:",
                    "exact": false
                },
                {
                    "pattern": "Interrupt Context:",
                    "exact": false
                }
            ]
        },
        {
            "id": "synchronization_explanation",
            "name": "Synchronization Need Explanation",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "=== Why Synchronization is Critical ===",
                    "exact": true
                },
                {
                    "pattern": "Data corruption",
                    "exact": false
                },
                {
                    "pattern": "Mutexes",
                    "exact": false
                }
            ]
        },
        {
            "id": "educational_comments",
            "name": "Educational Comments Present",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "// CONCEPT: Concurrency and Race Conditions",
                "// DANGEROUS: No synchronization!",
                "// WHY: Without proper synchronization"
            ],
            "prohibitedSymbols": []
        }
    ]
});


// Problem 40: Basic Character Device Registration
generatedTestDefinitions.set(40, {
    "name": "Basic Character Device Registration",
    "category": "kernel_core",
    "description": "Create a basic character device driver that registers a device, allocates a major/minor number, and implements basic file operations. This is fundamental for all Linux device driver development at enterprise companies.",
    "exactRequirements": {
        "functionNames": [
            "char_dev_init",
            "char_dev_exit",
            "device_open",
            "device_release",
            "device_read",
            "device_write"
        ],
        "variables": [
            {
                "name": "char_dev",
                "type": "struct char_device_data"
            },
            {
                "name": "char_dev_fops",
                "type": "struct file_operations"
            }
        ],
        "outputMessages": [
            "Character device driver loaded successfully",
            "Device registered: /dev/mychardev",
            "Character device driver unloaded"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/fs.h",
            "linux/device.h",
            "linux/cdev.h",
            "linux/uaccess.h"
        ],
        "mustContain": [
            "alloc_chrdev_region",
            "cdev_init",
            "cdev_add",
            "class_create",
            "device_create",
            "copy_to_user",
            "copy_from_user"
        ]
    },
    "testCases": [
        {
            "id": "device_registration",
            "name": "Device Registration",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "alloc_chrdev_region(&char_dev.dev_num",
                "cdev_init(&char_dev.cdev",
                "cdev_add(&char_dev.cdev"
            ],
            "prohibitedSymbols": [
                "register_chrdev"
            ]
        },
        {
            "id": "device_class_creation",
            "name": "Device Class and Node Creation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "class_create(THIS_MODULE, CLASS_NAME)",
                "device_create(char_dev.class"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "file_operations",
            "name": "File Operations Implementation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                ".open = device_open",
                ".release = device_release",
                ".read = device_read",
                ".write = device_write"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "user_space_interaction",
            "name": "User Space Data Transfer",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "copy_to_user(user_buffer",
                "copy_from_user(dev_data->buffer",
                "return -EFAULT"
            ],
            "prohibitedSymbols": [
                "memcpy",
                "strcpy"
            ]
        },
        {
            "id": "thread_safety",
            "name": "Thread Safety Implementation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "mutex_init(&char_dev.device_mutex)",
                "mutex_lock_interruptible(&dev_data->device_mutex)",
                "mutex_unlock(&dev_data->device_mutex)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "error_handling",
            "name": "Proper Error Handling",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "return -ENOMEM",
                "return -EFAULT",
                "return -EINVAL",
                "IS_ERR(char_dev.class)"
            ],
            "prohibitedSymbols": [
                "return -1"
            ]
        },
        {
            "id": "cleanup_order",
            "name": "Proper Cleanup Order",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "device_destroy(char_dev.class",
                "class_destroy(char_dev.class)",
                "cdev_del(&char_dev.cdev)",
                "unregister_chrdev_region"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "device_registration_message",
            "name": "Device Registration Message",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Device registered: /dev/mychardev",
                    "exact": true
                }
            ]
        }
    ]
});


// Problem 40: Basic Mutex Usage for Synchronization
generatedTestDefinitions.set(40, {
    "name": "Basic Mutex Usage for Synchronization",
    "category": "kernel_core",
    "description": "Learn to use mutexes (mutual exclusion locks) to prevent race conditions. Understand how mutexes provide synchronized access to shared resources and fix the concurrency problems from the previous lesson.",
    "exactRequirements": {
        "functionNames": [
            "mutex_demo_init",
            "mutex_demo_exit",
            "safe_thread_function",
            "demonstrate_mutex_protection",
            "demonstrate_mutex_properties",
            "explain_mutex_best_practices"
        ],
        "variables": [
            {
                "name": "protected_counter",
                "type": "int"
            },
            {
                "name": "counter_mutex",
                "type": "struct mutex"
            }
        ],
        "outputMessages": [
            "Mutex demonstration module loaded",
            "Learning proper synchronization with mutexes",
            "=== Demonstrating Mutex Protection ===",
            "SUCCESS: Mutex prevented race condition!",
            "=== Mutex Properties ===",
            "Mutex acquired successfully",
            "=== Mutex Best Practices ===",
            "Remember: mutex_lock() -> critical section -> mutex_unlock()"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/mutex.h",
            "linux/kthread.h",
            "linux/delay.h"
        ],
        "mustContain": [
            "DEFINE_MUTEX",
            "mutex_lock",
            "mutex_unlock",
            "protected_counter++"
        ]
    },
    "testCases": [
        {
            "id": "mutex_declaration",
            "name": "Mutex Declaration",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "DEFINE_MUTEX(counter_mutex)",
                "mutex_lock(&counter_mutex)",
                "mutex_unlock(&counter_mutex)"
            ],
            "prohibitedSymbols": [
                "spinlock",
                "atomic"
            ]
        },
        {
            "id": "critical_section",
            "name": "Protected Critical Section",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "mutex_lock(&counter_mutex)",
                "protected_counter++",
                "mutex_unlock(&counter_mutex)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "synchronization_success",
            "name": "Synchronization Success",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "SUCCESS: Mutex prevented race condition!",
                    "exact": true
                },
                {
                    "pattern": "Final counter value: 2000",
                    "exact": true
                }
            ]
        },
        {
            "id": "best_practices",
            "name": "Best Practices Explanation",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "=== Mutex Best Practices ===",
                    "exact": true
                },
                {
                    "pattern": "Always unlock what you lock",
                    "exact": false
                },
                {
                    "pattern": "Keep critical sections small",
                    "exact": false
                }
            ]
        }
    ]
});


// Problem 40: Kernel Timer Implementation
generatedTestDefinitions.set(40, {
    "name": "Kernel Timer Implementation",
    "category": "kernel_core",
    "description": "Implement a kernel module that uses a timer to periodically print messages. The timer should fire every 2 seconds and print a counter value. This teaches you kernel timer management and periodic task scheduling.",
    "exactRequirements": {
        "functionNames": [
            "timer_demo_init",
            "timer_demo_exit",
            "timer_callback"
        ],
        "variables": [
            {
                "name": "my_timer",
                "type": "struct timer_list"
            },
            {
                "name": "counter",
                "type": "int"
            }
        ],
        "outputMessages": [
            "Timer demo module loaded",
            "Timer fired: count = 1",
            "Timer demo module unloaded"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/timer.h",
            "linux/jiffies.h"
        ],
        "mustContain": [
            "timer_setup",
            "mod_timer",
            "del_timer",
            "jiffies",
            "msecs_to_jiffies"
        ]
    },
    "testCases": [
        {
            "id": "required_functions",
            "name": "Required Function Names",
            "type": "symbol_check",
            "critical": true,
            "expected": [
                "timer_demo_init",
                "timer_demo_exit",
                "timer_callback"
            ]
        },
        {
            "id": "timer_variables",
            "name": "Timer Variables Declaration",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "my_timer",
                "counter",
                "timer_list"
            ],
            "prohibitedSymbols": [
                "TODO:",
                "FIXME:"
            ]
        },
        {
            "id": "timer_api_usage",
            "name": "Kernel Timer API Usage",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "timer_setup",
                "mod_timer",
                "del_timer",
                "jiffies"
            ],
            "prohibitedSymbols": [
                "sleep",
                "delay",
                "usleep"
            ]
        },
        {
            "id": "required_headers",
            "name": "Required Header Files",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "linux/timer.h",
                "linux/jiffies.h"
            ],
            "prohibitedSymbols": [
                "time.h",
                "unistd.h"
            ]
        },
        {
            "id": "module_output",
            "name": "Module Load/Unload Messages",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Timer demo module loaded",
                    "exact": true
                },
                {
                    "pattern": "Timer demo module unloaded",
                    "exact": true
                }
            ]
        },
        {
            "id": "timer_callback_output",
            "name": "Timer Callback Output",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Timer fired: count =",
                    "exact": false
                }
            ]
        }
    ]
});


// Problem 41: Device Attributes and Sysfs Integration
generatedTestDefinitions.set(41, {
    "name": "Device Attributes and Sysfs Integration",
    "category": "kernel_core",
    "description": "Extend the character device driver with sysfs attributes for configuration and status monitoring. This teaches device attribute management used extensively in production drivers at enterprise companies for device configuration and debugging.",
    "exactRequirements": {
        "functionNames": [
            "attr_dev_init",
            "attr_dev_exit",
            "debug_level_show",
            "debug_level_store",
            "read_only_show",
            "read_only_store",
            "stats_show",
            "device_name_show",
            "device_name_store"
        ],
        "variables": [
            {
                "name": "attr_dev",
                "type": "struct attr_device"
            },
            {
                "name": "attr_dev_group",
                "type": "struct attribute_group"
            }
        ],
        "outputMessages": [
            "Attribute device driver loaded successfully",
            "Device: /dev/attrdev",
            "Sysfs attributes: /sys/class/attrclass/attrdev/",
            "Attribute device driver unloaded"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/fs.h",
            "linux/device.h",
            "linux/cdev.h"
        ],
        "mustContain": [
            "DEVICE_ATTR_RW",
            "DEVICE_ATTR_RO",
            "sysfs_create_group",
            "sysfs_remove_group",
            "dev_set_drvdata",
            "dev_get_drvdata"
        ]
    },
    "testCases": [
        {
            "id": "device_attribute_macros",
            "name": "Device Attribute Macros",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "DEVICE_ATTR_RW(debug_level)",
                "DEVICE_ATTR_RW(read_only)",
                "DEVICE_ATTR_RO(stats)",
                "DEVICE_ATTR_RW(device_name)"
            ],
            "prohibitedSymbols": [
                "DEVICE_ATTR("
            ]
        },
        {
            "id": "show_store_functions",
            "name": "Show and Store Function Implementation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "sprintf(buf",
                "kstrtoint(buf, 10, &value)",
                "kstrtobool(buf, &value)",
                "strncpy(attr_dev_ptr->config.device_name"
            ],
            "prohibitedSymbols": [
                "strcpy"
            ]
        },
        {
            "id": "attribute_group_creation",
            "name": "Attribute Group Management",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "sysfs_create_group(&attr_dev.device->kobj, &attr_dev_group)",
                "sysfs_remove_group(&attr_dev.device->kobj, &attr_dev_group)"
            ],
            "prohibitedSymbols": [
                "device_create_file"
            ]
        },
        {
            "id": "driver_data_management",
            "name": "Driver Data Management",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "dev_set_drvdata(attr_dev.device, &attr_dev)",
                "dev_get_drvdata(dev)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "input_validation",
            "name": "Input Validation in Store Functions",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "if (value < 0 || value > 3)",
                "return -EINVAL",
                "if (count >= sizeof"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "thread_safety_attributes",
            "name": "Thread Safety in Attribute Access",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "mutex_lock(&attr_dev_ptr->device_mutex)",
                "mutex_unlock(&attr_dev_ptr->device_mutex)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "configuration_integration",
            "name": "Configuration Integration with Operations",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "if (dev_data->config.read_only)",
                "if (dev_data->config.debug_level >= 2)",
                "return -EPERM"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "sysfs_attributes_message",
            "name": "Sysfs Attributes Path Message",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Sysfs attributes: /sys/class/attrclass/attrdev/",
                    "exact": true
                }
            ]
        }
    ]
});


// Problem 42: Poll/Select Support and Asynchronous I/O
generatedTestDefinitions.set(42, {
    "name": "Poll/Select Support and Asynchronous I/O",
    "category": "kernel_core",
    "description": "Implement poll/select support for the character device to enable asynchronous I/O operations. This teaches advanced I/O patterns used in high-performance drivers and networking code at enterprise companies.",
    "exactRequirements": {
        "functionNames": [
            "poll_dev_init",
            "poll_dev_exit",
            "device_poll",
            "device_fasync",
            "data_generation_work",
            "data_timer_callback"
        ],
        "variables": [
            {
                "name": "poll_dev",
                "type": "struct poll_device"
            },
            {
                "name": "poll_dev_fops",
                "type": "struct file_operations"
            }
        ],
        "outputMessages": [
            "Poll device driver loaded successfully",
            "Device: /dev/polldev supports poll/select operations",
            "Poll device driver unloaded",
            "Final stats - Reads:"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/fs.h",
            "linux/wait.h",
            "linux/poll.h"
        ],
        "mustContain": [
            "poll_wait",
            "wake_up_interruptible",
            "wait_event_interruptible",
            "init_waitqueue_head",
            "fasync_helper",
            "kill_fasync",
            "EPOLLIN",
            "EPOLLOUT"
        ]
    },
    "testCases": [
        {
            "id": "poll_function_implementation",
            "name": "Poll Function Implementation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "poll_wait(file, &dev->read_wait, wait)",
                "poll_wait(file, &dev->write_wait, wait)",
                "mask |= EPOLLIN | EPOLLRDNORM",
                "mask |= EPOLLOUT | EPOLLWRNORM"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "wait_queue_management",
            "name": "Wait Queue Management",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "init_waitqueue_head(&poll_dev.read_wait)",
                "init_waitqueue_head(&poll_dev.write_wait)",
                "wake_up_interruptible(&dev->read_wait)",
                "wake_up_interruptible(&dev->write_wait)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "async_notification",
            "name": "Asynchronous Notification",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "fasync_helper(fd, file, mode, &dev->async_queue)",
                "kill_fasync(&dev->async_queue, SIGIO, POLL_IN)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "nonblocking_io",
            "name": "Non-blocking I/O Support",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "if (file->f_flags & O_NONBLOCK)",
                "return -EAGAIN",
                "wait_event_interruptible"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "file_operations_poll",
            "name": "File Operations Poll Entry",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                ".poll = device_poll",
                ".fasync = device_fasync"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "buffer_synchronization",
            "name": "Buffer Synchronization",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "spin_lock_irqsave(&dev->buffer_lock, flags)",
                "spin_unlock_irqrestore(&dev->buffer_lock, flags)",
                "spin_lock_init(&poll_dev.buffer_lock)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "timer_work_integration",
            "name": "Timer and Work Integration",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "timer_setup(&poll_dev.data_timer",
                "INIT_WORK(&poll_dev.data_work",
                "schedule_work(&dev->data_work)",
                "container_of(work, struct poll_device, data_work)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "poll_support_message",
            "name": "Poll Support Message",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Device: /dev/polldev supports poll/select operations",
                    "exact": true
                }
            ]
        }
    ]
});


// Problem 43: Memory Mapping (mmap) Implementation
generatedTestDefinitions.set(43, {
    "name": "Memory Mapping (mmap) Implementation",
    "category": "kernel_core",
    "description": "Implement memory mapping support for the character device, allowing userspace applications to directly map device memory. This teaches advanced memory management techniques critical for high-performance drivers and shared memory systems.",
    "exactRequirements": {
        "functionNames": [
            "mmap_dev_init",
            "mmap_dev_exit",
            "device_mmap",
            "mmap_vma_open",
            "mmap_vma_close",
            "mmap_vma_fault",
            "allocate_buffer_pages",
            "free_buffer_pages"
        ],
        "variables": [
            {
                "name": "mmap_dev",
                "type": "struct mmap_device"
            },
            {
                "name": "mmap_vm_ops",
                "type": "struct vm_operations_struct"
            }
        ],
        "outputMessages": [
            "Mmap device driver loaded successfully",
            "Device: /dev/mmapdev with",
            "bytes mappable memory",
            "Mmap device driver unloaded",
            "Final stats - Total mappings:"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/fs.h",
            "linux/mm.h",
            "linux/mman.h",
            "linux/vmalloc.h"
        ],
        "mustContain": [
            "alloc_page",
            "__free_page",
            "vmap",
            "vunmap",
            "get_page",
            "vm_operations_struct",
            "VM_FAULT_SIGBUS",
            "vm_fault"
        ]
    },
    "testCases": [
        {
            "id": "mmap_file_operation",
            "name": "Mmap File Operation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                ".mmap = device_mmap",
                "vm_area_struct *vma"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "vm_operations_structure",
            "name": "VM Operations Structure",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "struct vm_operations_struct mmap_vm_ops",
                ".open = mmap_vma_open",
                ".close = mmap_vma_close",
                ".fault = mmap_vma_fault"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "page_allocation",
            "name": "Page Allocation and Management",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "alloc_page(GFP_KERNEL",
                "__free_page(mmap_dev.pages[i])",
                "vmap(mmap_dev.pages",
                "vunmap(mmap_dev.kernel_buffer)"
            ],
            "prohibitedSymbols": [
                "kmalloc",
                "vmalloc"
            ]
        },
        {
            "id": "fault_handling",
            "name": "Page Fault Handling",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "vm_fault_t mmap_vma_fault",
                "get_page(page)",
                "vmf->page = page",
                "return VM_FAULT_SIGBUS"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "vma_management",
            "name": "VMA Management",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "vma->vm_flags |= VM_DONTEXPAND",
                "vma->vm_private_data = info",
                "vma->vm_ops = &mmap_vm_ops"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "mapping_validation",
            "name": "Mapping Request Validation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "if (offset + size > mmap_dev.buffer_size)",
                "return -EINVAL",
                "vma->vm_end - vma->vm_start"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "reference_counting",
            "name": "Reference Counting",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "atomic_inc(&mmap_dev.mapping_count)",
                "atomic_dec(&mmap_dev.mapping_count)",
                "get_page(page)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "mappable_memory_message",
            "name": "Mappable Memory Message",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "bytes mappable memory",
                    "exact": true
                }
            ]
        }
    ]
});


// Problem 44: Interrupt-Driven I/O and Bottom Halves
generatedTestDefinitions.set(44, {
    "name": "Interrupt-Driven I/O and Bottom Halves",
    "category": "kernel_core",
    "description": "Implement interrupt-driven I/O with proper top-half/bottom-half processing using tasklets and workqueues. This teaches critical interrupt handling patterns used in high-performance device drivers at enterprise companies.",
    "exactRequirements": {
        "functionNames": [
            "irq_dev_init",
            "irq_dev_exit",
            "irq_handler",
            "data_tasklet_handler",
            "data_work_handler",
            "irq_simulation_timer"
        ],
        "variables": [
            {
                "name": "irq_dev",
                "type": "struct irq_device"
            },
            {
                "name": "irq_dev_fops",
                "type": "struct file_operations"
            }
        ],
        "outputMessages": [
            "Interrupt-driven device loaded successfully",
            "Device: /dev/irqdev with interrupt simulation",
            "Write 'stats' to show statistics, 'reset' to reset",
            "Interrupt-driven device unloaded",
            "Final IRQ stats - Total:"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/interrupt.h",
            "linux/timer.h",
            "linux/workqueue.h"
        ],
        "mustContain": [
            "irqreturn_t",
            "IRQ_HANDLED",
            "tasklet_init",
            "tasklet_schedule",
            "create_singlethread_workqueue",
            "queue_work",
            "GFP_ATOMIC",
            "spin_lock_irqsave",
            "spin_unlock_irqrestore"
        ]
    },
    "testCases": [
        {
            "id": "interrupt_handler",
            "name": "Interrupt Handler Implementation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "irqreturn_t irq_handler",
                "return IRQ_HANDLED",
                "GFP_ATOMIC"
            ],
            "prohibitedSymbols": [
                "GFP_KERNEL",
                "msleep",
                "might_sleep"
            ]
        },
        {
            "id": "top_bottom_half",
            "name": "Top/Bottom Half Architecture",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "tasklet_schedule(&dev->data_tasklet)",
                "queue_work(dev->irq_workqueue",
                "tasklet_init(&irq_dev.data_tasklet"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "atomic_context_safety",
            "name": "Atomic Context Safety",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "spin_lock_irqsave(&dev->irq_lock, flags)",
                "spin_unlock_irqrestore(&dev->irq_lock, flags)",
                "kmalloc(sizeof(*packet), GFP_ATOMIC)"
            ],
            "prohibitedSymbols": [
                "mutex_lock",
                "might_sleep"
            ]
        },
        {
            "id": "process_context_work",
            "name": "Process Context Work",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "msleep(10)",
                "container_of(work, struct irq_device, data_work)",
                "INIT_WORK(&irq_dev.data_work"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "workqueue_management",
            "name": "Workqueue Management",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "create_singlethread_workqueue(\"irq_workqueue\")",
                "destroy_workqueue(irq_dev.irq_workqueue)",
                "flush_workqueue(irq_dev.irq_workqueue)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "tasklet_cleanup",
            "name": "Tasklet Cleanup",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "tasklet_kill(&irq_dev.data_tasklet)",
                "del_timer_sync(&irq_dev.irq_timer)"
            ],
            "prohibitedSymbols": [
                "del_timer"
            ]
        },
        {
            "id": "interrupt_context_restrictions",
            "name": "Interrupt Context Restrictions",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "// This is interrupt context - must be fast and atomic",
                "// Must use GFP_ATOMIC in IRQ context"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "interrupt_simulation_message",
            "name": "Interrupt Simulation Message",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Device: /dev/irqdev with interrupt simulation",
                    "exact": true
                }
            ]
        }
    ]
});


// Problem 44: Understanding Hardware Interrupts
generatedTestDefinitions.set(44, {
    "name": "Understanding Hardware Interrupts",
    "category": "kernel_core",
    "description": "Learn what hardware interrupts are and how they work in the kernel. Understand the difference between process context and interrupt context, and why interrupt handlers have special requirements.",
    "exactRequirements": {
        "functionNames": [
            "interrupt_concepts_init",
            "interrupt_concepts_exit",
            "simulated_interrupt_handler",
            "demonstrate_process_context",
            "demonstrate_interrupt_context_restrictions",
            "explain_interrupt_importance",
            "explain_interrupt_handling_strategy"
        ],
        "variables": [
            {
                "name": "interrupt_simulator",
                "type": "struct timer_list"
            },
            {
                "name": "interrupt_count",
                "type": "unsigned long"
            },
            {
                "name": "last_interrupt_time",
                "type": "unsigned long"
            }
        ],
        "outputMessages": [
            "Interrupt concepts module loaded",
            "Learning about hardware interrupts and contexts",
            "=== PROCESS CONTEXT DEMONSTRATION ===",
            "This code runs in PROCESS CONTEXT",
            "=== INTERRUPT CONTEXT RESTRICTIONS ===",
            "=== WHY INTERRUPTS ARE IMPORTANT ===",
            "=== INTERRUPT HANDLING STRATEGY ===",
            "Starting interrupt simulation...",
            "INTERRUPT #1: Hardware event occurred!",
            "Running in INTERRUPT CONTEXT",
            "Total simulated interrupts:",
            "Remember: Interrupt context is special!"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/timer.h",
            "linux/jiffies.h",
            "linux/interrupt.h"
        ],
        "mustContain": [
            "timer_setup",
            "mod_timer",
            "del_timer_sync",
            "jiffies",
            "msleep"
        ]
    },
    "testCases": [
        {
            "id": "timer_interrupt_simulation",
            "name": "Timer Interrupt Simulation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "timer_setup(&interrupt_simulator, simulated_interrupt_handler, 0)",
                "mod_timer(&interrupt_simulator",
                "del_timer_sync(&interrupt_simulator)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "context_demonstration",
            "name": "Context Demonstration",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "msleep(100)",
                "printk(KERN_INFO \"This code runs in PROCESS CONTEXT",
                "printk(KERN_INFO \"Running in INTERRUPT CONTEXT"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "interrupt_explanation",
            "name": "Interrupt Concept Explanation",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "=== WHY INTERRUPTS ARE IMPORTANT ===",
                    "exact": true
                },
                {
                    "pattern": "Hardware events need immediate attention",
                    "exact": false
                },
                {
                    "pattern": "=== INTERRUPT HANDLING STRATEGY ===",
                    "exact": true
                }
            ]
        },
        {
            "id": "context_restrictions",
            "name": "Context Restrictions Explanation",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "=== INTERRUPT CONTEXT RESTRICTIONS ===",
                    "exact": true
                },
                {
                    "pattern": "Interrupt handlers CANNOT:",
                    "exact": true
                },
                {
                    "pattern": "Sleep (no msleep, no mutex_lock)",
                    "exact": false
                }
            ]
        },
        {
            "id": "educational_comments",
            "name": "Educational Comments Present",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "// CONCEPT: Hardware Interrupts",
                "// Process Context vs Interrupt Context:",
                "// WHY: Hardware events need immediate attention"
            ],
            "prohibitedSymbols": []
        }
    ]
});


// Problem 45: Atomic Context Programming
generatedTestDefinitions.set(45, {
    "name": "Atomic Context Programming",
    "category": "kernel_core",
    "description": "Learn how to write code that works correctly in atomic context (interrupt handlers). Understand the restrictions, proper memory allocation flags, and safe programming practices for interrupt-safe code.",
    "exactRequirements": {
        "functionNames": [
            "atomic_context_init",
            "atomic_context_exit",
            "atomic_context_handler",
            "demonstrate_atomic_context_violations",
            "demonstrate_atomic_context_alternatives",
            "demonstrate_atomic_operations",
            "demonstrate_spinlock_usage"
        ],
        "variables": [
            {
                "name": "demo_data",
                "type": "struct atomic_data"
            },
            {
                "name": "atomic_timer",
                "type": "struct timer_list"
            },
            {
                "name": "atomic_context_calls",
                "type": "unsigned long"
            }
        ],
        "outputMessages": [
            "Atomic context programming module loaded",
            "Learning interrupt-safe programming techniques",
            "=== ATOMIC CONTEXT HANDLER #1 ===",
            "Running in atomic context - following strict rules",
            "=== ATOMIC CONTEXT VIOLATIONS (DO NOT DO THIS!) ===",
            "=== ATOMIC CONTEXT ALTERNATIVES ===",
            "=== ATOMIC OPERATIONS DEMONSTRATION ===",
            "=== SPINLOCK USAGE DEMONSTRATION ===",
            "Remember: GFP_ATOMIC, spinlocks, be fast!"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/timer.h",
            "linux/spinlock.h",
            "linux/atomic.h",
            "linux/slab.h"
        ],
        "mustContain": [
            "GFP_ATOMIC",
            "spin_lock_irqsave",
            "spin_unlock_irqrestore",
            "atomic_inc",
            "atomic_read",
            "atomic_set"
        ]
    },
    "testCases": [
        {
            "id": "atomic_memory_allocation",
            "name": "Atomic Memory Allocation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "kmalloc(64, GFP_ATOMIC)",
                "if (temp_buffer)",
                "kfree(temp_buffer)"
            ],
            "prohibitedSymbols": [
                "GFP_KERNEL",
                "msleep",
                "mutex_lock"
            ]
        },
        {
            "id": "spinlock_usage",
            "name": "Proper Spinlock Usage",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "spin_lock_irqsave(&demo_data.lock, flags)",
                "spin_unlock_irqrestore(&demo_data.lock, flags)",
                "unsigned long flags"
            ],
            "prohibitedSymbols": [
                "mutex_lock",
                "mutex_unlock"
            ]
        },
        {
            "id": "atomic_operations",
            "name": "Atomic Operations Usage",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "atomic_inc(&demo_data.counter)",
                "atomic_read(&demo_data.counter)",
                "atomic_set(&test_atomic, 100)",
                "atomic_dec(&test_atomic)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "violations_explanation",
            "name": "Violations Explanation",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "=== ATOMIC CONTEXT VIOLATIONS (DO NOT DO THIS!) ===",
                    "exact": true
                },
                {
                    "pattern": "msleep() - FORBIDDEN",
                    "exact": false
                },
                {
                    "pattern": "mutex_lock() - FORBIDDEN",
                    "exact": false
                }
            ]
        },
        {
            "id": "alternatives_explanation",
            "name": "Alternatives Explanation",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "=== ATOMIC CONTEXT ALTERNATIVES ===",
                    "exact": true
                },
                {
                    "pattern": "Instead of GFP_KERNEL -> GFP_ATOMIC",
                    "exact": true
                },
                {
                    "pattern": "Instead of mutex_lock() -> spin_lock_irqsave()",
                    "exact": true
                }
            ]
        },
        {
            "id": "educational_comments",
            "name": "Educational Comments Present",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "// CONCEPT: Atomic Context Programming",
                "// Rules for Atomic Context:",
                "// WHY: Sleeping in atomic context"
            ],
            "prohibitedSymbols": []
        }
    ]
});


// Problem 46: Device Power Management and Runtime PM
generatedTestDefinitions.set(46, {
    "name": "Device Power Management and Runtime PM",
    "category": "kernel_core",
    "description": "Implement device power management with runtime power management support, including suspend/resume operations and power state transitions. This teaches power management techniques essential for mobile and embedded device drivers.",
    "exactRequirements": {
        "functionNames": [
            "pm_dev_init",
            "pm_dev_exit",
            "pm_runtime_suspend",
            "pm_runtime_resume",
            "pm_suspend",
            "pm_resume",
            "pm_change_state",
            "pm_update_activity",
            "idle_timer_callback",
            "suspend_work_handler"
        ],
        "variables": [
            {
                "name": "pm_dev",
                "type": "struct pm_device"
            },
            {
                "name": "pm_dev_pm_ops",
                "type": "struct dev_pm_ops"
            },
            {
                "name": "pm_platform_driver",
                "type": "struct platform_driver"
            }
        ],
        "outputMessages": [
            "Power management device loaded successfully",
            "Device: /dev/pmdev with runtime PM support",
            "Auto-suspend delay:",
            "Power management device unloaded",
            "PM stats - Suspend:"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/pm.h",
            "linux/pm_runtime.h",
            "linux/platform_device.h"
        ],
        "mustContain": [
            "pm_runtime_enable",
            "pm_runtime_disable",
            "pm_runtime_get_sync",
            "pm_runtime_put",
            "pm_runtime_mark_last_busy",
            "pm_runtime_set_autosuspend_delay",
            "pm_runtime_use_autosuspend",
            "dev_pm_ops",
            "platform_driver_register",
            "platform_device_register_simple"
        ]
    },
    "testCases": [
        {
            "id": "runtime_pm_setup",
            "name": "Runtime PM Setup",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "pm_runtime_enable(&pm_dev.pdev->dev)",
                "pm_runtime_set_autosuspend_delay(&pm_dev.pdev->dev",
                "pm_runtime_use_autosuspend(&pm_dev.pdev->dev)",
                "pm_runtime_disable(&pm_dev.pdev->dev)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "pm_ops_structure",
            "name": "Power Management Operations",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "struct dev_pm_ops pm_dev_pm_ops",
                ".suspend = pm_suspend",
                ".resume = pm_resume",
                ".runtime_suspend = pm_runtime_suspend",
                ".runtime_resume = pm_runtime_resume"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "platform_device_integration",
            "name": "Platform Device Integration",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "platform_driver_register(&pm_platform_driver)",
                "platform_device_register_simple(\"pm-demo\"",
                "platform_set_drvdata(pm_dev.pdev, &pm_dev)",
                "platform_get_drvdata(pdev)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "runtime_pm_usage",
            "name": "Runtime PM Usage in Operations",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "pm_runtime_get_sync(&dev->pdev->dev)",
                "pm_runtime_put(&dev->pdev->dev)",
                "pm_runtime_mark_last_busy(&dev->pdev->dev)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "power_state_management",
            "name": "Power State Management",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "enum pm_device_state",
                "PM_STATE_ACTIVE",
                "PM_STATE_SUSPENDED",
                "pm_change_state(dev, PM_STATE_SUSPENDED)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "activity_tracking",
            "name": "Activity Tracking",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "pm_update_activity(dev)",
                "dev->stats.last_activity_jiffies = jiffies",
                "jiffies - dev->stats.last_activity_jiffies"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "auto_suspend_timer",
            "name": "Auto-suspend Timer",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "timer_setup(&pm_dev.idle_timer, idle_timer_callback",
                "mod_timer(&dev->idle_timer",
                "del_timer_sync(&pm_dev.idle_timer)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "runtime_pm_message",
            "name": "Runtime PM Support Message",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Device: /dev/pmdev with runtime PM support",
                    "exact": true
                }
            ]
        }
    ]
});


// Problem 47: Device Tree Integration and Platform Drivers
generatedTestDefinitions.set(47, {
    "name": "Device Tree Integration and Platform Drivers",
    "category": "kernel_core",
    "description": "Implement a platform driver with device tree integration, including property parsing and resource management. This teaches embedded system development techniques used in ARM-based systems and IoT devices.",
    "exactRequirements": {
        "functionNames": [
            "dt_dev_init",
            "dt_dev_exit",
            "dt_device_probe",
            "dt_device_remove",
            "parse_dt_properties",
            "setup_device_resources",
            "cleanup_device_resources"
        ],
        "variables": [
            {
                "name": "dt_device_driver",
                "type": "struct platform_driver"
            },
            {
                "name": "dt_device_of_match",
                "type": "struct of_device_id[]"
            },
            {
                "name": "dt_dev_fops",
                "type": "struct file_operations"
            }
        ],
        "outputMessages": [
            "Device tree device driver loaded successfully",
            "Waiting for device tree match...",
            "Device tree device driver unloaded"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/platform_device.h",
            "linux/of.h",
            "linux/of_device.h",
            "linux/of_platform.h"
        ],
        "mustContain": [
            "of_property_read_string",
            "of_property_read_u32",
            "of_property_read_bool",
            "platform_get_resource",
            "platform_get_irq",
            "devm_clk_get",
            "devm_reset_control_get_optional",
            "ioremap",
            "iounmap",
            "request_mem_region",
            "release_mem_region"
        ]
    },
    "testCases": [
        {
            "id": "devicetree_match_table",
            "name": "Device Tree Match Table",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "struct of_device_id dt_device_of_match",
                ".compatible = \"kernel-academy,dt-demo-device\"",
                "MODULE_DEVICE_TABLE(of, dt_device_of_match)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "devicetree_property_parsing",
            "name": "Device Tree Property Parsing",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "of_property_read_string(np, \"compatible\"",
                "of_property_read_u32(np, \"clock-frequency\"",
                "of_property_read_bool(np, \"enable-debug\")",
                "of_property_read_u32_index(np, \"reg\""
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "platform_driver_structure",
            "name": "Platform Driver Structure",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "struct platform_driver dt_device_driver",
                ".probe = dt_device_probe",
                ".remove = dt_device_remove",
                ".of_match_table = dt_device_of_match"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "resource_management",
            "name": "Platform Resource Management",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "platform_get_resource(pdev, IORESOURCE_MEM",
                "request_mem_region(dev->mem_resource->start",
                "ioremap(dev->mem_resource->start",
                "iounmap(dev->reg_base)",
                "release_mem_region(dev->mem_resource->start"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "devm_resource_usage",
            "name": "Device Managed Resource Usage",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "devm_kzalloc(&pdev->dev",
                "devm_clk_get(&pdev->dev",
                "devm_reset_control_get_optional(&pdev->dev"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "clock_reset_management",
            "name": "Clock and Reset Management",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "clk_prepare_enable(dev->device_clock)",
                "clk_disable_unprepare(dev->device_clock)",
                "reset_control_deassert(dev->reset_control)",
                "reset_control_assert(dev->reset_control)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "probe_defer_handling",
            "name": "Probe Defer Handling",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "if (PTR_ERR(dev->device_clock) == -EPROBE_DEFER)",
                "return -EPROBE_DEFER"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "dt_match_message",
            "name": "Device Tree Match Message",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "Waiting for device tree match...",
                    "exact": true
                }
            ]
        }
    ]
});


// Problem 47: Memory Hierarchy and Cache Coherency
generatedTestDefinitions.set(47, {
    "name": "Memory Hierarchy and Cache Coherency",
    "category": "kernel_core",
    "description": "Understand the memory hierarchy from CPU caches to main memory and the cache coherency problems that arise in modern systems. Learn why special memory management is needed for hardware DMA operations.",
    "exactRequirements": {
        "functionNames": [
            "memory_hierarchy_init",
            "memory_hierarchy_exit",
            "demonstrate_cache_line_effects",
            "cache_coherency_test_thread",
            "demonstrate_cache_coherency",
            "explain_memory_barriers",
            "explain_dma_cache_problems",
            "demonstrate_cache_alignment"
        ],
        "variables": [
            {
                "name": "shared_data",
                "type": "struct cache_test_data *"
            },
            {
                "name": "test_counter",
                "type": "atomic_t"
            },
            {
                "name": "test_running",
                "type": "volatile bool"
            }
        ],
        "outputMessages": [
            "Memory hierarchy and cache coherency module loaded",
            "Learning about CPU caches and memory architecture",
            "=== CACHE LINE EFFECTS DEMONSTRATION ===",
            "Cache line size:",
            "Sequential access time:",
            "Random access time:",
            "=== CACHE COHERENCY DEMONSTRATION ===",
            "Number of CPUs:",
            "=== MEMORY BARRIERS EXPLANATION ===",
            "=== DMA AND CACHE PROBLEMS ===",
            "=== CACHE ALIGNMENT DEMONSTRATION ===",
            "Remember: Cache coherency is critical for DMA!"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/slab.h",
            "linux/smp.h",
            "linux/cache.h"
        ],
        "mustContain": [
            "L1_CACHE_BYTES",
            "smp_wmb",
            "smp_mb",
            "smp_rmb",
            "ktime_get",
            "num_online_cpus"
        ]
    },
    "testCases": [
        {
            "id": "cache_line_demonstration",
            "name": "Cache Line Effects",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "L1_CACHE_BYTES",
                "ktime_get()",
                "sequential_time",
                "random_time"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "memory_barriers",
            "name": "Memory Barriers Usage",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "smp_wmb()",
                "smp_mb()",
                "smp_rmb()"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "cache_coherency_test",
            "name": "Cache Coherency Test",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "kthread_create(cache_coherency_test_thread",
                "kthread_bind(threads[active_cpus], cpu)",
                "for_each_online_cpu(cpu)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "dma_explanation",
            "name": "DMA Cache Problems Explanation",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "=== DMA AND CACHE PROBLEMS ===",
                    "exact": true
                },
                {
                    "pattern": "Cache Coherency",
                    "exact": false
                },
                {
                    "pattern": "DMA controller accesses main memory directly",
                    "exact": false
                }
            ]
        },
        {
            "id": "cache_alignment",
            "name": "Cache Alignment Demonstration",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "=== CACHE ALIGNMENT DEMONSTRATION ===",
                    "exact": true
                },
                {
                    "pattern": "False sharing occurs",
                    "exact": false
                },
                {
                    "pattern": "Cache line size:",
                    "exact": false
                }
            ]
        }
    ]
});


// Problem 48: Introduction to DMA Concepts
generatedTestDefinitions.set(48, {
    "name": "Introduction to DMA Concepts",
    "category": "kernel_core",
    "description": "Learn the fundamental concepts of Direct Memory Access (DMA) and why it's essential for high-performance I/O operations. Understand the difference between programmed I/O and DMA, and the basic requirements for DMA-safe memory.",
    "exactRequirements": {
        "functionNames": [
            "dma_concepts_init",
            "dma_concepts_exit",
            "simulate_programmed_io",
            "dma_simulation_callback",
            "simulate_dma_transfer",
            "compare_io_methods",
            "explain_dma_requirements",
            "explain_address_types",
            "explain_dma_directions"
        ],
        "variables": [
            {
                "name": "perf_test",
                "type": "struct io_performance_test"
            },
            {
                "name": "dma_simulation_timer",
                "type": "struct timer_list"
            },
            {
                "name": "dma_transfer_complete",
                "type": "volatile bool"
            },
            {
                "name": "dma_bytes_transferred",
                "type": "size_t"
            }
        ],
        "outputMessages": [
            "DMA concepts module loaded",
            "Learning Direct Memory Access fundamentals",
            "=== PROGRAMMED I/O SIMULATION ===",
            "CPU manually transfers data byte by byte",
            "=== DMA SIMULATION ===",
            "DMA controller transfers data while CPU does other work",
            "=== I/O METHODS COMPARISON ===",
            "=== DMA REQUIREMENTS ===",
            "=== ADDRESS TYPES IN DMA ===",
            "=== DMA TRANSFER DIRECTIONS ===",
            "Remember: DMA needs special memory management!"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/slab.h",
            "linux/timer.h",
            "linux/jiffies.h"
        ],
        "mustContain": [
            "virt_to_phys",
            "timer_setup",
            "mod_timer",
            "del_timer_sync",
            "ktime_get",
            "memcpy"
        ]
    },
    "testCases": [
        {
            "id": "programmed_io_simulation",
            "name": "Programmed I/O Simulation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "ktime_get()",
                "udelay(1)",
                "perf_test.programmed_io_time",
                "for (i = 0; i < perf_test.buffer_size; i++)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "dma_simulation",
            "name": "DMA Transfer Simulation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "timer_setup(&dma_simulation_timer, dma_simulation_callback, 0)",
                "mod_timer(&dma_simulation_timer",
                "dma_transfer_complete = true",
                "memcpy(perf_test.dest_buffer"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "address_explanation",
            "name": "Address Types Explanation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "virt_to_phys(virtual_addr)",
                "Virtual address:",
                "Physical address:",
                "Bus Address (dma_addr_t)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "dma_requirements",
            "name": "DMA Requirements Explanation",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "=== DMA REQUIREMENTS ===",
                    "exact": true
                },
                {
                    "pattern": "Physically contiguous",
                    "exact": false
                },
                {
                    "pattern": "Cache coherent",
                    "exact": false
                },
                {
                    "pattern": "Properly aligned",
                    "exact": false
                }
            ]
        },
        {
            "id": "dma_directions",
            "name": "DMA Directions Explanation",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "=== DMA TRANSFER DIRECTIONS ===",
                    "exact": true
                },
                {
                    "pattern": "DMA_TO_DEVICE",
                    "exact": true
                },
                {
                    "pattern": "DMA_FROM_DEVICE",
                    "exact": true
                },
                {
                    "pattern": "DMA_BIDIRECTIONAL",
                    "exact": true
                }
            ]
        },
        {
            "id": "performance_comparison",
            "name": "Performance Comparison",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "=== I/O METHODS COMPARISON ===",
                    "exact": true
                },
                {
                    "pattern": "Programmed I/O:",
                    "exact": false
                },
                {
                    "pattern": "DMA simulation:",
                    "exact": false
                }
            ]
        }
    ]
});


// Problem 49: Memory Mapping (mmap) Implementation
generatedTestDefinitions.set(49, {
    "name": "Memory Mapping (mmap) Implementation",
    "category": "kernel_core",
    "description": "Implement memory mapping support for the character device, allowing userspace applications to directly map device memory. This teaches advanced memory management techniques critical for high-performance drivers and shared memory systems.",
    "exactRequirements": {
        "functionNames": [
            "mmap_dev_init",
            "mmap_dev_exit",
            "device_mmap",
            "mmap_vma_open",
            "mmap_vma_close",
            "mmap_vma_fault",
            "allocate_buffer_pages",
            "free_buffer_pages"
        ],
        "variables": [
            {
                "name": "mmap_dev",
                "type": "struct mmap_device"
            },
            {
                "name": "mmap_vm_ops",
                "type": "struct vm_operations_struct"
            }
        ],
        "outputMessages": [
            "Mmap device driver loaded successfully",
            "Device: /dev/mmapdev with",
            "bytes mappable memory",
            "Mmap device driver unloaded",
            "Final stats - Total mappings:"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/fs.h",
            "linux/mm.h",
            "linux/mman.h",
            "linux/vmalloc.h"
        ],
        "mustContain": [
            "alloc_page",
            "__free_page",
            "vmap",
            "vunmap",
            "get_page",
            "vm_operations_struct",
            "VM_FAULT_SIGBUS",
            "vm_fault"
        ]
    },
    "testCases": [
        {
            "id": "mmap_file_operation",
            "name": "Mmap File Operation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                ".mmap = device_mmap",
                "vm_area_struct *vma"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "vm_operations_structure",
            "name": "VM Operations Structure",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "struct vm_operations_struct mmap_vm_ops",
                ".open = mmap_vma_open",
                ".close = mmap_vma_close",
                ".fault = mmap_vma_fault"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "page_allocation",
            "name": "Page Allocation and Management",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "alloc_page(GFP_KERNEL",
                "__free_page(mmap_dev.pages[i])",
                "vmap(mmap_dev.pages",
                "vunmap(mmap_dev.kernel_buffer)"
            ],
            "prohibitedSymbols": [
                "kmalloc",
                "vmalloc"
            ]
        },
        {
            "id": "fault_handling",
            "name": "Page Fault Handling",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "vm_fault_t mmap_vma_fault",
                "get_page(page)",
                "vmf->page = page",
                "return VM_FAULT_SIGBUS"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "vma_management",
            "name": "VMA Management",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "vma->vm_flags |= VM_DONTEXPAND",
                "vma->vm_private_data = info",
                "vma->vm_ops = &mmap_vm_ops"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "mapping_validation",
            "name": "Mapping Request Validation",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "if (offset + size > mmap_dev.buffer_size)",
                "return -EINVAL",
                "vma->vm_end - vma->vm_start"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "reference_counting",
            "name": "Reference Counting",
            "type": "code_analysis",
            "critical": true,
            "expectedSymbols": [
                "atomic_inc(&mmap_dev.mapping_count)",
                "atomic_dec(&mmap_dev.mapping_count)",
                "get_page(page)"
            ],
            "prohibitedSymbols": []
        },
        {
            "id": "mappable_memory_message",
            "name": "Mappable Memory Message",
            "type": "output_match",
            "critical": true,
            "expected": [
                {
                    "pattern": "bytes mappable memory",
                    "exact": true
                }
            ]
        }
    ]
});


// Problem 50: Advanced Character Device with Hardware Emulation
generatedTestDefinitions.set(50, {
    "name": "Advanced Character Device with Hardware Emulation",
    "category": "kernel_core",
    "description": "Create a complete character device driver that handles read/write operations and test it with hardware emulation. This problem demonstrates advanced kernel_project_test capabilities including QEMU device emulation and userspace testing.",
    "exactRequirements": {
        "functionNames": [
            "mydriver_init",
            "mydriver_exit"
        ],
        "variables": [
            {
                "name": "device_number",
                "type": "dev_t"
            },
            {
                "name": "device_class",
                "type": "struct class *"
            },
            {
                "name": "device_struct",
                "type": "struct device *"
            },
            {
                "name": "device_cdev",
                "type": "struct cdev"
            }
        ],
        "outputMessages": [
            "mychardev: driver loaded",
            "mychardev: driver unloaded",
            "SUCCESS: Device opened successfully",
            "SUCCESS: Written.*bytes to device",
            "SUCCESS: Read.*bytes from device",
            "SUCCESS: Data integrity verified",
            "All device tests passed"
        ],
        "requiredIncludes": [
            "linux/module.h",
            "linux/kernel.h",
            "linux/init.h",
            "linux/fs.h",
            "linux/cdev.h",
            "linux/device.h",
            "linux/uaccess.h"
        ],
        "mustContain": [
            "alloc_chrdev_region",
            "class_create",
            "device_create",
            "cdev_init",
            "cdev_add",
            "file_operations"
        ],
        "moduleInfo": {
            "license": "GPL"
        }
    },
    "testCases": [
        {
            "id": "advanced_chardev_test",
            "name": "Advanced Character Device Test",
            "type": "kernel_project_test",
            "critical": true,
            "testScenario": {
                "qemuArgs": [
                    "-device",
                    "edu,id=test-edu-device",
                    "-netdev",
                    "user,id=net0",
                    "-device",
                    "rtl8139,netdev=net0"
                ],
                "userspaceApps": [
                    {
                        "name": "device_tester",
                        "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <fcntl.h>\\n#include <unistd.h>\\n#include <string.h>\\n\\n#define DEVICE_PATH \"/dev/mychardev\"\\n#define TEST_DATA \"Hello from userspace!\"\\n\\nint main() {\\n    int fd;\\n    char read_buffer[256] = {0};\\n    ssize_t bytes_written, bytes_read;\\n    \\n    printf(\"=== Character Device Test Started ===\\\\n\");\\n    \\n    // Test 1: Open device\\n    fd = open(DEVICE_PATH, O_RDWR);\\n    if (fd < 0) {\\n        printf(\"ERROR: Cannot open device %s\\\\n\", DEVICE_PATH);\\n        return 1;\\n    }\\n    printf(\"SUCCESS: Device opened successfully\\\\n\");\\n    \\n    // Test 2: Write data\\n    bytes_written = write(fd, TEST_DATA, strlen(TEST_DATA));\\n    if (bytes_written != strlen(TEST_DATA)) {\\n        printf(\"ERROR: Write failed (expected %zu, got %zd)\\\\n\", strlen(TEST_DATA), bytes_written);\\n        close(fd);\\n        return 1;\\n    }\\n    printf(\"SUCCESS: Written %zd bytes to device\\\\n\", bytes_written);\\n    \\n    // Test 3: Reset position and read data\\n    lseek(fd, 0, SEEK_SET);\\n    bytes_read = read(fd, read_buffer, sizeof(read_buffer) - 1);\\n    if (bytes_read <= 0) {\\n        printf(\"ERROR: Read failed\\\\n\");\\n        close(fd);\\n        return 1;\\n    }\\n    printf(\"SUCCESS: Read %zd bytes from device\\\\n\", bytes_read);\\n    printf(\"SUCCESS: Data read: %s\\\\n\", read_buffer);\\n    \\n    // Test 4: Verify data integrity\\n    if (strncmp(read_buffer, TEST_DATA, strlen(TEST_DATA)) == 0) {\\n        printf(\"SUCCESS: Data integrity verified\\\\n\");\\n    } else {\\n        printf(\"ERROR: Data corruption detected\\\\n\");\\n        close(fd);\\n        return 1;\\n    }\\n    \\n    // Test 5: Close device\\n    close(fd);\\n    printf(\"SUCCESS: Device closed successfully\\\\n\");\\n    \\n    printf(\"=== All device tests passed! ===\\\\n\");\\n    return 0;\\n}",
                        "compileFlags": [
                            "-O2"
                        ]
                    }
                ],
                "setupCommands": [
                    "echo 'Setting up hardware emulation environment'",
                    "mkdir -p /dev",
                    "echo 'Hardware devices available:'",
                    "ls -la /dev/ | head -10",
                    "echo 'PCI devices:'",
                    "ls /sys/bus/pci/devices/ 2>/dev/null || echo 'PCI subsystem not ready'"
                ],
                "testCommands": [
                    "echo 'Creating device node for mychardev...'",
                    "major=$(grep mychardev /proc/devices | cut -d' ' -f1)",
                    "if [ -z \"$major\" ]; then echo 'ERROR: mychardev not found in /proc/devices'; exit 1; fi",
                    "mknod /dev/mychardev c $major 0",
                    "chmod 666 /dev/mychardev",
                    "echo 'Device node /dev/mychardev created'",
                    "echo 'Checking device node creation'",
                    "ls -la /dev/mychardev || echo 'Device node not found'",
                    "echo 'Running comprehensive device test'",
                    "/bin/device_tester",
                    "echo 'Checking device permissions'",
                    "ls -la /dev/mychardev 2>/dev/null || echo 'Device check failed'"
                ],
                "cleanupCommands": [
                    "echo 'Cleaning up test environment'",
                    "rm -f /dev/mychardev 2>/dev/null || true"
                ],
                "expected": {
                    "exitCode": 0,
                    "dmesg": [
                        "mychardev.*driver loaded",
                        "mychardev.*device.*registered"
                    ],
                    "stdout": [
                        "SUCCESS: Device opened successfully",
                        "SUCCESS: Written.*bytes to device",
                        "SUCCESS: Read.*bytes from device",
                        "SUCCESS: Data integrity verified",
                        "All device tests passed"
                    ]
                },
                "timeout": 60
            }
        }
    ]
});


module.exports = generatedTestDefinitions;
