{
  "id": 23,
  "title": "STDF Binary Parser - Production Semiconductor Data Processing",
  "phase": "foundations",
  "difficulty": 9,
  "xp": 75,
  "description": "Master STDF (Standard Test Data Format) parsing using real production patterns. Learn header/data separation, record type dispatch, and multi-record processing exactly as used in semiconductor test systems and libstdf parsers.",
  "mainFile": "stdf_parser.c",
  "files": [
    {
      "name": "stdf_parser.h",
      "content": "#ifndef STDF_PARSER_H\n#define STDF_PARSER_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#define MAX_NAME_LEN 32\n#define MAX_RESULTS 8\n\n/* STDF Record Type Constants (like libstdf) */\n#define REC_PTR 0x15  /* Parametric Test Record */\n#define REC_MPR 0x16  /* Multiple-Result Parametric */\n\n/* STDF Header Structure (like libstdf rec_header) */\ntypedef struct {\n    uint16_t rec_length;  /* Number of bytes to follow */\n    uint8_t rec_type;     /* Record type identifier */\n    uint8_t rec_subtype;  /* Record subtype identifier */\n} stdf_header;\n\n/* Generic STDF Record (like libstdf rec_unknown) */\ntypedef struct {\n    stdf_header header;   /* Parsed header */\n    void *data;          /* Points to record payload */\n} stdf_record;\n\n/* PTR Record Structure (like libstdf rec_ptr) */\ntypedef struct {\n    uint32_t TEST_NUM;    /* Test number */\n    uint8_t HEAD_NUM;     /* Test head number */\n    uint8_t SITE_NUM;     /* Test site number */\n    uint8_t TEST_FLG;     /* Test flags */\n    uint8_t PARM_FLG;     /* Parameter flags */\n    uint32_t RESULT;      /* Test result (as integer) */\n    char TEST_TXT[MAX_NAME_LEN]; /* Test text */\n    char ALARM_ID[MAX_NAME_LEN]; /* Alarm identifier */\n} ptr_record;\n\n/* MPR Record Structure (like libstdf rec_mpr) */\ntypedef struct {\n    uint32_t TEST_NUM;    /* Test number */\n    uint8_t HEAD_NUM;     /* Test head number */\n    uint8_t SITE_NUM;     /* Test site number */\n    uint8_t TEST_FLG;     /* Test flags */\n    uint8_t PARM_FLG;     /* Parameter flags */\n    uint16_t RTN_ICNT;    /* Return result count */\n    uint32_t RTN_RSLT[MAX_RESULTS]; /* Return results array (as integers) */\n} mpr_record;\n\n/* Global variables for testing */\nextern stdf_record *parsed_record;\nextern uint8_t *test_buffer;\nextern size_t buffer_size;\n\n/* TODO: Declare your STDF parsing functions */\n/* stdf_header* parse_stdf_header(uint8_t **buffer_ptr); */\n/* uint8_t read_uint8_from_buffer(uint8_t **buffer_ptr); */\n/* uint32_t read_uint32_from_buffer(uint8_t **buffer_ptr); */\n/* uint16_t read_uint16_from_buffer(uint8_t **buffer_ptr); */\n/* char* read_string_from_buffer(uint8_t **buffer_ptr, uint8_t *out_length); */\n/* ptr_record* parse_ptr_record(uint8_t *data, uint16_t length); */\n/* mpr_record* parse_mpr_record(uint8_t *data, uint16_t length); */\n/* stdf_record* parse_stdf_record_from_buffer(uint8_t *raw_buffer); */\n/* int parse_stdf_file_buffer(uint8_t *buffer, size_t total_size); */\n/* void print_stdf_record(stdf_record *record); */\n\n#endif /* STDF_PARSER_H */",
      "readOnly": false,
      "language": "h"
    },
    {
      "name": "stdf_parser.c",
      "content": "#include \"stdf_parser.h\"\n\n/* Global variables */\nstdf_record *parsed_record = NULL;\nuint8_t *test_buffer = NULL;\nsize_t buffer_size = 0;\n\nint test_record_type = REC_PTR;\nint test_num = 1001;\nint test_result = 255;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your STDF parsing logic works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(test_record_type, int, 0644);\nMODULE_PARM_DESC(test_record_type, \"STDF record type for testing\");\nmodule_param(test_num, int, 0644);\nMODULE_PARM_DESC(test_num, \"Test number for anti-hardcoding testing\");\nmodule_param(test_result, int, 0644);\nMODULE_PARM_DESC(test_result, \"Test result for anti-hardcoding testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: How STDF parsing works in production systems */\n/* This is the EXACT technique used in libstdf and semiconductor test systems:\n *\n * STDF File Structure:\n * ┌─────────────┬─────────────┬─────────────────────────────────────┐\n * │ rec_length  │ rec_type    │        RECORD PAYLOAD DATA          │\n * │ (2 bytes)   │ (1 byte)    │     (rec_length bytes)              │\n * │             │ rec_subtype │                                     │\n * │             │ (1 byte)    │                                     │\n * └─────────────┴─────────────┴─────────────────────────────────────┘\n *               ↑ header      ↑ data points here\n *\n * Step 1: Parse 4-byte header (length, type, subtype)\n * Step 2: Point data to payload after header\n * Step 3: Dispatch based on record type (PTR vs MPR)\n * Step 4: Parse fields based on specific record format\n */\n\n/* STDF HEADER/DATA SEPARATION EXPLAINED: */\n/* This is the KEY pattern that makes STDF parsing work:\n *\n * 1. Header contains metadata (length, type)\n * 2. Data points to payload (actual record fields)\n * 3. Length tells us how many payload bytes to read\n * 4. Type tells us how to interpret the payload\n *\n * Example PTR Record:\n * Header: [0x20, 0x00, 0x15, 0x10] = length=32, type=0x15, subtype=0x10\n * Data:   [TEST_NUM][HEAD_NUM][SITE_NUM][TEST_FLG][RESULT][TEST_TXT...]\n */\n\n/* RECORD TYPE DISPATCH PATTERN: */\n/* Production STDF parsers use switch-based dispatch:\n *\n * switch (header->rec_type) {\n *     case REC_PTR: return parse_ptr_record(data, length);\n *     case REC_MPR: return parse_mpr_record(data, length);\n *     default: return parse_unknown_record(data, length);\n * }\n *\n * This allows one parser to handle 30+ different record types!\n */\n\n/* STDF DATA TYPES (like libstdf): */\n/* U1 = uint8_t   (1 byte unsigned) */\n/* U2 = uint16_t  (2 byte unsigned) */\n/* U4 = uint32_t  (4 byte unsigned) */\n/* R4 = uint32_t  (4 byte data, stored as integer for kernel compatibility) */\n/* Cn = string    (1 byte length + n bytes data) */\n\n/* TODO: Implement STDF header parsing */\nstdf_header* parse_stdf_header(uint8_t **buffer_ptr) {\n    /* TODO: Allocate memory for stdf_header using kmalloc */\n    /* TODO: Read rec_length (2 bytes) using read_uint16_from_buffer */\n    /* TODO: Read rec_type (1 byte) using read_uint8_from_buffer */\n    /* TODO: Read rec_subtype (1 byte) using read_uint8_from_buffer */\n    /* TODO: Return populated header */\n    return NULL;\n}\n\n/* TODO: Implement single byte reading */\nuint8_t read_uint8_from_buffer(uint8_t **buffer_ptr) {\n    /* TODO: Read 1 byte from buffer as uint8_t */\n    /* TODO: Cast *buffer_ptr to uint8_t* and dereference: *(*buffer_ptr) */\n    /* TODO: Advance *buffer_ptr by 1 byte: *buffer_ptr += 1 */\n    /* TODO: Return the uint8_t value */\n    return 0;\n}\n\n/* TODO: Implement 4-byte reading */\nuint32_t read_uint32_from_buffer(uint8_t **buffer_ptr) {\n    /* TODO: Read 4 bytes from buffer as uint32_t */\n    /* TODO: Cast *buffer_ptr to uint32_t* and dereference: *(uint32_t*)(*buffer_ptr) */\n    /* TODO: Advance *buffer_ptr by 4 bytes: *buffer_ptr += 4 */\n    /* TODO: Return the uint32_t value */\n    return 0;\n}\n\n/* TODO: Implement 2-byte reading */\nuint16_t read_uint16_from_buffer(uint8_t **buffer_ptr) {\n    /* TODO: Read 2 bytes from buffer as uint16_t */\n    /* TODO: Cast *buffer_ptr to uint16_t* and dereference: *(uint16_t*)(*buffer_ptr) */\n    /* TODO: Advance *buffer_ptr by 2 bytes: *buffer_ptr += 2 */\n    /* TODO: Return the uint16_t value */\n    return 0;\n}\n\n/* TODO: Implement STDF string reading (Cn type) */\nchar* read_string_from_buffer(uint8_t **buffer_ptr, uint8_t *out_length) {\n    /* TODO: Read first byte as string length using read_uint8_from_buffer */\n    /* TODO: Allocate memory for string using kmalloc(length + 1, GFP_KERNEL) */\n    /* TODO: Copy string data from buffer to allocated memory using memcpy */\n    /* TODO: Add null terminator to string */\n    /* TODO: Advance *buffer_ptr by length bytes: *buffer_ptr += length */\n    /* TODO: Store length in *out_length */\n    /* TODO: Return pointer to allocated string */\n    return NULL;\n}\n\n/* TODO: Implement PTR record parsing */\nptr_record* parse_ptr_record(uint8_t *data, uint16_t length) {\n    /* TODO: Allocate memory for ptr_record using kmalloc */\n    /* TODO: Create buffer position pointer: uint8_t *buffer_pos = data */\n    /* TODO: Parse TEST_NUM using read_uint32_from_buffer */\n    /* TODO: Parse HEAD_NUM using read_uint8_from_buffer */\n    /* TODO: Parse SITE_NUM using read_uint8_from_buffer */\n    /* TODO: Parse TEST_FLG using read_uint8_from_buffer */\n    /* TODO: Parse PARM_FLG using read_uint8_from_buffer */\n    /* TODO: Parse RESULT using read_uint32_from_buffer */\n    /* TODO: Parse TEST_TXT using read_string_from_buffer */\n    /* TODO: Copy string to record->TEST_TXT (max MAX_NAME_LEN-1 chars) */\n    /* TODO: Free temporary string */\n    /* TODO: Parse ALARM_ID using read_string_from_buffer */\n    /* TODO: Copy string to record->ALARM_ID (max MAX_NAME_LEN-1 chars) */\n    /* TODO: Free temporary string */\n    /* TODO: Return populated ptr_record */\n    return NULL;\n}\n\n/* TODO: Implement MPR record parsing */\nmpr_record* parse_mpr_record(uint8_t *data, uint16_t length) {\n    /* TODO: Allocate memory for mpr_record using kmalloc */\n    /* TODO: Create buffer position pointer: uint8_t *buffer_pos = data */\n    /* TODO: Parse TEST_NUM using read_uint32_from_buffer */\n    /* TODO: Parse HEAD_NUM using read_uint8_from_buffer */\n    /* TODO: Parse SITE_NUM using read_uint8_from_buffer */\n    /* TODO: Parse TEST_FLG using read_uint8_from_buffer */\n    /* TODO: Parse PARM_FLG using read_uint8_from_buffer */\n    /* TODO: Parse RTN_ICNT using read_uint16_from_buffer */\n    /* TODO: Loop through RTN_ICNT results, parsing each with read_uint32_from_buffer */\n    /* TODO: Store results in RTN_RSLT array (max MAX_RESULTS) */\n    /* TODO: Return populated mpr_record */\n    return NULL;\n}\n\n/* TODO: Implement main STDF record parser with dispatch */\nstdf_record* parse_stdf_record_from_buffer(uint8_t *raw_buffer) {\n    /* TODO: Allocate memory for stdf_record using kmalloc */\n    /* TODO: Create buffer position pointer: uint8_t *buffer_pos = raw_buffer */\n    /* TODO: Parse header using parse_stdf_header(&buffer_pos) */\n    /* TODO: Copy header to record->header */\n    /* TODO: Set record->data to point to buffer_pos (payload after header) */\n    /* TODO: Dispatch based on record type using switch statement: */\n    /* TODO:   case REC_PTR: parse PTR record from record->data */\n    /* TODO:   case REC_MPR: parse MPR record from record->data */\n    /* TODO:   default: handle unknown record type */\n    /* TODO: Return populated stdf_record */\n    return NULL;\n}\n\nvoid print_stdf_record(stdf_record *record) {\n    if (!record) {\n        printk(KERN_ERR \"No STDF record to print\\n\");\n        return;\n    }\n    \n    printk(KERN_INFO \"STDF Record Header:\\n\");\n    printk(KERN_INFO \"Record Length: %u\\n\", record->header.rec_length);\n    printk(KERN_INFO \"Record Type: 0x%02x\\n\", record->header.rec_type);\n    printk(KERN_INFO \"Record Subtype: 0x%02x\\n\", record->header.rec_subtype);\n    \n    switch (record->header.rec_type) {\n        case REC_PTR: {\n            ptr_record *ptr = (ptr_record*)record->data;\n            if (ptr) {\n                printk(KERN_INFO \"PTR Record Fields:\\n\");\n                printk(KERN_INFO \"TEST_NUM: %u\\n\", ptr->TEST_NUM);\n                printk(KERN_INFO \"HEAD_NUM: %u\\n\", ptr->HEAD_NUM);\n                printk(KERN_INFO \"SITE_NUM: %u\\n\", ptr->SITE_NUM);\n                printk(KERN_INFO \"TEST_FLG: 0x%02x\\n\", ptr->TEST_FLG);\n                printk(KERN_INFO \"RESULT: %u\\n\", ptr->RESULT);\n                printk(KERN_INFO \"TEST_TXT: %s\\n\", ptr->TEST_TXT);\n            }\n            break;\n        }\n        case REC_MPR: {\n            mpr_record *mpr = (mpr_record*)record->data;\n            if (mpr) {\n                printk(KERN_INFO \"MPR Record Fields:\\n\");\n                printk(KERN_INFO \"TEST_NUM: %u\\n\", mpr->TEST_NUM);\n                printk(KERN_INFO \"HEAD_NUM: %u\\n\", mpr->HEAD_NUM);\n                printk(KERN_INFO \"SITE_NUM: %u\\n\", mpr->SITE_NUM);\n                printk(KERN_INFO \"RTN_ICNT: %u\\n\", mpr->RTN_ICNT);\n                for (int i = 0; i < mpr->RTN_ICNT && i < MAX_RESULTS; i++) {\n                    printk(KERN_INFO \"RTN_RSLT[%d]: %u\\n\", i, mpr->RTN_RSLT[i]);\n                }\n            }\n            break;\n        }\n        default:\n            printk(KERN_INFO \"Unknown record type: 0x%02x\\n\", record->header.rec_type);\n            break;\n    }\n}\n\n/* REAL STDF FILE BUFFER: Authentic multi-record STDF data like production .stdf files */\n/* This is EXACTLY what you'd find in a real semiconductor test file! */\n/* Students must parse multiple records sequentially like libstdf does */\n\n/* \n * PRODUCTION STDF FILE STRUCTURE:\n * Real STDF files contain multiple consecutive records that must be parsed sequentially.\n * This buffer simulates a section of a real .stdf file with multiple record types.\n * \n * Layout: [PTR Record][MPR Record][PTR Record] = 89 bytes total\n * This teaches the EXACT pattern used in production semiconductor test systems!\n */\nstatic uint8_t real_stdf_file_buffer[] = {\n    /* ============ RECORD 1: PTR (Parametric Test Record) - 30 bytes ============ */\n    /* STDF Header (4 bytes) */\n    0x1A, 0x00,           /* REC_LEN = 26 bytes payload (little-endian) */\n    0x15,                 /* REC_TYP = 21 (PTR record type) */\n    0x10,                 /* REC_SUB = 16 (PTR subtype) */\n\n    /* PTR Record Payload (26 bytes) - Real STDF field layout */\n    0xE9, 0x03, 0x00, 0x00,  /* TEST_NUM = 1001 (U4, little-endian) */\n    0x01,                     /* HEAD_NUM = 1 (U1) */\n    0x01,                     /* SITE_NUM = 1 (U1) */\n    0x00,                     /* TEST_FLG = 0 (B1) - No test flags set */\n    0x00,                     /* PARM_FLG = 0 (B1) - No optional parameters */\n    0xFF, 0x00, 0x00, 0x00,  /* RESULT = 255 (U4, stored as integer for kernel) */\n\n    /* TEST_TXT field (Cn = length + string) - Real STDF Cn format */\n    0x0C,                     /* String length = 12 */\n    'V', 'o', 'l', 't', 'a', 'g', 'e', '_', 'T', 'e', 's', 't',  /* \"Voltage_Test\" */\n\n    /* ALARM_ID field (Cn format) - Empty in this test */\n    0x00,                     /* String length = 0 (no alarm) */\n\n    /* ============ RECORD 2: MPR (Multiple-Result Parametric) - 26 bytes ============ */\n    /* STDF Header (4 bytes) */\n    0x16, 0x00,           /* REC_LEN = 22 bytes payload (little-endian) */\n    0x16,                 /* REC_TYP = 22 (MPR record type) */\n    0x10,                 /* REC_SUB = 16 (MPR subtype) */\n\n    /* MPR Record Payload (22 bytes) - Real STDF field layout */\n    0xEA, 0x03, 0x00, 0x00,  /* TEST_NUM = 1002 (U4, little-endian) */\n    0x01,                     /* HEAD_NUM = 1 (U1) */\n    0x01,                     /* SITE_NUM = 1 (U1) */\n    0x00,                     /* TEST_FLG = 0 (B1) */\n    0x00,                     /* PARM_FLG = 0 (B1) */\n    0x03, 0x00,              /* RTN_ICNT = 3 (U2, little-endian) - 3 results */\n\n    /* RTN_RSLT array (3 results, each U4) */\n    0x64, 0x00, 0x00, 0x00,  /* RTN_RSLT[0] = 100 (U4) */\n    0x65, 0x00, 0x00, 0x00,  /* RTN_RSLT[1] = 101 (U4) */\n    0x66, 0x00, 0x00, 0x00,  /* RTN_RSLT[2] = 102 (U4) */\n\n    /* ============ RECORD 3: Another PTR (Parametric Test Record) - 31 bytes ============ */\n    /* STDF Header (4 bytes) */\n    0x1B, 0x00,           /* REC_LEN = 27 bytes payload (little-endian) */\n    0x15,                 /* REC_TYP = 21 (PTR record type) */\n    0x10,                 /* REC_SUB = 16 (PTR subtype) */\n\n    /* PTR Record Payload (27 bytes) - Real STDF field layout */\n    0xEB, 0x03, 0x00, 0x00,  /* TEST_NUM = 1003 (U4, little-endian) */\n    0x01,                     /* HEAD_NUM = 1 (U1) */\n    0x01,                     /* SITE_NUM = 1 (U1) */\n    0x00,                     /* TEST_FLG = 0 (B1) - No test flags set */\n    0x00,                     /* PARM_FLG = 0 (B1) - No optional parameters */\n    0x00, 0x01, 0x00, 0x00,  /* RESULT = 256 (U4, stored as integer for kernel) */\n\n    /* TEST_TXT field (Cn = length + string) - Real STDF Cn format */\n    0x0D,                     /* String length = 13 */\n    'C', 'u', 'r', 'r', 'e', 'n', 't', '_', 'T', 'e', 's', 't', '2',  /* \"Current_Test2\" */\n\n    /* ALARM_ID field (Cn format) - Empty in this test */\n    0x00,                     /* String length = 0 (no alarm) */\n\n    /* End of multi-record STDF buffer - total 89 bytes (30+26+31) */\n    /* This simulates real .stdf file content that needs sequential processing! */\n};\n\n/* TODO: Implement PRODUCTION STDF multi-record parser */\n/* This is the CORE function that students must implement - it teaches the */\n/* EXACT same pattern used in real libstdf and semiconductor test systems! */\nint parse_stdf_file_buffer(uint8_t *buffer, size_t total_size) {\n    /* TODO: Initialize variables for multi-record processing */\n    /* TODO: uint8_t *current_pos = buffer; */\n    /* TODO: uint8_t *buffer_end = buffer + total_size; */\n    /* TODO: int record_count = 0; */\n    \n    /* TODO: Implement PRODUCTION LIBSTDF PATTERN: */\n    /* TODO: while (current_pos < buffer_end) { */\n    /* TODO:     // Parse one record from current position */\n    /* TODO:     stdf_record *record = parse_stdf_record_from_buffer(current_pos); */\n    /* TODO:     if (!record) break; */\n    /* TODO:     */\n    /* TODO:     // Print the parsed record */\n    /* TODO:     print_stdf_record(record); */\n    /* TODO:     */\n    /* TODO:     // CRITICAL: Advance to next record (like libstdf does) */\n    /* TODO:     current_pos += 4 + record->header.rec_length; */\n    /* TODO:     record_count++; */\n    /* TODO:     */\n    /* TODO:     // Clean up current record memory */\n    /* TODO:     if (record->data) kfree(record->data); */\n    /* TODO:     kfree(record); */\n    /* TODO: } */\n    \n    /* TODO: Return total number of records processed */\n    /* TODO: return record_count; */\n    return 0;\n}\n\n/* Helper function to create real STDF multi-record buffer for testing */\nstatic uint8_t* get_real_stdf_file_buffer(uint32_t test_num, uint32_t result) {\n    uint8_t *pos;\n    \n    /* Use the complete multi-record STDF buffer */\n    buffer_size = sizeof(real_stdf_file_buffer);\n    test_buffer = kmalloc(buffer_size, GFP_KERNEL);\n    if (!test_buffer) {\n        return NULL;\n    }\n    \n    /* Copy the entire multi-record STDF file buffer */\n    memcpy(test_buffer, real_stdf_file_buffer, buffer_size);\n    \n    /* Update dynamic test values in FIRST PTR record (for validation) */\n    pos = test_buffer + 4;  /* Skip header to first PTR payload */\n    *(uint32_t*)pos = test_num;     /* Update TEST_NUM field */\n    pos += 4 + 1 + 1 + 1 + 1;      /* Skip to RESULT field */\n    *(uint32_t*)pos = result;       /* Update RESULT field */\n    \n    return test_buffer;\n}\n\nstatic int __init stdf_parser_init(void)\n{\n    int record_count;\n    \n    printk(KERN_INFO \"STDF parser module loaded\\n\");\n    \n    /* Get real STDF multi-record buffer with dynamic parameter values */\n    if (!get_real_stdf_file_buffer(test_num, (uint32_t)test_result)) {\n        printk(KERN_ERR \"Failed to create STDF test buffer\\n\");\n        return -ENOMEM;\n    }\n    \n    printk(KERN_INFO \"Created STDF buffer: type=0x%02x, test_num=%d, result=%d\\n\", \n           test_record_type, test_num, test_result);\n    \n    /* PRODUCTION LIBSTDF PATTERN: Parse multiple records sequentially */\n    /* This is EXACTLY how real semiconductor test systems process STDF files! */\n    record_count = parse_stdf_file_buffer(test_buffer, buffer_size);\n    \n    printk(KERN_INFO \"STDF file processing complete: %d records parsed\\n\", record_count);\n    \n    return 0;\n}\n\nstatic void __exit stdf_parser_exit(void)\n{\n    printk(KERN_INFO \"STDF parser module unloaded\\n\");\n    \n    /* Clean up allocated memory */\n    if (parsed_record) {\n        if (parsed_record->data) {\n            kfree(parsed_record->data);\n        }\n        kfree(parsed_record);\n        parsed_record = NULL;\n    }\n    \n    if (test_buffer) {\n        kfree(test_buffer);\n        test_buffer = NULL;\n    }\n}\n\nmodule_init(stdf_parser_init);\nmodule_exit(stdf_parser_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning STDF parsing with production header/data separation and record dispatch\");\nMODULE_VERSION(\"1.0\");",
      "readOnly": false,
      "language": "c"
    },
    {
      "name": "Makefile",
      "content": "# STDF parser module Makefile\nobj-m += stdf_parser.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
      "readOnly": true,
      "language": "makefile"
    }
  ],
  "concepts": [
    "STDF header/data separation",
    "record type dispatch",
    "multi-record parsing",
    "production STDF patterns",
    "semiconductor data processing",
    "libstdf architecture"
  ],
  "skills": [
    "Parsing STDF headers with length/type/subtype",
    "Implementing record type dispatch",
    "Handling multiple record formats",
    "Using production STDF field names",
    "Understanding header/data separation",
    "Building real semiconductor parsers"
  ],
  "validation": {
    "exactRequirements": {
      "functionNames": [
        "stdf_parser_init",
        "stdf_parser_exit",
        "parse_stdf_header",
        "read_uint8_from_buffer",
        "read_uint32_from_buffer",
        "read_uint16_from_buffer",
        "read_string_from_buffer",
        "parse_ptr_record",
        "parse_mpr_record",
        "parse_stdf_record_from_buffer",
        "parse_stdf_file_buffer",
        "print_stdf_record"
      ],
      "function_declarations": [
        {
          "name": "parse_stdf_header",
          "returnType": "stdf_header*",
          "parameters": [
            "uint8_t **buffer_ptr"
          ]
        },
        {
          "name": "read_uint8_from_buffer",
          "returnType": "uint8_t",
          "parameters": [
            "uint8_t **buffer_ptr"
          ]
        },
        {
          "name": "read_uint32_from_buffer",
          "returnType": "uint32_t",
          "parameters": [
            "uint8_t **buffer_ptr"
          ]
        },
        {
          "name": "read_uint16_from_buffer",
          "returnType": "uint16_t",
          "parameters": [
            "uint8_t **buffer_ptr"
          ]
        },
        {
          "name": "read_string_from_buffer",
          "returnType": "char*",
          "parameters": [
            "uint8_t **buffer_ptr",
            "uint8_t *out_length"
          ]
        },
        {
          "name": "parse_ptr_record",
          "returnType": "ptr_record*",
          "parameters": [
            "uint8_t *data",
            "uint16_t length"
          ]
        },
        {
          "name": "parse_mpr_record",
          "returnType": "mpr_record*",
          "parameters": [
            "uint8_t *data",
            "uint16_t length"
          ]
        },
        {
          "name": "parse_stdf_record_from_buffer",
          "returnType": "stdf_record*",
          "parameters": [
            "uint8_t *raw_buffer"
          ]
        },
        {
          "name": "parse_stdf_file_buffer",
          "returnType": "int",
          "parameters": [
            "uint8_t *buffer",
            "size_t total_size"
          ]
        },
        {
          "name": "print_stdf_record",
          "returnType": "void",
          "parameters": [
            "stdf_record *record"
          ]
        }
      ],
      "variables_declarations": [
        {
          "name": "stdf_header",
          "type": "typedef struct",
          "value": "{uint16_t rec_length; uint8_t rec_type; uint8_t rec_subtype;}",
          "storageClass": "none"
        },
        {
          "name": "stdf_record",
          "type": "typedef struct",
          "value": "{stdf_header header; void *data;}",
          "storageClass": "none"
        },
        {
          "name": "ptr_record",
          "type": "typedef struct",
          "value": "{uint32_t TEST_NUM; uint8_t HEAD_NUM; uint8_t SITE_NUM; uint8_t TEST_FLG; uint8_t PARM_FLG; uint32_t RESULT; char TEST_TXT[MAX_NAME_LEN]; char ALARM_ID[MAX_NAME_LEN];}",
          "storageClass": "none"
        },
        {
          "name": "mpr_record",
          "type": "typedef struct",
          "value": "{uint32_t TEST_NUM; uint8_t HEAD_NUM; uint8_t SITE_NUM; uint8_t TEST_FLG; uint8_t PARM_FLG; uint16_t RTN_ICNT; uint32_t RTN_RSLT[MAX_RESULTS];}",
          "storageClass": "none"
        },
        {
          "name": "parsed_record",
          "type": "stdf_record *",
          "storageClass": "extern"
        },
        {
          "name": "test_buffer",
          "type": "uint8_t *",
          "storageClass": "extern"
        }
      ],
      "variables": [
        {
          "name": "parsed_record",
          "type": "stdf_record *",
          "value": "NULL",
          "storageClass": "none"
        },
        {
          "name": "test_buffer",
          "type": "uint8_t *",
          "value": "NULL",
          "storageClass": "none"
        }
      ],
      "outputMessages": [
        "STDF parser module loaded",
        "Created STDF buffer: type=0x15, test_num=1001, result=255",
        "STDF Record Header:",
        "Record Length: 26",
        "Record Type: 0x15",
        "Record Subtype: 0x10",
        "PTR Record Fields:",
        "TEST_NUM: 1001",
        "HEAD_NUM: 1",
        "SITE_NUM: 1",
        "TEST_FLG: 0x00",
        "RESULT: 255",
        "TEST_TXT: Voltage_Test",
        "STDF Record Header:",
        "Record Length: 22",
        "Record Type: 0x16",
        "Record Subtype: 0x10",
        "MPR Record Fields:",
        "TEST_NUM: 1002",
        "HEAD_NUM: 1",
        "SITE_NUM: 1",
        "RTN_ICNT: 3",
        "RTN_RSLT[0]: 100",
        "RTN_RSLT[1]: 101",
        "RTN_RSLT[2]: 102",
        "STDF Record Header:",
        "Record Length: 27",
        "Record Type: 0x15",
        "Record Subtype: 0x10",
        "PTR Record Fields:",
        "TEST_NUM: 1003",
        "HEAD_NUM: 1",
        "SITE_NUM: 1",
        "TEST_FLG: 0x00",
        "RESULT: 256",
        "TEST_TXT: Current_Test2",
        "STDF file processing complete: 3 records parsed",
        "STDF parser module unloaded"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/types.h",
        "linux/slab.h",
        "linux/string.h"
      ],
      "mustContain": [
        "parse_stdf_header(&buffer_pos)",
        "read_uint8_from_buffer(&buffer_pos)",
        "*(uint32_t*)(*buffer_ptr)",
        "*buffer_ptr += 4",
        "*(uint16_t*)(*buffer_ptr)",
        "*buffer_ptr += 2",
        "switch (record->header.rec_type)",
        "case REC_PTR:",
        "case REC_MPR:",
        "record->data",
        "kmalloc",
        "kfree",
        "while (current_pos < buffer_end)",
        "current_pos += 4 + record->header.rec_length",
        "parse_stdf_file_buffer(test_buffer, buffer_size)",
        "module_param(test_record_type, int, 0644)",
        "module_param(test_num, int, 0644)",
        "module_param(test_result, int, 0644)"
      ],
      "moduleInfo": {
        "license": "GPL"
      }
    },
    "testCases": [
      {
        "id": "function_declarations",
        "name": "Function Declarations in Header",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "stdf_header* parse_stdf_header(uint8_t **buffer_ptr)",
          "uint8_t read_uint8_from_buffer(uint8_t **buffer_ptr)",
          "uint32_t read_uint32_from_buffer(uint8_t **buffer_ptr)",
          "uint16_t read_uint16_from_buffer(uint8_t **buffer_ptr)",
          "char* read_string_from_buffer(uint8_t **buffer_ptr, uint8_t *out_length)",
          "ptr_record* parse_ptr_record(uint8_t *data, uint16_t length)",
          "mpr_record* parse_mpr_record(uint8_t *data, uint16_t length)",
          "stdf_record* parse_stdf_record_from_buffer(uint8_t *raw_buffer)",
          "int parse_stdf_file_buffer(uint8_t *buffer, size_t total_size)",
          "void print_stdf_record(stdf_record *record)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "function_signatures_source",
        "name": "Function Signatures in Source File",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "stdf_header* parse_stdf_header(uint8_t **buffer_ptr)",
          "uint8_t read_uint8_from_buffer(uint8_t **buffer_ptr)",
          "uint32_t read_uint32_from_buffer(uint8_t **buffer_ptr)",
          "uint16_t read_uint16_from_buffer(uint8_t **buffer_ptr)",
          "char* read_string_from_buffer(uint8_t **buffer_ptr, uint8_t *out_length)",
          "ptr_record* parse_ptr_record(uint8_t *data, uint16_t length)",
          "mpr_record* parse_mpr_record(uint8_t *data, uint16_t length)",
          "stdf_record* parse_stdf_record_from_buffer(uint8_t *raw_buffer)",
          "int parse_stdf_file_buffer(uint8_t *buffer, size_t total_size)",
          "void print_stdf_record(stdf_record *record)",
          "static int __init stdf_parser_init(void)",
          "static void __exit stdf_parser_exit(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "exact_output",
        "name": "Exact Output Messages",
        "type": "output_match",
        "critical": true,
        "expected": [
          {
            "pattern": "STDF parser module loaded",
            "exact": true,
            "linkedFunction": "static int __init stdf_parser_init(void)"
          },
          {
            "pattern": "Created STDF buffer: type=0x15, test_num=1001, result=255",
            "exact": true,
            "linkedFunction": "static int __init stdf_parser_init(void)"
          },
          {
            "pattern": "STDF Record Header:",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "Record Length: 26",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "Record Type: 0x15",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "Record Subtype: 0x10",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "PTR Record Fields:",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "TEST_NUM: 1001",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "HEAD_NUM: 1",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "SITE_NUM: 1",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "TEST_FLG: 0x00",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "RESULT: 255",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "TEST_TXT: Voltage_Test",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "STDF Record Header:",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "Record Length: 22",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "Record Type: 0x16",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "Record Subtype: 0x10",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "MPR Record Fields:",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "TEST_NUM: 1002",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "HEAD_NUM: 1",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "SITE_NUM: 1",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "RTN_ICNT: 3",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "RTN_RSLT[0]: 100",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "RTN_RSLT[1]: 101",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "RTN_RSLT[2]: 102",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "STDF Record Header:",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "Record Length: 27",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "Record Type: 0x15",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "Record Subtype: 0x10",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "PTR Record Fields:",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "TEST_NUM: 1003",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "HEAD_NUM: 1",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "SITE_NUM: 1",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "TEST_FLG: 0x00",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "RESULT: 256",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "TEST_TXT: Current_Test2",
            "exact": true,
            "linkedFunction": "void print_stdf_record(stdf_record *record)"
          },
          {
            "pattern": "STDF file processing complete: 3 records parsed",
            "exact": true,
            "linkedFunction": "static int __init stdf_parser_init(void)"
          },
          {
            "pattern": "STDF parser module unloaded",
            "exact": true,
            "linkedFunction": "static void __exit stdf_parser_exit(void)"
          }
        ]
      },
      {
        "id": "advanced_stdf_parsing_validation",
        "name": "Advanced STDF Parsing with Anti-Hardcoding Protection",
        "type": "kernel_project_test",
        "critical": true,
        "testScenario": {
          "userspaceApps": [
            {
              "name": "stdf_parsing_dynamic_tester",
              "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Anti-Hardcoding STDF Parsing Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate unpredictable test values\\n    int random_record_type = (rand() % 2) ? 0x15 : 0x16;  // PTR or MPR\\n    int random_test_num = (rand() % 9000) + 1000;         // 1000-9999\\n    int random_result = (rand() % 500) + 100;             // 100-599\\n    \\n    printf(\\\"Test 1: Random STDF parsing (type=0x%02x, test_num=%d, result=%d)\\\\n\\\", random_record_type, random_test_num, random_result);\\n    \\n    // Test with random values\\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod stdf_parser 2>/dev/null\\\");\\n    \\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/stdf_parser.ko test_record_type=%d test_num=%d test_result=%d\\\", random_record_type, random_test_num, random_result);\\n    printf(\\\"DEBUG: Command: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Anti-hardcoding STDF parsing test completed\\\\n\\\");\\n    return 0;\\n}"
            }
          ],
          "setupCommands": [
            "echo 'Starting advanced STDF parsing implementation validation'"
          ],
          "testCommands": [
            "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
            "echo 'Creating minimal kernel header stubs for TCC...'",
            "mkdir -p /tmp/linux",
            "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
            "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
            "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
            "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
            "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
            "echo '#define module_init(x)' >> /tmp/linux/module.h",
            "echo '#define module_exit(x)' >> /tmp/linux/module.h",
            "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
            "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
            "echo '#define __init' > /tmp/linux/init.h",
            "echo '#define __exit' >> /tmp/linux/init.h",
            "echo 'typedef unsigned char uint8_t;' > /tmp/linux/types.h",
            "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
            "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
            "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
            "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
            "echo '#define MAX_RESULTS 8' >> /tmp/linux/types.h",
            "echo '#define REC_PTR 0x15' >> /tmp/linux/types.h",
            "echo '#define REC_MPR 0x16' >> /tmp/linux/types.h",
            "echo 'void* kmalloc(size_t size, int flags);' > /tmp/linux/slab.h",
            "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
            "echo '#define GFP_KERNEL 0' >> /tmp/linux/slab.h",
            "echo 'void* memcpy(void *dest, const void *src, size_t n);' >> /tmp/linux/slab.h",
            "echo 'size_t strlen(const char *s);' >> /tmp/linux/slab.h",
            "echo 'void* memcpy(void *dest, const void *src, size_t n);' > /tmp/linux/string.h",
            "echo 'size_t strlen(const char *s);' >> /tmp/linux/string.h",
            "echo 'char* strcpy(char *dest, const char *src);' >> /tmp/linux/string.h",
            "echo 'Creating test file that includes STDF parsing header...'",
            "echo '#include \"/lib/modules/stdf_parser.h\"' > /tmp/test.c",
            "echo 'int main() { uint8_t *buf; uint8_t len; size_t size = 89; parsed_record = (stdf_record*)0; parse_stdf_header(&buf); read_uint8_from_buffer(&buf); read_uint32_from_buffer(&buf); read_uint16_from_buffer(&buf); read_string_from_buffer(&buf, &len); parse_ptr_record(buf, 26); parse_mpr_record(buf, 22); parse_stdf_record_from_buffer(buf); parse_stdf_file_buffer(buf, size); print_stdf_record((stdf_record*)0); return 0; }' >> /tmp/test.c",
            "echo 'Running TCC validation...'",
            "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
            "TCC_EXIT_CODE=$?",
            "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
            "echo 'Phase 2: Anti-Hardcoding Dynamic STDF Parsing Test'",
            "/bin/stdf_parsing_dynamic_tester > /tmp/test_output.log",
            "cat /tmp/test_output.log",
            "echo 'Phase 3: Random Value Extraction and Validation'",
            "echo 'Adding delay to ensure dmesg messages are written...'",
            "sleep 1",
            "echo 'Extracting random test values from output...'",
            "RECORD_TYPE=$(grep -o 'Random STDF parsing (type=0x[0-9a-f]*' /tmp/test_output.log | cut -d'=' -f2)",
            "TEST_NUM=$(grep -o 'test_num=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
            "RESULT=$(grep -o 'result=[0-9]*)' /tmp/test_output.log | cut -d'=' -f2 | cut -d')' -f1)",
            "echo 'Extracted values: RECORD_TYPE='$RECORD_TYPE', TEST_NUM='$TEST_NUM', RESULT='$RESULT",
            "if [ -z \"$RECORD_TYPE\" ] || [ -z \"$TEST_NUM\" ] || [ -z \"$RESULT\" ]; then echo 'FAIL: Could not extract random test values'; else echo 'PASS: Random values extracted successfully'; fi",
            "echo 'Phase 4: Anti-Hardcoding Validation with Random Values'",
            "echo 'Validating STDF record type parsing with random value '$RECORD_TYPE",
            "dmesg | grep \"Record Type: $RECORD_TYPE\" && echo 'PASS: STDF record type parsing with random value working' || echo 'FAIL: STDF record type parsing with random value broken'",
            "echo 'Validating TEST_NUM parsing with random value '$TEST_NUM",
            "dmesg | grep \"TEST_NUM: $TEST_NUM\" && echo 'PASS: TEST_NUM parsing with random value working' || echo 'FAIL: TEST_NUM parsing with random value broken'",
            "echo 'Validating RESULT parsing with random value '$RESULT",
            "dmesg | grep \"RESULT: $RESULT\" && echo 'PASS: RESULT parsing with random value working' || echo 'FAIL: RESULT parsing with random value broken'",
            "echo 'Phase 5: Static Field Validation (Non-Randomized Fields)'",
            "dmesg | grep 'STDF Record Header:' && echo 'PASS: STDF header parsing working' || echo 'FAIL: STDF header parsing broken'",
            "dmesg | grep 'HEAD_NUM: 1' && echo 'PASS: HEAD_NUM parsing working' || echo 'FAIL: HEAD_NUM parsing broken'",
            "dmesg | grep 'SITE_NUM: 1' && echo 'PASS: SITE_NUM parsing working' || echo 'FAIL: SITE_NUM parsing broken'",
            "echo 'Phase 6: STDF Architecture Validation'",
            "dmesg | grep 'PTR Record Fields:' && echo 'PASS: PTR record dispatch working' || echo 'FAIL: PTR record dispatch broken'",
            "dmesg | grep 'MPR Record Fields:' && echo 'PASS: MPR record dispatch working' || echo 'FAIL: MPR record dispatch broken'",
            "dmesg | grep 'RTN_ICNT: 3' && echo 'PASS: MPR array count parsing working' || echo 'FAIL: MPR array count parsing broken'",
            "dmesg | grep 'RTN_RSLT\\[0\\]: 100' && echo 'PASS: MPR array element parsing working' || echo 'FAIL: MPR array element parsing broken'",
            "dmesg | grep 'STDF file processing complete: 3 records parsed' && echo 'PASS: Multi-record processing working' || echo 'FAIL: Multi-record processing broken'",
            "dmesg | grep 'STDF parser module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
            "dmesg | grep 'STDF parser module unloaded' && echo 'PASS: Module cleanup working' || echo 'FAIL: Module cleanup broken'",
            "echo 'Phase 7: Final Validation Summary'",
            "echo 'All phases completed successfully - anti-hardcoding STDF parsing protection verified'",
            "echo 'PASS: All anti-hardcoding STDF parsing validation successful'"
          ],
          "expected": {
            "dmesg": [
              "STDF parser module loaded",
              "Created STDF buffer: type=.*, test_num=.*, result=.*",
              "STDF Record Header:",
              "Record Length: .*",
              "Record Type: .*",
              "Record Subtype: .*",
              "PTR Record Fields:",
              "TEST_NUM: .*",
              "HEAD_NUM: .*",
              "SITE_NUM: .*",
              "TEST_FLG: .*",
              "RESULT: .*",
              "TEST_TXT: .*",
              "MPR Record Fields:",
              "RTN_ICNT: .*",
              "RTN_RSLT\\[.*\\]: .*",
              "STDF file processing complete: .* records parsed",
              "STDF parser module unloaded"
            ],
            "stdout": [
              "PASS: All function and variable declarations found in header file",
              "SUCCESS: Anti-hardcoding STDF parsing test completed",
              "PASS: Random values extracted successfully",
              "PASS: STDF record type parsing with random value working",
              "PASS: TEST_NUM parsing with random value working",
              "PASS: RESULT parsing with random value working",
              "PASS: STDF header parsing working",
              "PASS: HEAD_NUM parsing working",
              "PASS: SITE_NUM parsing working",
              "PASS: PTR record dispatch working",
              "PASS: MPR record dispatch working",
              "PASS: MPR array count parsing working",
              "PASS: MPR array element parsing working",
              "PASS: Multi-record processing working",
              "PASS: Module initialization working",
              "PASS: Module cleanup working",
              "PASS: All anti-hardcoding STDF parsing validation successful"
            ]
          },
          "timeout": 15
        }
      }
    ]
  }
}
