{
  "id": 21,
  "title": "Pointer Arithmetic - Buffer Navigation Fundamentals",
  "phase": "foundations",
  "difficulty": 6,
  "xp": 50,
  "description": "Master pointer arithmetic fundamentals and double pointer concepts. Learn to navigate through memory buffers, advance pointers sequentially, and understand the building blocks needed for binary data processing in Problem 22.",
  "mainFile": "pointer_arithmetic.c",
  "files": [
    {
      "name": "pointer_arithmetic.h",
      "content": "#ifndef POINTER_ARITHMETIC_H\n#define POINTER_ARITHMETIC_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n#define BUFFER_SIZE 16\n\n/* Global variables for testing */\nextern uint8_t test_buffer[BUFFER_SIZE];\nextern uint8_t *current_position;\nextern int total_bytes_read;\n\n/* TODO: Declare your pointer arithmetic functions */\n/* void advance_pointer(uint8_t **ptr, int bytes); */\n/* uint32_t read_uint32_and_advance(uint8_t **ptr); */\n/* uint16_t read_uint16_and_advance(uint8_t **ptr); */\n/* void traverse_buffer(uint8_t *buffer, size_t size); */\n/* void print_buffer_status(void); */\n\n#endif /* POINTER_ARITHMETIC_H */",
      "readOnly": false,
      "language": "h"
    },
    {
      "name": "pointer_arithmetic.c",
      "content": "#include \"pointer_arithmetic.h\"\n\n/* Global variables */\nuint8_t test_buffer[BUFFER_SIZE] = {\n    0x01, 0x00, 0x00, 0x00,  /* uint32_t: 1 */\n    0xFF, 0x00,              /* uint16_t: 255 */\n    0x42, 0x00, 0x00, 0x00,  /* uint32_t: 66 */\n    0x7B, 0x00,              /* uint16_t: 123 */\n    0xAA, 0xBB, 0xCC, 0xDD   /* Extra bytes */\n};\n\nuint8_t *current_position = NULL;\nint total_bytes_read = 0;\n\nint test_advance_bytes = 4;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your pointer arithmetic logic works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(test_advance_bytes, int, 0644);\nMODULE_PARM_DESC(test_advance_bytes, \"Number of bytes to advance for testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: How pointer arithmetic works in C */\n/* This teaches the FOUNDATION for binary parsing:\n *\n * Memory Buffer:  [0x01][0x00][0x00][0x00][0xFF][0x00][0x42]...\n * Pointer:         ↑ ptr points here initially\n *                      ↑ ptr + 1 points here\n *                              ↑ ptr + 4 points here\n *\n * Step 1: Start with pointer at beginning of buffer\n * Step 2: Read data at current pointer location\n * Step 3: Advance pointer to next data location\n * Step 4: Repeat until buffer is fully processed\n */\n\n/* WHAT EACH POINTER OPERATION DOES AND HOW TO USE IT: */\n\n/* 1. void advance_pointer(uint8_t **ptr, int bytes) */\n/*    Purpose: Move a pointer forward by specified number of bytes */\n/*    Input: Double pointer (so we can modify caller's pointer) + byte count */\n/*    Output: None (modifies the pointer itself) */\n/*    Usage: advance_pointer(&my_ptr, 4);  // Moves my_ptr forward 4 bytes */\n\n/* 2. uint32_t read_uint32_and_advance(uint8_t **ptr) */\n/*    Purpose: Read 4 bytes as uint32_t AND move pointer forward */\n/*    Input: Double pointer to current buffer position */\n/*    Output: The 32-bit value that was read */\n/*    Side Effect: Advances pointer by 4 bytes automatically */\n/*    Usage: uint32_t value = read_uint32_and_advance(&buffer_pos); */\n\n/* 3. uint16_t read_uint16_and_advance(uint8_t **ptr) */\n/*    Purpose: Read 2 bytes as uint16_t AND move pointer forward */\n/*    Input: Double pointer to current buffer position */\n/*    Output: The 16-bit value that was read */\n/*    Side Effect: Advances pointer by 2 bytes automatically */\n/*    Usage: uint16_t value = read_uint16_and_advance(&buffer_pos); */\n\n/* POINTER ARITHMETIC BASICS EXPLAINED: */\n\n/* SINGLE POINTER ARITHMETIC: */\n/* uint8_t *ptr = buffer;       // ptr points to buffer[0] */\n/* ptr++;                       // ptr now points to buffer[1] */\n/* ptr += 4;                    // ptr now points to buffer[5] */\n/* uint8_t value = *ptr;        // Read the byte at current position */\n\n/* WHY WE NEED DOUBLE POINTERS (**): */\n/* Problem: Functions receive COPIES of pointer values */\n/* */\n/* void wrong_advance(uint8_t *ptr) { */\n/*     ptr += 4;  // Only changes the LOCAL copy! */\n/* } */\n/* // Caller's pointer stays unchanged - NOT what we want! */\n/* */\n/* Solution: Use double pointer to modify the original */\n/* void correct_advance(uint8_t **ptr) { */\n/*     *ptr += 4;  // Changes the ORIGINAL pointer! */\n/* } */\n/* // Caller's pointer gets advanced - EXACTLY what we want! */\n\n/* DOUBLE POINTER SYNTAX BREAKDOWN: */\n/* uint8_t **ptr means \"pointer to a pointer to uint8_t\" */\n/* */\n/* SIMPLE EXAMPLE TO UNDERSTAND DOUBLE POINTERS: */\n/* int a = 5; */\n/* int* ptr = &a;      // ptr points to a */\n/* int** ptr2 = &ptr;  // ptr2 points to ptr */\n/* */\n/* What Each Contains: */\n/* a = 5                    // The value */\n/* ptr = &a                 // Address of a (like 0x1000) */\n/* ptr2 = &ptr              // Address of ptr variable (like 0x2000) */\n/* */\n/* The Dereferencing Chain: */\n/* ptr2        // Address of ptr variable (0x2000) */\n/* *ptr2       // Contents of ptr variable (0x1000) - same as ptr */\n/* **ptr2      // Contents of a variable (5) - same as a */\n/* */\n/* APPLIED TO OUR BUFFER POINTERS: */\n/* If we have: uint8_t *buffer_pos = &buffer[0]; */\n/* And we call: advance_pointer(&buffer_pos, 4); */\n/* */\n/* Inside function: */\n/* ptr parameter contains: &buffer_pos (address of buffer_pos variable) */\n/* *ptr gives us: buffer_pos (the actual pointer value) */\n/* *ptr += 4 modifies: buffer_pos (moves it forward 4 bytes) */\n\n/* POINTER ARITHMETIC WITH TYPES: */\n/* uint8_t *ptr points to 1-byte values */\n/* ptr + 1 advances by 1 byte */\n/* ptr + 4 advances by 4 bytes */\n/* */\n/* uint32_t *ptr32 points to 4-byte values */\n/* ptr32 + 1 advances by 4 bytes (1 uint32_t) */\n/* ptr32 + 2 advances by 8 bytes (2 uint32_t values) */\n\n/* TYPE CASTING FOR DATA READING: */\n/* uint8_t *ptr = buffer; */\n/* uint32_t value = *(uint32_t*)ptr; */\n/*                   ↑       ↑     */\n/*                   |       └─ Dereference to read value */\n/*                   └─ Cast uint8_t* to uint32_t* */\n/* */\n/* This reads 4 bytes starting at ptr as a single uint32_t value */\n\n/* BUFFER TRAVERSAL PATTERN: */\n/* uint8_t *current = buffer;           // Start at beginning */\n/* while (current < buffer + size) {    // Check if within bounds */\n/*     process_byte(*current);          // Process current byte */\n/*     current++;                       // Move to next byte */\n/* } */\n\n/* MEMORY LAYOUT VISUALIZATION: */\n/* test_buffer:  [0x01][0x00][0x00][0x00][0xFF][0x00][0x42][0x00] */\n/* Addresses:     0x1000          0x1004  0x1006               */\n/* */\n/* uint8_t *ptr = test_buffer;     // ptr = 0x1000 */\n/* uint32_t val = *(uint32_t*)ptr; // Read bytes 0x1000-0x1003 = 1 */\n/* ptr += 4;                       // ptr = 0x1004 */\n/* uint16_t val2 = *(uint16_t*)ptr;// Read bytes 0x1004-0x1005 = 255 */\n\n/* COMMON MISTAKES AND SOLUTIONS: */\n/* MISTAKE 1: Forgetting to use double pointer for modification */\n/*   void bad_advance(uint8_t *ptr) { ptr += 4; }  // WRONG */\n/* SOLUTION: */\n/*   void good_advance(uint8_t **ptr) { *ptr += 4; }  // CORRECT */\n/* */\n/* MISTAKE 2: Confusing pointer and value dereferencing */\n/*   uint32_t val = (uint32_t)*ptr;    // WRONG - reads 1 byte, casts to uint32_t */\n/* SOLUTION: */\n/*   uint32_t val = *(uint32_t*)ptr;   // CORRECT - reads 4 bytes as uint32_t */\n/* */\n/* MISTAKE 3: Not checking buffer bounds */\n/*   ptr += 10;  // WRONG - might go past end of buffer */\n/* SOLUTION: */\n/*   if (ptr + 10 <= buffer + buffer_size) ptr += 10;  // CORRECT */\n\n/* PRACTICAL EXAMPLES FOR UNDERSTANDING: */\n/* Example 1: Reading consecutive integers from buffer */\n/* uint8_t buffer[] = {0x01, 0x00, 0x00, 0x00, 0xFF, 0x00}; */\n/* uint8_t *pos = buffer; */\n/* uint32_t first = read_uint32_and_advance(&pos);   // first = 1, pos += 4 */\n/* uint16_t second = read_uint16_and_advance(&pos);  // second = 255, pos += 2 */\n/* */\n/* Example 2: Manual buffer traversal */\n/* uint8_t *current = buffer; */\n/* for (int i = 0; i < buffer_size; i++) { */\n/*     printk(\"Byte %d: 0x%02x\\n\", i, *current); */\n/*     current++;  // Move to next byte */\n/* } */\n\n/* WHY THIS PREPARES YOU FOR PROBLEM 22: */\n/* Problem 22 (Binary Parsing) combines these concepts: */\n/* - Double pointers for buffer advancement (learned here) */\n/* - Type casting for data reading (learned here) */\n/* - Sequential data extraction (learned here) */\n/* + Dynamic memory allocation (from Problem 18) */\n/* + Structure parsing (from Problems 15-16) */\n/* = Complete binary parser capability! */\n\n/* TODO: Implement pointer advancement function */\nvoid advance_pointer(uint8_t **ptr, int bytes) {\n    /* TODO: Move the pointer forward by 'bytes' number of bytes */\n    /* TODO: Use *ptr += bytes to modify the caller's actual pointer */\n    /* TODO: This teaches the fundamental double pointer pattern */\n}\n\n/* TODO: Implement read and advance function */\nuint32_t read_uint32_and_advance(uint8_t **ptr) {\n    /* TODO: Read 4 bytes from current pointer position as uint32_t */\n    /* TODO: Cast *ptr to uint32_t* and dereference: *(uint32_t*)(*ptr) */\n    /* TODO: Advance the pointer by 4 bytes: *ptr += 4 */\n    /* TODO: Return the uint32_t value that was read */\n    return 0;\n}\n\n/* TODO: Implement read and advance function */\nuint16_t read_uint16_and_advance(uint8_t **ptr) {\n    /* TODO: Read 2 bytes from current pointer position as uint16_t */\n    /* TODO: Cast *ptr to uint16_t* and dereference: *(uint16_t*)(*ptr) */\n    /* TODO: Advance the pointer by 2 bytes: *ptr += 2 */\n    /* TODO: Return the uint16_t value that was read */\n    return 0;\n}\n\n/* TODO: Implement buffer traversal function */\nvoid traverse_buffer(uint8_t *buffer, size_t size) {\n    /* TODO: Create a pointer to traverse the buffer: uint8_t *buffer_ptr = buffer */\n    /* TODO: Loop through each byte: for (int i = 0; i < size; i++) */\n    /* TODO: Print each byte with its position: printk(\"Position %d: 0x%02x\\n\", i, *buffer_ptr) */\n    /* TODO: Advance to next byte: buffer_ptr++ */\n}\n\nvoid print_buffer_status(void) {\n    if (!current_position) {\n        printk(KERN_INFO \"Buffer Status: No current position set\\n\");\n        return;\n    }\n    \n    printk(KERN_INFO \"Buffer Status:\\n\");\n    printk(KERN_INFO \"Buffer start: %p\\n\", test_buffer);\n    printk(KERN_INFO \"Current position: %p\\n\", current_position);\n    printk(KERN_INFO \"Bytes advanced: %ld\\n\", current_position - test_buffer);\n    printk(KERN_INFO \"Total bytes read: %d\\n\", total_bytes_read);\n}\n\nstatic int __init pointer_arithmetic_init(void)\n{\n    uint32_t value32;\n    uint16_t value16;\n    \n    printk(KERN_INFO \"Pointer arithmetic module loaded\\n\");\n    \n    /* Initialize current position to start of buffer */\n    current_position = test_buffer;\n    total_bytes_read = 0;\n    \n    printk(KERN_INFO \"Starting pointer arithmetic demonstration\\n\");\n    \n    /* Test 1: Read first uint32_t and advance */\n    printk(KERN_INFO \"Test 1: Reading uint32_t from buffer\\n\");\n    value32 = read_uint32_and_advance(&current_position);\n    total_bytes_read += 4;\n    printk(KERN_INFO \"Read uint32_t: %u\\n\", value32);\n    print_buffer_status();\n    \n    /* Test 2: Read uint16_t and advance */\n    printk(KERN_INFO \"Test 2: Reading uint16_t from buffer\\n\");\n    value16 = read_uint16_and_advance(&current_position);\n    total_bytes_read += 2;\n    printk(KERN_INFO \"Read uint16_t: %u\\n\", value16);\n    print_buffer_status();\n    \n    /* Test 3: Advance pointer by dynamic amount */\n    printk(KERN_INFO \"Test 3: Advancing pointer by %d bytes\\n\", test_advance_bytes);\n    advance_pointer(&current_position, test_advance_bytes);\n    total_bytes_read += test_advance_bytes;\n    print_buffer_status();\n    \n    /* Test 4: Traverse entire buffer */\n    printk(KERN_INFO \"Test 4: Traversing entire buffer\\n\");\n    traverse_buffer(test_buffer, BUFFER_SIZE);\n    \n    printk(KERN_INFO \"Pointer arithmetic demonstration completed\\n\");\n    \n    return 0;\n}\n\nstatic void __exit pointer_arithmetic_exit(void)\n{\n    printk(KERN_INFO \"Pointer arithmetic module unloaded\\n\");\n    \n    /* Reset global state */\n    current_position = NULL;\n    total_bytes_read = 0;\n}\n\nmodule_init(pointer_arithmetic_init);\nmodule_exit(pointer_arithmetic_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning pointer arithmetic fundamentals for buffer navigation\");\nMODULE_VERSION(\"1.0\");",
      "readOnly": false,
      "language": "c"
    },
    {
      "name": "Makefile",
      "content": "# Pointer arithmetic module Makefile\nobj-m += pointer_arithmetic.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
      "readOnly": true,
      "language": "makefile"
    }
  ],
  "concepts": [
    "pointer arithmetic fundamentals",
    "double pointer concepts",
    "buffer navigation",
    "memory traversal",
    "type casting basics",
    "sequential data access"
  ],
  "skills": [
    "Understanding double pointer modification",
    "Implementing pointer advancement functions",
    "Reading data types from memory buffers",
    "Traversing memory buffers safely",
    "Preparing for binary data parsing",
    "Foundation for Problem 22 concepts"
  ],
  "validation": {
    "exactRequirements": {
      "functionNames": [
        "pointer_arithmetic_init",
        "pointer_arithmetic_exit",
        "advance_pointer",
        "read_uint32_and_advance",
        "read_uint16_and_advance",
        "traverse_buffer",
        "print_buffer_status"
      ],
      "function_declarations": [
        {
          "name": "advance_pointer",
          "returnType": "void",
          "parameters": [
            "uint8_t **ptr",
            "int bytes"
          ]
        },
        {
          "name": "read_uint32_and_advance",
          "returnType": "uint32_t",
          "parameters": [
            "uint8_t **ptr"
          ]
        },
        {
          "name": "read_uint16_and_advance",
          "returnType": "uint16_t",
          "parameters": [
            "uint8_t **ptr"
          ]
        },
        {
          "name": "traverse_buffer",
          "returnType": "void",
          "parameters": [
            "uint8_t *buffer",
            "size_t size"
          ]
        },
        {
          "name": "print_buffer_status",
          "returnType": "void",
          "parameters": []
        }
      ],
      "variables_declarations": [
        {
          "name": "test_buffer",
          "type": "uint8_t",
          "storageClass": "extern"
        },
        {
          "name": "current_position",
          "type": "uint8_t *",
          "storageClass": "extern"
        },
        {
          "name": "total_bytes_read",
          "type": "int",
          "storageClass": "extern"
        }
      ],
      "variables": [
        {
          "name": "current_position",
          "type": "uint8_t *",
          "value": "NULL",
          "storageClass": "none"
        },
        {
          "name": "total_bytes_read",
          "type": "int",
          "value": "0",
          "storageClass": "none"
        }
      ],
      "outputMessages": [
        "Pointer arithmetic module loaded",
        "Starting pointer arithmetic demonstration",
        "Test 1: Reading uint32_t from buffer",
        "Read uint32_t: 1",
        "Test 2: Reading uint16_t from buffer", 
        "Read uint16_t: 255",
        "Test 3: Advancing pointer by 4 bytes",
        "Test 4: Traversing entire buffer",
        "Position 0: 0x01",
        "Position 1: 0x00",
        "Pointer arithmetic demonstration completed",
        "Pointer arithmetic module unloaded"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/types.h"
      ],
      "mustContain": [
        "*ptr += bytes",
        "*(uint32_t*)(*ptr)",
        "*ptr += 4", 
        "*(uint16_t*)(*ptr)",
        "*ptr += 2",
        "uint8_t *buffer_ptr = buffer",
        "buffer_ptr++",
        "read_uint32_and_advance(&current_position)",
        "read_uint16_and_advance(&current_position)",
        "advance_pointer(&current_position",
        "module_param(test_advance_bytes, int, 0644)"
      ],
      "moduleInfo": {
        "license": "GPL"
      }
    },
    "testCases": [
      {
        "id": "function_declarations",
        "name": "Function Declarations in Header",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "void advance_pointer(uint8_t **ptr, int bytes)",
          "uint32_t read_uint32_and_advance(uint8_t **ptr)",
          "uint16_t read_uint16_and_advance(uint8_t **ptr)",
          "void traverse_buffer(uint8_t *buffer, size_t size)",
          "void print_buffer_status(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "function_signatures_source", 
        "name": "Function Signatures in Source File",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "void advance_pointer(uint8_t **ptr, int bytes)",
          "uint32_t read_uint32_and_advance(uint8_t **ptr)",
          "uint16_t read_uint16_and_advance(uint8_t **ptr)",
          "void traverse_buffer(uint8_t *buffer, size_t size)",
          "void print_buffer_status(void)",
          "static int __init pointer_arithmetic_init(void)",
          "static void __exit pointer_arithmetic_exit(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "exact_output",
        "name": "Exact Output Messages",
        "type": "output_match",
        "critical": true,
        "expected": [
          {
            "pattern": "Pointer arithmetic module loaded",
            "exact": true,
            "linkedFunction": "static int __init pointer_arithmetic_init(void)"
          },
          {
            "pattern": "Starting pointer arithmetic demonstration",
            "exact": true,
            "linkedFunction": "static int __init pointer_arithmetic_init(void)"
          },
          {
            "pattern": "Test 1: Reading uint32_t from buffer",
            "exact": true,
            "linkedFunction": "static int __init pointer_arithmetic_init(void)"
          },
          {
            "pattern": "Read uint32_t: 1",
            "exact": true,
            "linkedFunction": "uint32_t read_uint32_and_advance(uint8_t **ptr)"
          },
          {
            "pattern": "Test 2: Reading uint16_t from buffer",
            "exact": true,
            "linkedFunction": "static int __init pointer_arithmetic_init(void)"
          },
          {
            "pattern": "Read uint16_t: 255",
            "exact": true,
            "linkedFunction": "uint16_t read_uint16_and_advance(uint8_t **ptr)"
          },
          {
            "pattern": "Test 3: Advancing pointer by 4 bytes",
            "exact": true,
            "linkedFunction": "static int __init pointer_arithmetic_init(void)"
          },
          {
            "pattern": "Test 4: Traversing entire buffer",
            "exact": true,
            "linkedFunction": "static int __init pointer_arithmetic_init(void)"
          },
          {
            "pattern": "Position 0: 0x01",
            "exact": true,
            "linkedFunction": "void traverse_buffer(uint8_t *buffer, size_t size)"
          },
          {
            "pattern": "Position 1: 0x00",
            "exact": true,
            "linkedFunction": "void traverse_buffer(uint8_t *buffer, size_t size)"
          },
          {
            "pattern": "Pointer arithmetic demonstration completed",
            "exact": true,
            "linkedFunction": "static int __init pointer_arithmetic_init(void)"
          },
          {
            "pattern": "Pointer arithmetic module unloaded",
            "exact": true,
            "linkedFunction": "static void __exit pointer_arithmetic_exit(void)"
          }
        ]
      },
      {
        "id": "advanced_pointer_arithmetic_validation",
        "name": "Advanced Pointer Arithmetic with Anti-Hardcoding Protection",
        "type": "kernel_project_test",
        "critical": true,
        "testScenario": {
          "userspaceApps": [
            {
              "name": "pointer_arithmetic_dynamic_tester",
              "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Anti-Hardcoding Pointer Arithmetic Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate unpredictable test values\\n    int random_advance_bytes = (rand() % 4) + 2;  // 2-5 bytes\\n    \\n    printf(\\\"Test 1: Random pointer advancement (bytes=%d)\\\\n\\\", random_advance_bytes);\\n    \\n    // Test with random values\\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod pointer_arithmetic 2>/dev/null\\\");\\n    \\n    char cmd[256];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/pointer_arithmetic.ko test_advance_bytes=%d\\\", random_advance_bytes);\\n    printf(\\\"DEBUG: Command: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Anti-hardcoding pointer arithmetic test completed\\\\n\\\");\\n    return 0;\\n}"
            }
          ],
          "setupCommands": [
            "echo 'Starting advanced pointer arithmetic implementation validation'"
          ],
          "testCommands": [
            "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
            "echo 'Creating minimal kernel header stubs for TCC...'",
            "mkdir -p /tmp/linux",
            "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
            "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
            "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
            "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
            "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
            "echo '#define module_init(x)' >> /tmp/linux/module.h",
            "echo '#define module_exit(x)' >> /tmp/linux/module.h",
            "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
            "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
            "echo '#define __init' > /tmp/linux/init.h",
            "echo '#define __exit' >> /tmp/linux/init.h",
            "echo 'typedef unsigned char uint8_t;' > /tmp/linux/types.h",
            "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
            "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
            "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
            "echo '#define BUFFER_SIZE 16' >> /tmp/linux/types.h",
            "echo 'Creating test file that includes pointer arithmetic header...'",
            "echo '#include \"/lib/modules/pointer_arithmetic.h\"' > /tmp/test.c",
            "echo 'int main() { uint8_t *ptr; current_position = (uint8_t*)0; advance_pointer(&ptr, 4); read_uint32_and_advance(&ptr); read_uint16_and_advance(&ptr); traverse_buffer((uint8_t*)0, 16); print_buffer_status(); return 0; }' >> /tmp/test.c",
            "echo 'Running TCC validation...'",
            "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
            "TCC_EXIT_CODE=$?",
            "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
            "echo 'Phase 2: Anti-Hardcoding Dynamic Pointer Arithmetic Test'",
            "/bin/pointer_arithmetic_dynamic_tester > /tmp/test_output.log",
            "cat /tmp/test_output.log",
            "echo 'Phase 3: Random Value Extraction and Validation'",
            "echo 'Adding delay to ensure dmesg messages are written...'",
            "sleep 1",
            "echo 'Extracting random test values from output...'",
            "ADVANCE_BYTES=$(grep -o 'Random pointer advancement (bytes=[0-9]*)' /tmp/test_output.log | cut -d'=' -f2 | cut -d')' -f1)",
            "echo 'Extracted values: ADVANCE_BYTES='$ADVANCE_BYTES",
            "if [ -z \"$ADVANCE_BYTES\" ]; then echo 'FAIL: Could not extract random test values'; else echo 'PASS: Random values extracted successfully'; fi",
            "echo 'Phase 4: Anti-Hardcoding Validation with Random Values'",
            "echo 'Validating pointer advancement with random value '$ADVANCE_BYTES",
            "dmesg | grep \"Test 3: Advancing pointer by $ADVANCE_BYTES bytes\" && echo 'PASS: Pointer advancement with random value working' || echo 'FAIL: Pointer advancement with random value broken'",
            "echo 'Phase 5: Static Field Validation (Non-Randomized Fields)'",
            "dmesg | grep 'Read uint32_t: 1' && echo 'PASS: uint32_t reading working' || echo 'FAIL: uint32_t reading broken'",
            "dmesg | grep 'Read uint16_t: 255' && echo 'PASS: uint16_t reading working' || echo 'FAIL: uint16_t reading broken'",
            "dmesg | grep 'Position 0: 0x01' && echo 'PASS: Buffer traversal working' || echo 'FAIL: Buffer traversal broken'",
            "echo 'Phase 6: Pointer Arithmetic Logic Validation'",
            "dmesg | grep 'Starting pointer arithmetic demonstration' && echo 'PASS: Module demonstration working' || echo 'FAIL: Module demonstration broken'",
            "dmesg | grep 'Pointer arithmetic module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
            "dmesg | grep 'Pointer arithmetic module unloaded' && echo 'PASS: Module cleanup working' || echo 'FAIL: Module cleanup broken'",
            "echo 'Phase 7: Final Validation Summary'",
            "echo 'All phases completed successfully - anti-hardcoding pointer arithmetic protection verified'",
            "echo 'PASS: All anti-hardcoding pointer arithmetic validation successful'"
          ],
          "expected": {
            "dmesg": [
              "Pointer arithmetic module loaded",
              "Starting pointer arithmetic demonstration",
              "Test 1: Reading uint32_t from buffer",
              "Read uint32_t: 1",
              "Test 2: Reading uint16_t from buffer",
              "Read uint16_t: 255",
              "Test 3: Advancing pointer by .* bytes",
              "Test 4: Traversing entire buffer",
              "Position 0: 0x01",
              "Position 1: 0x00",
              "Pointer arithmetic demonstration completed",
              "Pointer arithmetic module unloaded"
            ],
            "stdout": [
              "PASS: All function and variable declarations found in header file",
              "SUCCESS: Anti-hardcoding pointer arithmetic test completed",
              "PASS: Random values extracted successfully",
              "PASS: Pointer advancement with random value working",
              "PASS: uint32_t reading working",
              "PASS: uint16_t reading working",
              "PASS: Buffer traversal working",
              "PASS: Module demonstration working",
              "PASS: Module initialization working",
              "PASS: Module cleanup working",
              "PASS: All anti-hardcoding pointer arithmetic validation successful"
            ]
          },
          "timeout": 15
        }
      }
    ]
  }
}