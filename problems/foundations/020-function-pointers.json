{
  "id": 20,
  "title": "Function Pointers - STDF-Style Record Processing",
  "phase": "foundations",
  "difficulty": 7,
  "xp": 60,
  "description": "Master function pointer typedefs and function dispatch patterns used in production kernel parsers like STDF. Learn to assign functions to pointers, call functions through pointers, and implement simple record processing dispatch similar to libstdf parsing architecture.",
  "mainFile": "function_pointers.c",
  "files": [
    {
      "name": "function_pointers.h",
      "content": "#ifndef FUNCTION_POINTERS_H\n#define FUNCTION_POINTERS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n#define MAX_NAME_LEN 32\n\n/* Record type constants (like STDF record types) */\n#define SENSOR_RECORD 1\n#define DEVICE_RECORD 2\n\n/* Base record header (like rec_header) */\ntypedef struct {\n    uint8_t rec_type;\n    uint8_t rec_subtype;\n    uint16_t rec_length;\n} record_header;\n\n/* Generic record (like rec_unknown) */\ntypedef struct {\n    record_header header;\n    void* data;\n} generic_record;\n\n/* Function pointer typedef (like STDF processor functions) */\ntypedef int (*record_processor_t)(void* record_data, uint32_t record_id);\n\n/* Global function pointers for different record types */\nextern record_processor_t sensor_processor;\nextern record_processor_t device_processor;\nextern record_processor_t active_processor;\n\n/* TODO: Declare your functions */\n/* void register_processor(uint8_t record_type, record_processor_t processor); */\n/* int process_record_with_function_pointer(void* raw_record, uint32_t record_id); */\n/* void call_processor_function(record_processor_t processor, void* data, uint32_t id); */\n\n/* Predefined processor functions for students to use */\nint sensor_record_processor(void* record_data, uint32_t record_id);\nint device_record_processor(void* record_data, uint32_t record_id);\n\n#endif /* FUNCTION_POINTERS_H */",
      "readOnly": false,
      "language": "h"
    },
    {
      "name": "function_pointers.c",
      "content": "#include \"function_pointers.h\"\n\n/* Global function pointers for record processing */\nrecord_processor_t sensor_processor = NULL;\nrecord_processor_t device_processor = NULL;\nrecord_processor_t active_processor = NULL;\n\nint test_record_type = SENSOR_RECORD;\nint test_record_id = 1001;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your function pointer logic works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(test_record_type, int, 0644);\nMODULE_PARM_DESC(test_record_type, \"Record type for testing function pointer dispatch\");\nmodule_param(test_record_id, int, 0644);\nMODULE_PARM_DESC(test_record_id, \"Record ID for anti-hardcoding testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* Predefined processor functions (provided for students) */\nint sensor_record_processor(void* record_data, uint32_t record_id) {\n    printk(KERN_INFO \"Processing sensor record ID: %u\\n\", record_id);\n    printk(KERN_INFO \"Sensor data processed successfully\\n\");\n    return 0;\n}\n\nint device_record_processor(void* record_data, uint32_t record_id) {\n    printk(KERN_INFO \"Processing device record ID: %u\\n\", record_id);\n    printk(KERN_INFO \"Device data processed successfully\\n\");\n    return 0;\n}\n\n/* Predefined test records for casting demonstration */\nstatic generic_record test_sensor_record = {\n    .header = { .rec_type = SENSOR_RECORD, .rec_subtype = 1, .rec_length = 48 },\n    .data = NULL\n};\n\nstatic generic_record test_device_record = {\n    .header = { .rec_type = DEVICE_RECORD, .rec_subtype = 1, .rec_length = 52 },\n    .data = NULL\n};\n\n/* PATTERN SCAFFOLDING: How function pointer dispatch works with casting */\n/* This combines casting chains from Problem 19 with function pointers:\n *\n * Step 1: Casting chain (like STDF parser)\n * void* raw_record → generic_record* rec → extract rec_type\n *\n * Step 2: Function pointer dispatch\n * typedef int (*record_processor_t)(void* data, uint32_t id);\n * record_processor_t processor = sensor_record_processor;\n * int result = processor(data, id);  // Call through function pointer\n *\n * This is like: void* → generic_record* → get type → select function → call\n */\n\n/* WHAT EACH POINTER AND FUNCTION CONTAINS AND HOW TO USE IT: */\n\n/* 1. void* raw_record - Generic data pointer (from Problem 19) */\n/*    Contains: Memory address pointing to some record data */\n/*    Usage: Must cast to specific type before accessing fields */\n/*    Example: raw_record points to memory, but raw_record->header won't work */\n\n/* 2. generic_record* rec - Typed record pointer (from Problem 19) */\n/*    Contains: Same memory address, now treated as generic_record */\n/*    Usage: Can access header fields: rec->header.rec_type */\n/*    Example: rec->header.rec_type tells us SENSOR_RECORD or DEVICE_RECORD */\n\n/* 3. record_processor_t processor - Function pointer variable */\n/*    Contains: Memory address pointing to a function (not data!) */\n/*    Usage: Can call the function: processor(data, id) */\n/*    Example: processor = sensor_record_processor; // Assign function address */\n\n/* HOW FUNCTION POINTER ASSIGNMENT WORKS: */\n/* Function names are addresses! */\n/* sensor_record_processor = Function address (like 0x401234) */\n/* processor = sensor_record_processor; // Copy function address to processor */\n/* Now processor contains the same address as sensor_record_processor */\n\n/* CASTING REVIEW FROM PROBLEM 19 (CRITICAL FOR FUNCTION POINTERS): */\n/* (type_name*)pointer means \"treat this pointer as type_name*\" */\n/* Example: (generic_record*)raw_record */\n/*          ↑ target type     ↑ source void* pointer */\n/* Why needed? To access record->header.rec_type for function dispatch! */\n\n/* AMPERSAND OPERATOR (&) REVIEW FROM PROBLEM 19: */\n/* &variable means \"get the address of variable\" */\n/* Example: (void*)&test_sensor_record */\n/*          ↑ cast to void*  ↑ get address of struct variable */\n/* Why &? Functions expect pointers (addresses), but test_sensor_record is a struct */\n\n/* FUNCTION POINTER CALLING EXPLAINED IN DETAIL: */\n/* processor(data, id) - Call function through pointer */\n/*    ↑ function pointer variable pointing to actual function */\n/*              ↑ parameters passed to the actual function */\n\n/* WHAT HAPPENS DURING FUNCTION POINTER CALL: */\n/* 1. processor contains function address (like 0x401234) */\n/* 2. processor(data, id) jumps to address 0x401234 */\n/* 3. Executes the actual function code at that address */\n/* 4. Passes data and id as parameters to the function */\n/* 5. Returns the function's return value */\n\n/* COMPARISON: DIRECT vs FUNCTION POINTER CALLS: */\n/* DIRECT:          sensor_record_processor(data, id); */\n/*                  ↑ compiler knows exact function at compile time */\n/* FUNCTION POINTER: processor(data, id); */\n/*                  ↑ function determined at runtime from processor variable */\n\n/* WHY USE FUNCTION POINTERS? DYNAMIC DISPATCH: */\n/* Without function pointers (hardcoded): */\n/*   if (type == SENSOR_RECORD) sensor_record_processor(data, id); */\n/*   if (type == DEVICE_RECORD) device_record_processor(data, id); */\n/* */\n/* With function pointers (dynamic): */\n/*   processor = get_processor_for_type(type); // Set function pointer */\n/*   processor(data, id);                      // Call through pointer */\n\n/* FUNCTION POINTER TYPEDEF EXPLAINED: */\n/* typedef int (*record_processor_t)(void* data, uint32_t id); */\n/*         ↑    ↑                    ↑                        */\n/*    return   function pointer      parameter types          */\n/*     type    name/type                                      */\n/* Creates a type name for \"pointer to function that takes (void*, uint32_t) and returns int\" */\n\n/* MEMORY LAYOUT OF FUNCTION POINTERS: */\n/* Memory for functions:                Memory for function pointers: */\n/* 0x401234: [sensor_record_processor]  processor variable: [0x401234] */\n/* 0x401500: [device_record_processor]  sensor_processor:  [0x401234] */\n/*           ↑ actual function code    device_processor:  [0x401500] */\n/*                                     ↑ stores address of function */\n\n/* PRACTICAL EXAMPLES IN OUR KERNEL CODE: */\n/* 1. Function pointer assignment: */\n/*    sensor_processor = sensor_record_processor; */\n/*    ↑ pointer variable gets function address */\n/* */\n/* 2. Function pointer calling: */\n/*    sensor_processor(data, id); */\n/*    ↑ calls function at address stored in sensor_processor */\n/* */\n/* 3. Combined with casting (the power pattern!): */\n/*    generic_record* rec = (generic_record*)raw_record;  // Cast data */\n/*    if (rec->header.rec_type == SENSOR_RECORD) {        // Check type */\n/*        active_processor = sensor_processor;            // Set function */\n/*        active_processor(raw_record, id);               // Call function */\n/*    } */\n\n/* COMMON MISTAKES AND SOLUTIONS: */\n/* MISTAKE 1: Forgetting to cast before accessing header */\n/*   raw_record->header.rec_type  // ERROR: void* has no header field */\n/* SOLUTION: */\n/*   generic_record* rec = (generic_record*)raw_record; */\n/*   rec->header.rec_type  // CORRECT: now we can access header */\n/* */\n/* MISTAKE 2: Calling function incorrectly through pointer */\n/*   processor->data  // ERROR: processor is function pointer, not data pointer */\n/* SOLUTION: */\n/*   processor(data, id)  // CORRECT: call function through pointer */\n/* */\n/* MISTAKE 3: NULL function pointer calls */\n/*   processor(data, id)  // CRASH if processor is NULL */\n/* SOLUTION: */\n/*   if (processor) processor(data, id);  // CORRECT: check before calling */\n\n/* TODO: Implement processor registration function */\nvoid register_processor(uint8_t record_type, record_processor_t processor) {\n    /* TODO: Check if record_type is SENSOR_RECORD or DEVICE_RECORD */\n    /* TODO: If SENSOR_RECORD, assign processor to sensor_processor global variable */\n    /* TODO: If DEVICE_RECORD, assign processor to device_processor global variable */\n    /* TODO: Print \"Registered sensor processor\" or \"Registered device processor\" */\n    /* TODO: Handle unknown record types with error message */\n}\n\n/* TODO: Implement record processing with casting + function pointers */\nint process_record_with_function_pointer(void* raw_record, uint32_t record_id) {\n    /* TODO: Step 1 - Cast void* raw_record to generic_record* (like STDF parser casting) */\n    /* TODO: Step 2 - Read rec_type from the header to determine record type */\n    /* TODO: Step 3 - If SENSOR_RECORD: set active_processor and call sensor_processor */\n    /* TODO: Step 4 - If DEVICE_RECORD: set active_processor and call device_processor */\n    /* TODO: Step 5 - Print appropriate \"Found X record, calling X processor\" message */\n    /* TODO: Step 6 - Return the result from the processor function call */\n    /* TODO: Step 7 - Handle unknown record types with error return */\n}\n\n/* TODO: Implement direct function pointer calling */\nvoid call_processor_function(record_processor_t processor, void* data, uint32_t id) {\n    /* TODO: Check if the processor function pointer is not NULL */\n    /* TODO: If valid, print \"Calling processor function through pointer\" */\n    /* TODO: Call the function through the function pointer with data and id parameters */\n    /* TODO: If NULL, print error message \"Processor function pointer is NULL\" */\n}\n\nstatic int __init function_pointers_init(void)\n{\n    int ret;\n    void* test_record;\n    \n    printk(KERN_INFO \"Function pointers module loaded\\n\");\n    \n    /* Register predefined processors */\n    register_processor(SENSOR_RECORD, sensor_record_processor);\n    register_processor(DEVICE_RECORD, device_record_processor);\n    \n    /* Select test record based on module parameter */\n    if (test_record_type == SENSOR_RECORD) {\n        test_record = (void*)&test_sensor_record;\n    } else {\n        test_record = (void*)&test_device_record;\n    }\n    \n    /* Test function pointer dispatch with casting */\n    printk(KERN_INFO \"Testing function pointer dispatch with record type: %d, ID: %d\\n\", test_record_type, test_record_id);\n    ret = process_record_with_function_pointer(test_record, test_record_id);\n    if (ret) {\n        printk(KERN_ERR \"Function pointer dispatch failed with error: %d\\n\", ret);\n        return ret;\n    }\n    \n    /* Test direct function pointer calling */\n    if (active_processor) {\n        call_processor_function(active_processor, test_record, test_record_id + 1);\n    }\n    \n    return 0;\n}\n\nstatic void __exit function_pointers_exit(void)\n{\n    printk(KERN_INFO \"Function pointers module unloaded\\n\");\n    \n    /* Reset global function pointers */\n    sensor_processor = NULL;\n    device_processor = NULL;\n    active_processor = NULL;\n}\n\nmodule_init(function_pointers_init);\nmodule_exit(function_pointers_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning function pointers with STDF-style record processing\");\nMODULE_VERSION(\"1.0\");",
      "readOnly": false,
      "language": "c"
    },
    {
      "name": "Makefile",
      "content": "# Function pointers module Makefile\nobj-m += function_pointers.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
      "readOnly": true,
      "language": "makefile"
    }
  ],
  "concepts": [
    "function pointer typedefs",
    "function pointer assignment",
    "calling functions through pointers",
    "combining casting with function dispatch",
    "STDF-style record processing patterns",
    "simple function pointer dispatch"
  ],
  "skills": [
    "Creating function pointer typedefs",
    "Assigning functions to pointers",
    "Calling functions through pointers",
    "Combining casting chains with function pointers",
    "Understanding STDF parser function dispatch",
    "Professional kernel processing patterns"
  ],
  "validation": {
    "exactRequirements": {
      "functionNames": ["function_pointers_init", "function_pointers_exit", "register_processor", "process_record_with_function_pointer", "call_processor_function"],
      "function_declarations": [
        { "name": "register_processor", "returnType": "void", "parameters": ["uint8_t record_type", "record_processor_t processor"] },
        { "name": "process_record_with_function_pointer", "returnType": "int", "parameters": ["void* raw_record", "uint32_t record_id"] },
        { "name": "call_processor_function", "returnType": "void", "parameters": ["record_processor_t processor", "void* data", "uint32_t id"] }
      ],
      "variables_declarations": [
        { "name": "record_header", "type": "typedef struct", "value": "{uint8_t rec_type; uint8_t rec_subtype; uint16_t rec_length;}", "storageClass": "none" },
        { "name": "generic_record", "type": "typedef struct", "value": "{record_header header; void* data;}", "storageClass": "none" },
        { "name": "record_processor_t", "type": "typedef", "value": "int (*)(void* record_data, uint32_t record_id)", "storageClass": "none" },
        { "name": "sensor_processor", "type": "record_processor_t", "storageClass": "extern" },
        { "name": "device_processor", "type": "record_processor_t", "storageClass": "extern" },
        { "name": "active_processor", "type": "record_processor_t", "storageClass": "extern" }
      ],
      "variables": [
        { "name": "sensor_processor", "type": "record_processor_t", "value": "NULL", "storageClass": "none" },
        { "name": "device_processor", "type": "record_processor_t", "value": "NULL", "storageClass": "none" },
        { "name": "active_processor", "type": "record_processor_t", "value": "NULL", "storageClass": "none" }
      ],
      "outputMessages": [
        "Function pointers module loaded",
        "Registered sensor processor",
        "Registered device processor",
        "Testing function pointer dispatch with record type: 1, ID: 1001",
        "Found sensor record, calling sensor processor",
        "Processing sensor record ID: 1001",
        "Sensor data processed successfully",
        "Calling processor function through pointer",
        "Processing sensor record ID: 1002",
        "Function pointers module unloaded"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/types.h"
      ],
      "mustContain": [
        "sensor_processor = processor",
        "device_processor = processor",
        "active_processor = sensor_processor",
        "active_processor = device_processor",
        "generic_record* rec = (generic_record*)raw_record",
        "if (rec->header.rec_type == SENSOR_RECORD)",
        "if (rec->header.rec_type == DEVICE_RECORD)",
        "sensor_processor(raw_record, record_id)",
        "device_processor(raw_record, record_id)",
        "processor(data, id)",
        "module_param(test_record_type, int, 0644)",
        "module_param(test_record_id, int, 0644)"
      ],
      "moduleInfo": {
        "license": "GPL"
      }
    },
    "testCases": [
      {
        "id": "function_declarations",
        "name": "Function Declarations in Header",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "void register_processor(uint8_t record_type, record_processor_t processor)",
          "int process_record_with_function_pointer(void* raw_record, uint32_t record_id)",
          "void call_processor_function(record_processor_t processor, void* data, uint32_t id)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "function_signatures_source",
        "name": "Function Signatures in Source File",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "void register_processor(uint8_t record_type, record_processor_t processor)",
          "int process_record_with_function_pointer(void* raw_record, uint32_t record_id)",
          "void call_processor_function(record_processor_t processor, void* data, uint32_t id)",
          "static int __init function_pointers_init(void)",
          "static void __exit function_pointers_exit(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "exact_output",
        "name": "Exact Output Messages",
        "type": "output_match",
        "critical": true,
        "expected": [
          { "pattern": "Function pointers module loaded", "exact": true, "linkedFunction": "static int __init function_pointers_init(void)" },
          { "pattern": "Registered sensor processor", "exact": true, "linkedFunction": "void register_processor(uint8_t record_type, record_processor_t processor)" },
          { "pattern": "Registered device processor", "exact": true, "linkedFunction": "void register_processor(uint8_t record_type, record_processor_t processor)" },
          { "pattern": "Testing function pointer dispatch with record type: 1, ID: 1001", "exact": true, "linkedFunction": "static int __init function_pointers_init(void)" },
          { "pattern": "Found sensor record, calling sensor processor", "exact": true, "linkedFunction": "int process_record_with_function_pointer(void* raw_record, uint32_t record_id)" },
          { "pattern": "Processing sensor record ID: 1001", "exact": true, "linkedFunction": "int sensor_record_processor(void* record_data, uint32_t record_id)" },
          { "pattern": "Sensor data processed successfully", "exact": true, "linkedFunction": "int sensor_record_processor(void* record_data, uint32_t record_id)" },
          { "pattern": "Calling processor function through pointer", "exact": true, "linkedFunction": "void call_processor_function(record_processor_t processor, void* data, uint32_t id)" },
          { "pattern": "Processing sensor record ID: 1002", "exact": true, "linkedFunction": "int sensor_record_processor(void* record_data, uint32_t record_id)" },
          { "pattern": "Function pointers module unloaded", "exact": true, "linkedFunction": "static void __exit function_pointers_exit(void)" }
        ]
      },
      {
        "id": "advanced_function_pointer_validation",
        "name": "Advanced Function Pointer with Casting Implementation and Anti-Hardcoding Protection",
        "type": "kernel_project_test",
        "critical": true,
        "testScenario": {
          "userspaceApps": [
            {
              "name": "function_pointer_dynamic_tester",
              "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Anti-Hardcoding Function Pointer Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate unpredictable test values\\n    int random_record_id1 = (rand() % 9000) + 1000;  // 1000-9999\\n    int random_record_id2 = (rand() % 8000) + 2000;  // 2000-9999\\n    \\n    printf(\\\"Test 1: Sensor function pointer dispatch (ID=%d)\\\\n\\\", random_record_id1);\\n    system(\\\"rmmod function_pointers 2>/dev/null\\\");\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/function_pointers.ko test_record_type=1 test_record_id=%d\\\", random_record_id1);\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Device function pointer dispatch (ID=%d)\\\\n\\\", random_record_id2);\\n    system(\\\"rmmod function_pointers\\\");\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/function_pointers.ko test_record_type=2 test_record_id=%d\\\", random_record_id2);\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Anti-hardcoding function pointer test completed\\\\n\\\");\\n    return 0;\\n}"
            }
          ],
          "setupCommands": [
            "echo 'Starting advanced function pointer dispatch implementation validation'"
          ],
          "testCommands": [
            "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
            "echo 'Creating minimal kernel header stubs for TCC...'",
            "mkdir -p /tmp/linux",
            "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
            "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
            "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
            "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
            "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
            "echo '#define module_init(x)' >> /tmp/linux/module.h",
            "echo '#define module_exit(x)' >> /tmp/linux/module.h",
            "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
            "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
            "echo '#define __init' > /tmp/linux/init.h",
            "echo '#define __exit' >> /tmp/linux/init.h",
            "echo 'typedef int bool;' > /tmp/linux/types.h",
            "echo 'typedef unsigned char uint8_t;' >> /tmp/linux/types.h",
            "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
            "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
            "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
            "echo '#define true 1' >> /tmp/linux/types.h",
            "echo '#define false 0' >> /tmp/linux/types.h",
            "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
            "echo 'Creating test file that includes function pointers header...'",
            "echo '#include \"/lib/modules/function_pointers.h\"' > /tmp/test.c",
            "echo 'int main() { sensor_processor = (record_processor_t)0; register_processor(1, (record_processor_t)0); process_record_with_function_pointer((void*)0, 1001); call_processor_function((record_processor_t)0, (void*)0, 1001); return 0; }' >> /tmp/test.c",
            "echo 'Running TCC validation...'",
            "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
            "TCC_EXIT_CODE=$?",
            "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
            "echo 'Phase 2: Anti-Hardcoding Dynamic Function Pointer Test'",
            "/bin/function_pointer_dynamic_tester > /tmp/test_output.log",
            "cat /tmp/test_output.log",
            "echo 'Phase 3: Random Value Extraction and Validation'",
            "echo 'Adding delay to ensure dmesg messages are written...'",
            "sleep 1",
            "echo 'Extracting random test values from output...'",
            "RECORD_ID1=$(grep -o 'Sensor function pointer dispatch (ID=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
            "RECORD_ID2=$(grep -o 'Device function pointer dispatch (ID=[0-9]*)' /tmp/test_output.log | cut -d'=' -f2 | cut -d')' -f1)",
            "echo 'Extracted values: SENSOR_ID='$RECORD_ID1', DEVICE_ID='$RECORD_ID2",
            "if [ -z \"$RECORD_ID1\" ] || [ -z \"$RECORD_ID2\" ]; then echo 'FAIL: Could not extract random test values'; else echo 'PASS: Random values extracted successfully'; fi",
            "echo 'Phase 4: Anti-Hardcoding Validation with Random Values'",
            "echo 'Validating sensor function pointer with random ID '$RECORD_ID1",
            "dmesg | grep \"Processing sensor record ID: $RECORD_ID1\" && echo 'PASS: Sensor function pointer with random ID working' || echo 'FAIL: Sensor function pointer with random ID broken'",
            "echo 'Validating device function pointer with random ID '$RECORD_ID2",
            "dmesg | grep \"Processing device record ID: $RECORD_ID2\" && echo 'PASS: Device function pointer with random ID working' || echo 'FAIL: Device function pointer with random ID broken'",
            "echo 'Phase 5: Function Pointer and Casting Validation'",
            "dmesg | grep 'Registered sensor processor' && echo 'PASS: Sensor processor registration working' || echo 'FAIL: Sensor processor registration broken'",
            "dmesg | grep 'Registered device processor' && echo 'PASS: Device processor registration working' || echo 'FAIL: Device processor registration broken'",
            "dmesg | grep 'Found sensor record, calling sensor processor' && echo 'PASS: Casting + function pointer dispatch working' || echo 'FAIL: Casting + function pointer dispatch broken'",
            "dmesg | grep 'Found device record, calling device processor' && echo 'PASS: Device casting + function pointer dispatch working' || echo 'FAIL: Device casting + function pointer dispatch broken'",
            "dmesg | grep 'Calling processor function through pointer' && echo 'PASS: Direct function pointer calling working' || echo 'FAIL: Direct function pointer calling broken'",
            "echo 'Phase 6: Module Validation'",
            "dmesg | grep 'Function pointers module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
            "dmesg | grep 'Function pointers module unloaded' && echo 'PASS: Module cleanup working' || echo 'FAIL: Module cleanup broken'",
            "echo 'All function pointer with casting implementation validations completed'"
          ],
          "expected": {
            "dmesg": [
              "Function pointers module loaded",
              "Registered sensor processor",
              "Registered device processor",
              "Testing function pointer dispatch with record type: .*, ID: .*",
              "Found sensor record, calling sensor processor",
              "Found device record, calling device processor",
              "Processing sensor record ID: .*",
              "Processing device record ID: .*",
              "Sensor data processed successfully",
              "Device data processed successfully",
              "Calling processor function through pointer"
            ],
            "stdout": [
              "PASS: All function and variable declarations found in header file",
              "SUCCESS: Anti-hardcoding function pointer test completed",
              "PASS: Random values extracted successfully",
              "PASS: Sensor function pointer with random ID working",
              "PASS: Device function pointer with random ID working",
              "PASS: Sensor processor registration working",
              "PASS: Device processor registration working",
              "PASS: Casting \\+ function pointer dispatch working",
              "PASS: Device casting \\+ function pointer dispatch working",
              "PASS: Direct function pointer calling working",
              "PASS: Module initialization working",
              "PASS: Module cleanup working"
            ]
          },
          "timeout": 15
        }
      }
    ]
  }
}