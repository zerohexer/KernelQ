{
  "id": 27,
  "title": "Error Handling - Kernel Resilience Patterns",
  "phase": "foundations",
  "difficulty": 5,
  "xp": 50,
  "description": "Master essential error handling patterns for robust kernel programming. Learn standard error codes, proper cleanup patterns, and defensive programming techniques that prevent crashes and memory leaks.",
  "mainFile": "error_handler.c",
  "files": [
    {
      "name": "error_handler.h",
      "content": "#ifndef ERROR_HANDLER_H\n#define ERROR_HANDLER_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\n#define MAX_BUFFER_SIZE 1024\n\n/* Simple device structure for error handling demonstration */\nstruct test_device {\n    int device_id;\n    char *buffer;\n    size_t buffer_size;\n    int is_initialized;\n};\n\n/* Global test device */\nextern struct test_device global_device;\n\n/* TODO: Declare your error handling functions */\n/* int validate_device_id(int device_id); */\n/* int allocate_device_buffer(struct test_device *dev, size_t size); */\n/* int initialize_device(struct test_device *dev, int device_id, size_t buffer_size); */\n/* void cleanup_device(struct test_device *dev); */\n/* const char* get_error_message(int error_code); */\n/* int process_device_operation(int device_id, size_t buffer_size); */\n\n#endif /* ERROR_HANDLER_H */",
      "readOnly": false,
      "language": "h"
    },
    {
      "name": "error_handler.c",
      "content": "#include \"error_handler.h\"\n\n/* Global test device */\nstruct test_device global_device = {0};\n\nint test_device_id = 100;\nint test_buffer_size = 512;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n */\nmodule_param(test_device_id, int, 0644);\nMODULE_PARM_DESC(test_device_id, \"Device ID for testing error handling\");\nmodule_param(test_buffer_size, int, 0644);\nMODULE_PARM_DESC(test_buffer_size, \"Buffer size for testing error handling\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: Essential Error Handling in Linux Kernel */\n/* This teaches the CORE patterns for robust kernel programming:\n *\n * 1. STANDARD ERROR CODES:\n * -EINVAL  = Invalid argument (22)\n * -ENOMEM  = Out of memory (12)\n * -EBUSY   = Device or resource busy (16)\n * -ENODEV  = No such device (19)\n *\n * 2. ERROR CHECKING PATTERN:\n * if (bad_condition) {\n *     printk(KERN_ERR \"Error description\\n\");\n *     return -ERROR_CODE;\n * }\n *\n * 3. RESOURCE CLEANUP PATTERN:\n * ptr = kmalloc(size, GFP_KERNEL);\n * if (!ptr) {\n *     return -ENOMEM;\n * }\n * // Use ptr...\n * kfree(ptr);  // Always clean up!\n *\n * 4. ERROR PROPAGATION:\n * ret = some_function();\n * if (ret < 0) {\n *     return ret;  // Pass error up\n * }\n */\n\n/* TODO: Implement device ID validation */\nint validate_device_id(int device_id) {\n    /* TODO: Check if device_id is negative */\n    /* TODO: If negative, print error message and return -EINVAL */\n    /* TODO: Check if device_id is greater than 1000 */\n    /* TODO: If too large, print error message and return -EINVAL */\n    /* TODO: Print \"Device ID %d is valid\" */\n    /* TODO: Return 0 for success */\n    return -ENOSYS;\n}\n\n/* TODO: Implement safe buffer allocation */\nint allocate_device_buffer(struct test_device *dev, size_t size) {\n    /* TODO: Check if dev is NULL */\n    /* TODO: If NULL, return -EINVAL */\n    /* TODO: Check if size is 0 or greater than MAX_BUFFER_SIZE */\n    /* TODO: If invalid size, return -EINVAL */\n    /* TODO: Check if buffer is already allocated (dev->buffer != NULL) */\n    /* TODO: If already allocated, return -EBUSY */\n    /* TODO: Allocate memory using kmalloc(size, GFP_KERNEL) */\n    /* TODO: If allocation fails, return -ENOMEM */\n    /* TODO: Set dev->buffer and dev->buffer_size */\n    /* TODO: Print \"Allocated buffer of size %zu\" */\n    /* TODO: Return 0 for success */\n    return -ENOSYS;\n}\n\n/* TODO: Implement device initialization with error handling */\nint initialize_device(struct test_device *dev, int device_id, size_t buffer_size) {\n    /* TODO: Check if dev is NULL */\n    /* TODO: If NULL, return -EINVAL */\n    \n    /* TODO: Validate device ID using validate_device_id() */\n    /* TODO: If validation fails, return the error code */\n    \n    /* TODO: Allocate buffer using allocate_device_buffer() */\n    /* TODO: If allocation fails, return the error code */\n    \n    /* TODO: Set dev->device_id = device_id */\n    /* TODO: Set dev->is_initialized = 1 */\n    /* TODO: Print \"Device %d initialized successfully\" */\n    /* TODO: Return 0 for success */\n    return -ENOSYS;\n}\n\n/* TODO: Implement safe cleanup */\nvoid cleanup_device(struct test_device *dev) {\n    /* TODO: Check if dev is NULL */\n    /* TODO: If NULL, return early */\n    /* TODO: If dev->buffer is not NULL, free it using kfree() */\n    /* TODO: Set dev->buffer = NULL */\n    /* TODO: Set dev->buffer_size = 0 */\n    /* TODO: Set dev->is_initialized = 0 */\n    /* TODO: Print \"Device cleaned up\" */\n}\n\n/* TODO: Implement error message conversion */\nconst char* get_error_message(int error_code) {\n    /* TODO: Use switch statement to convert error codes to messages */\n    /* TODO: Case -EINVAL: return \"Invalid argument\" */\n    /* TODO: Case -ENOMEM: return \"Out of memory\" */\n    /* TODO: Case -EBUSY: return \"Device busy\" */\n    /* TODO: Case -ENODEV: return \"No such device\" */\n    /* TODO: Case 0: return \"Success\" */\n    /* TODO: Default: return \"Unknown error\" */\n    return \"Not implemented\";\n}\n\n/* TODO: Implement complete device operation with error handling */\nint process_device_operation(int device_id, size_t buffer_size) {\n    /* TODO: Initialize device using initialize_device() */\n    /* TODO: If initialization fails, print error and return error code */\n    /* TODO: Print \"Device operation completed successfully\" */\n    /* TODO: Return 0 for success */\n    return -ENOSYS;\n}\n\nstatic int __init error_handler_init(void)\n{\n    int ret;\n    \n    printk(KERN_INFO \"Error handler module loaded\\n\");\n    \n    /* Test error handling with module parameters */\n    printk(KERN_INFO \"Testing error handling with device_id=%d, buffer_size=%d\\n\", \n           test_device_id, test_buffer_size);\n    \n    /* Process device operation */\n    ret = process_device_operation(test_device_id, test_buffer_size);\n    if (ret < 0) {\n        printk(KERN_ERR \"Device operation failed: %s\\n\", get_error_message(ret));\n    } else {\n        printk(KERN_INFO \"All operations completed successfully\\n\");\n    }\n    \n    return 0;\n}\n\nstatic void __exit error_handler_exit(void)\n{\n    printk(KERN_INFO \"Error handler module unloading\\n\");\n    \n    /* Clean up the device */\n    cleanup_device(&global_device);\n    \n    printk(KERN_INFO \"Error handler module unloaded\\n\");\n}\n\nmodule_init(error_handler_init);\nmodule_exit(error_handler_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning essential error handling patterns for kernel development\");\nMODULE_VERSION(\"1.0\");",
      "readOnly": false,
      "language": "c"
    },
    {
      "name": "Makefile",
      "content": "# Error handling module Makefile\nobj-m += error_handler.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
      "readOnly": true,
      "language": "makefile"
    }
  ],
  "concepts": [
    "standard error codes",
    "parameter validation",
    "memory allocation errors",
    "resource cleanup",
    "error propagation",
    "defensive programming"
  ],
  "skills": [
    "Using standard Linux error codes",
    "Implementing proper error checking",
    "Managing memory allocation failures",
    "Writing defensive kernel code",
    "Propagating errors correctly",
    "Cleaning up resources safely"
  ],
  "validation": {
    "exactRequirements": {
      "functionNames": [
        "error_handler_init",
        "error_handler_exit",
        "validate_device_id",
        "allocate_device_buffer",
        "initialize_device",
        "cleanup_device",
        "get_error_message",
        "process_device_operation"
      ],
      "function_declarations": [
        {
          "name": "validate_device_id",
          "returnType": "int",
          "parameters": ["int device_id"]
        },
        {
          "name": "allocate_device_buffer",
          "returnType": "int",
          "parameters": ["struct test_device *dev", "size_t size"]
        },
        {
          "name": "initialize_device",
          "returnType": "int",
          "parameters": ["struct test_device *dev", "int device_id", "size_t buffer_size"]
        },
        {
          "name": "cleanup_device",
          "returnType": "void",
          "parameters": ["struct test_device *dev"]
        },
        {
          "name": "get_error_message",
          "returnType": "const char*",
          "parameters": ["int error_code"]
        },
        {
          "name": "process_device_operation",
          "returnType": "int",
          "parameters": ["int device_id", "size_t buffer_size"]
        }
      ],
      "variables_declarations": [
        {
          "name": "test_device",
          "type": "struct",
          "value": "{int device_id; char *buffer; size_t buffer_size; int is_initialized;}",
          "storageClass": "none"
        },
        {
          "name": "global_device",
          "type": "struct test_device",
          "storageClass": "extern"
        }
      ],
      "variables": [
        {
          "name": "global_device",
          "type": "struct test_device",
          "storageClass": "none"
        },
        {
          "name": "test_device_id",
          "type": "int",
          "value": "100",
          "storageClass": "none"
        },
        {
          "name": "test_buffer_size",
          "type": "int",
          "value": "512",
          "storageClass": "none"
        }
      ],
      "outputMessages": [
        "Error handler module loaded",
        "Testing error handling with device_id=100, buffer_size=512",
        "Device ID 100 is valid",
        "Allocated buffer of size 512",
        "Device 100 initialized successfully",
        "Device operation completed successfully",
        "All operations completed successfully",
        "Error handler module unloading",
        "Device cleaned up",
        "Error handler module unloaded"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/types.h",
        "linux/slab.h",
        "linux/errno.h"
      ],
      "mustContain": [
        "kmalloc",
        "kfree",
        "-EINVAL",
        "-ENOMEM",
        "-EBUSY",
        "-ENODEV",
        "module_param(test_device_id, int, 0644)",
        "module_param(test_buffer_size, int, 0644)"
      ],
      "moduleInfo": {
        "license": "GPL"
      }
    },
    "testCases": [
      {
        "id": "function_declarations",
        "name": "Function Declarations in Header",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "int validate_device_id(int device_id)",
          "int allocate_device_buffer(struct test_device *dev, size_t size)",
          "int initialize_device(struct test_device *dev, int device_id, size_t buffer_size)",
          "void cleanup_device(struct test_device *dev)",
          "const char* get_error_message(int error_code)",
          "int process_device_operation(int device_id, size_t buffer_size)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "function_signatures_source",
        "name": "Function Signatures in Source File",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "int validate_device_id(int device_id)",
          "int allocate_device_buffer(struct test_device *dev, size_t size)",
          "int initialize_device(struct test_device *dev, int device_id, size_t buffer_size)",
          "void cleanup_device(struct test_device *dev)",
          "const char* get_error_message(int error_code)",
          "int process_device_operation(int device_id, size_t buffer_size)",
          "static int __init error_handler_init(void)",
          "static void __exit error_handler_exit(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "exact_output",
        "name": "Exact Output Messages",
        "type": "output_match",
        "critical": true,
        "expected": [
          {
            "pattern": "Error handler module loaded",
            "exact": true,
            "linkedFunction": "static int __init error_handler_init(void)"
          },
          {
            "pattern": "Testing error handling with device_id=100, buffer_size=512",
            "exact": true,
            "linkedFunction": "static int __init error_handler_init(void)"
          },
          {
            "pattern": "Device ID 100 is valid",
            "exact": true,
            "linkedFunction": "int validate_device_id(int device_id)"
          },
          {
            "pattern": "Allocated buffer of size 512",
            "exact": true,
            "linkedFunction": "int allocate_device_buffer(struct test_device *dev, size_t size)"
          },
          {
            "pattern": "Device 100 initialized successfully",
            "exact": true,
            "linkedFunction": "int initialize_device(struct test_device *dev, int device_id, size_t buffer_size)"
          },
          {
            "pattern": "Device operation completed successfully",
            "exact": true,
            "linkedFunction": "int process_device_operation(int device_id, size_t buffer_size)"
          },
          {
            "pattern": "All operations completed successfully",
            "exact": true,
            "linkedFunction": "static int __init error_handler_init(void)"
          },
          {
            "pattern": "Error handler module unloading",
            "exact": true,
            "linkedFunction": "static void __exit error_handler_exit(void)"
          },
          {
            "pattern": "Device cleaned up",
            "exact": true,
            "linkedFunction": "void cleanup_device(struct test_device *dev)"
          },
          {
            "pattern": "Error handler module unloaded",
            "exact": true,
            "linkedFunction": "static void __exit error_handler_exit(void)"
          }
        ]
      },
      {
        "id": "simple_error_handling_validation",
        "name": "Simple Error Handling Validation",
        "type": "kernel_project_test",
        "critical": true,
        "testScenario": {
          "userspaceApps": [
            {
              "name": "error_handling_tester",
              "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Error Handling Test ===\\\\n\\\");\\n    \\n    srand(time(NULL));\\n    \\n    int random_device_id = (rand() % 500) + 50;   // 50-549\\n    int random_buffer_size = (rand() % 700) + 300; // 300-999\\n    \\n    printf(\\\"Test: device_id=%d, buffer_size=%d\\\\n\\\", random_device_id, random_buffer_size);\\n    \\n    system(\\\"rmmod error_handler 2>/dev/null\\\");\\n    \\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/error_handler.ko test_device_id=%d test_buffer_size=%d\\\", random_device_id, random_buffer_size);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Error handling test completed\\\\n\\\");\\n    return 0;\\n}"
            }
          ],
          "setupCommands": [
            "echo 'Starting simple error handling validation'"
          ],
          "testCommands": [
            "echo 'Phase 1: TCC Header Validation'",
            "mkdir -p /tmp/linux",
            "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
            "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
            "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
            "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
            "echo '#define module_init(x)' >> /tmp/linux/module.h",
            "echo '#define module_exit(x)' >> /tmp/linux/module.h",
            "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
            "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
            "echo '#define __init' > /tmp/linux/init.h",
            "echo '#define __exit' >> /tmp/linux/init.h",
            "echo 'typedef unsigned long size_t;' > /tmp/linux/types.h",
            "echo '#define MAX_BUFFER_SIZE 1024' >> /tmp/linux/types.h",
            "echo 'void* kmalloc(size_t size, int flags);' > /tmp/linux/slab.h",
            "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
            "echo '#define GFP_KERNEL 0' >> /tmp/linux/slab.h",
            "echo '#define EINVAL 22' > /tmp/linux/errno.h",
            "echo '#define ENOMEM 12' >> /tmp/linux/errno.h",
            "echo '#define EBUSY 16' >> /tmp/linux/errno.h",
            "echo '#define ENODEV 19' >> /tmp/linux/errno.h",
            "echo '#define ENOSYS 38' >> /tmp/linux/errno.h",
            "echo '#include \"/lib/modules/error_handler.h\"' > /tmp/test.c",
            "echo 'int main() { struct test_device dev; validate_device_id(100); allocate_device_buffer(&dev, 512); initialize_device(&dev, 100, 512); cleanup_device(&dev); get_error_message(-22); process_device_operation(100, 512); return 0; }' >> /tmp/test.c",
            "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
            "TCC_EXIT_CODE=$?",
            "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing'; cat /tmp/tcc_error.log; else echo 'PASS: All declarations found'; fi",
            "echo 'Phase 2: Dynamic Error Handling Test'",
            "/bin/error_handling_tester > /tmp/test_output.log",
            "cat /tmp/test_output.log",
            "echo 'Phase 3: Error Handling Validation'",
            "sleep 1",
            "dmesg | grep 'Error handler module loaded' && echo 'PASS: Module loading' || echo 'FAIL: Module loading'",
            "dmesg | grep 'Device ID .* is valid' && echo 'PASS: Device validation' || echo 'FAIL: Device validation'",
            "dmesg | grep 'Allocated buffer of size' && echo 'PASS: Buffer allocation' || echo 'FAIL: Buffer allocation'",
            "dmesg | grep 'Device .* initialized successfully' && echo 'PASS: Device initialization' || echo 'FAIL: Device initialization'",
            "dmesg | grep 'Device operation completed successfully' && echo 'PASS: Operation completion' || echo 'FAIL: Operation completion'",
            "dmesg | grep 'All operations completed successfully' && echo 'PASS: All operations' || echo 'FAIL: All operations'",
            "dmesg | grep 'Device cleaned up' && echo 'PASS: Cleanup' || echo 'FAIL: Cleanup'",
            "dmesg | grep 'Error handler module unloaded' && echo 'PASS: Module unloading' || echo 'FAIL: Module unloading'",
            "echo 'PASS: All error handling validation successful'"
          ],
          "expected": {
            "dmesg": [
              "Error handler module loaded",
              "Testing error handling with device_id=.*, buffer_size=.*",
              "Device ID .* is valid",
              "Allocated buffer of size .*",
              "Device .* initialized successfully",
              "Device operation completed successfully",
              "All operations completed successfully",
              "Error handler module unloading",
              "Device cleaned up",
              "Error handler module unloaded"
            ],
            "stdout": [
              "PASS: All declarations found",
              "SUCCESS: Error handling test completed",
              "PASS: Module loading",
              "PASS: Device validation",
              "PASS: Buffer allocation",
              "PASS: Device initialization",
              "PASS: Operation completion",
              "PASS: All operations",
              "PASS: Cleanup",
              "PASS: Module unloading",
              "PASS: All error handling validation successful"
            ]
          },
          "timeout": 30
        }
      }
    ]
  }
}