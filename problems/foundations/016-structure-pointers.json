{
  "id": 16,
  "title": "Structure Pointers - Advanced Data Manipulation",
  "phase": "foundations",
  "difficulty": 5,
  "xp": 45,
  "description": "Learn essential pointer concepts by working with pointers to structures. Focus on arrow operator (->), address-of operator (&), and passing structures to functions by reference.",
  "mainFile": "struct_pointers.c",
  "files": [
    {
      "name": "struct_pointers.h",
      "content": "#ifndef STRUCT_POINTERS_H\n#define STRUCT_POINTERS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n#define MAX_NAME_LEN 32\n\n/* TODO: Define device_info structure with the following fields: */\n/* - char device_name[MAX_NAME_LEN] for storing device name */\n/* - int device_id for storing device identifier */\n/* - bool is_active for storing activation status */\n/* - int data_count for storing data counter */\n\nextern struct device_info my_device;\n\n/* TODO: Declare your functions that work with pointers */\n/* void print_device_info(struct device_info *dev); - prints all device information */\n/* void update_device_count(struct device_info *dev, int new_count); - updates device count */\n/* void activate_device(struct device_info *dev); - activates the device */\n\n#endif /* STRUCT_POINTERS_H */",
      "readOnly": false,
      "language": "h"
    },
    {
      "name": "struct_pointers.c",
      "content": "#include \"struct_pointers.h\"\n\n/* PATTERN SCAFFOLDING: How structure pointers work in C */\n/* Basic pattern for working with structure pointers:\n *\n * struct my_struct variable = {...};        // Create struct variable\n * struct my_struct* ptr = &variable;        // Get pointer to struct\n * ptr->field = value;                       // Access/modify through pointer\n *\n * This is like: variable → &variable → ptr->field\n */\n\n/* WHAT EACH EXPRESSION CONTAINS AND HOW TO USE IT: */\n\n/* 1. struct device_info my_device - Structure variable (actual data) */\n/*    Contains: The actual struct data in memory */\n/*    Usage: Direct access to fields: my_device.device_id */\n/*    Example: my_device.device_name contains the string \"sensor01\" */\n\n/* 2. struct device_info* dev - Pointer to structure */\n/*    Contains: Memory address pointing to the struct */\n/*    Usage: Access fields through arrow operator: dev->device_id */\n/*    Example: dev points to where my_device lives in memory */\n\n/* 3. &my_device - Address of the structure variable */\n/*    Contains: Memory address where my_device is stored */\n/*    Usage: Pass to functions that expect pointers */\n/*    Example: &my_device gives the address to pass to functions */\n\n/* STRUCTURE MEMBER ACCESS OPERATORS EXPLAINED: */\n\n/* DOT OPERATOR (.) - Used with structure variables: */\n/* my_device.device_id = 1001;               // Direct access to variable */\n/* my_device.is_active = true;               // Modifying field directly */\n/* Why dot? Because my_device IS the actual struct, not a pointer */\n\n/* ARROW OPERATOR (->) - Used with structure pointers: */\n/* dev->device_id = 1001;                    // Access through pointer */\n/* dev->is_active = true;                    // Modifying field through pointer */\n/* Why arrow? Because dev POINTS TO the struct, it's not the struct itself */\n\n/* ARROW OPERATOR IS ACTUALLY SHORTHAND: */\n/* dev->device_id  is exactly the same as  (*dev).device_id */\n/*  ↑ shorthand                              ↑ longhand */\n/* The arrow operator (->) is just a convenient way to write (*ptr).field */\n\n/* AMPERSAND OPERATOR (&) EXPLAINED FOR STRUCTURES: */\n/* & is the \"address-of\" operator - gets memory address of a variable */\n\n/* WHAT & PRODUCES WITH STRUCTURES: */\n/* my_device                    = The actual struct contents */\n/* &my_device                   = Pointer to where the struct is stored */\n/* */\n/* Example: */\n/* struct device_info my_device = {...};     // Struct variable */\n/* struct device_info* ptr = &my_device;     // Get pointer to the struct */\n\n/* WHY FUNCTIONS NEED POINTERS TO STRUCTURES: */\n/* Function parameter: void print_device_info(struct device_info *dev) */\n/*                                             ↑ expects a POINTER */\n/* */\n/* If we have: struct device_info my_device = {...}; */\n/* */\n/* CORRECT:   print_device_info(&my_device); */\n/*            ↑ pass address of the struct */\n/* */\n/* WRONG:     print_device_info(my_device); */\n/*            ↑ tries to pass struct contents instead of address */\n\n/* MEMORY LAYOUT VISUALIZATION FOR STRUCTURES: */\n/* Memory Address: 0x1000 */\n/* ┌─────────────────────────────────────────────────────┐ */\n/* │ my_device struct data lives here                    │ */\n/* │ [device_name: \"sensor01\"][device_id: 1001][......]  │ */\n/* └─────────────────────────────────────────────────────┘ */\n/*   ↑ */\n/*   This address (0x1000) is what &my_device gives us */\n\n/* WHAT EACH EXPRESSION EVALUATES TO: */\n/* my_device          = The actual struct contents (all fields together) */\n/* &my_device         = 0x1000 (the address where the struct is stored) */\n/* ptr = &my_device   = ptr now contains 0x1000 */\n/* ptr->device_id     = Access device_id field at address 0x1000 + offset */\n\n/* POINTER DEREFERENCING RELATIONSHIP: */\n/* If: struct device_info* ptr = &my_device; */\n/* Then: */\n/*   ptr                = Address of my_device (like 0x1000) */\n/*   *ptr               = Contents of my_device (entire struct) */\n/*   ptr->device_id     = my_device.device_id (same field) */\n/*   (*ptr).device_id   = my_device.device_id (same as arrow operator) */\n\n/* COMMON MISTAKES AND COMPILER ERRORS: */\n/* MISTAKE 1: Using dot instead of arrow with pointers */\n/*   struct device_info* dev = &my_device; */\n/*   dev.device_id = 1001;  // ERROR: dev is pointer, use -> not . */\n/* SOLUTION: */\n/*   dev->device_id = 1001;  // CORRECT: use -> with pointers */\n/* */\n/* MISTAKE 2: Using arrow instead of dot with variables */\n/*   my_device->device_id = 1001;  // ERROR: my_device is variable, use . not -> */\n/* SOLUTION: */\n/*   my_device.device_id = 1001;   // CORRECT: use . with variables */\n/* */\n/* MISTAKE 3: Forgetting & when passing to functions */\n/*   print_device_info(my_device);  // ERROR: function expects pointer */\n/* SOLUTION: */\n/*   print_device_info(&my_device); // CORRECT: pass address with & */\n\n/* PRACTICAL EXAMPLES IN STRUCTURE CONTEXT: */\n/* struct device_info my_device = {.device_name = \"sensor01\", .device_id = 1001}; */\n/* struct device_info* ptr = &my_device;     // ptr points to my_device */\n/* */\n/* printf(\"%s\", my_device.device_name);      // Direct access: \"sensor01\" */\n/* printf(\"%s\", ptr->device_name);           // Pointer access: \"sensor01\" */\n/* printf(\"%d\", my_device.device_id);        // Direct access: 1001 */\n/* printf(\"%d\", ptr->device_id);             // Pointer access: 1001 */\n\n/* IN OUR KERNEL CODE CONTEXT: */\n/* struct device_info my_device = {...};              // Global struct variable */\n/* void print_device_info(struct device_info *dev);  // Function takes pointer */\n/* */\n/* Inside init function: */\n/* print_device_info(&my_device);                     // Pass address to function */\n/* */\n/* Inside print_device_info function: */\n/* void print_device_info(struct device_info *dev) {  // dev is pointer parameter */\n/*     printk(\"Name: %s\", dev->device_name);           // Use -> to access fields */\n/*     printk(\"ID: %d\", dev->device_id);               // dev points to my_device */\n/* } */\n\n/* TODO: Initialize device structure */\n/* Use the pattern: struct device_info my_device = { .field = value, ... }; */\n/* Initialize with: device_name=\"sensor01\", device_id=1001, is_active=false, data_count=0 */\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your pointer operations work\n * with different input values. Removing them will cause test failures.\n */\nmodule_param_named(device_id, my_device.device_id, int, 0644);\nMODULE_PARM_DESC(device_id, \"Device ID for testing pointer member access\");\nmodule_param_named(data_count, my_device.data_count, int, 0644);\nMODULE_PARM_DESC(data_count, \"Initial data count for testing pointer operations\");\n/* Note: string and bool module params need special handling for structures */\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* TODO: Implement function to print device info using pointer */\nvoid print_device_info(struct device_info *dev) {\n    /* TODO: Print device name using dev->device_name */\n    /* TODO: Print device ID using dev->device_id */\n    /* TODO: Print device active status using dev->is_active */\n    /* TODO: Print data count using dev->data_count */\n    /* Use printk(KERN_INFO \"...\", ...) for each field */\n}\n\n/* TODO: Implement function to update device count via pointer */\nvoid update_device_count(struct device_info *dev, int new_count) {\n    /* TODO: Update dev->data_count to new_count value */\n    /* TODO: Print confirmation message with device name and new count */\n    /* Format: \"Device %s count updated to: %d\" */\n}\n\n/* TODO: Implement function to activate device via pointer */\nvoid activate_device(struct device_info *dev) {\n    /* TODO: Set dev->is_active to true */\n    /* TODO: Print confirmation message with device name */\n    /* Format: \"Device %s activated\" */\n}\n\n/* DETAILED EXPLANATION OF INIT FUNCTION - STEP BY STEP STRUCTURE POINTER ANALYSIS */\n/* This function demonstrates the complete structure pointer workflow with detailed explanations */\n\n/* UNDERSTANDING THE INIT FUNCTION CALLS: */\n/* printk(KERN_INFO \"Initial Device Information:\");  // Print header message */\n/* print_device_info(&my_device);                     // Pass structure address to function */\n/* update_device_count(&my_device, 5);               // Pass structure address + new value */\n/* activate_device(&my_device);                       // Pass structure address to function */\n/* */\n/* WHAT &my_device GIVES YOU: */\n/* - &my_device = address of the ENTIRE structure (not individual fields) */\n/* - Functions receive this address as a pointer parameter */\n/* */\n/* MEMORY LAYOUT VISUALIZATION: */\n/* Memory Address: 0x2000 */\n/* ┌─────────────────────────────────────────┐ */\n/* │ my_device struct (entire thing)         │ */\n/* │ ┌─────────────────────────────────────┐ │  ← &my_device points HERE (to start) */\n/* │ │ device_name: \"sensor01\"             │ │ */\n/* │ ├─────────────────────────────────────┤ │ */\n/* │ │ device_id: 1001                     │ │ */\n/* │ ├─────────────────────────────────────┤ │ */\n/* │ │ is_active: false                    │ │ */\n/* │ ├─────────────────────────────────────┤ │ */\n/* │ │ data_count: 0                       │ │ */\n/* │ └─────────────────────────────────────┘ │ */\n/* └─────────────────────────────────────────┘ */\n/* */\n/* SO &my_device POINTS TO: */\n/* - YES: The entire struct (including all fields: device_name, device_id, is_active, data_count) */\n/* - NO: NOT just one field or partial data */\n/* */\n/* INSIDE print_device_info(&my_device): */\n/* void print_device_info(struct device_info *dev) { */\n/*     // dev parameter contains 0x2000 (address of entire my_device struct) */\n/*  */\n/*     printk(\"Device Name: %s\", dev->device_name); */\n/*     // dev->device_name accesses the device_name field at address 0x2000 + offset */\n/*     // This works because dev points to the start of my_device! */\n/* } */\n/* */\n/* INSIDE update_device_count(&my_device, 5): */\n/* void update_device_count(struct device_info *dev, int new_count) { */\n/*     // dev parameter contains 0x2000 (same address as my_device) */\n/*  */\n/*     dev->data_count = new_count; */\n/*     // This DIRECTLY modifies my_device.data_count because dev points to my_device! */\n/*     // After this line, my_device.data_count will be 5 */\n/* } */\n/* */\n/* KEY POINT: */\n/* &my_device gives you the address of the WHOLE struct, not individual fields. */\n/* Functions receive this address as a pointer and can access/modify any field. */\n/* When functions modify fields through the pointer, they're directly modifying my_device! */\n/* */\n/* THE STRUCTURE POINTER CHAIN: */\n/* 1. my_device = actual struct variable with data */\n/* 2. &my_device = pointer to entire struct */\n/* 3. function parameter gets this address */\n/* 4. Inside function: use -> to access/modify fields */\n/* 5. Changes affect the original my_device struct */\n/* */\n/* So yes, the functions receive the address of the ENTIRE struct and can modify it directly! */\n\nstatic int __init struct_pointers_init(void)\n{\n    printk(KERN_INFO \"Structure pointers module loaded\\n\");\n    \n    /* TODO: Print \"Initial Device Information:\" message */\n    /* TODO: Call print_device_info() function with pointer to my_device */\n    /* Remember to use &my_device to get the address of the structure */\n    \n    /* TODO: Update device count to 5 using update_device_count() function */\n    /* Pass &my_device and the value 5 as parameters */\n    \n    /* TODO: Activate the device using activate_device() function */\n    /* Pass &my_device as parameter */\n    \n    /* TODO: Print \"Final Device Information:\" message */\n    /* TODO: Call print_device_info() again to show updated values */\n    \n    return 0;\n}\n\nstatic void __exit struct_pointers_exit(void)\n{\n    printk(KERN_INFO \"Structure pointers module unloaded\\n\");\n}\n\nmodule_init(struct_pointers_init);\nmodule_exit(struct_pointers_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning structure pointers and basic operations\");\nMODULE_VERSION(\"1.0\");",
      "readOnly": false,
      "language": "c"
    },
    {
      "name": "Makefile",
      "content": "# Structure pointers module Makefile\nobj-m += struct_pointers.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
      "readOnly": true,
      "language": "makefile"
    }
  ],
  "concepts": [
    "structure pointers",
    "pointer dereferencing", 
    "arrow operator (->)",
    "address-of operator (&)",
    "structure modification via pointers"
  ],
  "skills": [
    "Working with structure pointers",
    "Using arrow operator for member access",
    "Passing structures to functions by reference",
    "Modifying structures through pointers",
    "Understanding pointer-based data manipulation"
  ],
  "validation": {
    "exactRequirements": {
      "functionNames": ["struct_pointers_init", "struct_pointers_exit", "print_device_info", "update_device_count", "activate_device"],
      "function_declarations": [
        { "name": "print_device_info", "returnType": "void", "parameters": ["struct device_info *dev"] },
        { "name": "update_device_count", "returnType": "void", "parameters": ["struct device_info *dev", "int new_count"] },
        { "name": "activate_device", "returnType": "void", "parameters": ["struct device_info *dev"] }
      ],
      "variables_declarations": [
        { "name": "device_info", "type": "struct", "value": "{char device_name[MAX_NAME_LEN]; int device_id; bool is_active; int data_count;}", "storageClass": "none" },
        { "name": "my_device", "type": "struct device_info", "storageClass": "extern" }
      ],
      "variables": [
        { "name": "my_device", "type": "struct device_info", "value": "{.device_name = \"sensor01\", .device_id = 1001, .is_active = false, .data_count = 0}", "storageClass": "none" }
      ],
      "outputMessages": [
        "Structure pointers module loaded",
        "Initial Device Information:",
        "Device Name: sensor01",
        "Device ID: 1001",
        "Device Active: 0",
        "Data Count: 0",
        "Device sensor01 count updated to: 5",
        "Device sensor01 activated",
        "Final Device Information:",
        "Device Name: sensor01",
        "Device ID: 1001",
        "Device Active: 1",
        "Data Count: 5"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/types.h"
      ],
      "mustContain": [
        "struct device_info {",
        "extern struct device_info my_device",
        "struct device_info my_device = {",
        "&my_device",
        "module_param_named(device_id, my_device.device_id, int, 0644)",
        "module_param_named(data_count, my_device.data_count, int, 0644)"
      ],
      "moduleInfo": {
        "license": "GPL"
      }
    },
    "testCases": [
      {
        "id": "function_declarations",
        "name": "Function Declarations in Header",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "void print_device_info(struct device_info *dev)",
          "void update_device_count(struct device_info *dev, int new_count)",
          "void activate_device(struct device_info *dev)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "function_signatures_source",
        "name": "Function Signatures in Source File",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "void print_device_info(struct device_info *dev)",
          "void update_device_count(struct device_info *dev, int new_count)",
          "void activate_device(struct device_info *dev)",
          "static int __init struct_pointers_init(void)",
          "static void __exit struct_pointers_exit(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "exact_output",
        "name": "Exact Output Messages",
        "type": "output_match",
        "critical": true,
        "expected": [
          { "pattern": "Structure pointers module loaded", "exact": true, "linkedFunction": "static int __init struct_pointers_init(void)" },
          { "pattern": "Initial Device Information:", "exact": true, "linkedFunction": "static int __init struct_pointers_init(void)" },
          { "pattern": "Device Name: sensor01", "exact": true, "linkedFunction": "void print_device_info(struct device_info *dev)" },
          { "pattern": "Device ID: 1001", "exact": true, "linkedFunction": "void print_device_info(struct device_info *dev)" },
          { "pattern": "Device Active: 0", "exact": true, "linkedFunction": "void print_device_info(struct device_info *dev)" },
          { "pattern": "Data Count: 0", "exact": true, "linkedFunction": "void print_device_info(struct device_info *dev)" },
          { "pattern": "Device sensor01 count updated to: 5", "exact": true, "linkedFunction": "void update_device_count(struct device_info *dev, int new_count)" },
          { "pattern": "Device sensor01 activated", "exact": true, "linkedFunction": "void activate_device(struct device_info *dev)" },
          { "pattern": "Final Device Information:", "exact": true, "linkedFunction": "static int __init struct_pointers_init(void)" },
          { "pattern": "Device Name: sensor01", "exact": true, "linkedFunction": "void print_device_info(struct device_info *dev)" },
          { "pattern": "Device ID: 1001", "exact": true, "linkedFunction": "void print_device_info(struct device_info *dev)" },
          { "pattern": "Device Active: 1", "exact": true, "linkedFunction": "void print_device_info(struct device_info *dev)" },
          { "pattern": "Data Count: 5", "exact": true, "linkedFunction": "void print_device_info(struct device_info *dev)" }
        ]
      },
      {
        "id": "advanced_pointer_structure_validation",
        "name": "Advanced Pointer Structure Implementation with TCC Header Validation",
        "type": "kernel_project_test",
        "critical": true,
        "testScenario": {
          "userspaceApps": [
            {
              "name": "pointer_struct_tester",
              "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Pointer Structure Implementation Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random device data\\n    int test_id1 = (rand() % 9000) + 2000;  // 2000-10999\\n    int test_count1 = (rand() % 10) + 1;    // 1-10\\n    int test_id2 = (rand() % 9000) + 5000;  // 5000-13999\\n    int test_count2 = (rand() % 20) + 5;    // 5-24\\n    \\n    printf(\\\"Test 1: Testing with device_id=%d, data_count=%d\\\\n\\\", test_id1, test_count1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/struct_pointers.ko device_id=%d data_count=%d\\\", test_id1, test_count1);\\n    system(\\\"rmmod struct_pointers 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Testing with device_id=%d, data_count=%d\\\\n\\\", test_id2, test_count2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/struct_pointers.ko device_id=%d data_count=%d\\\", test_id2, test_count2);\\n    system(\\\"rmmod struct_pointers\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Dynamic pointer structure test completed\\\\n\\\");\\n    return 0;\\n}"
            }
          ],
          "setupCommands": [
            "echo 'Starting advanced pointer structure implementation validation'"
          ],
          "testCommands": [
            "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
            "echo 'Creating minimal kernel header stubs for TCC...'",
            "mkdir -p /tmp/linux",
            "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
            "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
            "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
            "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
            "echo '#define module_init(x)' >> /tmp/linux/module.h",
            "echo '#define module_exit(x)' >> /tmp/linux/module.h",
            "echo '#define __init' > /tmp/linux/init.h",
            "echo '#define __exit' >> /tmp/linux/init.h",
            "echo 'typedef int bool;' > /tmp/linux/types.h",
            "echo '#define true 1' >> /tmp/linux/types.h",
            "echo '#define false 0' >> /tmp/linux/types.h",
            "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
            "echo 'Creating test file that includes pointer structure header...'",
            "echo '#include \"/lib/modules/struct_pointers.h\"' > /tmp/test.c",
            "echo 'int main() { my_device.device_id = 888; print_device_info(&my_device); update_device_count(&my_device, 10); activate_device(&my_device); return 0; }' >> /tmp/test.c",
            "echo 'Running TCC validation...'",
            "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
            "TCC_EXIT_CODE=$?",
            "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
            "echo 'Phase 2: Dynamic Pointer Structure Implementation Testing'",
            "/bin/pointer_struct_tester > /tmp/test_output.log",
            "cat /tmp/test_output.log",
            "echo 'Phase 3: Dynamic Value Extraction and Validation'",
            "echo 'Adding delay to ensure dmesg messages are written...'",
            "sleep 1",
            "echo 'Extracting random test values from output...'",
            "TEST1_ID=$(grep -o 'Test 1: Testing with device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
            "TEST1_COUNT=$(grep -o 'data_count=[0-9]*' /tmp/test_output.log | head -1 | cut -d'=' -f2)",
            "TEST2_ID=$(grep -o 'Test 2: Testing with device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
            "TEST2_COUNT=$(grep -o 'data_count=[0-9]*' /tmp/test_output.log | tail -1 | cut -d'=' -f2)",
            "echo 'Test values: ID1='$TEST1_ID', Count1='$TEST1_COUNT', ID2='$TEST2_ID', Count2='$TEST2_COUNT",
            "echo 'Validating pointer-based structure member access with dynamic values'",
            "dmesg | grep 'Device ID: '$TEST1_ID && echo 'PASS: Pointer access to device_id working with '$TEST1_ID || echo 'FAIL: Pointer access to device_id broken for '$TEST1_ID",
            "dmesg | grep 'Device Name: sensor01' && echo 'PASS: Pointer access to device_name working' || echo 'FAIL: Pointer access to device_name broken'",
            "dmesg | grep 'Data Count: '$TEST1_COUNT && echo 'PASS: Initial data_count from module param '$TEST1_COUNT || echo 'FAIL: Module parameter data_count not working'",
            "dmesg | grep 'Device ID: '$TEST2_ID && echo 'PASS: Pointer access to device_id working with '$TEST2_ID || echo 'FAIL: Pointer access to device_id broken for '$TEST2_ID",
            "echo 'Phase 3.1: Function Logic Validation'",
            "dmesg | grep 'Device sensor01 count updated to: 5' && echo 'PASS: update_device_count function message works' || echo 'FAIL: update_device_count message broken'",
            "dmesg | grep 'Data Count: 5' && echo 'PASS: update_device_count actually modified struct data_count to 5' || echo 'FAIL: update_device_count function logic broken - struct not modified'",
            "dmesg | grep 'Device sensor01 activated' && echo 'PASS: activate_device function message works' || echo 'FAIL: activate_device message broken'",
            "dmesg | grep 'Device Active: 1' && echo 'PASS: activate_device actually modified struct is_active to true' || echo 'FAIL: activate_device function logic broken - struct not modified'",
            "echo 'Phase 3.2: Final State Validation'",
            "dmesg | grep 'Final Device Information:' && echo 'PASS: Final print_device_info called' || echo 'FAIL: Final print_device_info not called'",
            "dmesg | grep 'Data Count: 5' && echo 'PASS: Final state data_count is correct' || echo 'FAIL: Final data_count wrong'",
            "dmesg | grep 'Device Active: 1' && echo 'PASS: Final state is_active is correct' || echo 'FAIL: Final is_active wrong'",
            "echo 'Phase 4: Structure Definition Validation'",
            "dmesg | grep 'Structure pointers module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
            "echo 'All pointer structure implementation validations completed'"
          ],
          "expected": {
            "dmesg": [
              "Structure pointers module loaded",
              "Device Name: sensor01",
              "Device ID: .*",
              "Data Count: .*",
              "Device sensor01 count updated to: 5",
              "Device sensor01 activated",
              "Device Active: 1"
            ],
            "stdout": [
              "PASS: All function and variable declarations found in header file",
              "SUCCESS: Dynamic pointer structure test completed",
              "PASS: Pointer access to device_id working with .*",
              "PASS: Pointer access to device_name working",
              "PASS: Initial data_count from module param .*",
              "PASS: update_device_count function message works",
              "PASS: update_device_count actually modified struct data_count to 5",
              "PASS: activate_device function message works",
              "PASS: activate_device actually modified struct is_active to true",
              "PASS: Final print_device_info called",
              "PASS: Final state data_count is correct",
              "PASS: Final state is_active is correct"
            ]
          },
          "timeout": 15
        }
      }
    ]
  }
}
