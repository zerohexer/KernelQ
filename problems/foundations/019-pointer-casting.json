{
  "id": 19,
  "title": "Pointer Casting - Multi-Level Type Conversion Mastery",
  "phase": "foundations",
  "difficulty": 7,
  "xp": 60,
  "description": "Master multi-level pointer casting chains: void* → generic_record* → sensor_record*. Learn the exact patterns used in production kernel parsers for safe type conversion and record processing.",
  "mainFile": "pointer_casting.c",
  "files": [
    {
      "name": "pointer_casting.h",
      "content": "#ifndef POINTER_CASTING_H\n#define POINTER_CASTING_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n#define MAX_NAME_LEN 32\n\n/* Record type constants */\n#define SENSOR_RECORD 1\n#define DEVICE_RECORD 2\n\n/* Base record header (like rec_header) */\ntypedef struct {\n    uint8_t rec_type;\n    uint8_t rec_subtype;\n    uint16_t rec_length;\n} record_header;\n\n/* Generic record (like rec_unknown) */\ntypedef struct {\n    record_header header;\n    void* data;\n} generic_record;\n\n/* Specific record types (like rec_ptr, rec_mpr) */\ntypedef struct {\n    record_header header;\n    uint32_t sensor_id;\n    char sensor_name[MAX_NAME_LEN];\n    uint32_t measurement_value;\n} sensor_record;\n\ntypedef struct {\n    record_header header;\n    uint32_t device_id;\n    char device_status[MAX_NAME_LEN];\n    bool is_active;\n} device_record;\n\n/* Global record pointers for testing */\nextern generic_record *current_record;\nextern sensor_record *sensor_data;\nextern device_record *device_data;\n\n/* TODO: Declare your functions */\n/* void process_generic_record(void *raw_record); */\n/* void extract_sensor_data(generic_record *rec); */\n/* void extract_device_data(generic_record *rec); */\n/* void print_record_info(void); */\n\n#endif /* POINTER_CASTING_H */",
      "readOnly": false,
      "language": "h"
    },
    {
      "name": "pointer_casting.c",
      "content": "#include \"pointer_casting.h\"\n\n/* Global record pointers initialized to NULL */\ngeneric_record *current_record = NULL;\nsensor_record *sensor_data = NULL;\ndevice_record *device_data = NULL;\n\nint test_record_type = SENSOR_RECORD;\nint test_sensor_id = 1001;\nint test_measurement = 257;\nint test_device_id = 2001;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your casting logic works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(test_record_type, int, 0644);\nMODULE_PARM_DESC(test_record_type, \"Record type for testing casting logic\");\nmodule_param(test_sensor_id, int, 0644);\nMODULE_PARM_DESC(test_sensor_id, \"Sensor ID for anti-hardcoding testing\");\nmodule_param(test_measurement, int, 0644);\nMODULE_PARM_DESC(test_measurement, \"Measurement value for anti-hardcoding testing\");\nmodule_param(test_device_id, int, 0644);\nMODULE_PARM_DESC(test_device_id, \"Device ID for anti-hardcoding testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: How multi-level pointer casting works in C */\n/* Basic pattern for casting pointers step by step:\n *\n * void* raw_ptr = get_generic_pointer();\n * generic_record* rec = (generic_record*)raw_ptr;  // Cast void* to generic type\n * sensor_record* sensor = (sensor_record*)rec;     // Cast generic to specific type\n *\n * This is like: void* → generic_record* → sensor_record*\n */\n\n/* WHAT EACH POINTER CONTAINS AND HOW TO USE IT: */\n\n/* 1. void* raw_ptr - Generic pointer (can point to ANY data type) */\n/*    Contains: Memory address, but no type information */\n/*    Usage: Cannot access fields directly - MUST cast first */\n/*    Example: raw_ptr points to memory, but raw_ptr->header won't work */\n\n/* 2. generic_record* rec - Pointer to generic record structure */\n/*    Contains: Same memory address, but now treats it as generic_record */\n/*    Usage: Can access generic fields: rec->header.rec_type, rec->data */\n/*    Example: rec->header.rec_type tells us if it's SENSOR or DEVICE */\n\n/* 3. sensor_record* sensor - Pointer to specific sensor record structure */\n/*    Contains: Same memory address, now treated as sensor_record */\n/*    Usage: Can access sensor fields: sensor->sensor_id, sensor->measurement_value */\n/*    Example: sensor->sensor_id gets the specific sensor ID number */\n\n/* HOW STRUCT-TO-STRUCT CASTING WORKS: */\n/* All structs start with same header layout: */\n/* generic_record: [header][data*]          <- Generic view */\n/* sensor_record:  [header][sensor_id][...] <- Specific view */\n/* device_record:  [header][device_id][...] <- Specific view */\n/* Same memory, different interpretation! */\n\n/* CASTING OPERATORS EXPLAINED: */\n/* (type_name*)pointer means \"treat this pointer as type_name*\" */\n/* Example: (sensor_record*)rec means \"treat rec as sensor_record*\" */\n/*          ↑ target type     ↑ source pointer */\n/* Why cast? To change how we interpret the memory structure */\n\n/* AMPERSAND OPERATOR (&) EXPLAINED IN DETAIL: */\n/* & is the \"address-of\" operator - it gets the memory address of a variable */\n\n/* WHAT & PRODUCES AND WHY WE NEED IT: */\n/* 1. &variable - Gets the memory address where variable is stored */\n/*    Contains: The actual memory address (like 0x7fff1234) */\n/*    Usage: Converts a variable into a pointer to that variable */\n/*    Example: &test_sensor_record gives the address where test_sensor_record lives */\n\n/* 2. variable (without &) - The actual data/contents of the variable */\n/*    Contains: The struct data itself (all the fields and values) */\n/*    Usage: Direct access to the variable's contents */\n/*    Example: test_sensor_record gives you the actual struct contents */\n\n/* WHY FUNCTIONS NEED POINTERS (ADDRESSES) NOT VALUES: */\n/* Function parameter: void process_record(void* raw_record) */\n/*                                          ↑ expects a POINTER (address) */\n/* */\n/* If we have: static generic_record test_sensor_record = {...}; */\n/* */\n/* CORRECT:   process_record((void*)&test_sensor_record); */\n/*            ↑ cast to void*  ↑ get address of the struct */\n/* */\n/* WRONG:     process_record((void*)test_sensor_record); */\n/*            ↑ tries to cast struct contents to pointer - INVALID! */\n\n/* MEMORY LAYOUT VISUALIZATION: */\n/* Memory Address: 0x1000                                    */\n/* ┌─────────────────────────────────────────────────────┐  */\n/* │ test_sensor_record struct data lives here           │  */\n/* │ [rec_type: 1][rec_subtype: 1][rec_length: 48][...] │  */\n/* └─────────────────────────────────────────────────────┘  */\n/*   ↑                                                       */\n/*   This address (0x1000) is what &test_sensor_record gives us */\n\n/* WHAT EACH EXPRESSION EVALUATES TO: */\n/* test_sensor_record      = The actual struct contents (can't fit in a pointer!) */\n/* &test_sensor_record     = 0x1000 (the address - this fits in a pointer!) */\n/* (void*)&test_sensor_record = 0x1000 cast as void* (what the function wants!) */\n\n/* THE & AND * RELATIONSHIP: */\n/* & = \"address of\" operator (gets address from variable) */\n/* * = \"dereference\" operator (gets value from address) */\n/* */\n/* If: generic_record* ptr = &test_sensor_record; */\n/* Then: *ptr gives you back the original test_sensor_record contents */\n/* And: ptr gives you the address (same as &test_sensor_record) */\n\n/* COMMON MISTAKES AND COMPILER ERRORS: */\n/* ERROR: test_record = (void*)test_sensor_record; */\n/* Compiler says: \"cannot convert 'generic_record' to 'void*'\" */\n/* Why? Because test_sensor_record is struct data, not an address */\n/* */\n/* CORRECT: test_record = (void*)&test_sensor_record; */\n/* Compiler happy: &test_sensor_record is an address, void* expects address */\n\n/* PRACTICAL EXAMPLES: */\n/* int x = 42; */\n/* int* ptr = &x;          // ptr now contains address of x */\n/* print(\"%p\", &x);       // Prints address like 0x7fff1234 */\n/* print(\"%d\", x);        // Prints value: 42 */\n/* print(\"%d\", *ptr);     // Prints value through pointer: 42 */\n\n/* IN OUR KERNEL CODE CONTEXT: */\n/* static generic_record test_sensor_record = {...}; // Struct variable */\n/* void* test_record = (void*)&test_sensor_record;   // Get its address */\n/* process_generic_record(test_record);              // Pass address to function */\n/* */\n/* Inside process_generic_record(void* raw_record): */\n/* generic_record* rec = (generic_record*)raw_record; // Cast address back to typed pointer */\n/* // Now rec points to our original test_sensor_record! */\n\n/* Predefined sensor record for testing */\nstatic sensor_record test_sensor = {\n    .header = { .rec_type = SENSOR_RECORD, .rec_subtype = 1, .rec_length = 48 },\n    .sensor_id = 1001,\n    .sensor_name = \"temperature_01\",\n    .measurement_value = 257\n};\n\n/* Predefined device record for testing */\nstatic device_record test_device = {\n    .header = { .rec_type = DEVICE_RECORD, .rec_subtype = 1, .rec_length = 52 },\n    .device_id = 2001,\n    .device_status = \"operational\",\n    .is_active = true\n};\n\n/* TODO: Implement multi-level casting function */\n/* Use the pattern above: void* → generic_record* → specific_record* */\nvoid process_generic_record(void *raw_record) {\n    /* WHY WE NEED THIS CASTING CHAIN: */\n    /* */\n    /* When we call this function from init: */\n    /* process_generic_record((void*)&test_sensor); */\n    /*                        ↑                    */\n    /*                        Cast sensor_record* to void* first */\n    /* */\n    /* STEP-BY-STEP EXPLANATION: */\n    /* 1. test_sensor is type: sensor_record */\n    /* 2. &test_sensor is type: sensor_record* (pointer to sensor_record) */\n    /* 3. (void*)&test_sensor is type: void* (generic pointer) */\n    /* 4. Function parameter raw_record receives: void* (generic pointer) */\n    /* */\n    /* INSIDE THIS FUNCTION - THE REVERSE JOURNEY: */\n    /* 5. raw_record is type: void* (we lost the original type information) */\n    /* 6. Cast to generic_record*: (generic_record*)raw_record */\n    /* 7. Now we can access header: rec->header.rec_type */\n    /* 8. Based on rec_type, cast to specific type: (sensor_record*)rec */\n    /* */\n    /* WHY THIS WORKS - MEMORY LAYOUT COMPATIBILITY: */\n    /* All record types start with the SAME header layout: */\n    /* sensor_record:  [header][sensor_id][measurement_value][sensor_name] */\n    /* device_record:  [header][device_id][device_status][is_active] */\n    /* generic_record: [header][data*] */\n    /*                  ↑ Same header in all types! */\n    /* */\n    /* So casting between them is safe for accessing the header portion */\n    \n    // TODO: Step 1: Cast void* raw_record to generic_record* (so we can access header)\n    // TODO: Step 2: Check header.rec_type to determine what kind of record this is\n    // TODO: Step 3: Route to extract_sensor_data() or extract_device_data() based on record type (use if or switch statement)\n    // Your implementation here\n}\n\n/* TODO: Implement sensor data extraction */\nvoid extract_sensor_data(generic_record *rec) {\n    // Cast generic_record* rec to sensor_record*\n    // Store sensor data and print information\n    // Your implementation here\n}\n\n/* TODO: Implement device data extraction */\nvoid extract_device_data(generic_record *rec) {\n    // Cast generic_record* rec to device_record*\n    // Store device data and print information\n    // Your implementation here\n}\n\nvoid print_record_info(void) {\n    if (!current_record) {\n        printk(KERN_ERR \"No current record available\\n\");\n        return;\n    }\n    \n    printk(KERN_INFO \"Current Record Info:\\n\");\n    \n    printk(KERN_INFO \"Record Subtype: %u\\n\", current_record->header.rec_subtype);\n    printk(KERN_INFO \"Record Type: %u\\n\", current_record->header.rec_type);\n    printk(KERN_INFO \"Record Length: %u\\n\", current_record->header.rec_length);\n}\n\n/* DETAILED EXPLANATION OF INIT FUNCTION - STEP BY STEP MEMORY ANALYSIS */\n/* This function demonstrates the complete casting chain with detailed memory explanations */\n\n/* UNDERSTANDING THE INIT FUNCTION CALLS: */\n/* test_sensor.sensor_id = test_sensor_id;        // Modify struct fields */\n/* test_sensor.measurement_value = test_measurement; */\n/* test_record = (void *)&test_sensor;           // Get address of entire struct */\n/* process_generic_record(test_record);          // Pass address to function */\n/* */\n/* WHAT &test_sensor GIVES YOU: */\n/* - &test_sensor = address of the ENTIRE struct (not just sensor_id) */\n/* - test_record = pointer to the whole struct */\n/* */\n/* MEMORY LAYOUT VISUALIZATION: */\n/* Memory Address: 0x1000 */\n/* ┌─────────────────────────────────────────┐ */\n/* │ test_sensor struct (entire thing)       │ */\n/* │ ┌─────────────────────────────────────┐ │  ← &test_sensor points HERE (to start) */\n/* │ │ header: {rec_type=1, subtype=1...} │ │ */\n/* │ ├─────────────────────────────────────┤ │ */\n/* │ │ sensor_id: 1001                     │ │ */\n/* │ ├─────────────────────────────────────┤ │ */\n/* │ │ sensor_name: \\\"temperature_01\\\"       │ │ */\n/* │ ├─────────────────────────────────────┤ │ */\n/* │ │ measurement_value: 257              │ │ */\n/* │ └─────────────────────────────────────┘ │ */\n/* └─────────────────────────────────────────┘ */\n/* */\n/* SO test_record POINTS TO: */\n/* - YES: The entire struct (including header, sensor_id, sensor_name, measurement_value) */\n/* - NO: NOT just sensor_id and measurement_value */\n/* */\n/* INSIDE process_generic_record(test_record): */\n/* void process_generic_record(void *raw_record) { */\n/*     // raw_record contains 0x1000 (address of entire test_sensor struct) */\n/*  */\n/*     generic_record *rec = (generic_record *)raw_record; */\n/*     // Now rec points to the same location, but treated as generic_record */\n/*  */\n/*     rec->header.rec_type;  // Accesses the header part */\n/*     // This works because both sensor_record and generic_record  */\n/*     // start with the same header layout! */\n/* } */\n/* */\n/* KEY POINT: */\n/* &test_sensor gives you the address of the WHOLE struct, not individual fields. */\n/* The function receives a pointer to the entire struct and can access any field within it. */\n/* */\n/* THE CASTING CHAIN: */\n/* 1. test_sensor = actual struct variable */\n/* 2. &test_sensor = pointer to entire struct */\n/* 3. (void *)&test_sensor = same pointer, but cast as generic void* */\n/* 4. Inside function: cast back to access fields */\n/* */\n/* So yes, test_record is a pointer, but it points to the ENTIRE struct, giving access to all fields! */\n\nstatic int __init pointer_casting_init(void)\n{\n    void *test_record;\n    \n    printk(KERN_INFO \"Pointer casting module loaded\\n\");\n    \n    /* Test both sensor and device records for comprehensive validation */\n    \n    /* First test: Sensor record with dynamic parameter values */\n    test_sensor.sensor_id = test_sensor_id;        /* Modify struct fields */\n    test_sensor.measurement_value = test_measurement;\n    test_record = (void *)&test_sensor;           /* Get address of entire struct */\n    process_generic_record(test_record);          /* Pass address to function */\n    print_record_info();\n    \n    /* Second test: Device record with dynamic parameter values */\n    test_device.device_id = test_device_id;       /* Modify struct fields */\n    test_record = (void *)&test_device;           /* Get address of entire struct */\n    process_generic_record(test_record);          /* Pass address to function */\n    print_record_info();\n    \n    return 0;\n}\n\nstatic void __exit pointer_casting_exit(void)\n{\n    printk(KERN_INFO \"Pointer casting module unloaded\\n\");\n    \n    /* Reset pointers */\n    current_record = NULL;\n    sensor_data = NULL;\n    device_data = NULL;\n}\n\nmodule_init(pointer_casting_init);\nmodule_exit(pointer_casting_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning multi-level pointer casting and type conversion\");\nMODULE_VERSION(\"1.0\");",
      "readOnly": false,
      "language": "c"
    },
    {
      "name": "Makefile",
      "content": "# Pointer casting module Makefile\nobj-m += pointer_casting.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
      "readOnly": true,
      "language": "makefile"
    }
  ],
  "concepts": [
    "multi-level pointer casting",
    "void* generic pointers",
    "type-safe casting patterns",
    "polymorphic C structures",
    "record header patterns",
    "production parsing techniques"
  ],
  "skills": [
    "Casting void* to specific types safely",
    "Understanding pointer type conversion",
    "Implementing polymorphic C patterns",
    "Using casting chains like libstdf",
    "Professional kernel development practices",
    "Type safety validation"
  ],
  "validation": {
    "exactRequirements": {
      "functionNames": [
        "pointer_casting_init",
        "pointer_casting_exit",
        "process_generic_record",
        "extract_sensor_data",
        "extract_device_data",
        "print_record_info"
      ],
      "function_declarations": [
        {
          "name": "process_generic_record",
          "returnType": "void",
          "parameters": [
            "void *raw_record"
          ]
        },
        {
          "name": "extract_sensor_data",
          "returnType": "void",
          "parameters": [
            "generic_record *rec"
          ]
        },
        {
          "name": "extract_device_data",
          "returnType": "void",
          "parameters": [
            "generic_record *rec"
          ]
        },
        {
          "name": "print_record_info",
          "returnType": "void",
          "parameters": []
        }
      ],
      "variables_declarations": [
        {
          "name": "record_header",
          "type": "typedef struct",
          "value": "{uint8_t rec_type; uint8_t rec_subtype; uint16_t rec_length;}",
          "storageClass": "none"
        },
        {
          "name": "generic_record",
          "type": "typedef struct",
          "value": "{record_header header; void* data;}",
          "storageClass": "none"
        },
        {
          "name": "sensor_record",
          "type": "typedef struct",
          "value": "{record_header header; uint32_t sensor_id; char sensor_name[MAX_NAME_LEN]; uint32_t measurement_value;}",
          "storageClass": "none"
        },
        {
          "name": "device_record",
          "type": "typedef struct",
          "value": "{record_header header; uint32_t device_id; char device_status[MAX_NAME_LEN]; bool is_active;}",
          "storageClass": "none"
        },
        {
          "name": "current_record",
          "type": "generic_record *",
          "storageClass": "extern"
        },
        {
          "name": "sensor_data",
          "type": "sensor_record *",
          "storageClass": "extern"
        },
        {
          "name": "device_data",
          "type": "device_record *",
          "storageClass": "extern"
        }
      ],
      "variables": [
        {
          "name": "current_record",
          "type": "generic_record *",
          "value": "NULL",
          "storageClass": "none"
        },
        {
          "name": "sensor_data",
          "type": "sensor_record *",
          "value": "NULL",
          "storageClass": "none"
        },
        {
          "name": "device_data",
          "type": "device_record *",
          "value": "NULL",
          "storageClass": "none"
        }
      ],
      "outputMessages": [
        "Pointer casting module loaded",
        "Sensor Record Extracted",
        "Sensor ID: 1001",
        "Sensor Name: temperature_01",
        "Measurement: 257",
        "Current Record Info:",
        "Record Type: 1",
        "Record Subtype: 1",
        "Record Length: 48",
        "Device Record Extracted",
        "Device ID: 2001",
        "Device Status: operational",
        "Active: true",
        "Current Record Info:",
        "Record Type: 2",
        "Record Subtype: 1",
        "Record Length: 52",
        "Pointer casting module unloaded"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/types.h"
      ],
      "mustContain": [
        "generic_record *rec = (generic_record *)raw_record",
        "sensor_record *sensor = (sensor_record *)rec",
        "device_record *device = (device_record *)rec",
        "current_record = rec",
        "sensor_data = sensor",
        "device_data = device",
        "if (rec->header.rec_type == SENSOR_RECORD)",
        "module_param(test_record_type, int, 0644)",
        "module_param(test_sensor_id, int, 0644)",
        "module_param(test_measurement, int, 0644)",
        "module_param(test_device_id, int, 0644)"
      ],
      "moduleInfo": {
        "license": "GPL"
      }
    },
    "testCases": [
      {
        "id": "function_declarations",
        "name": "Function Declarations in Header",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "void process_generic_record(void *raw_record)",
          "void extract_sensor_data(generic_record *rec)",
          "void extract_device_data(generic_record *rec)",
          "void print_record_info(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "function_signatures_source",
        "name": "Function Signatures in Source File",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "void process_generic_record(void *raw_record)",
          "void extract_sensor_data(generic_record *rec)",
          "void extract_device_data(generic_record *rec)",
          "void print_record_info(void)",
          "static int __init pointer_casting_init(void)",
          "static void __exit pointer_casting_exit(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "exact_output",
        "name": "Exact Output Messages",
        "type": "output_match",
        "critical": true,
        "expected": [
          {
            "pattern": "Pointer casting module loaded",
            "exact": true,
            "linkedFunction": "static int __init pointer_casting_init(void)"
          },
          {
            "pattern": "Sensor Record Extracted",
            "exact": true,
            "linkedFunction": "void extract_sensor_data(generic_record *rec)"
          },
          {
            "pattern": "Sensor ID: 1001",
            "exact": true,
            "linkedFunction": "void extract_sensor_data(generic_record *rec)"
          },
          {
            "pattern": "Sensor Name: temperature_01",
            "exact": true,
            "linkedFunction": "void extract_sensor_data(generic_record *rec)"
          },
          {
            "pattern": "Measurement: 257",
            "exact": true,
            "linkedFunction": "void extract_sensor_data(generic_record *rec)"
          },
          {
            "pattern": "Current Record Info:",
            "exact": true,
            "linkedFunction": "void print_record_info(void)"
          },
          {
            "pattern": "Record Type: 1",
            "exact": true,
            "linkedFunction": "void print_record_info(void)"
          },
          {
            "pattern": "Record Subtype: 1",
            "exact": true,
            "linkedFunction": "void print_record_info(void)"
          },
          {
            "pattern": "Record Length: 48",
            "exact": true,
            "linkedFunction": "void print_record_info(void)"
          },
          {
            "pattern": "Device Record Extracted",
            "exact": true,
            "linkedFunction": "void extract_device_data(generic_record *rec)"
          },
          {
            "pattern": "Device ID: 2001",
            "exact": true,
            "linkedFunction": "void extract_device_data(generic_record *rec)"
          },
          {
            "pattern": "Device Status: operational",
            "exact": true,
            "linkedFunction": "void extract_device_data(generic_record *rec)"
          },
          {
            "pattern": "Active: true",
            "exact": true,
            "linkedFunction": "void extract_device_data(generic_record *rec)"
          },
          {
            "pattern": "Current Record Info:",
            "exact": true,
            "linkedFunction": "void print_record_info(void)"
          },
          {
            "pattern": "Record Type: 2",
            "exact": true,
            "linkedFunction": "void print_record_info(void)"
          },
          {
            "pattern": "Record Subtype: 1",
            "exact": true,
            "linkedFunction": "void print_record_info(void)"
          },
          {
            "pattern": "Record Length: 52",
            "exact": true,
            "linkedFunction": "void print_record_info(void)"
          },
          {
            "pattern": "Pointer casting module unloaded",
            "exact": true,
            "linkedFunction": "static void __exit pointer_casting_exit(void)"
          }
        ]
      },
      {
        "id": "advanced_casting_validation",
        "name": "Advanced Multi-Level Casting Implementation with Anti-Hardcoding Protection",
        "type": "kernel_project_test",
        "critical": true,
        "testScenario": {
          "userspaceApps": [
            {
              "name": "casting_dynamic_tester",
              "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Anti-Hardcoding Casting Test ===\\\\n\\\");\\n    \\n    // Seed random number generator with current time\\n    srand(time(NULL));\\n    \\n    // Generate unpredictable sensor test values\\n    int random_sensor_id = (rand() % 9000) + 1000;  // 1000-9999\\n    int random_measurement = (rand() % 500) + 100;   // 100-599\\n    \\n    // Generate unpredictable device test values\\n    int random_device_id = (rand() % 8000) + 2000;  // 2000-9999\\n    \\n    printf(\\\"Test 1: Random sensor casting (ID=%d, measurement=%d)\\\\n\\\", random_sensor_id, random_measurement);\\n    printf(\\\"Test 2: Random device casting (ID=%d)\\\\n\\\", random_device_id);\\n    \\n    // Test sensor record casting with random values\\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod pointer_casting 2>/dev/null\\\");\\n    \\n    char cmd1[512];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/pointer_casting.ko test_record_type=1 test_sensor_id=%d test_measurement=%d\\\", random_sensor_id, random_measurement);\\n    printf(\\\"DEBUG: Sensor command: %s\\\\n\\\", cmd1);\\n    system(cmd1);\\n    \\n    \\n    // Test device record casting with random values\\n    printf(\\\"DEBUG: Switching to device test...\\\\n\\\");\\n    system(\\\"rmmod pointer_casting\\\");\\n    \\n    char cmd2[512];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/pointer_casting.ko test_record_type=2 test_device_id=%d\\\", random_device_id);\\n    printf(\\\"DEBUG: Device command: %s\\\\n\\\", cmd2);\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Anti-hardcoding casting test completed\\\\n\\\");\\n    return 0;\\n}"
            }
          ],
          "setupCommands": [
            "echo 'Starting advanced multi-level casting implementation validation'"
          ],
          "testCommands": [
            "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
            "echo 'Creating minimal kernel header stubs for TCC...'",
            "mkdir -p /tmp/linux",
            "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
            "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
            "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
            "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
            "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
            "echo '#define module_init(x)' >> /tmp/linux/module.h",
            "echo '#define module_exit(x)' >> /tmp/linux/module.h",
            "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
            "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
            "echo '#define __init' > /tmp/linux/init.h",
            "echo '#define __exit' >> /tmp/linux/init.h",
            "echo 'typedef int bool;' > /tmp/linux/types.h",
            "echo 'typedef unsigned char uint8_t;' >> /tmp/linux/types.h",
            "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
            "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
            "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
            "echo '#define true 1' >> /tmp/linux/types.h",
            "echo '#define false 0' >> /tmp/linux/types.h",
            "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
            "echo 'Creating test file that includes casting header...'",
            "echo '#include \"/lib/modules/pointer_casting.h\"' > /tmp/test.c",
            "echo 'int main() { current_record->header.rec_type = 1; process_generic_record((void*)0); extract_sensor_data((generic_record*)0); extract_device_data((generic_record*)0); print_record_info(); return 0; }' >> /tmp/test.c",
            "echo 'Running TCC validation...'",
            "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
            "TCC_EXIT_CODE=$?",
            "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
            "echo 'Phase 2: Anti-Hardcoding Dynamic Casting Test'",
            "/bin/casting_dynamic_tester > /tmp/test_output.log",
            "cat /tmp/test_output.log",
            "echo 'Phase 3: Random Value Extraction and Validation'",
            "echo 'Adding delay to ensure dmesg messages are written...'",
            "sleep 1",
            "echo 'Extracting random test values from output...'",
            "SENSOR_ID=$(grep -o 'Random sensor casting (ID=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
            "SENSOR_MEASUREMENT=$(grep -o 'measurement=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
            "DEVICE_ID=$(grep -o 'Random device casting (ID=[0-9]*)' /tmp/test_output.log | cut -d'=' -f2 | cut -d')' -f1)",
            "echo 'Extracted values: SENSOR_ID='$SENSOR_ID', MEASUREMENT='$SENSOR_MEASUREMENT', DEVICE_ID='$DEVICE_ID",
            "if [ -z \"$SENSOR_ID\" ] || [ -z \"$SENSOR_MEASUREMENT\" ] || [ -z \"$DEVICE_ID\" ]; then echo 'FAIL: Could not extract random test values'; else echo 'PASS: Random values extracted successfully'; fi",
            "echo 'Phase 4: Anti-Hardcoding Validation with Random Values'",
            "echo 'Validating sensor casting with random ID '$SENSOR_ID",
            "dmesg | grep \"Sensor ID: $SENSOR_ID\" && echo 'PASS: Sensor casting with random ID working' || echo 'FAIL: Sensor casting with random ID broken'",
            "echo 'Validating sensor measurement with random value '$SENSOR_MEASUREMENT",
            "dmesg | grep \"Measurement: $SENSOR_MEASUREMENT\" && echo 'PASS: Sensor measurement with random value working' || echo 'FAIL: Sensor measurement with random value broken'",
            "echo 'Validating device casting with random ID '$DEVICE_ID",
            "dmesg | grep \"Device ID: $DEVICE_ID\" && echo 'PASS: Device casting with random ID working' || echo 'FAIL: Device casting with random ID broken'",
            "echo 'Phase 5: Static Field Validation (Non-Randomized Fields)'",
            "dmesg | grep 'Sensor Name: temperature_01' && echo 'PASS: Sensor name field access working' || echo 'FAIL: Sensor name field access broken'",
            "dmesg | grep 'Device Status: operational' && echo 'PASS: Device status field access working' || echo 'FAIL: Device status field access broken'",
            "echo 'Phase 6: Casting Logic and Record Type Validation'",
            "dmesg | grep 'Sensor Record Extracted' && echo 'PASS: Sensor extraction logic working' || echo 'FAIL: Sensor extraction logic broken'",
            "dmesg | grep 'Device Record Extracted' && echo 'PASS: Device extraction logic working' || echo 'FAIL: Device extraction logic broken'",
            "dmesg | grep 'Current Record Info:' && echo 'PASS: Record info display working' || echo 'FAIL: Record info display broken'",
            "echo 'Phase 7: Final Validation Summary'",
            "echo 'All phases completed successfully - anti-hardcoding protection verified'",
            "echo 'PASS: All anti-hardcoding casting validation successful'"
          ],
          "expected": {
            "dmesg": [
              "Pointer casting module loaded",
              "Sensor Record Extracted",
              "Sensor ID: .*",
              "Sensor Name: temperature_01",
              "Measurement: .*",
              "Device Record Extracted",
              "Device ID: .*",
              "Device Status: operational",
              "Current Record Info:",
              "Record Type: .*"
            ],
            "stdout": [
              "PASS: All function and variable declarations found in header file",
              "SUCCESS: Anti-hardcoding casting test completed",
              "PASS: Random values extracted successfully",
              "PASS: Sensor casting with random ID working",
              "PASS: Sensor measurement with random value working",
              "PASS: Device casting with random ID working",
              "PASS: Sensor name field access working",
              "PASS: Device status field access working",
              "PASS: Sensor extraction logic working",
              "PASS: Device extraction logic working",
              "PASS: Record info display working",
              "PASS: All anti-hardcoding casting validation successful"
            ]
          },
          "timeout": 15
        }
      }
    ]
  }
}
