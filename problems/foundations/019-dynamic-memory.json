{
  "id": 19,
  "title": "Dynamic Memory - WHEN and WHY to Use kmalloc",
  "phase": "foundations",
  "difficulty": 4,
  "xp": 40,
  "description": "Master the decision-making process for dynamic vs static memory allocation in kernel development. Learn WHEN kmalloc is required (runtime-determined sizes, persistent memory, returning pointers) and WHY static allocation fails in these scenarios. Understand the kmalloc/kfree lifecycle pattern used throughout the Linux kernel.",
  "mainFile": "dynamic_memory.c",
  "files": [
    {
      "name": "MEMORY_ALLOCATION_GUIDE.md",
      "content": "# Dynamic Memory Allocation - Visual Guide for Kernel Programming\n\n## Understanding the Core Concept\n\nThis guide uses **generic examples** to help you understand WHEN and WHY to use dynamic memory allocation (kmalloc) versus static allocation in kernel development.\n\n## The Fundamental Question: Static or Dynamic?\n\nBefore writing any memory allocation code, ask yourself:\n**\"Do I know the size at compile time, and will the memory lifetime work with the stack?\"**\n\n---\n\n## Part 1: The Decision Tree\n\n### WHEN Must You Use kmalloc?\n\nFollow this decision tree:\n\n```\n┌─────────────────────────────────────────────────┐\n│  Q1: Is the size known at COMPILE TIME?        │\n└─────────────────────────────────────────────────┘\n                    │\n        ┌───────────┴───────────┐\n       NO                      YES\n        │                        │\n        ▼                        ▼\n  ┌──────────┐         ┌─────────────────────────┐\n  │ USE      │         │ Q2: Does memory need to │\n  │ KMALLOC  │         │ outlive function scope? │\n  │ (MUST)   │         └─────────────────────────┘\n  └──────────┘                    │\n                      ┌───────────┴───────────┐\n                     YES                     NO\n                      │                       │\n                      ▼                       ▼\n                ┌──────────┐        ┌─────────────────────┐\n                │ USE      │        │ Q3: Returning       │\n                │ KMALLOC  │        │ pointer from func?  │\n                │ (MUST)   │        └─────────────────────┘\n                └──────────┘                  │\n                                  ┌───────────┴───────────┐\n                                 YES                     NO\n                                  │                       │\n                                  ▼                       ▼\n                            ┌──────────┐          ┌────────────┐\n                            │ USE      │          │ STATIC OK  │\n                            │ KMALLOC  │          │ (optional) │\n                            │ (MUST)   │          └────────────┘\n                            └──────────┘\n```\n\n---\n\n## Part 2: Stack vs Heap Memory\n\n### Understanding Where Memory Lives\n\n**Stack Memory (Static Allocation):**\n```\nFunction scope:\nvoid my_function() {\n    int local_var = 42;        ← Lives on STACK\n    Device dev = {1, 2, true}; ← Lives on STACK\n    \n    // Memory is AUTOMATICALLY freed when function returns\n}\n// After return: local_var and dev are GONE!\n```\n\n**Heap Memory (Dynamic Allocation):**\n```\nFunction scope:\nvoid my_function() {\n    Device *dev = kmalloc(sizeof(Device), GFP_KERNEL); ← Lives on HEAP\n    \n    // Memory persists even after function returns\n}\n// After return: Memory still exists! (Must manually free later)\n```\n\n**Memory Layout Visualization:**\n```\n┌─────────────────────────────────────┐ High Addresses\n│                                     │\n│  KERNEL SPACE (not accessible)      │\n│                                     │\n├─────────────────────────────────────┤\n│                                     │\n│  STACK (grows downward)             │ ← Static allocation lives here\n│  ┌───────────────────────┐          │\n│  │ Function call frames  │          │\n│  │ Local variables       │          │\n│  │ Function parameters   │          │\n│  └───────────────────────┘          │\n│         ↓                           │\n│                                     │\n│  (Free space)                       │\n│                                     │\n│         ↑                           │\n│  ┌───────────────────────┐          │\n│  │ Dynamically allocated │          │ ← kmalloc allocates here\n│  │ memory (heap)         │          │\n│  └───────────────────────┘          │\n│  HEAP (grows upward)                │\n│                                     │\n├─────────────────────────────────────┤\n│  BSS (uninitialized globals)        │\n│  DATA (initialized globals)         │\n│  TEXT (program code)                │\n└─────────────────────────────────────┘ Low Addresses\n```\n\n**Key Differences:**\n\n```\n┌──────────────┬─────────────────┬──────────────────┐\n│ Property     │ STACK (static)  │ HEAP (kmalloc)   │\n├──────────────┼─────────────────┼──────────────────┤\n│ Lifetime     │ Function scope  │ Until kfree()    │\n│ Size         │ Compile-time    │ Runtime          │\n│ Speed        │ FAST            │ Slower           │\n│ Cleanup      │ Automatic       │ Manual (kfree)   │\n│ Failure risk │ Stack overflow  │ Out of memory    │\n└──────────────┴─────────────────┴──────────────────┘\n```\n\n---\n\n## Part 3: Scenario 1 - Runtime-Determined Size\n\n### The Problem: Size Unknown at Compile Time\n\n**Example: Module parameter determines array size**\n\n```c\nint device_count = 5;  // Set at MODULE LOAD TIME via parameter\nmodule_param(device_count, int, 0644);\n```\n\n**WRONG - Static Allocation:**\n```c\nDevice devices[device_count];  // ILLEGAL!\n//             ^\n//             |\n//     Variable-Length Array (VLA)\n//     NOT ALLOWED in kernel code!\n```\n\n**Why this fails:**\n- `device_count` is only known when user runs `insmod module.ko device_count=10`\n- Compiler needs array size at compile time\n- VLAs are prohibited in kernel for safety (stack overflow risk)\n\n**CORRECT - Dynamic Allocation:**\n```c\nDevice *devices = kmalloc(sizeof(Device) * device_count, GFP_KERNEL);\n//      ^         ^        ^                 ^\n//      |         |        |                 |\n//   pointer   allocate  size per item    count of items\n```\n\n**Memory Layout:**\n```\nBEFORE kmalloc:\n  Stack:                 Heap:\n  ┌──────────┐          (empty)\n  │ devices  │ = NULL\n  └──────────┘\n\nAFTER kmalloc (device_count = 3):\n  Stack:                 Heap:\n  ┌──────────┐          ┌────────────────┐\n  │ devices  │────────→ │ Device 0       │\n  └──────────┘          │ Device 1       │\n                        │ Device 2       │\n                        └────────────────┘\n                        Single contiguous array!\n```\n\n**Accessing elements:**\n```c\ndevices[0].device_id = 1000;  // First device\ndevices[1].device_id = 1001;  // Second device\ndevices[2].device_id = 1002;  // Third device\n\n// Same as:\n(&devices[0])->device_id = 1000;\n(&devices[1])->device_id = 1001;\n(&devices[2])->device_id = 1002;\n```\n\n---\n\n## Part 4: Scenario 2 - Returning Pointers from Functions\n\n### The Problem: Returning Local Variables\n\n**DANGEROUS - Returning Stack Address:**\n```c\nDevice* create_device_wrong(int id) {\n    Device local = {id, 200, true};  // Lives on STACK\n    return &local;                    // DANGER!\n}\n//  Function returns\n//  Stack frame destroyed\n//  'local' no longer exists!\n```\n\n**What happens:**\n```\nDURING function:\n  Stack:                         \n  ┌────────────────────┐         \n  │ create_device_wrong│         \n  │ ┌────────────────┐ │         \n  │ │ local:         │ │ ← Address 0x1000\n  │ │   id = 1001    │ │         \n  │ │   status = 200 │ │         \n  │ │   active = true│ │         \n  │ └────────────────┘ │         \n  └────────────────────┘         \n\nAFTER function returns:\n  Stack:                         \n  ┌────────────────────┐         \n  │ (Frame popped)     │         \n  │ ????????????????   │ ← Address 0x1000 now GARBAGE!\n  └────────────────────┘         \n\n  Caller has pointer to 0x1000:\n  Device *dev = create_device_wrong(1001);\n  dev->device_id  ← Reading GARBAGE! (Undefined behavior)\n```\n\n**SAFE - Using kmalloc:**\n```c\nDevice* create_device_correct(int id) {\n    Device *dev = kmalloc(sizeof(Device), GFP_KERNEL);\n    if (!dev) {\n        return NULL;  // Allocation failed\n    }\n    \n    dev->device_id = id;\n    dev->status = 200;\n    dev->is_active = true;\n    \n    return dev;  // SAFE! Heap memory persists\n}\n```\n\n**Memory flow:**\n```\nDURING function:\n  Stack:                 Heap:\n  ┌────────────────┐    ┌────────────────┐\n  │ create_device  │    │ Device:        │ ← Address 0x5000\n  │ ┌────┐         │    │   id = 1001    │\n  │ │dev │─────────┼───→│   status = 200 │\n  │ └────┘         │    │   active = true│\n  └────────────────┘    └────────────────┘\n\nAFTER function returns:\n  Stack:                 Heap:\n  ┌────────────────┐    ┌────────────────┐\n  │ (Frame popped) │    │ Device:        │ ← Still at 0x5000!\n  └────────────────┘    │   id = 1001    │   MEMORY PERSISTS!\n                        │   status = 200 │\n  Caller:               │   active = true│\n  Device *dev ─────────→└────────────────┘\n  dev->device_id works!\n```\n\n---\n\n## Part 5: The kmalloc/kfree Lifecycle\n\n### The Four Essential Steps\n\n**Step 1: ALLOCATE**\n```c\nDevice *dev = kmalloc(sizeof(Device), GFP_KERNEL);\n//      ^     ^        ^               ^\n//      |     |        |               |\n//   pointer  alloc   size          flags (kernel memory, can sleep)\n```\n\n**Breaking down the syntax:**\n```\nkmalloc(size_t size, gfp_t flags)\n        ^            ^\n        |            |\n        |            Memory allocation flags:\n        |            - GFP_KERNEL: Normal allocation (can sleep)\n        |            - GFP_ATOMIC: Atomic (interrupt context)\n        |\n        Number of bytes to allocate\n\nsizeof(Device)\n  Returns size of Device structure in bytes\n  Example: If Device has:\n    int (4 bytes) + int (4 bytes) + bool (1 byte) + padding (3 bytes)\n    = 12 bytes total\n\nsizeof(Device) * count\n  For arrays: multiply by number of elements\n  Example: 5 devices × 12 bytes = 60 bytes\n```\n\n**Step 2: CHECK (CRITICAL!)**\n```c\nif (!dev) {\n    printk(KERN_ERR \"Allocation failed!\\n\");\n    return -ENOMEM;  // Error code for \"out of memory\"\n}\n```\n\n**Why checking is critical:**\n```\nkmalloc CAN FAIL when:\n- System is out of memory\n- Requested size is too large\n- Memory is fragmented\n\nIF you don't check:\ndev->device_id = 1001;  ← NULL pointer dereference!\n                        ← KERNEL PANIC! System crashes!\n```\n\n**Memory state after allocation:**\n```\nSUCCESS:\n  dev ────→  ┌────────────┐\n             │ ????????   │ ← Uninitialized!\n             │ ????????   │    Contains garbage!\n             │ ????????   │\n             └────────────┘\n\nFAILURE:\n  dev = NULL ──→ (nothing)\n```\n\n**Step 3: USE**\n```c\ndev->device_id = 1001;\ndev->status = 200;\ndev->is_active = true;\n```\n\n**Memory after initialization:**\n```\n  dev ────→  ┌────────────────┐\n             │ device_id: 1001│ ← Initialized\n             │ status: 200    │\n             │ is_active: true│\n             └────────────────┘\n```\n\n**Step 4: FREE**\n```c\nkfree(dev);\ndev = NULL;  // Important! Prevent use-after-free\n```\n\n**Memory after kfree:**\n```\nBEFORE kfree:\n  dev ────→  ┌────────────────┐\n             │ device_id: 1001│\n             │ status: 200    │\n             │ is_active: true│\n             └────────────────┘\n\nAFTER kfree(dev):\n  dev ────→  ┌────────────────┐\n             │ ????????       │ ← Memory freed!\n             │ ????????       │    Contents undefined!\n             │ ????????       │    DANGEROUS to access!\n             └────────────────┘\n\nAFTER dev = NULL:\n  dev = NULL ──→ (nothing)      ← Safe! Can't accidentally use\n```\n\n---\n\n## Part 6: Common Mistakes and How to Avoid Them\n\n### Mistake 1: Memory Leak (Forgetting kfree)\n\n**WRONG:**\n```c\nvoid process_device(void) {\n    Device *dev = kmalloc(sizeof(Device), GFP_KERNEL);\n    if (!dev) return;\n    \n    dev->device_id = 1001;\n    \n    // Function returns without freeing!\n    return;  // MEMORY LEAK!\n}\n```\n\n**What happens:**\n```\nCall 1:  Allocates 12 bytes  ────→ Lost forever!\nCall 2:  Allocates 12 bytes  ────→ Lost forever!\nCall 3:  Allocates 12 bytes  ────→ Lost forever!\n...\nCall 1000: System runs out of memory! \n```\n\n**CORRECT:**\n```c\nvoid process_device(void) {\n    Device *dev = kmalloc(sizeof(Device), GFP_KERNEL);\n    if (!dev) return;\n    \n    dev->device_id = 1001;\n    \n    kfree(dev);  // Always free!\n    dev = NULL;\n}\n```\n\n### Mistake 2: Use-After-Free\n\n**WRONG:**\n```c\nDevice *dev = kmalloc(sizeof(Device), GFP_KERNEL);\ndev->device_id = 1001;\n\nkfree(dev);\n\ndev->device_id = 1002;  // Use-after-free!\n```\n\n**What happens:**\n```\nAFTER kfree:\n  dev still points to freed memory\n  \n  dev ────→  ┌────────────────┐\n             │ ????????       │ ← May be reused by kernel!\n             │ ????????       │ ← Writing here corrupts memory!\n             │ ????????       │ ← UNDEFINED BEHAVIOR!\n             └────────────────┘\n\nCould cause:\n- Data corruption\n- Kernel panic\n- Security vulnerabilities\n```\n\n**CORRECT:**\n```c\nDevice *dev = kmalloc(sizeof(Device), GFP_KERNEL);\ndev->device_id = 1001;\n\nkfree(dev);\ndev = NULL;  // Prevent use-after-free\n\nif (dev) {   // This check now prevents the bug\n    dev->device_id = 1002;\n}\n```\n\n### Mistake 3: Double Free\n\n**WRONG:**\n```c\nDevice *dev = kmalloc(sizeof(Device), GFP_KERNEL);\nkfree(dev);\nkfree(dev);  // Double free!\n```\n\n**What happens:**\n```\nFirst kfree:\n  Memory returned to kernel allocator\n  Kernel marks it as \"free\"\n\nSecond kfree:\n  Kernel thinks memory is allocated\n  Tries to free already-free memory\n  CORRUPTS KERNEL ALLOCATOR DATA STRUCTURES!\n  KERNEL PANIC! \n```\n\n**CORRECT:**\n```c\nDevice *dev = kmalloc(sizeof(Device), GFP_KERNEL);\nkfree(dev);\ndev = NULL;  // Prevent double free\n\nif (dev) {   // This check prevents second free\n    kfree(dev);\n}\n```\n\n### Mistake 4: Forgetting NULL Check\n\n**WRONG:**\n```c\nDevice *dev = kmalloc(sizeof(Device), GFP_KERNEL);\ndev->device_id = 1001;  // What if kmalloc failed?\n```\n\n**What happens:**\n```\nIF kmalloc fails:\n  dev = NULL\n  \nNULL->device_id\n  Try to dereference address 0x00000000\n  KERNEL PANIC! \n```\n\n**CORRECT:**\n```c\nDevice *dev = kmalloc(sizeof(Device), GFP_KERNEL);\nif (!dev) {  // Always check!\n    printk(KERN_ERR \"Out of memory!\\n\");\n    return -ENOMEM;\n}\ndev->device_id = 1001;  // Safe now\n```\n\n---\n\n## Part 7: Single Array Allocation Pattern\n\n### Allocating an Array of Structures\n\n**Pattern:**\n```c\nint count = 5;\nDevice *devices = kmalloc(sizeof(Device) * count, GFP_KERNEL);\n//                       └────────┬─────────┘\n//                          Total bytes needed\n```\n\n**Memory layout:**\n```\nHeap (single contiguous allocation):\n┌────────────────────────────────────────────────┐\n│ devices[0]  devices[1]  devices[2] ...         │\n│ 12 bytes    12 bytes    12 bytes               │\n└────────────────────────────────────────────────┘\n ↑\n devices pointer\n\nTotal: 5 × 12 bytes = 60 bytes (contiguous)\n```\n\n**Accessing elements:**\n```c\n// Method 1: Array notation\ndevices[0].device_id = 1000;\ndevices[1].device_id = 1001;\ndevices[2].device_id = 1002;\n\n// Method 2: Pointer notation\n(&devices[0])->device_id = 1000;\n(&devices[1])->device_id = 1001;\n\n// Method 3: Pointer arithmetic\n(devices + 0)->device_id = 1000;\n(devices + 1)->device_id = 1001;\n\n// All three are equivalent!\n```\n\n**Cleanup (simple!):**\n```c\nkfree(devices);  // Single free for entire array!\ndevices = NULL;\n\n// NO LOOP NEEDED!\n// The entire contiguous block is freed at once.\n```\n\n**Visualization:**\n```\nALLOCATION:\n  Single kmalloc call\n      ↓\n  ┌─────┬─────┬─────┬─────┬─────┐\n  │ [0] │ [1] │ [2] │ [3] │ [4] │\n  └─────┴─────┴─────┴─────┴─────┘\n\nFREE:\n  Single kfree call\n      ↓\n  Entire array freed at once!\n```\n\n---\n\n## Part 8: GFP Flags - Memory Allocation Context\n\n### Understanding GFP_KERNEL\n\n**Common GFP flags:**\n```\n┌──────────────┬─────────────────┬──────────────────┐\n│ Flag         │ When to use     │ Can sleep?       │\n├──────────────┼─────────────────┼──────────────────┤\n│ GFP_KERNEL   │ Normal context  │ YES (can wait)   │\n│ GFP_ATOMIC   │ Interrupt/lock  │ NO (must succeed)│\n│ GFP_NOWAIT   │ No sleeping     │ NO               │\n│ GFP_DMA      │ DMA-capable     │ YES              │\n└──────────────┴─────────────────┴──────────────────┘\n```\n\n**GFP_KERNEL (most common):**\n```c\nDevice *dev = kmalloc(sizeof(Device), GFP_KERNEL);\n//                                    ^\n//                                    |\n//                    Allocation can SLEEP if needed\n//                    Waits for memory to become available\n```\n\n**Use GFP_KERNEL when:**\n- In normal process context\n- In module init/exit functions\n- Can afford to wait for memory\n- Most common case!\n\n**GFP_ATOMIC (special cases):**\n```c\nDevice *dev = kmalloc(sizeof(Device), GFP_ATOMIC);\n//                                    ^\n//                                    |\n//                    CANNOT sleep!\n//                    Returns immediately\n```\n\n**Use GFP_ATOMIC when:**\n- In interrupt handler\n- Holding a spinlock\n- Cannot sleep (atomic context)\n- Less likely to succeed!\n\n---\n\n## Part 9: Complete Example Walkthrough\n\n### Full Lifecycle Example\n\n```c\n/* Step 1: Allocate array */\nint count = 3;\nDevice *devices = kmalloc(sizeof(Device) * count, GFP_KERNEL);\n\n/* Step 2: Check for failure */\nif (!devices) {\n    printk(KERN_ERR \"Failed to allocate devices\\n\");\n    return -ENOMEM;\n}\n\n/* Step 3: Initialize all devices */\nfor (int i = 0; i < count; i++) {\n    devices[i].device_id = 1000 + i;\n    devices[i].status = 200;\n    devices[i].is_active = true;\n}\n\n/* Step 4: Use devices */\nfor (int i = 0; i < count; i++) {\n    printk(KERN_INFO \"Device %d: ID=%d, Status=%d\\n\",\n           i, devices[i].device_id, devices[i].status);\n}\n\n/* Step 5: Cleanup when done */\nkfree(devices);\ndevices = NULL;\n```\n\n**Memory state at each step:**\n```\nSTEP 1: After kmalloc\n  devices ──→  ┌─────┬─────┬─────┐\n               │  ?  │  ?  │  ?  │ Uninitialized\n               └─────┴─────┴─────┘\n\nSTEP 3: After initialization loop\n  devices ──→  ┌──────┬──────┬──────┐\n               │ 1000 │ 1001 │ 1002 │ device_id\n               │  200 │  200 │  200 │ status\n               │ true │ true │ true │ is_active\n               └──────┴──────┴──────┘\n\nSTEP 5: After kfree and NULL assignment\n  devices = NULL ──→ (nothing)\n  Memory returned to kernel\n```\n\n---\n\n## Part 10: Quick Reference\n\n### Decision Checklist\n\n**Use STATIC allocation when:**\n- Size known at compile time\n- Lifetime limited to function scope\n- Not returning pointer from function\n- Small size (< 1KB typically)\n\n**Use KMALLOC when:**\n- Size determined at runtime\n- Memory must persist beyond function\n- Returning pointer from function\n- Large data structures\n\n### Allocation Pattern Template\n\n```c\n/* Single structure */\nType *ptr = kmalloc(sizeof(Type), GFP_KERNEL);\nif (!ptr) {\n    return -ENOMEM;\n}\n// ... use ptr ...\nkfree(ptr);\nptr = NULL;\n\n/* Array of structures */\nType *array = kmalloc(sizeof(Type) * count, GFP_KERNEL);\nif (!array) {\n    return -ENOMEM;\n}\n// ... use array[0], array[1], etc ...\nkfree(array);\narray = NULL;\n```\n\n### Safety Checklist\n\n**After kmalloc:**\n- [ ] Check if pointer is NULL\n- [ ] Handle allocation failure\n\n**Before using:**\n- [ ] Initialize all fields\n- [ ] Don't use uninitialized memory\n\n**When done:**\n- [ ] Call kfree()\n- [ ] Set pointer to NULL\n- [ ] Don't use after free\n- [ ] Don't free twice\n\n---\n\n## Key Takeaways\n\n1. **Runtime sizes REQUIRE kmalloc** - No compile-time arrays with variable sizes\n2. **Returning pointers REQUIRES kmalloc** - Stack variables die when function returns\n3. **Always check kmalloc return** - NULL means out of memory\n4. **Single allocation = single free** - Arrays freed with one kfree call\n5. **Set to NULL after free** - Prevents use-after-free bugs\n6. **GFP_KERNEL for normal code** - Can sleep, most common case\n\nNow apply these patterns to your specific problem! The decision tree and lifecycle pattern are the same for any kernel code.\n",
      "readOnly": true,
      "language": "txt"
    },
    {
      "name": "dynamic_memory.h",
      "content": "#ifndef DYNAMIC_MEMORY_H\n#define DYNAMIC_MEMORY_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: WHEN to Use Static vs Dynamic Memory Allocation */\n/* ========================================================================== */\n/* This problem teaches the DECISION-MAKING PROCESS for choosing between\n * static allocation and dynamic allocation (kmalloc).\n *\n * CRITICAL LEARNING OBJECTIVE:\n * Understanding WHEN kmalloc is REQUIRED vs OPTIONAL is essential for\n * kernel development. Many students learn the syntax but not the criteria!\n *\n * DECISION TREE:\n * \n * Q1: Is the size known at compile time?\n *     NO  -> MUST use kmalloc (required)\n *     YES -> Continue to Q2\n *\n * Q2: Does memory need to outlive the function scope?\n *     YES -> MUST use kmalloc (required)\n *     NO  -> Continue to Q3\n *\n * Q3: Do you need to return a pointer from a function?\n *     YES -> MUST use kmalloc (required)\n *     NO  -> Static allocation is acceptable\n *\n * EXAMPLES OF WHEN KMALLOC IS REQUIRED:\n *\n * 1. RUNTIME-DETERMINED SIZE (Cannot use static allocation):\n *    int count = module_parameter;  // Unknown at compile time\n *    Device devices[count];  // ILLEGAL in C (VLA not allowed in kernel)\n *    Device *devices = kmalloc(sizeof(Device) * count, GFP_KERNEL);  // REQUIRED\n *\n * 2. RETURNING MEMORY FROM FUNCTION (Cannot use local variables):\n *    Device* bad_create(void) {\n *        Device local = {1, 2, true};  // Stack variable destroyed on return\n *        return &local;  // DANGER: Dangling pointer!\n *    }\n *    Device* good_create(void) {\n *        Device *dev = kmalloc(sizeof(Device), GFP_KERNEL);  // REQUIRED\n *        return dev;  // SAFE: Heap memory persists\n *    }\n *\n * 3. PERSISTENT LIFETIME (Beyond function scope):\n *    void init_device(void) {\n *        Device temp = {1, 2, true};  // Destroyed when function exits\n *    }\n *    Device *persistent_device = kmalloc(sizeof(Device), GFP_KERNEL);  // REQUIRED\n *\n * EXAMPLES OF WHEN STATIC IS ACCEPTABLE:\n *\n * 1. FIXED SIZE, KNOWN AT COMPILE TIME:\n *    Device single_device = {1001, 200, true};  // OK: Size known, lifetime OK\n *\n * 2. FIXED-SIZE ARRAY:\n *    Device devices[5] = {...};  // OK: Size known at compile time\n *\n * WHY THIS MATTERS IN KERNEL DEVELOPMENT:\n * - The Linux kernel uses kmalloc extensively for runtime-sized data structures\n * - Driver registration, device management, buffer allocation all use kmalloc\n * - Misunderstanding leads to stack corruption, memory leaks, crashes\n */\n\n/* ========================================================================== */\n/* MEMORY ALLOCATION PATTERN: The Lifecycle */\n/* ========================================================================== */\n/* KMALLOC/KFREE LIFECYCLE (4 Essential Steps):\n *\n * Step 1: ALLOCATE\n *   Device *dev = kmalloc(sizeof(Device), GFP_KERNEL);\n *   ^       ^      ^       ^               ^\n *   type    result function size           flags\n *\n * Step 2: CHECK (Critical - kmalloc can fail!)\n *   if (!dev) {\n *       printk(KERN_ERR \"Allocation failed!\\n\");\n *       return -ENOMEM;\n *   }\n *\n * Step 3: USE\n *   dev->device_id = 1001;\n *   dev->status = 200;\n *   dev->is_active = true;\n *\n * Step 4: FREE (When done)\n *   kfree(dev);\n *   dev = NULL;  // Prevent use-after-free bugs\n *\n * COMMON MISTAKES:\n * - Forgetting to check if kmalloc returned NULL\n * - Using memory after kfree (use-after-free bug)\n * - Forgetting to kfree (memory leak)\n * - Double-freeing the same pointer (double-free bug)\n */\n\n/* Device structure definition */\ntypedef struct {\n    int device_id;\n    int status;\n    bool is_active;\n} Device;\n\n/* Global device array pointer - dynamically allocated */\nextern Device *device_array;\nextern int device_count;\n\n/* ========================================================================== */\n/* SECTION 1: Function Declarations */\n/* ========================================================================== */\n/* TODO: Declare the following functions (declaration only, no implementation) */\n/* \n * REQUIRED FUNCTIONS:\n * 1. allocate_devices - Takes device count, returns 0 on success, -ENOMEM on failure\n * 2. initialize_device - Takes device pointer and ID, initializes device fields\n * 3. print_device_info - Takes device pointer, prints device information\n * 4. cleanup_devices - Takes no parameters, frees all allocated memory\n *\n * HINTS:\n * - allocate_devices should return int (for error code)\n * - initialize_device should take (Device *dev, int id) as parameters\n * - print_device_info should take (Device *dev) as parameter\n * - cleanup_devices should return void\n */\n\n#endif /* DYNAMIC_MEMORY_H */",
      "readOnly": false,
      "language": "h"
    },
    {
      "name": "dynamic_memory.c",
      "content": "#include \"dynamic_memory.h\"\n\n/* Global device array pointer - starts as NULL */\nDevice *device_array = NULL;\nint device_count = 3;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses device_count to verify your dynamic allocation\n * works with RUNTIME-DETERMINED sizes (the key learning objective!).\n */\nmodule_param(device_count, int, 0644);\nMODULE_PARM_DESC(device_count, \"Number of devices to allocate (runtime-determined)\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: WHY Static Allocation Fails Here */\n/* ========================================================================== */\n/* PROBLEM: We need to allocate 'device_count' devices, but device_count\n * is determined at MODULE LOAD TIME (runtime), not compile time!\n *\n * STATIC ALLOCATION ATTEMPT (WILL NOT WORK):\n *   Device devices[device_count];  // ILLEGAL: VLA not allowed in kernel!\n *   \n * WHY THIS FAILS:\n * - device_count is only known when module loads (insmod dynamic_memory.ko device_count=5)\n * - C requires array sizes to be known at compile time\n * - Variable-Length Arrays (VLAs) are prohibited in kernel code for safety\n *\n * SOLUTION: MUST use kmalloc for runtime-determined sizes!\n *   Device *devices = kmalloc(sizeof(Device) * device_count, GFP_KERNEL);\n *   ^       ^         ^        ^                 ^\n *   type    result    function size calculation  flags\n *\n * This is a REQUIRED use case for dynamic memory allocation!\n *\n * MEMORY LAYOUT VISUALIZATION:\n *   Stack:                    Heap (Single Array):\n *   +-------------+          +----------+\n *   |device_array |--------->| Device 0 |\n *   +-------------+          | Device 1 |\n *                            | Device 2 |\n *                            +----------+\n *\n * CLEANUP IS SIMPLE (single kfree):\n *   kfree(device_array);\n */\n\n/* ========================================================================== */\n/* SECTION 1: Memory Allocation Function */\n/* ========================================================================== */\n/* TODO: Implement allocate_devices function\n *\n * REQUIREMENTS:\n * - Function signature: int allocate_devices(int count)\n * - Allocate single array of Device structures\n * - Check allocation for NULL (error handling!)\n * - Return 0 on success, -ENOMEM on failure\n * - Store result in global device_array variable\n *\n * ALGORITHM:\n * 1. Print message: \"Allocating %d devices...\" with count\n * 2. Allocate array: device_array = kmalloc(sizeof(Device) * count, GFP_KERNEL)\n * 3. Check if device_array is NULL (allocation failed)\n *    - If NULL: print error, return -ENOMEM\n * 4. Print success message: \"Successfully allocated %d devices\"\n * 5. Return 0\n *\n * CRITICAL ERROR HANDLING:\n * Always check if kmalloc returns NULL before using the memory!\n */\nint allocate_devices(int count)\n{\n    /* TODO: Implement single-level array allocation as described above */\n    return -ENOMEM;  /* Replace with actual implementation */\n}\n\n/* ========================================================================== */\n/* SECTION 2: Device Initialization Function */\n/* ========================================================================== */\n/* TODO: Implement initialize_device function\n *\n * REQUIREMENTS:\n * - Function signature: void initialize_device(Device *dev, int id)\n * - Check if dev pointer is NULL (safety check)\n * - Initialize device fields:\n *   - device_id = id\n *   - status = 200\n *   - is_active = true\n * - Print message: \"Device %d initialized\"\n *\n * ALGORITHM:\n * 1. Check if dev is NULL\n *    - If NULL: print error \"Cannot initialize NULL device\", return\n * 2. Set dev->device_id = id\n * 3. Set dev->status = 200\n * 4. Set dev->is_active = true\n * 5. Print success message with device ID\n */\nvoid initialize_device(Device *dev, int id)\n{\n    /* TODO: Implement device initialization as described above */\n}\n\n/* ========================================================================== */\n/* SECTION 3: Device Info Printing Function */\n/* ========================================================================== */\n/* TODO: Implement print_device_info function\n *\n * REQUIREMENTS:\n * - Function signature: void print_device_info(Device *dev)\n * - Check if dev pointer is NULL (safety check)\n * - Print device information:\n *   - \"=== Device Info ===\"\n *   - \"Device ID: %d\" (dev->device_id)\n *   - \"Status: %d\" (dev->status)\n *   - \"Active: YES\" or \"Active: NO\" (based on dev->is_active)\n *\n * ALGORITHM:\n * 1. Check if dev is NULL\n *    - If NULL: print error \"Cannot print info: device is NULL\", return\n * 2. Print header \"=== Device Info ===\"\n * 3. Print \"Device ID: %d\" with dev->device_id\n * 4. Print \"Status: %d\" with dev->status\n * 5. Print \"Active: YES\" if dev->is_active is true, else \"Active: NO\"\n */\nvoid print_device_info(Device *dev)\n{\n    /* TODO: Implement device info printing as described above */\n}\n\n/* ========================================================================== */\n/* SECTION 4: Memory Cleanup Function */\n/* ========================================================================== */\n/* TODO: Implement cleanup_devices function\n *\n * REQUIREMENTS:\n * - Function signature: void cleanup_devices(void)\n * - Free all allocated memory (single kfree!)\n * - Set pointer to NULL after freeing (prevent use-after-free)\n * - Use global variables: device_array, device_count\n *\n * ALGORITHM:\n * 1. Check if device_array is NULL\n *    - If NULL: print \"No devices to free\", return\n * 2. Print message: \"Freeing %d devices...\" with device_count\n * 3. Free device_array using kfree\n * 4. Set device_array = NULL\n * 5. Print success message: \"All devices freed\"\n *\n * CRITICAL: Single allocation requires single kfree!\n * No loop needed - the entire array is freed with one kfree call.\n */\nvoid cleanup_devices(void)\n{\n    /* TODO: Implement cleanup as described above */\n}\n\n/* ========================================================================== */\n/* MODULE INIT/EXIT */\n/* ========================================================================== */\nstatic int __init dynamic_memory_init(void)\n{\n    int ret;\n    int i;\n    int base_id = 1000;\n    \n    printk(KERN_INFO \"Dynamic memory module loaded\\n\");\n    printk(KERN_INFO \"Runtime device count: %d\\n\", device_count);\n    \n    /* Allocate devices dynamically */\n    ret = allocate_devices(device_count);\n    if (ret != 0) {\n        printk(KERN_ERR \"Failed to allocate devices\\n\");\n        return ret;\n    }\n    \n    /* Initialize all devices */\n    printk(KERN_INFO \"Initializing %d devices...\\n\", device_count);\n    for (i = 0; i < device_count; i++) {\n        /* NOTE: &device_array[i] gets the address of the i-th element\n         * device_array is a pointer to the first element\n         * device_array[i] is the actual struct (value)\n         * &device_array[i] is the address of that struct (pointer)\n         * We need the address because initialize_device expects Device *dev\n         */\n        initialize_device(&device_array[i], base_id + i);\n    }\n    \n    /* Print information for all devices */\n    printk(KERN_INFO \"Printing device information...\\n\");\n    for (i = 0; i < device_count; i++) {\n        printk(KERN_INFO \"Device %d:\\n\", i);\n        /* Same pattern: &device_array[i] passes address of i-th struct */\n        print_device_info(&device_array[i]);\n    }\n    \n    printk(KERN_INFO \"Dynamic allocation demonstration completed\\n\");\n    return 0;\n}\n\nstatic void __exit dynamic_memory_exit(void)\n{\n    printk(KERN_INFO \"Dynamic memory module unloading\\n\");\n    \n    /* Clean up all allocated memory */\n    cleanup_devices();\n    \n    printk(KERN_INFO \"Module unloaded cleanly\\n\");\n}\n\nmodule_init(dynamic_memory_init);\nmodule_exit(dynamic_memory_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Dynamic memory allocation with runtime-determined sizes\");\nMODULE_VERSION(\"1.0\");",
      "readOnly": false,
      "language": "c"
    },
    {
      "name": "Makefile",
      "content": "# Dynamic memory module Makefile\nobj-m += dynamic_memory.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
      "readOnly": true,
      "language": "makefile"
    }
  ],
  "concepts": [
    "WHEN to use kmalloc vs static allocation (decision tree)",
    "WHY static allocation fails (runtime-determined sizes)",
    "Single-level array allocation with kmalloc",
    "kmalloc() function and GFP_KERNEL flags",
    "kfree() function and proper cleanup",
    "NULL pointer checking and error handling",
    "Memory lifecycle: allocate, check, use, free",
    "Use-after-free prevention",
    "Direct array indexing with allocated memory"
  ],
  "skills": [
    "Applying decision tree for static vs dynamic allocation",
    "Identifying scenarios requiring kmalloc (runtime sizes, persistent lifetime, returning pointers)",
    "Implementing single-level array allocation",
    "Using kmalloc(sizeof(Type) * count, GFP_KERNEL) for arrays",
    "Proper error handling for allocation failures",
    "Direct array indexing with allocated memory",
    "Setting pointers to NULL after freeing"
  ],
  "validation": {
    "exactRequirements": {
      "functionNames": ["dynamic_memory_init", "dynamic_memory_exit", "allocate_devices", "initialize_device", "print_device_info", "cleanup_devices"],
      "function_declarations": [
        { "name": "allocate_devices", "returnType": "int", "parameters": ["int count"] },
        { "name": "initialize_device", "returnType": "void", "parameters": ["Device *dev", "int id"] },
        { "name": "print_device_info", "returnType": "void", "parameters": ["Device *dev"] },
        { "name": "cleanup_devices", "returnType": "void", "parameters": [] }
      ],
      "variables_declarations": [
        { "name": "Device", "type": "typedef struct", "value": "{int device_id; int status; bool is_active;}", "storageClass": "none" },
        { "name": "device_array", "type": "Device *", "storageClass": "extern" },
        { "name": "device_count", "type": "int", "storageClass": "extern" }
      ],
      "variables": [
        { "name": "device_array", "type": "Device *", "value": "NULL", "storageClass": "none" },
        { "name": "device_count", "type": "int", "value": "3", "storageClass": "none" }
      ],
      "outputMessages": [
        "Dynamic memory module loaded",
        "Runtime device count: 3",
        "Allocating 3 devices...",
        "Successfully allocated 3 devices",
        "Initializing 3 devices...",
        "Device 1000 initialized",
        "Device 1001 initialized",
        "Device 1002 initialized",
        "Printing device information...",
        "Device 0:",
        "=== Device Info ===",
        "Device ID: 1000",
        "Status: 200",
        "Active: YES",
        "Device 1:",
        "Device ID: 1001",
        "Device 2:",
        "Device ID: 1002",
        "Dynamic allocation demonstration completed",
        "Dynamic memory module unloading",
        "Freeing 3 devices...",
        "All devices freed",
        "Module unloaded cleanly"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/types.h",
        "linux/slab.h"
      ],
      "mustContain": [
        "kmalloc(sizeof(Device) * count, GFP_KERNEL)",
        "kfree(device_array)",
        "if (!device_array)",
        "device_array = NULL",
        "module_param(device_count, int, 0644)"
      ],
      "moduleInfo": {
        "license": "GPL"
      }
    },
    "testCases": [
      {
        "id": "function_declarations",
        "name": "Function Declarations in Header",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "int allocate_devices(int count)",
          "void initialize_device(Device *dev, int id)",
          "void print_device_info(Device *dev)",
          "void cleanup_devices(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "function_signatures_source",
        "name": "Function Signatures in Source File",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "int allocate_devices(int count)",
          "void initialize_device(Device *dev, int id)",
          "void print_device_info(Device *dev)",
          "void cleanup_devices(void)",
          "static int __init dynamic_memory_init(void)",
          "static void __exit dynamic_memory_exit(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "exact_output",
        "name": "Exact Output Messages with Function Linkage",
        "type": "output_match",
        "critical": true,
        "expected": [
          { "pattern": "Dynamic memory module loaded", "exact": true, "linkedFunction": "static int __init dynamic_memory_init(void)" },
          { "pattern": "Runtime device count:", "exact": false, "linkedFunction": "static int __init dynamic_memory_init(void)" },
          { "pattern": "Allocating", "exact": false, "linkedFunction": "int allocate_devices(int count)" },
          { "pattern": "Successfully allocated", "exact": false, "linkedFunction": "int allocate_devices(int count)" },
          { "pattern": "Initializing", "exact": false, "linkedFunction": "static int __init dynamic_memory_init(void)" },
          { "pattern": "Device 1000 initialized", "exact": true, "linkedFunction": "void initialize_device(Device *dev, int id)" },
          { "pattern": "Printing device information...", "exact": true, "linkedFunction": "static int __init dynamic_memory_init(void)" },
          { "pattern": "Device 0:", "exact": true, "linkedFunction": "static int __init dynamic_memory_init(void)" },
          { "pattern": "=== Device Info ===", "exact": true, "linkedFunction": "void print_device_info(Device *dev)" },
          { "pattern": "Device ID: 1000", "exact": true, "linkedFunction": "void print_device_info(Device *dev)" },
          { "pattern": "Status: 200", "exact": true, "linkedFunction": "void print_device_info(Device *dev)" },
          { "pattern": "Active: YES", "exact": true, "linkedFunction": "void print_device_info(Device *dev)" },
          { "pattern": "Dynamic allocation demonstration completed", "exact": true, "linkedFunction": "static int __init dynamic_memory_init(void)" },
          { "pattern": "Dynamic memory module unloading", "exact": true, "linkedFunction": "static void __exit dynamic_memory_exit(void)" },
          { "pattern": "Freeing", "exact": false, "linkedFunction": "void cleanup_devices(void)" },
          { "pattern": "All devices freed", "exact": true, "linkedFunction": "void cleanup_devices(void)" },
          { "pattern": "Module unloaded cleanly", "exact": true, "linkedFunction": "static void __exit dynamic_memory_exit(void)" }
        ]
      },
      {
        "id": "advanced_dynamic_memory_validation",
        "name": "Advanced Dynamic Memory Implementation with TCC Header Validation",
        "type": "kernel_project_test",
        "critical": true,
        "testScenario": {
          "userspaceApps": [
            {
              "name": "memory_dynamic_tester",
              "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Runtime-Determined Size Allocation Test ===\\\\n\\\");\\n    \\n    srand(time(NULL));\\n    \\n    // Test different device counts (runtime-determined)\\n    int test_count1 = (rand() % 3) + 2;  // 2-4 devices\\n    int test_count2 = (rand() % 4) + 5;  // 5-8 devices\\n    \\n    printf(\\\"Test 1: Allocating %d devices (runtime size)\\\\n\\\", test_count1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/dynamic_memory.ko device_count=%d\\\", test_count1);\\n    system(\\\"rmmod dynamic_memory 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Allocating %d devices (runtime size)\\\\n\\\", test_count2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/dynamic_memory.ko device_count=%d\\\", test_count2);\\n    system(\\\"rmmod dynamic_memory\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Runtime-sized allocation test completed\\\\n\\\");\\n    return 0;\\n}"
            }
          ],
          "setupCommands": [
            "echo 'Starting advanced dynamic memory implementation validation'"
          ],
          "testCommands": [
            "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
            "echo 'Creating minimal kernel header stubs for TCC...'",
            "mkdir -p /tmp/linux",
            "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
            "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
            "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
            "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
            "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
            "echo '#define module_init(x)' >> /tmp/linux/module.h",
            "echo '#define module_exit(x)' >> /tmp/linux/module.h",
            "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
            "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
            "echo '#define __init' > /tmp/linux/init.h",
            "echo '#define __exit' >> /tmp/linux/init.h",
            "echo 'typedef int bool;' > /tmp/linux/types.h",
            "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
            "echo '#define true 1' >> /tmp/linux/types.h",
            "echo '#define false 0' >> /tmp/linux/types.h",
            "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
            "echo '#define MAX_DEVICES 5' >> /tmp/linux/types.h",
            "echo '#define GFP_KERNEL 0' > /tmp/linux/slab.h",
            "echo '#define ENOMEM 12' >> /tmp/linux/slab.h",
            "echo 'void *kmalloc(size_t size, int flags);' >> /tmp/linux/slab.h",
            "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
            "echo 'Creating test file that includes dynamic memory header...'",
            "echo '#include \"/lib/modules/dynamic_memory.h\"' > /tmp/test.c",
            "echo 'int main() { allocate_devices(3); initialize_device(&device_array[0], 1000); print_device_info(&device_array[0]); cleanup_devices(); return 0; }' >> /tmp/test.c",
            "echo 'Running TCC validation...'",
            "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
            "TCC_EXIT_CODE=$?",
            "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
            "echo 'Phase 2: Runtime-Determined Size Allocation Testing'",
            "/bin/memory_dynamic_tester > /tmp/test_output.log",
            "cat /tmp/test_output.log",
            "echo 'Phase 3: Extract Runtime Device Counts'",
            "sleep 1",
            "echo 'Extracting runtime device counts from test output...'",
            "COUNT1=$(grep -o 'Test 1: Allocating [0-9]*' /tmp/test_output.log | cut -d' ' -f4)",
            "COUNT2=$(grep -o 'Test 2: Allocating [0-9]*' /tmp/test_output.log | cut -d' ' -f4)",
            "echo 'Extracted runtime counts: COUNT1='$COUNT1', COUNT2='$COUNT2",
            "if [ -z \"$COUNT1\" ] || [ -z \"$COUNT2\" ]; then echo 'FAIL: Could not extract runtime counts'; else echo 'PASS: Runtime device counts extracted successfully'; fi",
            "echo 'Phase 4: Single Array Allocation Validation'",
            "echo 'Validating single array allocation...'",
            "dmesg | grep -E '(Allocating|allocated)' && echo 'PASS: Array allocation initiated' || echo 'FAIL: Array allocation broken'",
            "dmesg | grep -E '(Successfully allocated|allocated)' && echo 'PASS: Array allocation successful' || echo 'FAIL: Array allocation broken'",
            "echo 'Phase 5: Runtime Device Count Validation'",
            "echo 'Validating with runtime count '$COUNT1' devices...'",
            "dmesg | grep \"Runtime device count: $COUNT1\" && echo 'PASS: Runtime count '$COUNT1' detected' || echo 'FAIL: Runtime count detection broken'",
            "dmesg | grep -E '(Allocating|allocated)' && echo 'PASS: Correct device count allocation' || echo 'FAIL: Wrong device count'",
            "dmesg | grep -E '(Successfully|allocated)' && echo 'PASS: All devices allocated' || echo 'FAIL: Allocation incomplete'",
            "echo 'Phase 6: Device Initialization Validation'",
            "dmesg | grep 'Device 1000 initialized' && echo 'PASS: Device initialization working' || echo 'FAIL: Device initialization broken'",
            "dmesg | grep 'Device ID: 1000' && echo 'PASS: First device data correct' || echo 'FAIL: First device data wrong'",
            "dmesg | grep 'Status: 200' && echo 'PASS: Device status field correct' || echo 'FAIL: Device status wrong'",
            "dmesg | grep 'Active: YES' && echo 'PASS: Device boolean field correct' || echo 'FAIL: Device boolean wrong'",
            "echo 'Phase 7: Cleanup Validation'",
            "dmesg | grep -E '(Freeing|free)' && echo 'PASS: Cleanup initiated' || echo 'FAIL: Cleanup not initiated'",
            "dmesg | grep 'All devices freed' && echo 'PASS: Cleanup successful' || echo 'FAIL: Cleanup broken'",
            "dmesg | grep 'Module unloaded cleanly' && echo 'PASS: Complete cleanup successful' || echo 'FAIL: Module unload broken'",
            "echo 'Phase 8: Final Validation Summary'",
            "echo 'PASS: All runtime-determined allocation validation successful'"
          ],
          "expected": {
            "dmesg": [
              "Dynamic memory module loaded",
              "Runtime device count: .*",
              "Allocat",
              "Initializing.*devices",
              "Device 1000 initialized",
              "Device ID: 1000",
              "Status: 200",
              "Active: YES",
              "Freeing",
              "All devices freed",
              "Module unloaded cleanly"
            ],
            "stdout": [
              "PASS: All function and variable declarations found in header file",
              "SUCCESS: Runtime-sized allocation test completed",
              "PASS: Runtime device counts extracted successfully",
              "PASS: Array allocation initiated",
              "PASS: Array allocation successful",
              "PASS: Runtime count.*detected",
              "PASS: Correct device count allocation",
              "PASS: All devices allocated",
              "PASS: Device initialization working",
              "PASS: First device data correct",
              "PASS: Device status field correct",
              "PASS: Device boolean field correct",
              "PASS: Cleanup initiated",
              "PASS: Cleanup successful",
              "PASS: Complete cleanup successful",
              "PASS: All runtime-determined allocation validation successful"
            ]
          },
          "timeout": 15
        }
      }
    ]
  }
}
