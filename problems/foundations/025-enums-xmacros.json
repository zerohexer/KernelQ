{
  "id": 25,
  "title": "Enums and X-Macros - Managing Related Constants",
  "phase": "foundations",
  "difficulty": 6,
  "xp": 65,
  "description": "Master enums for grouped constants and X-macros for sophisticated code generation. Learn to define data once and generate multiple related structures automatically - a powerful pattern used throughout Linux kernel development.",
  "mainFile": "enum_processor.c",
  "files": [
    {
      "name": "enum_processor.h",
      "content": "#ifndef ENUM_PROCESSOR_H\n#define ENUM_PROCESSOR_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* LEARNING PROGRESSION: From Basic Constants to Code Generation */\n/* This problem teaches the evolution from basic #define to sophisticated X-macros */\n\n/* STEP 1: Introduction to Enums */\n/* Enums are a way to group related constants together with automatic numbering */\n/* Instead of: #define STATE_IDLE 0, #define STATE_ACTIVE 1, #define STATE_ERROR 2 */\n/* You can write: enum { STATE_IDLE, STATE_ACTIVE, STATE_ERROR }; */\n\n/* TODO: Define basic device state enum */\n/* Create enum device_state with values: DEVICE_OFFLINE, DEVICE_ONLINE, DEVICE_ERROR */\n/* Enums automatically assign 0, 1, 2... unless you specify otherwise */\n\n/* TODO: Define priority enum with custom values */\n/* Create enum priority with values: PRIORITY_LOW = 1, PRIORITY_MEDIUM = 5, PRIORITY_HIGH = 10 */\n\n/* STEP 2: The Manual Maintenance Problem */\n/* When you have related data (enum + strings + IDs), keeping them synchronized is tedious */\n\n/* TODO: Define device type enum manually */\n/* Create enum device_type with values: TYPE_SENSOR, TYPE_MOTOR, TYPE_LED */\n\n/* Manual approach - you have to update multiple places when adding new types! */\nextern const char* device_type_names[];\nextern const uint16_t device_type_ids[];\n\n/* STEP 3: X-Macro Solution - Define Once, Use Everywhere */\n/* X-macros solve the synchronization problem by defining data once */\n/* and generating multiple related structures automatically */\n\n/* TODO: Define the X-macro table */\n/* Create macro DEVICE_TABLE(X) that calls X for each device: */\n/* X(SENSOR, \"Temperature Sensor\", 0x2001) */\n/* X(MOTOR, \"Stepper Motor\", 0x2002) */\n/* X(LED, \"Status LED\", 0x2003) */\n/* X(DISPLAY, \"LCD Display\", 0x2004) */\n\n/* TODO: Generate enum using X-macro */\n/* Create enum xmacro_device_type using the DEVICE_TABLE */\n/* Pattern: #define MAKE_ENUM(name, desc, id) XDEV_##name, */\n/*          enum xmacro_device_type { DEVICE_TABLE(MAKE_ENUM) }; */\n/*          #undef MAKE_ENUM */\n\n/* Configuration structure for testing */\ntypedef struct {\n    enum device_state state;\n    enum priority priority;\n    enum device_type manual_type;\n    // enum xmacro_device_type auto_type;  // TODO: Add this after creating X-macro enum\n    uint16_t device_id;\n    char device_name[64];\n} device_config;\n\n/* Global test configuration */\nextern device_config test_config;\n\n/* TODO: Declare your testing functions */\n/* void test_basic_enums(void); */\n/* void test_manual_approach(void); */\n/* void test_xmacro_generation(void); */\n/* void demonstrate_synchronization(void); */\n/* void print_device_config(device_config *config); */\n\n#endif /* ENUM_PROCESSOR_H */",
      "readOnly": false,
      "language": "h"
    },
    {
      "name": "enum_processor.c",
      "content": "#include \"enum_processor.h\"\n\n/* Global test configuration */\ndevice_config test_config = {\n    .state = DEVICE_OFFLINE,\n    .priority = PRIORITY_LOW,\n    .manual_type = TYPE_SENSOR,\n    // .auto_type = XDEV_SENSOR,  // TODO: Enable after creating X-macro enum\n    .device_id = 0,\n    .device_name = \"Test Device\"\n};\n\nint test_device_type = TYPE_SENSOR;\nint test_priority = PRIORITY_MEDIUM;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n */\nmodule_param(test_device_type, int, 0644);\nMODULE_PARM_DESC(test_device_type, \"Device type for testing enum values\");\nmodule_param(test_priority, int, 0644);\nMODULE_PARM_DESC(test_priority, \"Priority level for testing enum functionality\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: Evolution from Constants to Code Generation */\n/* This teaches the PROGRESSION in kernel programming:\n *\n * Stage 1: Basic Constants\n * #define STATE_IDLE 0\n * #define STATE_ACTIVE 1\n * Problem: No grouping, easy to make mistakes\n *\n * Stage 2: Enums (Grouped Constants)\n * enum state { STATE_IDLE, STATE_ACTIVE, STATE_ERROR };\n * Benefits: Automatic numbering, type safety, logical grouping\n *\n * Stage 3: Manual Related Data\n * enum device_type { TYPE_A, TYPE_B };\n * const char* names[] = { \"Device A\", \"Device B\" };\n * Problem: Must update multiple places, easy to get out of sync\n *\n * Stage 4: X-Macros (Code Generation)\n * #define DEVICE_TABLE(X) X(A, \"Device A\", 0x100) X(B, \"Device B\", 0x200)\n * Benefits: Define once, generate enum + strings + IDs automatically\n *\n * Why X-Macros are Essential in Kernel:\n * - System call tables: NR_syscalls generated from syscall definitions\n * - Error codes: Both enum and string arrays from single definition\n * - Driver registration: Device tables with IDs, names, and handlers\n * - Trace points: Event definitions generate both code and documentation\n */\n\n/* STEP 1: Manual arrays for device types (before X-macros) */\n/* TODO: Implement manual device type arrays */\nconst char* device_type_names[] = {\n    /* TODO: Add string names that match the enum device_type order */\n    /* \"Temperature Sensor\", \"Stepper Motor\", \"Status LED\" */\n};\n\nconst uint16_t device_type_ids[] = {\n    /* TODO: Add IDs that match the enum device_type order */\n    /* 0x1001, 0x1002, 0x1003 */\n};\n\n/* STEP 2: X-Macro generated arrays (after X-macros) */\n/* TODO: Implement X-macro generated arrays */\n/* Generate string array using X-macro pattern: */\n/* const char* xmacro_device_names[] = { */\n/* #define MAKE_STRING(name, desc, id) desc, */\n/*     DEVICE_TABLE(MAKE_STRING) */\n/* #undef MAKE_STRING */\n/* }; */\n\n/* Generate ID array using X-macro pattern: */\n/* const uint16_t xmacro_device_ids[] = { */\n/* #define MAKE_ID(name, desc, id) id, */\n/*     DEVICE_TABLE(MAKE_ID) */\n/* #undef MAKE_ID */\n/* }; */\n\n/* TODO: Implement basic enum testing */\nvoid test_basic_enums(void) {\n    /* TODO: Test basic enum functionality */\n    /* TODO: Print \"Testing basic enums:\" */\n    /* TODO: Print \"DEVICE_OFFLINE = %d\" with DEVICE_OFFLINE value */\n    /* TODO: Print \"DEVICE_ONLINE = %d\" with DEVICE_ONLINE value */\n    /* TODO: Print \"DEVICE_ERROR = %d\" with DEVICE_ERROR value */\n    \n    /* TODO: Test priority enum with custom values */\n    /* TODO: Print \"PRIORITY_LOW = %d\" with PRIORITY_LOW value */\n    /* TODO: Print \"PRIORITY_MEDIUM = %d\" with PRIORITY_MEDIUM value */\n    /* TODO: Print \"PRIORITY_HIGH = %d\" with PRIORITY_HIGH value */\n}\n\n/* TODO: Implement manual approach testing */\nvoid test_manual_approach(void) {\n    /* TODO: Test manual enum and array coordination */\n    /* TODO: Print \"Testing manual approach:\" */\n    \n    /* TODO: Test that enum values match array indices */\n    /* TODO: Print \"TYPE_SENSOR name: %s\" with device_type_names[TYPE_SENSOR] */\n    /* TODO: Print \"TYPE_MOTOR name: %s\" with device_type_names[TYPE_MOTOR] */\n    /* TODO: Print \"TYPE_LED name: %s\" with device_type_names[TYPE_LED] */\n    \n    /* TODO: Test ID lookup */\n    /* TODO: Print \"TYPE_SENSOR ID: 0x%04x\" with device_type_ids[TYPE_SENSOR] */\n    /* TODO: Print \"TYPE_MOTOR ID: 0x%04x\" with device_type_ids[TYPE_MOTOR] */\n}\n\n/* TODO: Implement X-macro generation testing */\nvoid test_xmacro_generation(void) {\n    /* TODO: Test X-macro generated structures */\n    /* TODO: Print \"Testing X-macro generation:\" */\n    \n    /* TODO: Test X-macro generated enum */\n    /* TODO: Print \"XDEV_SENSOR = %d\" with XDEV_SENSOR value */\n    /* TODO: Print \"XDEV_MOTOR = %d\" with XDEV_MOTOR value */\n    /* TODO: Print \"XDEV_LED = %d\" with XDEV_LED value */\n    /* TODO: Print \"XDEV_DISPLAY = %d\" with XDEV_DISPLAY value */\n    \n    /* TODO: Test X-macro generated arrays */\n    /* TODO: Print \"XDEV_SENSOR name: %s\" with xmacro_device_names[XDEV_SENSOR] */\n    /* TODO: Print \"XDEV_DISPLAY name: %s\" with xmacro_device_names[XDEV_DISPLAY] */\n    /* TODO: Print \"XDEV_SENSOR ID: 0x%04x\" with xmacro_device_ids[XDEV_SENSOR] */\n    /* TODO: Print \"XDEV_DISPLAY ID: 0x%04x\" with xmacro_device_ids[XDEV_DISPLAY] */\n}\n\n/* TODO: Implement synchronization demonstration */\nvoid demonstrate_synchronization(void) {\n    /* TODO: Show the power of X-macro synchronization */\n    /* TODO: Print \"Demonstrating automatic synchronization:\" */\n    \n    /* TODO: Show that adding new devices to DEVICE_TABLE automatically updates everything */\n    /* TODO: Create variable: int device_count = sizeof(xmacro_device_names) / sizeof(xmacro_device_names[0]) */\n    /* TODO: Print \"Total devices in X-macro table: %d\" with device_count */\n    \n    /* TODO: Demonstrate dynamic access */\n    /* TODO: Use test_device_type parameter to look up device info */\n    /* TODO: Print \"Selected device type %d\" with test_device_type */\n    /* TODO: Print \"Device name: %s\" with xmacro_device_names[test_device_type] */\n    /* TODO: Print \"Device ID: 0x%04x\" with xmacro_device_ids[test_device_type] */\n}\n\nvoid print_device_config(device_config *config) {\n    if (!config) {\n        printk(KERN_ERR \"No device configuration available\\n\");\n        return;\n    }\n    \n    printk(KERN_INFO \"Device Configuration:\\n\");\n    printk(KERN_INFO \"  Name: %s\\n\", config->device_name);\n    printk(KERN_INFO \"  State: %d\\n\", config->state);\n    printk(KERN_INFO \"  Priority: %d\\n\", config->priority);\n    printk(KERN_INFO \"  Manual Type: %d\\n\", config->manual_type);\n    printk(KERN_INFO \"  Device ID: 0x%04x\\n\", config->device_id);\n}\n\nstatic int __init enum_processor_init(void)\n{\n    printk(KERN_INFO \"Enum processor module loaded\\n\");\n    \n    /* Update test configuration with dynamic parameter values */\n    test_config.manual_type = test_device_type;\n    test_config.priority = test_priority;\n    test_config.device_id = device_type_ids[test_device_type];\n    \n    printk(KERN_INFO \"Testing enum and X-macro concepts\\n\");\n    \n    /* Test all enum and X-macro concepts */\n    test_basic_enums();\n    test_manual_approach();\n    test_xmacro_generation();\n    demonstrate_synchronization();\n    \n    /* Display final configuration */\n    print_device_config(&test_config);\n    \n    printk(KERN_INFO \"Enum and X-macro demonstration completed\\n\");\n    \n    return 0;\n}\n\nstatic void __exit enum_processor_exit(void)\n{\n    printk(KERN_INFO \"Enum processor module unloaded\\n\");\n}\n\nmodule_init(enum_processor_init);\nmodule_exit(enum_processor_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning enums and X-macros for managing related constants\");\nMODULE_VERSION(\"1.0\");",
      "readOnly": false,
      "language": "c"
    },
    {
      "name": "Makefile",
      "content": "# Enum processor module Makefile\nobj-m += enum_processor.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
      "readOnly": true,
      "language": "makefile"
    }
  ],
  "concepts": [
    "enum fundamentals",
    "grouped constants",
    "automatic enumeration",
    "custom enum values",
    "X-macro patterns",
    "code generation",
    "define once use everywhere",
    "data synchronization"
  ],
  "skills": [
    "Defining enums for related constants",
    "Using enums instead of #define constants",
    "Understanding automatic vs custom enum values",
    "Creating X-macro tables",
    "Generating code with X-macros",
    "Maintaining synchronized data structures",
    "Applying kernel-style code generation patterns"
  ],
  "validation": {
    "exactRequirements": {
      "functionNames": [
        "enum_processor_init",
        "enum_processor_exit",
        "test_basic_enums",
        "test_manual_approach",
        "test_xmacro_generation",
        "demonstrate_synchronization",
        "print_device_config"
      ],
      "macro_declarations": [
        {
          "name": "DEVICE_TABLE",
          "type": "function-like",
          "parameters": ["X"],
          "value": "X(SENSOR, \"Temperature Sensor\", 0x2001) X(MOTOR, \"Stepper Motor\", 0x2002) X(LED, \"Status LED\", 0x2003) X(DISPLAY, \"LCD Display\", 0x2004)",
          "description": "X-macro table defining all devices with name, description, and ID"
        },
        {
          "name": "MAKE_ENUM",
          "type": "function-like",
          "parameters": ["name", "desc", "id"],
          "value": "XDEV_##name,",
          "description": "X-macro helper to generate enum values"
        },
        {
          "name": "MAKE_STRING",
          "type": "function-like",
          "parameters": ["name", "desc", "id"],
          "value": "desc,",
          "description": "X-macro helper to generate string array entries"
        },
        {
          "name": "MAKE_ID",
          "type": "function-like",
          "parameters": ["name", "desc", "id"],
          "value": "id,",
          "description": "X-macro helper to generate ID array entries"
        }
      ],
      "macro_definitions": [],
      "function_declarations": [
        {
          "name": "test_basic_enums",
          "returnType": "void",
          "parameters": ["void"]
        },
        {
          "name": "test_manual_approach",
          "returnType": "void",
          "parameters": ["void"]
        },
        {
          "name": "test_xmacro_generation",
          "returnType": "void",
          "parameters": ["void"]
        },
        {
          "name": "demonstrate_synchronization",
          "returnType": "void",
          "parameters": ["void"]
        },
        {
          "name": "print_device_config",
          "returnType": "void",
          "parameters": ["device_config *config"]
        }
      ],
      "variables_declarations": [
        {
          "name": "device_state",
          "type": "enum",
          "value": "{DEVICE_OFFLINE, DEVICE_ONLINE, DEVICE_ERROR}",
          "storageClass": "none"
        },
        {
          "name": "priority",
          "type": "enum",
          "value": "{PRIORITY_LOW = 1, PRIORITY_MEDIUM = 5, PRIORITY_HIGH = 10}",
          "storageClass": "none"
        },
        {
          "name": "device_type",
          "type": "enum",
          "value": "{TYPE_SENSOR, TYPE_MOTOR, TYPE_LED}",
          "storageClass": "none"
        },
        {
          "name": "xmacro_device_type",
          "type": "enum",
          "value": "{XDEV_SENSOR, XDEV_MOTOR, XDEV_LED, XDEV_DISPLAY}",
          "storageClass": "none"
        },
        {
          "name": "device_config",
          "type": "typedef struct",
          "value": "{enum device_state state; enum priority priority; enum device_type manual_type; uint16_t device_id; char device_name[64];}",
          "storageClass": "none"
        },
        {
          "name": "device_type_names",
          "type": "const char*",
          "value": "[]",
          "storageClass": "extern"
        },
        {
          "name": "device_type_ids",
          "type": "const uint16_t",
          "value": "[]",
          "storageClass": "extern"
        },
        {
          "name": "test_config",
          "type": "device_config",
          "storageClass": "extern"
        }
      ],
      "variables": [
        {
          "name": "test_config",
          "type": "device_config",
          "storageClass": "none"
        },
        {
          "name": "device_type_names",
          "type": "const char*",
          "value": "[]",
          "storageClass": "none"
        },
        {
          "name": "device_type_ids",
          "type": "const uint16_t",
          "value": "[]",
          "storageClass": "none"
        },
        {
          "name": "xmacro_device_names",
          "type": "const char*",
          "value": "[]",
          "storageClass": "none"
        },
        {
          "name": "xmacro_device_ids",
          "type": "const uint16_t",
          "value": "[]",
          "storageClass": "none"
        }
      ],
      "outputMessages": [
        "Enum processor module loaded",
        "Testing enum and X-macro concepts",
        "Testing basic enums:",
        "DEVICE_OFFLINE = 0",
        "DEVICE_ONLINE = 1",
        "DEVICE_ERROR = 2",
        "PRIORITY_LOW = 1",
        "PRIORITY_MEDIUM = 5",
        "PRIORITY_HIGH = 10",
        "Testing manual approach:",
        "TYPE_SENSOR name:",
        "TYPE_MOTOR name:",
        "TYPE_LED name:",
        "TYPE_SENSOR ID:",
        "TYPE_MOTOR ID:",
        "Testing X-macro generation:",
        "XDEV_SENSOR = 0",
        "XDEV_MOTOR = 1",
        "XDEV_LED = 2",
        "XDEV_DISPLAY = 3",
        "XDEV_SENSOR name:",
        "XDEV_DISPLAY name:",
        "XDEV_SENSOR ID:",
        "XDEV_DISPLAY ID:",
        "Demonstrating automatic synchronization:",
        "Total devices in X-macro table:",
        "Selected device type",
        "Device name:",
        "Device ID:",
        "Device Configuration:",
        "Enum and X-macro demonstration completed",
        "Enum processor module unloaded"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/types.h"
      ],
      "mustContain": [
        "enum device_state",
        "DEVICE_OFFLINE",
        "DEVICE_ONLINE",
        "DEVICE_ERROR",
        "enum priority",
        "PRIORITY_LOW = 1",
        "PRIORITY_MEDIUM = 5",
        "PRIORITY_HIGH = 10",
        "enum device_type",
        "TYPE_SENSOR",
        "TYPE_MOTOR",
        "TYPE_LED",
        "#define DEVICE_TABLE(X)",
        "X(SENSOR,",
        "X(MOTOR,",
        "X(LED,",
        "X(DISPLAY,",
        "enum xmacro_device_type",
        "#define MAKE_ENUM(name, desc, id) XDEV_##name,",
        "DEVICE_TABLE(MAKE_ENUM)",
        "#undef MAKE_ENUM",
        "xmacro_device_names",
        "#define MAKE_STRING(name, desc, id) desc,",
        "DEVICE_TABLE(MAKE_STRING)",
        "#undef MAKE_STRING",
        "xmacro_device_ids",
        "#define MAKE_ID(name, desc, id) id,",
        "DEVICE_TABLE(MAKE_ID)",
        "#undef MAKE_ID",
        "device_type_names[TYPE_SENSOR]",
        "device_type_ids[TYPE_SENSOR]",
        "xmacro_device_names[XDEV_SENSOR]",
        "xmacro_device_ids[XDEV_SENSOR]",
        "sizeof(xmacro_device_names)",
        "module_param(test_device_type, int, 0644)",
        "module_param(test_priority, int, 0644)"
      ],
      "moduleInfo": {
        "license": "GPL"
      }
    },
    "testCases": [
      {
        "id": "function_declarations",
        "name": "Function Declarations in Header",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "void test_basic_enums(void)",
          "void test_manual_approach(void)",
          "void test_xmacro_generation(void)",
          "void demonstrate_synchronization(void)",
          "void print_device_config(device_config *config)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "enum_definitions",
        "name": "Enum Definitions in Header",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "enum device_state",
          "enum priority",
          "enum device_type",
          "enum xmacro_device_type",
          "DEVICE_OFFLINE",
          "DEVICE_ONLINE",
          "DEVICE_ERROR",
          "PRIORITY_LOW",
          "PRIORITY_MEDIUM",
          "PRIORITY_HIGH",
          "TYPE_SENSOR",
          "TYPE_MOTOR",
          "TYPE_LED",
          "XDEV_SENSOR",
          "XDEV_MOTOR",
          "XDEV_LED",
          "XDEV_DISPLAY"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "xmacro_patterns",
        "name": "X-Macro Pattern Implementation",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "#define DEVICE_TABLE(X)",
          "#define MAKE_ENUM",
          "DEVICE_TABLE(MAKE_ENUM)",
          "#undef MAKE_ENUM",
          "#define MAKE_STRING",
          "DEVICE_TABLE(MAKE_STRING)",
          "#undef MAKE_STRING",
          "#define MAKE_ID",
          "DEVICE_TABLE(MAKE_ID)",
          "#undef MAKE_ID"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "function_signatures_source",
        "name": "Function Signatures in Source File",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "void test_basic_enums(void)",
          "void test_manual_approach(void)",
          "void test_xmacro_generation(void)",
          "void demonstrate_synchronization(void)",
          "void print_device_config(device_config *config)",
          "static int __init enum_processor_init(void)",
          "static void __exit enum_processor_exit(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "exact_output",
        "name": "Exact Output Messages",
        "type": "output_match",
        "critical": true,
        "expected": [
          {
            "pattern": "Enum processor module loaded",
            "exact": true,
            "linkedFunction": "static int __init enum_processor_init(void)"
          },
          {
            "pattern": "Testing enum and X-macro concepts",
            "exact": true,
            "linkedFunction": "static int __init enum_processor_init(void)"
          },
          {
            "pattern": "Testing basic enums:",
            "exact": true,
            "linkedFunction": "void test_basic_enums(void)"
          },
          {
            "pattern": "DEVICE_OFFLINE = 0",
            "exact": true,
            "linkedFunction": "void test_basic_enums(void)"
          },
          {
            "pattern": "DEVICE_ONLINE = 1",
            "exact": true,
            "linkedFunction": "void test_basic_enums(void)"
          },
          {
            "pattern": "DEVICE_ERROR = 2",
            "exact": true,
            "linkedFunction": "void test_basic_enums(void)"
          },
          {
            "pattern": "PRIORITY_LOW = 1",
            "exact": true,
            "linkedFunction": "void test_basic_enums(void)"
          },
          {
            "pattern": "PRIORITY_MEDIUM = 5",
            "exact": true,
            "linkedFunction": "void test_basic_enums(void)"
          },
          {
            "pattern": "PRIORITY_HIGH = 10",
            "exact": true,
            "linkedFunction": "void test_basic_enums(void)"
          },
          {
            "pattern": "Testing manual approach:",
            "exact": true,
            "linkedFunction": "void test_manual_approach(void)"
          },
          {
            "pattern": "Testing X-macro generation:",
            "exact": true,
            "linkedFunction": "void test_xmacro_generation(void)"
          },
          {
            "pattern": "XDEV_SENSOR = 0",
            "exact": true,
            "linkedFunction": "void test_xmacro_generation(void)"
          },
          {
            "pattern": "XDEV_MOTOR = 1",
            "exact": true,
            "linkedFunction": "void test_xmacro_generation(void)"
          },
          {
            "pattern": "XDEV_LED = 2",
            "exact": true,
            "linkedFunction": "void test_xmacro_generation(void)"
          },
          {
            "pattern": "XDEV_DISPLAY = 3",
            "exact": true,
            "linkedFunction": "void test_xmacro_generation(void)"
          },
          {
            "pattern": "Demonstrating automatic synchronization:",
            "exact": true,
            "linkedFunction": "void demonstrate_synchronization(void)"
          },
          {
            "pattern": "Device Configuration:",
            "exact": true,
            "linkedFunction": "void print_device_config(device_config *config)"
          },
          {
            "pattern": "Enum and X-macro demonstration completed",
            "exact": true,
            "linkedFunction": "static int __init enum_processor_init(void)"
          },
          {
            "pattern": "Enum processor module unloaded",
            "exact": true,
            "linkedFunction": "static void __exit enum_processor_exit(void)"
          }
        ]
      },
      {
        "id": "enum_xmacro_validation",
        "name": "Enum and X-Macro Dynamic Validation",
        "type": "kernel_project_test",
        "critical": true,
        "testScenario": {
          "userspaceApps": [
            {
              "name": "enum_dynamic_tester",
              "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Enum and X-Macro Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate test values\\n    int random_device_type = (rand() % 3);     // 0, 1, or 2 (TYPE_SENSOR, TYPE_MOTOR, TYPE_LED)\\n    int random_priority = ((rand() % 3) == 0) ? 1 : ((rand() % 3) == 1) ? 5 : 10;  // 1, 5, or 10\\n    \\n    printf(\\\"Random enum test (device=%d, priority=%d)\\\\n\\\", random_device_type, random_priority);\\n    \\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod enum_processor 2>/dev/null\\\");\\n    \\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/enum_processor.ko test_device_type=%d test_priority=%d\\\", random_device_type, random_priority);\\n    printf(\\\"DEBUG: Command: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Enum test completed\\\\n\\\");\\n    return 0;\\n}"
            }
          ],
          "setupCommands": [
            "echo 'Starting enum and X-macro validation'"
          ],
          "testCommands": [
            "echo 'Phase 1: TCC Header Validation'",
            "mkdir -p /tmp/linux",
            "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
            "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
            "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
            "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
            "echo '#define module_init(x)' >> /tmp/linux/module.h",
            "echo '#define module_exit(x)' >> /tmp/linux/module.h",
            "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
            "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
            "echo '#define __init' > /tmp/linux/init.h",
            "echo '#define __exit' >> /tmp/linux/init.h",
            "echo 'typedef unsigned char uint8_t;' > /tmp/linux/types.h",
            "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
            "echo '#include \"/lib/modules/enum_processor.h\"' > /tmp/test.c",
            "echo 'int main() { device_config config; test_basic_enums(); test_manual_approach(); test_xmacro_generation(); demonstrate_synchronization(); print_device_config(&config); return 0; }' >> /tmp/test.c",
            "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
            "TCC_EXIT_CODE=$?",
            "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or enum definition missing'; cat /tmp/tcc_error.log; else echo 'PASS: All declarations found in header'; fi",
            "echo 'Phase 2: Dynamic Enum Test'",
            "/bin/enum_dynamic_tester > /tmp/test_output.log",
            "cat /tmp/test_output.log",
            "echo 'Phase 3: Enum and X-Macro Validation'",
            "sleep 1",
            "dmesg | grep 'DEVICE_OFFLINE = 0' && echo 'PASS: Basic enum values working' || echo 'FAIL: Basic enum values broken'",
            "dmesg | grep 'PRIORITY_LOW = 1' && echo 'PASS: Custom enum values working' || echo 'FAIL: Custom enum values broken'",
            "dmesg | grep 'PRIORITY_MEDIUM = 5' && echo 'PASS: Custom enum values working' || echo 'FAIL: Custom enum values broken'",
            "dmesg | grep 'PRIORITY_HIGH = 10' && echo 'PASS: Custom enum values working' || echo 'FAIL: Custom enum values broken'",
            "dmesg | grep 'XDEV_SENSOR = 0' && echo 'PASS: X-macro enum generation working' || echo 'FAIL: X-macro enum generation broken'",
            "dmesg | grep 'XDEV_DISPLAY = 3' && echo 'PASS: X-macro enum generation working' || echo 'FAIL: X-macro enum generation broken'",
            "dmesg | grep 'Total devices in X-macro table:' && echo 'PASS: X-macro synchronization working' || echo 'FAIL: X-macro synchronization broken'",
            "dmesg | grep 'Testing basic enums:' && echo 'PASS: Basic enum testing working' || echo 'FAIL: Basic enum testing broken'",
            "dmesg | grep 'Testing manual approach:' && echo 'PASS: Manual approach testing working' || echo 'FAIL: Manual approach testing broken'",
            "dmesg | grep 'Testing X-macro generation:' && echo 'PASS: X-macro generation testing working' || echo 'FAIL: X-macro generation testing broken'",
            "dmesg | grep 'Enum processor module loaded' && echo 'PASS: Module loading working' || echo 'FAIL: Module loading broken'",
            "echo 'PASS: All enum and X-macro validation successful'"
          ],
          "expected": {
            "dmesg": [
              "Enum processor module loaded",
              "Testing enum and X-macro concepts",
              "Testing basic enums:",
              "DEVICE_OFFLINE = 0",
              "DEVICE_ONLINE = 1",
              "DEVICE_ERROR = 2",
              "PRIORITY_LOW = 1",
              "PRIORITY_MEDIUM = 5",
              "PRIORITY_HIGH = 10",
              "Testing manual approach:",
              "TYPE_SENSOR name: .*",
              "TYPE_MOTOR name: .*",
              "TYPE_LED name: .*",
              "TYPE_SENSOR ID: .*",
              "TYPE_MOTOR ID: .*",
              "Testing X-macro generation:",
              "XDEV_SENSOR = 0",
              "XDEV_MOTOR = 1",
              "XDEV_LED = 2",
              "XDEV_DISPLAY = 3",
              "XDEV_SENSOR name: .*",
              "XDEV_DISPLAY name: .*",
              "XDEV_SENSOR ID: .*",
              "XDEV_DISPLAY ID: .*",
              "Demonstrating automatic synchronization:",
              "Total devices in X-macro table: .*",
              "Selected device type .*",
              "Device name: .*",
              "Device ID: .*",
              "Device Configuration:",
              "Enum and X-macro demonstration completed",
              "Enum processor module unloaded"
            ],
            "stdout": [
              "PASS: All declarations found in header",
              "SUCCESS: Enum test completed",
              "PASS: Basic enum values working",
              "PASS: Custom enum values working",
              "PASS: X-macro enum generation working",
              "PASS: X-macro synchronization working",
              "PASS: Basic enum testing working",
              "PASS: Manual approach testing working",
              "PASS: X-macro generation testing working",
              "PASS: Module loading working",
              "PASS: All enum and X-macro validation successful"
            ]
          },
          "timeout": 30
        }
      }
    ]
  }
}