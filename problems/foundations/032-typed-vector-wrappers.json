{
  "id": 32,
  "title": "Typed Vector Wrappers - Building Generic Libraries with Macros",
  "phase": "foundations",
  "difficulty": 7,
  "xp": 70,
  "description": "Master macro-based generic programming by creating type-safe wrappers around the generic vector. Learn to build reusable 'template-like' libraries in C using typedef aliases and macros - the exact pattern used in production kernel code like the Linux kernel's list.h and other generic data structures. This problem teaches you to turn void* containers into type-safe interfaces without code duplication.",
  "mainFile": "sensor_vector.c",
  "files": [
    {
      "name": "kernel_vector.h",
      "content": "#ifndef KERNEL_VECTOR_H\n#define KERNEL_VECTOR_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n/* Generic vector implementation (from Problem 030) */\n#define VECTOR_INIT_CAPACITY 4\n#define VECTOR_SUCCESS 0\n#define VECTOR_ERROR -1\n\ntypedef struct vector {\n    void **items;\n    int capacity;\n    int total;\n} vector;\n\n/* Generic vector API */\nint vector_init(vector *v);\nint vector_total(vector *v);\nint vector_add(vector *v, void *item);\nint vector_set(vector *v, int index, void *item);\nvoid *vector_get(vector *v, int index);\nint vector_delete(vector *v, int index);\nvoid vector_free(vector *v);\n\n#endif /* KERNEL_VECTOR_H */\n",
      "readOnly": true,
      "language": "h"
    },
    {
      "name": "kernel_vector.c",
      "content": "#include \"kernel_vector.h\"\n\n/* Generic vector implementation (provided from Problem 030) */\n\nstatic int vector_resize(vector *v, int capacity) {\n    void **new_items = krealloc(v->items, sizeof(void*) * capacity, GFP_KERNEL);\n    if (!new_items) return VECTOR_ERROR;\n    v->items = new_items;\n    v->capacity = capacity;\n    return VECTOR_SUCCESS;\n}\n\nint vector_init(vector *v) {\n    v->capacity = VECTOR_INIT_CAPACITY;\n    v->total = 0;\n    v->items = kmalloc(sizeof(void*) * v->capacity, GFP_KERNEL);\n    return v->items ? VECTOR_SUCCESS : VECTOR_ERROR;\n}\nEXPORT_SYMBOL(vector_init);\n\nint vector_total(vector *v) {\n    return v->total;\n}\nEXPORT_SYMBOL(vector_total);\n\nint vector_add(vector *v, void *item) {\n    if (v->capacity == v->total) {\n        if (vector_resize(v, v->capacity * 2) == VECTOR_ERROR)\n            return VECTOR_ERROR;\n    }\n    v->items[v->total++] = item;\n    return VECTOR_SUCCESS;\n}\nEXPORT_SYMBOL(vector_add);\n\nint vector_set(vector *v, int index, void *item) {\n    if (index < 0 || index >= v->total) return VECTOR_ERROR;\n    v->items[index] = item;\n    return VECTOR_SUCCESS;\n}\nEXPORT_SYMBOL(vector_set);\n\nvoid *vector_get(vector *v, int index) {\n    if (index < 0 || index >= v->total) return NULL;\n    return v->items[index];\n}\nEXPORT_SYMBOL(vector_get);\n\nint vector_delete(vector *v, int index) {\n    if (index < 0 || index >= v->total) return VECTOR_ERROR;\n    for (int i = index; i < v->total - 1; i++)\n        v->items[i] = v->items[i + 1];\n    v->total--;\n    if (v->total > 0 && v->total == v->capacity / 4)\n        vector_resize(v, v->capacity / 2);\n    return VECTOR_SUCCESS;\n}\nEXPORT_SYMBOL(vector_delete);\n\nvoid vector_free(vector *v) {\n    kfree(v->items);\n    v->items = NULL;\n    v->total = 0;\n    v->capacity = 0;\n}\nEXPORT_SYMBOL(vector_free);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"KernelQ\");\nMODULE_DESCRIPTION(\"Generic vector implementation for kernel modules\");\nMODULE_VERSION(\"1.0\");\n",
      "readOnly": true,
      "language": "c"
    },
    {
      "name": "sensor_data.h",
      "content": "#ifndef SENSOR_DATA_H\n#define SENSOR_DATA_H\n\n#include <linux/types.h>\n\n#define MAX_SENSOR_NAME 32\n#define MAX_SENSOR_UNIT 16\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: Typed Data Structure for Generic Container */\n/* ========================================================================== */\n/* This teaches you to design data structures that work with generic containers!\n *\n * DESIGN PRINCIPLES:\n * 1. Self-contained: All data needed is in the struct\n * 2. Fixed-size strings: No dynamic allocation within the struct\n * 3. Clear semantics: Field names describe their purpose\n * 4. Production pattern: Exactly how kernel subsystems work\n *\n * EXAMPLE KERNEL USAGE:\n * - struct task_struct for processes (linux/sched.h)\n * - struct net_device for network devices (linux/netdevice.h)\n * - struct file for open files (linux/fs.h)\n */\n\n/* Sensor data structure */\ntypedef struct {\n    uint32_t sensor_id;\n    char sensor_name[MAX_SENSOR_NAME];\n    uint32_t reading_value;  /* Fixed-point: divide by 10 for decimal (e.g., 255 = 25.5) */\n    char unit[MAX_SENSOR_UNIT];\n    uint64_t timestamp;\n    bool is_active;\n} SensorData;\n\n#endif /* SENSOR_DATA_H */\n",
      "readOnly": false,
      "language": "h"
    },
    {
      "name": "sensor_vector.h",
      "content": "#ifndef SENSOR_VECTOR_H\n#define SENSOR_VECTOR_H\n\n#include \"kernel_vector.h\"\n#include \"sensor_data.h\"\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: Type-Safe Vector Wrapper Using Macros */\n/* ========================================================================== */\n/* This teaches PRODUCTION-LEVEL generic programming patterns in C!\n *\n * THE PROBLEM:\n * - Generic vector uses void*, which loses type information\n * - Casting everywhere: (SensorData*)vector_get(&v, 0) is error-prone\n * - No compile-time type checking for wrong types\n *\n * THE SOLUTION:\n * - Create typed aliases using typedef\n * - Wrap generic functions with type-safe macros\n * - Hide void* casts inside macros\n * - Provide a clean, type-safe interface\n *\n * REAL-WORLD EXAMPLES:\n * Linux kernel uses this pattern extensively:\n * - list.h: list_for_each_entry()\n * - rbtree.h: rb_entry()\n * - hashtable.h: hash_for_each()\n *\n * TEMPLATE-LIKE BEHAVIOR IN C:\n * C++ Template:                C Macro Equivalent:\n * vector<SensorData> v;        sensor_vector v;\n * v.push_back(sensor);         SENSOR_VEC_ADD(v, sensor_ptr);\n * SensorData s = v[0];         SensorData *s = SENSOR_VEC_GET(v, 0);\n *\n * WHY THIS WORKS:\n * - typedef creates type alias (sensor_vector)\n * - Macros perform type-safe wrapping at compile time\n * - Underlying implementation stays generic\n * - Each typed wrapper is just a few lines of code\n */\n\n/* ========================================================================== */\n/* TODO: CREATE TYPED VECTOR ALIAS */\n/* ========================================================================== */\n/* TASK: Create a type alias for a vector of SensorData pointers\n *\n * PATTERN:\n * typedef vector TYPE_NAME;\n *\n * EXAMPLE:\n * typedef vector sensor_vector;\n *\n * This creates \"sensor_vector\" as an alias for \"vector\", making your\n * intent clear and providing a foundation for typed macros.\n */\n\n/* TODO: typedef vector sensor_vector; */\n\n/* ========================================================================== */\n/* TODO: CREATE TYPE-SAFE WRAPPER MACROS */\n/* ========================================================================== */\n/* TASK: Create macros that wrap the generic vector API with type safety\n *\n * MACRO PATTERNS:\n *\n * 1. INITIALIZATION MACRO:\n *    #define SENSOR_VEC_INIT(v) vector_init(&(v))\n *    Why &(v)? The generic API expects vector*, this ensures correct usage\n *\n * 2. ADD MACRO (with type cast):\n *    #define SENSOR_VEC_ADD(v, sensor_ptr) vector_add(&(v), (void*)(sensor_ptr))\n *    Casts SensorData* to void* for storage in generic vector\n *\n * 3. GET MACRO (with type cast):\n *    #define SENSOR_VEC_GET(v, idx) ((SensorData*)vector_get(&(v), (idx)))\n *    Casts void* back to SensorData* for type-safe access\n *\n * 4. TOTAL MACRO:\n *    #define SENSOR_VEC_TOTAL(v) vector_total(&(v))\n *\n * 5. SET MACRO:\n *    #define SENSOR_VEC_SET(v, idx, sensor_ptr) vector_set(&(v), (idx), (void*)(sensor_ptr))\n *\n * 6. DELETE MACRO:\n *    #define SENSOR_VEC_DELETE(v, idx) vector_delete(&(v), (idx))\n *\n * 7. FREE MACRO:\n *    #define SENSOR_VEC_FREE(v) vector_free(&(v))\n *\n * CRITICAL SAFETY NOTES:\n * - Use (v) in parentheses to avoid macro expansion issues\n * - Cast to void* when adding, cast from void* when getting\n * - These macros provide type safety at compile time\n * - They hide the ugly casts, making code cleaner\n */\n\n/* TODO: Implement all 7 type-safe wrapper macros */\n/* #define SENSOR_VEC_INIT(v)              vector_init(&(v)) */\n/* #define SENSOR_VEC_ADD(v, sensor_ptr)   vector_add(&(v), (void*)(sensor_ptr)) */\n/* #define SENSOR_VEC_GET(v, idx)          ((SensorData*)vector_get(&(v), (idx))) */\n/* #define SENSOR_VEC_TOTAL(v)             vector_total(&(v)) */\n/* #define SENSOR_VEC_SET(v, idx, ptr)     vector_set(&(v), (idx), (void*)(ptr)) */\n/* #define SENSOR_VEC_DELETE(v, idx)       vector_delete(&(v), (idx)) */\n/* #define SENSOR_VEC_FREE(v)              vector_free(&(v)) */\n\n/* ========================================================================== */\n/* HELPER FUNCTION DECLARATIONS */\n/* ========================================================================== */\n/* TODO: Declare helper functions for sensor operations */\n/* SensorData* create_sensor(uint32_t id, const char *name, uint32_t value, const char *unit); */\n/* void print_sensor(SensorData *sensor); */\n/* void free_all_sensors(sensor_vector *sv); */\n\n#endif /* SENSOR_VECTOR_H */\n",
      "readOnly": false,
      "language": "h"
    },
    {
      "name": "sensor_vector.c",
      "content": "#include \"sensor_vector.h\"\n#include <linux/string.h>\n#include <linux/jiffies.h>\n\n/* Module parameters for dynamic testing */\nint test_sensor_count = 3;\nint test_sensor_id_base = 1000;\n\nmodule_param(test_sensor_count, int, 0644);\nMODULE_PARM_DESC(test_sensor_count, \"Number of sensors to create for testing\");\nmodule_param(test_sensor_id_base, int, 0644);\nMODULE_PARM_DESC(test_sensor_id_base, \"Base sensor ID for anti-hardcoding testing\");\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: Creating Type-Safe Instances */\n/* ========================================================================== */\n/* This teaches you to create instances of your typed data for the container!\n *\n * MEMORY MANAGEMENT PATTERN:\n * 1. Allocate: Use kmalloc for each instance\n * 2. Initialize: Fill in all struct fields\n * 3. Store: Add pointer to vector\n * 4. Access: Get pointer from vector, use ->\n * 5. Cleanup: Free each instance, then free vector\n *\n * WHY HEAP ALLOCATION?\n * - Vector stores pointers, not values\n * - Heap allocation persists beyond function scope\n * - Allows dynamic creation and deletion\n * - Standard kernel development practice\n */\n\n/* TODO: Implement sensor creation function */\n/* ALGORITHM:\n * 1. Allocate memory: kmalloc(sizeof(SensorData), GFP_KERNEL)\n * 2. Check for NULL (allocation failure)\n * 3. Fill all fields:\n *    - sensor_id = id\n *    - Use strscpy() for strings (kernel-safe string copy)\n *    - reading_value = value\n *    - timestamp = get_jiffies_64() (kernel time)\n *    - is_active = true\n * 4. Return pointer\n *\n * EXAMPLE:\n * SensorData *sensor = kmalloc(sizeof(SensorData), GFP_KERNEL);\n * if (!sensor) return NULL;\n * sensor->sensor_id = id;\n * strscpy(sensor->sensor_name, name, MAX_SENSOR_NAME);\n * return sensor;\n */\nSensorData* create_sensor(uint32_t id, const char *name, uint32_t value, const char *unit) {\n    /* TODO: Implement sensor creation with proper initialization */\n    return NULL;\n}\n\n/* TODO: Implement sensor printing function */\n/* ALGORITHM:\n * 1. Check if sensor pointer is NULL\n * 2. Use printk(KERN_INFO, ...) to print:\n *    - \"Sensor ID: %u\"\n *    - \"Name: %s\"\n *    - \"Reading: %u %s\" (value is fixed-point, divide by 10 for display)\n *    - \"Timestamp: %llu\"\n *    - \"Active: %s\" (\"YES\" or \"NO\")\n */\nvoid print_sensor(SensorData *sensor) {\n    /* TODO: Implement sensor information printing */\n}\n\n/* TODO: Implement cleanup function for all sensors in vector */\n/* ALGORITHM:\n * 1. Loop through all elements: for (i = 0; i < SENSOR_VEC_TOTAL(*sv); i++)\n * 2. Get each sensor: SensorData *s = SENSOR_VEC_GET(*sv, i);\n * 3. Free each sensor: kfree(s);\n * 4. After loop, free the vector itself: SENSOR_VEC_FREE(*sv);\n *\n * CRITICAL: Must free in reverse order:\n * - First free all SensorData instances (heap allocated)\n * - Then free the vector structure\n */\nvoid free_all_sensors(sensor_vector *sv) {\n    /* TODO: Implement proper two-level cleanup */\n}\n\n/* ========================================================================== */\n/* MODULE INIT: Test the typed vector wrapper */\n/* ========================================================================== */\nstatic int __init sensor_vector_init(void)\n{\n    sensor_vector sv;\n    SensorData *sensor;\n    int result;\n    int i;\n\n    printk(KERN_INFO \"Sensor vector module loaded\\n\");\n    printk(KERN_INFO \"Testing with %d sensors starting from ID %d\\n\", \n           test_sensor_count, test_sensor_id_base);\n\n    /* Test 1: Initialize typed vector */\n    printk(KERN_INFO \"Test 1: Initializing sensor vector\\n\");\n    result = SENSOR_VEC_INIT(sv);\n    if (result != VECTOR_SUCCESS) {\n        printk(KERN_ERR \"Failed to initialize sensor vector\\n\");\n        return -ENOMEM;\n    }\n    printk(KERN_INFO \"Sensor vector initialized\\n\");\n\n    /* Test 2: Create and add sensors using dynamic parameters */\n    printk(KERN_INFO \"Test 2: Creating and adding sensors\\n\");\n    for (i = 0; i < test_sensor_count && i < 5; i++) {\n        char name[MAX_SENSOR_NAME];\n        snprintf(name, sizeof(name), \"Sensor_%d\", test_sensor_id_base + i);\n        \n        sensor = create_sensor(test_sensor_id_base + i, name, \n                               255 + i * 5, \"Celsius\");\n        if (!sensor) {\n            printk(KERN_ERR \"Failed to create sensor %d\\n\", i);\n            free_all_sensors(&sv);\n            return -ENOMEM;\n        }\n\n        result = SENSOR_VEC_ADD(sv, sensor);\n        if (result != VECTOR_SUCCESS) {\n            printk(KERN_ERR \"Failed to add sensor %d\\n\", i);\n            kfree(sensor);\n            free_all_sensors(&sv);\n            return -ENOMEM;\n        }\n        printk(KERN_INFO \"Added sensor ID %u (total=%d)\\n\", \n               sensor->sensor_id, SENSOR_VEC_TOTAL(sv));\n    }\n\n    /* Test 3: Access and print sensors */\n    printk(KERN_INFO \"Test 3: Accessing and printing sensors\\n\");\n    for (i = 0; i < SENSOR_VEC_TOTAL(sv); i++) {\n        sensor = SENSOR_VEC_GET(sv, i);\n        if (sensor) {\n            printk(KERN_INFO \"--- Sensor at index %d ---\\n\", i);\n            print_sensor(sensor);\n        }\n    }\n\n    /* Test 4: Modify sensor using SET */\n    printk(KERN_INFO \"Test 4: Modifying sensor\\n\");\n    if (SENSOR_VEC_TOTAL(sv) > 0) {\n        SensorData *new_sensor = create_sensor(9999, \"Modified_Sensor\", \n                                               999, \"Fahrenheit\");\n        if (new_sensor) {\n            SensorData *old_sensor = SENSOR_VEC_GET(sv, 0);\n            if (old_sensor) {\n                kfree(old_sensor);  /* Free old sensor first */\n            }\n            result = SENSOR_VEC_SET(sv, 0, new_sensor);\n            if (result == VECTOR_SUCCESS) {\n                printk(KERN_INFO \"Modified sensor at index 0\\n\");\n                print_sensor(new_sensor);\n            }\n        }\n    }\n\n    /* Test 5: Delete sensor */\n    printk(KERN_INFO \"Test 5: Deleting sensor\\n\");\n    if (SENSOR_VEC_TOTAL(sv) > 1) {\n        SensorData *to_delete = SENSOR_VEC_GET(sv, 1);\n        if (to_delete) {\n            printk(KERN_INFO \"Deleting sensor ID %u at index 1\\n\", \n                   to_delete->sensor_id);\n            kfree(to_delete);  /* Free sensor before deleting from vector */\n            result = SENSOR_VEC_DELETE(sv, 1);\n            if (result == VECTOR_SUCCESS) {\n                printk(KERN_INFO \"Deleted sensor (total=%d)\\n\", \n                       SENSOR_VEC_TOTAL(sv));\n            }\n        }\n    }\n\n    /* Test 6: Final state */\n    printk(KERN_INFO \"Test 6: Final vector state\\n\");\n    printk(KERN_INFO \"Final sensor count: %d\\n\", SENSOR_VEC_TOTAL(sv));\n    for (i = 0; i < SENSOR_VEC_TOTAL(sv); i++) {\n        sensor = SENSOR_VEC_GET(sv, i);\n        if (sensor) {\n            printk(KERN_INFO \"  [%d] Sensor ID %u: %s\\n\", \n                   i, sensor->sensor_id, sensor->sensor_name);\n        }\n    }\n\n    /* Cleanup */\n    printk(KERN_INFO \"Cleaning up all sensors\\n\");\n    free_all_sensors(&sv);\n    printk(KERN_INFO \"All tests completed successfully\\n\");\n\n    return 0;\n}\n\nstatic void __exit sensor_vector_exit(void)\n{\n    printk(KERN_INFO \"Sensor vector module unloaded\\n\");\n}\n\nmodule_init(sensor_vector_init);\nmodule_exit(sensor_vector_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Typed vector wrapper implementation using macros\");\nMODULE_VERSION(\"1.0\");\n",
      "readOnly": false,
      "language": "c"
    },
    {
      "name": "Makefile",
      "content": "# Sensor vector module Makefile\nobj-m += kernel_vector.o sensor_vector.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help\n",
      "readOnly": true,
      "language": "makefile"
    }
  ],
  "concepts": [
    "typedef aliases for generic types",
    "type-safe macro wrappers",
    "template-like generic programming in C",
    "macro-based type safety",
    "building reusable libraries",
    "kernel generic programming patterns",
    "void* abstraction and type casting",
    "compile-time type wrapping"
  ],
  "skills": [
    "Creating typed aliases with typedef",
    "Writing type-safe wrapper macros",
    "Understanding macro parameter safety ((v) patterns)",
    "Building generic library interfaces",
    "Applying Linux kernel generic patterns",
    "Managing two-level memory allocation",
    "Proper cleanup with typed wrappers",
    "Creating production-quality APIs"
  ],
  "validation": {
    "exactRequirements": {
      "functionNames": [
        "sensor_vector_init",
        "sensor_vector_exit",
        "create_sensor",
        "print_sensor",
        "free_all_sensors"
      ],
      "macro_declarations": [
        {
          "name": "SENSOR_VEC_INIT",
          "type": "function-like",
          "parameters": ["v"],
          "value": "vector_init(&(v))",
          "description": "Initialize the sensor vector"
        },
        {
          "name": "SENSOR_VEC_ADD",
          "type": "function-like",
          "parameters": ["v", "sensor_ptr"],
          "value": "vector_add(&(v), (void*)(sensor_ptr))",
          "description": "Add a sensor pointer to the vector"
        },
        {
          "name": "SENSOR_VEC_GET",
          "type": "function-like",
          "parameters": ["v", "idx"],
          "value": "((SensorData*)vector_get(&(v), (idx)))",
          "description": "Get a sensor pointer from the vector (with type cast)"
        },
        {
          "name": "SENSOR_VEC_TOTAL",
          "type": "function-like",
          "parameters": ["v"],
          "value": "vector_total(&(v))",
          "description": "Get total number of sensors in the vector"
        },
        {
          "name": "SENSOR_VEC_SET",
          "type": "function-like",
          "parameters": ["v", "idx", "ptr"],
          "value": "vector_set(&(v), (idx), (void*)(ptr))",
          "description": "Set a sensor at a specific index"
        },
        {
          "name": "SENSOR_VEC_DELETE",
          "type": "function-like",
          "parameters": ["v", "idx"],
          "value": "vector_delete(&(v), (idx))",
          "description": "Delete a sensor at a specific index"
        },
        {
          "name": "SENSOR_VEC_FREE",
          "type": "function-like",
          "parameters": ["v"],
          "value": "vector_free(&(v))",
          "description": "Free the vector structure"
        }
      ],
      "function_declarations": [
        {
          "name": "create_sensor",
          "returnType": "SensorData*",
          "parameters": ["uint32_t id", "const char *name", "uint32_t value", "const char *unit"]
        },
        {
          "name": "print_sensor",
          "returnType": "void",
          "parameters": ["SensorData *sensor"]
        },
        {
          "name": "free_all_sensors",
          "returnType": "void",
          "parameters": ["sensor_vector *sv"]
        }
      ],
      "variables_declarations": [
        {
          "name": "SensorData",
          "type": "typedef struct",
          "value": "{uint32_t sensor_id; char sensor_name[MAX_SENSOR_NAME]; uint32_t reading_value; char unit[MAX_SENSOR_UNIT]; uint64_t timestamp; bool is_active;}",
          "storageClass": "none"
        },
        {
          "name": "sensor_vector",
          "type": "typedef vector",
          "storageClass": "none"
        }
      ],
      "variables": [
        {
          "name": "test_sensor_count",
          "type": "int",
          "value": 3,
          "storageClass": "none"
        },
        {
          "name": "test_sensor_id_base",
          "type": "int",
          "value": 1000,
          "storageClass": "none"
        }
      ],
      "function_definitions": [
        {
          "name": "create_sensor",
          "returnType": "SensorData*",
          "parameters": ["uint32_t id", "const char *name", "uint32_t value", "const char *unit"],
          "description": "Allocate and initialize a SensorData instance with kmalloc"
        },
        {
          "name": "print_sensor",
          "returnType": "void",
          "parameters": ["SensorData *sensor"],
          "description": "Print sensor information using printk"
        },
        {
          "name": "free_all_sensors",
          "returnType": "void",
          "parameters": ["sensor_vector *sv"],
          "description": "Free all sensors in vector, then free the vector itself"
        },
        {
          "name": "sensor_vector_init",
          "returnType": "static int",
          "parameters": ["void"],
          "description": "Module initialization function",
          "attributes": ["__init"]
        },
        {
          "name": "sensor_vector_exit",
          "returnType": "static void",
          "parameters": ["void"],
          "description": "Module cleanup function",
          "attributes": ["__exit"]
        }
      ],
      "outputMessages": [
        "Sensor vector module loaded",
        "Testing with 3 sensors starting from ID 1000",
        "Test 1: Initializing sensor vector",
        "Sensor vector initialized",
        "Test 2: Creating and adding sensors",
        "Added sensor ID 1000",
        "Added sensor ID 1001",
        "Added sensor ID 1002",
        "Test 3: Accessing and printing sensors",
        "Sensor ID: 1000",
        "Sensor ID: 1001",
        "Sensor ID: 1002",
        "Test 4: Modifying sensor",
        "Modified sensor at index 0",
        "Sensor ID: 9999",
        "Test 5: Deleting sensor",
        "Deleted sensor",
        "Test 6: Final vector state",
        "Cleaning up all sensors",
        "All tests completed successfully",
        "Sensor vector module unloaded"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/slab.h",
        "linux/types.h",
        "linux/string.h",
        "linux/jiffies.h"
      ],
      "mustContain": [
        "typedef vector sensor_vector",
        "#define SENSOR_VEC_INIT(v) vector_init(&(v))",
        "#define SENSOR_VEC_ADD(v, sensor_ptr) vector_add(&(v), (void*)(sensor_ptr))",
        "#define SENSOR_VEC_GET(v, idx) ((SensorData*)vector_get(&(v), (idx)))",
        "#define SENSOR_VEC_TOTAL(v) vector_total(&(v))",
        "#define SENSOR_VEC_FREE(v) vector_free(&(v))",
        "kmalloc(sizeof(SensorData), GFP_KERNEL)",
        "strscpy(",
        "get_jiffies_64()",
        "for (i = 0; i < SENSOR_VEC_TOTAL(*sv); i++)",
        "kfree(s)",
        "SENSOR_VEC_FREE(*sv)",
        "module_param(test_sensor_count, int, 0644)",
        "module_param(test_sensor_id_base, int, 0644)"
      ],
      "moduleInfo": {
        "license": "GPL"
      }
    },
    "testCases": [
      {
        "id": "function_declarations",
        "name": "Function Declarations in Header",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "SensorData* create_sensor(uint32_t id, const char *name, uint32_t value, const char *unit)",
          "void print_sensor(SensorData *sensor)",
          "void free_all_sensors(sensor_vector *sv)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "function_signatures_source",
        "name": "Function Implementations in Source",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "SensorData* create_sensor(uint32_t id, const char *name, uint32_t value, const char *unit)",
          "void print_sensor(SensorData *sensor)",
          "void free_all_sensors(sensor_vector *sv)",
          "static int __init sensor_vector_init(void)",
          "static void __exit sensor_vector_exit(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "struct_definition",
        "name": "SensorData Structure Definition",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "typedef struct",
          "uint32_t sensor_id",
          "char sensor_name[MAX_SENSOR_NAME]",
          "uint32_t reading_value",
          "char unit[MAX_SENSOR_UNIT]",
          "uint64_t timestamp",
          "bool is_active"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "exact_output",
        "name": "Exact Output Messages",
        "type": "output_match",
        "critical": true,
        "expected": [
          { "pattern": "Sensor vector module loaded", "exact": true, "linkedFunction": "static int __init sensor_vector_init(void)" },
          { "pattern": "Testing with 3 sensors starting from ID 1000", "exact": true, "linkedFunction": "static int __init sensor_vector_init(void)" },
          { "pattern": "Sensor vector initialized", "exact": true, "linkedFunction": "static int __init sensor_vector_init(void)" },
          { "pattern": "Added sensor ID 1000", "exact": false, "linkedFunction": "static int __init sensor_vector_init(void)" },
          { "pattern": "Sensor ID: 1000", "exact": true, "linkedFunction": "void print_sensor(SensorData *sensor)" },
          { "pattern": "Sensor ID: 9999", "exact": true, "linkedFunction": "void print_sensor(SensorData *sensor)" },
          { "pattern": "All tests completed successfully", "exact": true, "linkedFunction": "static int __init sensor_vector_init(void)" },
          { "pattern": "Sensor vector module unloaded", "exact": true, "linkedFunction": "static void __exit sensor_vector_exit(void)" }
        ]
      },
      {
        "id": "comprehensive_typed_vector_validation",
        "name": "Comprehensive Typed Vector Wrapper Validation",
        "type": "kernel_project_test",
        "critical": true,
        "testScenario": {
          "userspaceApps": [
            {
              "name": "sensor_vector_dynamic_tester",
              "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Typed Vector Wrapper Test ===\\\\n\\\");\\n    \\n    srand(time(NULL));\\n    \\n    int random_sensor_count = (rand() % 3) + 2;\\n    int random_id_base = (rand() % 900) + 1000;\\n    \\n    printf(\\\"Test 1: Creating %d sensors with base ID %d\\\\n\\\", random_sensor_count, random_id_base);\\n    \\n    system(\\\"rmmod sensor_vector 2>/dev/null\\\");\\n    system(\\\"rmmod kernel_vector 2>/dev/null\\\");\\n    \\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/kernel_vector.ko && insmod /lib/modules/sensor_vector.ko test_sensor_count=%d test_sensor_id_base=%d\\\", random_sensor_count, random_id_base);\\n    printf(\\\"DEBUG: Command: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Dynamic typed vector test completed\\\\n\\\");\\n    return 0;\\n}"
            }
          ],
          "setupCommands": [
            "echo 'Starting comprehensive typed vector wrapper validation'"
          ],
          "testCommands": [
            "echo 'Phase 1: TCC Header Validation'",
            "mkdir -p /tmp/linux",
            "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
            "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
            "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
            "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
            "echo '#define module_init(x)' >> /tmp/linux/module.h",
            "echo '#define module_exit(x)' >> /tmp/linux/module.h",
            "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
            "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
            "echo '#define __init' > /tmp/linux/init.h",
            "echo '#define __exit' >> /tmp/linux/init.h",
            "echo 'typedef int bool;' > /tmp/linux/types.h",
            "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
            "echo 'typedef unsigned long long uint64_t;' >> /tmp/linux/types.h",
            "echo '#define true 1' >> /tmp/linux/types.h",
            "echo '#define false 0' >> /tmp/linux/types.h",
            "echo '#define MAX_SENSOR_NAME 32' >> /tmp/linux/types.h",
            "echo '#define MAX_SENSOR_UNIT 16' >> /tmp/linux/types.h",
            "echo 'void *kmalloc(unsigned long size, int flags);' > /tmp/linux/slab.h",
            "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
            "echo '#define GFP_KERNEL 0' >> /tmp/linux/slab.h",
            "echo 'unsigned long long get_jiffies_64(void);' > /tmp/linux/jiffies.h",
            "echo 'char *strscpy(char *dest, const char *src, unsigned long count);' > /tmp/linux/string.h",
            "echo '#include \"/lib/modules/sensor_vector.h\"' > /tmp/test.c",
            "echo 'int main() { sensor_vector sv; SensorData *s; SENSOR_VEC_INIT(sv); s = create_sensor(1, \"test\", 314, \"C\"); SENSOR_VEC_ADD(sv, s); print_sensor(s); free_all_sensors(&sv); return 0; }' >> /tmp/test.c",
            "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
            "TCC_EXIT_CODE=$?",
            "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or macro declarations missing in header'; cat /tmp/tcc_error.log; else echo 'PASS: All function and macro declarations found in header file'; fi",
            "echo 'Phase 2: Dynamic Typed Vector Testing'",
            "/bin/sensor_vector_dynamic_tester > /tmp/test_output.log",
            "cat /tmp/test_output.log",
            "echo 'Phase 3: Extract Runtime Values'",
            "sleep 1",
            "SENSOR_COUNT=$(grep -o 'Creating [0-9]* sensors' /tmp/test_output.log | grep -o '[0-9]*' | head -1)",
            "ID_BASE=$(grep -o 'base ID [0-9]*' /tmp/test_output.log | grep -o '[0-9]*' | head -1)",
            "echo 'Extracted values: SENSOR_COUNT='$SENSOR_COUNT', ID_BASE='$ID_BASE",
            "if [ -z \"$SENSOR_COUNT\" ] || [ -z \"$ID_BASE\" ]; then echo 'FAIL: Could not extract test values'; else echo 'PASS: Test values extracted successfully'; fi",
            "echo 'Phase 4: Validate Typedef and Macros'",
            "dmesg | grep 'Sensor vector initialized' && echo 'PASS: SENSOR_VEC_INIT macro working' || echo 'FAIL: Init macro broken'",
            "dmesg | grep -E 'Added sensor ID' && echo 'PASS: SENSOR_VEC_ADD macro working' || echo 'FAIL: Add macro broken'",
            "dmesg | grep 'Sensor ID: '$ID_BASE && echo 'PASS: SENSOR_VEC_GET macro working with dynamic ID' || echo 'FAIL: Get macro broken'",
            "echo 'Phase 5: Validate Sensor Creation'",
            "dmesg | grep 'Sensor ID: '$ID_BASE && echo 'PASS: create_sensor() working with dynamic ID' || echo 'FAIL: create_sensor broken'",
            "ID_PLUS_1=$((ID_BASE + 1))",
            "dmesg | grep 'Sensor ID: '$ID_PLUS_1 && echo 'PASS: Multiple sensors created correctly' || echo 'FAIL: Multiple sensor creation broken'",
            "echo 'Phase 6: Validate Printing and Cleanup'",
            "dmesg | grep 'Name:' && echo 'PASS: print_sensor() implemented' || echo 'FAIL: print_sensor missing'",
            "dmesg | grep 'Reading:' && echo 'PASS: Sensor reading field printed' || echo 'FAIL: Reading field missing'",
            "dmesg | grep 'Cleaning up all sensors' && echo 'PASS: free_all_sensors() called' || echo 'FAIL: Cleanup not called'",
            "echo 'Phase 7: Validate Modified Sensor (ID 9999)'",
            "dmesg | grep 'Sensor ID: 9999' && echo 'PASS: SENSOR_VEC_SET macro working' || echo 'FAIL: Set macro broken'",
            "dmesg | grep 'Modified_Sensor' && echo 'PASS: Sensor modification working' || echo 'FAIL: Modification broken'",
            "echo 'Phase 8: Module System Validation'",
            "dmesg | grep 'Sensor vector module loaded' && echo 'PASS: Module init working' || echo 'FAIL: Module init broken'",
            "dmesg | grep 'All tests completed successfully' && echo 'PASS: All tests passed' || echo 'FAIL: Tests incomplete'",
            "echo 'PASS: All comprehensive typed vector validation completed successfully'"
          ],
          "expected": {
            "dmesg": [
              "Sensor vector module loaded",
              "Testing with.*sensors starting from ID",
              "Sensor vector initialized",
              "Added sensor ID",
              "Sensor ID: .*",
              "Name: .*",
              "Reading: .*",
              "Modified sensor at index 0",
              "Sensor ID: 9999",
              "Cleaning up all sensors",
              "All tests completed successfully",
              "Sensor vector module unloaded"
            ],
            "stdout": [
              "PASS: All function and macro declarations found in header file",
              "SUCCESS: Dynamic typed vector test completed",
              "PASS: Test values extracted successfully",
              "PASS: SENSOR_VEC_INIT macro working",
              "PASS: SENSOR_VEC_ADD macro working",
              "PASS: SENSOR_VEC_GET macro working with dynamic ID",
              "PASS: create_sensor\\(\\) working with dynamic ID",
              "PASS: Multiple sensors created correctly",
              "PASS: print_sensor\\(\\) implemented",
              "PASS: Sensor reading field printed",
              "PASS: free_all_sensors\\(\\) called",
              "PASS: SENSOR_VEC_SET macro working",
              "PASS: Sensor modification working",
              "PASS: Module init working",
              "PASS: All tests passed",
              "PASS: All comprehensive typed vector validation completed successfully"
            ]
          },
          "timeout": 20
        }
      }
    ]
  }
}
