{
  "id": 21,
  "title": "Function Pointers - Runtime-Unknown Type Dispatch",
  "phase": "foundations",
  "difficulty": 6,
  "xp": 55,
  "description": "Master function pointers by handling RUNTIME-UNKNOWN event types! Learn WHAT function pointers are, HOW they work, WHY they're necessary (not just convenient), and WHEN they're required vs overkill. Build an extensible callback system where handlers are registered dynamically - proving function pointers handle types that DON'T EXIST at compile time. This is the exact pattern Linux uses for interrupt handlers, filesystem operations, and driver registration.",
  "mainFile": "function_dispatch.c",
  "files": [
    {
      "name": "function_dispatch.h",
      "content": "#ifndef FUNCTION_DISPATCH_H\n#define FUNCTION_DISPATCH_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n#define MAX_HANDLERS 8\n#define MAX_NAME_LEN 32\n#define MAX_HANDLER_TYPES 5\n\n/* Event handler function pointer type */\ntypedef void (*event_handler_t)(uint8_t event_type, void* event_data, uint32_t data_size);\n\n/* Event operations struct - demonstrates OOP in C pattern */\ntypedef struct {\n    event_handler_t handler;           /* Function pointer IN struct */\n    char event_name[MAX_NAME_LEN];   /* Event type name */\n    uint32_t event_count;             /* Number of times handled */\n} event_operations;\n\n/* Global event operations table */\nextern event_operations event_ops_table[MAX_HANDLERS];\nextern int registered_handler_count;\n\n/* TODO: Declare your callback registration function */\n/* void register_event_handler(uint8_t event_type, event_handler_t handler, const char* name); */\n\n/* TODO: Declare your dispatch function that uses the stored function pointer */\n/* void dispatch_event(uint8_t event_type, void* data, uint32_t size); */\n\n/* TODO: Declare your function to show all registered handlers */\n/* void show_registered_handlers(void); */\n\n/* Predefined handler functions (5 available, but student won't know which are used!) */\nvoid sensor_event_handler(uint8_t type, void* data, uint32_t size);\nvoid motor_event_handler(uint8_t type, void* data, uint32_t size);\nvoid status_event_handler(uint8_t type, void* data, uint32_t size);\nvoid network_event_handler(uint8_t type, void* data, uint32_t size);\nvoid storage_event_handler(uint8_t type, void* data, uint32_t size);\n\n#endif /* FUNCTION_DISPATCH_H */",
      "readOnly": false,
      "language": "h"
    },
    {
      "name": "function_dispatch.c",
      "content": "#include \"function_dispatch.h\"\n#include <linux/string.h>\n\n/* Global event operations table - each entry has function pointer */\nevent_operations event_ops_table[MAX_HANDLERS];\nint registered_handler_count = 0;\n\n/* Module parameters for DYNAMIC handler registration (student doesn't know which will be used!) */\nint register_handler_types[MAX_HANDLER_TYPES] = {0, 0, 0, 0, 0};  /* Which handlers to register: 0=skip, 1=register */\nint test_dispatch_types[MAX_HANDLERS] = {0, 0, 0, 0, 0, 0, 0, 0};  /* Which types to dispatch to */\nint test_dispatch_count = 3;  /* How many dispatch operations */\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your function pointer logic works\n * with RUNTIME-UNKNOWN handler types. Removing them will cause test failures.\n */\nmodule_param_array(register_handler_types, int, NULL, 0644);\nMODULE_PARM_DESC(register_handler_types, \"Which handlers to register (runtime-unknown to student)\");\nmodule_param_array(test_dispatch_types, int, &test_dispatch_count, 0644);\nMODULE_PARM_DESC(test_dispatch_types, \"Array of event types to dispatch (runtime-unknown)\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: Complete Beginner's Guide to Function Pointers */\n/* ========================================================================== */\n/* This problem teaches function pointers from FIRST PRINCIPLES!\n *\n * LEARNING PATH:\n * 1. WHAT is a function pointer? (basics)\n * 2. HOW does it work? (memory and syntax)\n * 3. WHY use it? (decision tree)\n * 4. WHEN to use it? (patterns)\n * 5. HOW to implement? (callback system)\n *\n * CRITICAL DIFFERENCE FROM TYPICAL PROBLEMS:\n * You DON'T KNOW which handlers will be registered!\n * The testing system controls this via module parameters.\n * This PROVES function pointers handle runtime-unknown types!\n */\n\n/* ========================================================================== */\n/* PART 1: WHAT IS A FUNCTION POINTER? */\n/* ========================================================================== */\n/* A function pointer is a VARIABLE that stores the MEMORY ADDRESS of a function.\n *\n * COMPARISON TO DATA POINTERS (from Problem 15):\n *\n * Data Pointer (you already know this!):\n *   int number = 42;\n *   int *ptr = &number;  // ptr stores ADDRESS of variable\n *   *ptr = 99;           // Change value through pointer\n *\n * Function Pointer (new concept!):\n *   void my_function(int x) { ... }\n *   void (*ptr)(int) = my_function;  // ptr stores ADDRESS of function!\n *   ptr(42);                          // Call function through pointer\n *\n * KEY INSIGHT: Functions have addresses in memory, just like variables!\n */\n\n/* ========================================================================== */\n/* PART 2: HOW FUNCTION POINTERS WORK - MEMORY LAYOUT */\n/* ========================================================================== */\n/* MEMORY VISUALIZATION:\n *\n * Code Segment (where functions live):\n * Address      Content\n * 0x401000:    [sensor_handler code]\n * 0x401200:    [motor_handler code]\n * 0x401400:    [status_handler code]\n * 0x401600:    [network_handler code]\n * 0x401800:    [storage_handler code]\n *\n * Data Segment (where function pointers live):\n * Address      Content\n * 0x500000:    handler_ptr = 0x401000  // Points to sensor_handler\n *\n * WHEN YOU CALL handler_ptr():\n * 1. CPU reads value at 0x500000 → gets 0x401000\n * 2. CPU jumps to address 0x401000\n * 3. Executes sensor_handler code\n * 4. Returns back\n *\n * This is called INDIRECT CALL (go through pointer first)\n * Direct call: my_function() → CPU knows address at compile time\n * Indirect call: ptr() → CPU must read pointer value first\n */\n\n/* ========================================================================== */\n/* PART 3: FUNCTION POINTER SYNTAX EXPLAINED */\n/* ========================================================================== */\n/* Function pointer declarations look scary, but follow a pattern!\n *\n * STEP-BY-STEP BREAKDOWN:\n *\n * 1. Start with a function signature:\n *    void sensor_handler(uint8_t type, void* data, uint32_t size);\n *    ↑         ↑            ↑\n *    return    name         parameters\n *\n * 2. Replace function name with (*pointer_name):\n *    void (*handler_ptr)(uint8_t type, void* data, uint32_t size);\n *    ↑     ↑              ↑\n *    return pointer name   parameters\n *\n * 3. That's it! Now handler_ptr can point to any function with this signature.\n *\n * WHY THE PARENTHESES (*handler_ptr)?\n * Without: void *handler_ptr(...) means \"function returning void*\"\n * With: void (*handler_ptr)(...) means \"pointer to function returning void\"\n */\n\n/* ========================================================================== */\n/* PART 4: ASSIGNING AND CALLING FUNCTION POINTERS */\n/* ========================================================================== */\n/* ASSIGNMENT (storing function address):\n *\n * void sensor_handler(uint8_t type, void* data, uint32_t size) {\n *     printk(\"Sensor handler called\\n\");\n * }\n *\n * // Declare pointer\n * void (*handler_ptr)(uint8_t, void*, uint32_t);\n *\n * // Assign function address (function name IS the address!)\n * handler_ptr = sensor_handler;  // Option 1: Direct\n * handler_ptr = &sensor_handler; // Option 2: Explicit (same thing!)\n *\n * CALLING (using stored address):\n *\n * handler_ptr(1, NULL, 256);  // Option 1: Direct\n * (*handler_ptr)(1, NULL, 256); // Option 2: Explicit (same!)\n *\n * Both work identically! Modern C allows the simpler syntax.\n */\n\n/* ========================================================================== */\n/* PART 5: TYPEDEF FOR FUNCTION POINTERS (Making Life Easier) */\n/* ========================================================================== */\n/* Raw function pointer syntax is hard to read:\n *\n * BAD (UGLY):\n * void (*handler1)(uint8_t, void*, uint32_t);\n * void (*handler2)(uint8_t, void*, uint32_t);\n * void (*handler3)(uint8_t, void*, uint32_t);\n * // Repetitive and error-prone!\n *\n * GOOD (CLEAN): Use typedef to create a type name\n * typedef void (*event_handler_t)(uint8_t, void*, uint32_t);\n * event_handler_t handler1;\n * event_handler_t handler2;\n * event_handler_t handler3;\n * // Much clearer!\n *\n * TYPEDEF SYNTAX BREAKDOWN:\n * typedef void (*event_handler_t)(uint8_t type, void* data, uint32_t size);\n * ↑       ↑     ↑                 ↑\n * keyword return type name        parameters\n *\n * Now event_handler_t is a TYPE, like int or char*!\n * We use this in function_dispatch.h!\n */\n\n/* ========================================================================== */\n/* PART 6: FUNCTION POINTERS IN ARRAYS (The Power Move) */\n/* ========================================================================== */\n/* You can store function pointers in arrays for table-based dispatch!\n *\n * EXAMPLE: Interrupt handler table (like real Linux kernel)\n *\n * typedef void (*irq_handler_t)(int irq_num);\n * irq_handler_t irq_handlers[256];  // Array of function pointers!\n *\n * // Setup (registration):\n * irq_handlers[5] = keyboard_interrupt_handler;\n * irq_handlers[14] = disk_interrupt_handler;\n *\n * // Usage (dispatch):\n * void handle_interrupt(int irq_num) {\n *     if (irq_handlers[irq_num]) {\n *         irq_handlers[irq_num](irq_num);  // Call stored function!\n *     }\n * }\n *\n * This is O(1) lookup - much faster than if-else chain!\n * We use this pattern in this problem with event_ops_table[]!\n */\n\n/* ========================================================================== */\n/* PART 7: FUNCTION POINTERS IN STRUCTS (OOP in C) */\n/* ========================================================================== */\n/* This is how Linux kernel does object-oriented programming!\n *\n * STRUCT WITH FUNCTION POINTER:\n * struct file_operations {\n *     int (*open)(struct file *f);\n *     ssize_t (*read)(struct file *f, char *buf, size_t len);\n *     ssize_t (*write)(struct file *f, const char *buf, size_t len);\n * };\n *\n * DIFFERENT IMPLEMENTATIONS:\n * struct file_operations ext4_ops = {\n *     .open = ext4_open,\n *     .read = ext4_read,\n *     .write = ext4_write\n * };\n *\n * struct file_operations ntfs_ops = {\n *     .open = ntfs_open,\n *     .read = ntfs_read,\n *     .write = ntfs_write\n * };\n *\n * USAGE (automatic dispatch):\n * struct file {\n *     struct file_operations *ops;\n * };\n *\n * // Setup once:\n * ext4_file->ops = &ext4_ops;\n * ntfs_file->ops = &ntfs_ops;\n *\n * // Use many times (NO TYPE CHECKING!):\n * ext4_file->ops->read(...)  // Automatically calls ext4_read()\n * ntfs_file->ops->read(...)  // Automatically calls ntfs_read()\n *\n * We use a similar pattern with event_operations struct!\n */\n\n/* ========================================================================== */\n/* PART 8: WHEN to Use Function Pointers vs Direct Calls */\n/* ========================================================================== */\n/* Now that you know HOW function pointers work, learn WHEN to use them!\n *\n * DECISION TREE:\n * \n * Q1: Do you need to select different functions at RUNTIME based on data?\n *     NO  -> Direct function calls are simpler (STOP: don't use function pointers)\n *     YES -> Continue to Q2\n *\n * Q2: Do you have only 2-3 function options?\n *     YES -> Simple if-else is clearer and faster (STOP: don't use function pointers)\n *     NO  -> Continue to Q3\n *\n * Q3: Is this one of these scenarios?\n *     - Callbacks (must STORE function for later use)\n *     - 5+ functions requiring table-based dispatch\n *     - Plugin/extensible systems (functions unknown at compile time)\n *     - OOP in C (function pointers in struct for polymorphism)\n *     YES -> Function pointers REQUIRED\n *     NO  -> Reconsider if complexity is justified\n *\n * EXAMPLES OF WHEN FUNCTION POINTERS ARE REQUIRED:\n *\n * 1. RUNTIME-UNKNOWN TYPES (Cannot use if-else - don't know what exists!):\n *    // Module parameters control which handlers exist:\n *    if (register_handler_types[0]) register_event_handler(0, sensor_handler, \"Sensor\");\n *    if (register_handler_types[1]) register_event_handler(1, motor_handler, \"Motor\");\n *    // You DON'T KNOW which handlers were registered!\n *    // Later when event occurs:\n *    dispatch_event(event_type, data, size);  // MUST use function pointer table!\n *    // WRONG: Can't use if-else - you don't know which types exist!\n *\n * 2. CALLBACK REGISTRATION (Cannot use if-else):\n *    void register_handler(event_handler_t handler) {\n *        handlers[event_type] = handler;  // MUST store for later!\n *    }\n *    // Later, when event occurs:\n *    handlers[event_type](data);  // Call stored function\n *    // WRONG: IMPOSSIBLE with if-else - you don't know which function user registered!\n *\n * 3. OOP IN C - Function Pointers in Struct (\"Set Once, Use Forever\"):\n *    struct file {\n *        struct file_operations *f_op;  // Points to function table\n *    };\n *    // Setup ONCE when file is opened:\n *    file->f_op = &ext4_file_operations;  // ← Decision made once!\n *    // Then all operations are automatic (no type checking!):\n *    file->f_op->read();   // No if-else needed!\n *    file->f_op->write();  // No if-else needed!\n *    file->f_op->close();  // No if-else needed!\n *\n * EXAMPLES OF WHEN DIRECT CALLS ARE BETTER:\n *\n * 1. FUNCTION KNOWN AT COMPILE TIME (No runtime selection):\n *    BAD:  handler = my_function; handler(data);  // Unnecessary indirection!\n *    GOOD: my_function(data);  // Direct call is faster!\n *\n * 2. ONLY 2-3 FUNCTION OPTIONS (Simple if-else is clearer):\n *    BAD:  Setup entire function pointer infrastructure for 2 functions\n *    GOOD: if (type == A) func_a(); else func_b();  // Simpler!\n *\n * 3. PERFORMANCE-CRITICAL INNER LOOPS (Every cycle matters):\n *    Function pointers have costs:\n *    - Indirect call overhead (CPU pipeline stall)\n *    - Compiler cannot inline\n *    - Harder branch prediction\n *    Use direct calls in hot paths!\n */\n\n/* ========================================================================== */\n/* PART 9: THE \"SET ONCE, USE FOREVER\" PATTERN */\n/* ========================================================================== */\n/* This is the KEY insight that makes function pointers worthwhile!\n *\n * WITHOUT function pointers (check type repeatedly):\n *   void process(struct data *d) {\n *       if (d->type == A) func_a(d);  // Check EVERY time\n *       else func_b(d);\n *   }\n *   // If you process 10,000 items: 10,000 type checks!\n *\n * WITH function pointers (decide once, use forever):\n *   // Setup ONCE:\n *   d->handler = (d->type == A) ? func_a : func_b;  // Decide once\n *   // Use MANY times (no type checking!):\n *   d->handler(d);  // Just call it - 0 type checks!\n *   // If you process 10,000 items: 0 type checks!\n *\n * PERFORMANCE COMPARISON:\n * Setup phase: 1 assignment vs 1 if-else (same cost)\n * Process phase (1000 calls):\n * - If-else: 1000 type checks\n * - Function pointer: 0 type checks, just 1000 indirect calls\n * Winner: Function pointer (when processing many times)\n */\n\n/* ========================================================================== */\n/* PART 10: RUNTIME-UNKNOWN TYPES - THE TRUE POWER */\n/* ========================================================================== */\n/* This problem demonstrates WHY function pointers are NECESSARY!\n *\n * THE SCENARIO:\n * You write a generic event system.\n * Users can register ANY handlers they want.\n * You DON'T KNOW which handlers will be registered!\n *\n * IN THIS PROBLEM:\n * - 5 handlers available: sensor, motor, status, network, storage\n * - Module parameters control WHICH handlers are registered\n * - You DON'T KNOW which combination will be used!\n * - Testing system uses RANDOM combinations you've never seen!\n *\n * THIS IS EXACTLY LIKE:\n * - Linux filesystem registration (ext4, ntfs, btrfs, ...)\n * - Driver registration (USB, PCI, SATA, ...)\n * - Interrupt handlers (keyboard, disk, network, ...)\n *\n * You CAN'T use if-else because you don't know what exists!\n * Function pointers are REQUIRED, not just convenient!\n */\n\n/* ========================================================================== */\n/* NOW LET'S IMPLEMENT IT! */\n/* ========================================================================== */\n\n/* Predefined handler functions (5 available, but student won't know which are used!) */\nvoid sensor_event_handler(uint8_t type, void* data, uint32_t size) {\n    printk(KERN_INFO \"[Sensor Handler] Processing event type %d, data size: %u\\n\", type, size);\n}\n\nvoid motor_event_handler(uint8_t type, void* data, uint32_t size) {\n    printk(KERN_INFO \"[Motor Handler] Processing event type %d, data size: %u\\n\", type, size);\n}\n\nvoid status_event_handler(uint8_t type, void* data, uint32_t size) {\n    printk(KERN_INFO \"[Status Handler] Processing event type %d, data size: %u\\n\", type, size);\n}\n\nvoid network_event_handler(uint8_t type, void* data, uint32_t size) {\n    printk(KERN_INFO \"[Network Handler] Processing event type %d, data size: %u\\n\", type, size);\n}\n\nvoid storage_event_handler(uint8_t type, void* data, uint32_t size) {\n    printk(KERN_INFO \"[Storage Handler] Processing event type %d, data size: %u\\n\", type, size);\n}\n\n/* PATTERN SCAFFOLDING: Callback Registration Pattern */\n/* TODO: Implement callback registration function */\nvoid register_event_handler(uint8_t event_type, event_handler_t handler, const char* name) {\n    /* STEP 1: VALIDATE EVENT TYPE */\n    /* TODO: Check if event_type is within valid range (0 to MAX_HANDLERS-1) */\n    /* TODO: if (event_type >= MAX_HANDLERS) { */\n    /* TODO:     printk(KERN_ERR \"Invalid event type %d (max: %d)\\n\", event_type, MAX_HANDLERS-1); */\n    /* TODO:     return; */\n    /* TODO: } */\n    \n    /* STEP 2: STORE THE FUNCTION POINTER (The Key Step!) */\n    /* This is where the MAGIC happens - we store the function address! */\n    /* TODO: event_ops_table[event_type].handler = handler; */\n    /* What this does: Saves the address of user's function in our table */\n    /* Later we can call: event_ops_table[event_type].handler(data) */\n    \n    /* STEP 3: STORE THE HANDLER NAME (for debugging/display) */\n    /* TODO: Copy the handler name to event_ops_table[event_type].event_name */\n    /* TODO: Use snprintf for safety: */\n    /* TODO: snprintf(event_ops_table[event_type].event_name, MAX_NAME_LEN, \"%s\", name); */\n    \n    /* STEP 4: INITIALIZE EVENT COUNT */\n    /* TODO: event_ops_table[event_type].event_count = 0; */\n    \n    /* STEP 5: TRACK TOTAL REGISTERED HANDLERS */\n    /* TODO: Increment registered_handler_count */\n    /* TODO: registered_handler_count++; */\n    \n    /* STEP 6: CONFIRMATION MESSAGE */\n    /* TODO: Print confirmation message */\n    /* TODO: printk(KERN_INFO \"Registered handler '%s' for event type %d\\n\", name, event_type); */\n}\n\n/* TODO: Implement event dispatch function using stored function pointer */\nvoid dispatch_event(uint8_t event_type, void* data, uint32_t size) {\n    /* STEP 1: VALIDATE EVENT TYPE */\n    /* TODO: Check if event_type is within valid range */\n    /* TODO: if (event_type >= MAX_HANDLERS) { */\n    /* TODO:     printk(KERN_ERR \"Invalid event type %d\\n\", event_type); */\n    /* TODO:     return; */\n    /* TODO: } */\n    \n    /* STEP 2: CHECK IF HANDLER IS REGISTERED */\n    /* This is CRITICAL - must check before calling! */\n    /* TODO: if (event_ops_table[event_type].handler == NULL) { */\n    /* TODO:     printk(KERN_ERR \"No handler registered for event type %d\\n\", event_type); */\n    /* TODO:     return; */\n    /* TODO: } */\n    \n    /* STEP 3: INCREMENT EVENT COUNTER (statistics) */\n    /* TODO: event_ops_table[event_type].event_count++; */\n    \n    /* STEP 4: CALL THE STORED FUNCTION POINTER! */\n    /* THIS IS THE MAGIC - No if-else needed! */\n    /* TODO: event_ops_table[event_type].handler(event_type, data, size); */\n    /*\n     * WHAT JUST HAPPENED?\n     * 1. event_ops_table[event_type].handler  ← Read function pointer from table\n     * 2. .handler(event_type, data, size)     ← Call function through pointer\n     *\n     * If event_type == 0:\n     *   - handler points to sensor_event_handler\n     *   - Calls sensor_event_handler(0, data, size)\n     *\n     * If event_type == 1:\n     *   - handler points to motor_event_handler  \n     *   - Calls motor_event_handler(1, data, size)\n     *\n     * NO IF-ELSE! The function pointer was set during registration!\n     * We just dereference and call - automatic dispatch!\n     */\n}\n\n/* TODO: Implement function to show all registered handlers */\nvoid show_registered_handlers(void) {\n    int i;\n    \n    /* STEP 1: PRINT HEADER */\n    /* TODO: Print header message */\n    /* TODO: printk(KERN_INFO \"\\n=== Registered Event Handlers ===\\n\"); */\n    \n    /* STEP 2: LOOP THROUGH ALL POSSIBLE EVENT TYPES */\n    /* TODO: Loop through all possible event types (0 to MAX_HANDLERS-1) */\n    /* TODO: for (i = 0; i < MAX_HANDLERS; i++) { */\n    \n        /* STEP 3: CHECK IF HANDLER IS REGISTERED AT THIS INDEX */\n        /* TODO: Check if handler is registered at this index */\n        /* TODO: if (event_ops_table[i].handler != NULL) { */\n        \n            /* STEP 4: PRINT HANDLER INFORMATION */\n            /* TODO: Print handler info: event type, name, call count */\n            /* TODO: printk(KERN_INFO \"Event Type %d: %s (called %u times)\\n\",  */\n            /*              i, event_ops_table[i].event_name, event_ops_table[i].event_count); */\n        \n        /* TODO: } */\n    /* TODO: } */\n    \n    /* STEP 5: PRINT FOOTER WITH TOTAL COUNT */\n    /* TODO: Print footer message */\n    /* TODO: printk(KERN_INFO \"Total registered handlers: %d\\n\", registered_handler_count); */\n}\n\nstatic int __init function_dispatch_init(void)\n{\n    int i;\n    \n    printk(KERN_INFO \"Function dispatch module loaded\\n\");\n    \n    /* Initialize the event operations table */\n    for (i = 0; i < MAX_HANDLERS; i++) {\n        event_ops_table[i].handler = NULL;\n        event_ops_table[i].event_count = 0;\n        memset(event_ops_table[i].event_name, 0, MAX_NAME_LEN);\n    }\n    \n    printk(KERN_INFO \"\\n=== Demonstrating Runtime-Unknown Handler Registration ===\\n\");\n    printk(KERN_INFO \"Student doesn't know which handlers will be registered!\\n\");\n    \n    /* Register handlers based on module parameters (UNKNOWN to student!) */\n    if (register_handler_types[0]) register_event_handler(0, sensor_event_handler, \"Sensor\");\n    if (register_handler_types[1]) register_event_handler(1, motor_event_handler, \"Motor\");\n    if (register_handler_types[2]) register_event_handler(2, status_event_handler, \"Status\");\n    if (register_handler_types[3]) register_event_handler(3, network_event_handler, \"Network\");\n    if (register_handler_types[4]) register_event_handler(4, storage_event_handler, \"Storage\");\n    \n    /* Show registered handlers */\n    show_registered_handlers();\n    \n    printk(KERN_INFO \"\\n=== Dispatching to Runtime-Unknown Types ===\\n\");\n    printk(KERN_INFO \"Will dispatch to %d different event types\\n\", test_dispatch_count);\n    \n    /* Dispatch to MULTIPLE different types (proves table lookup works!) */\n    for (i = 0; i < test_dispatch_count && i < MAX_HANDLERS; i++) {\n        uint8_t dispatch_type = test_dispatch_types[i];\n        printk(KERN_INFO \"\\nDispatching to type %d:\\n\", dispatch_type);\n        dispatch_event(dispatch_type, NULL, 128 + (i * 64));\n    }\n    \n    /* Show final statistics */\n    printk(KERN_INFO \"\\n=== Final Handler Statistics ===\\n\");\n    show_registered_handlers();\n    \n    printk(KERN_INFO \"\\nFunction dispatch demonstration complete\\n\");\n    \n    return 0;\n}\n\nstatic void __exit function_dispatch_exit(void)\n{\n    printk(KERN_INFO \"Function dispatch module unloaded\\n\");\n    registered_handler_count = 0;\n}\n\nmodule_init(function_dispatch_init);\nmodule_exit(function_dispatch_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning WHY function pointers are required for runtime-unknown types\");\nMODULE_VERSION(\"1.0\");",
      "readOnly": false,
      "language": "c"
    },
    {
      "name": "Makefile",
      "content": "# Function dispatch module Makefile\nobj-m += function_dispatch.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
      "readOnly": true,
      "language": "makefile"
    }
  ],
  "concepts": [
    "WHAT is a function pointer (variable storing function address)",
    "HOW function pointers work (memory layout and indirect calls)",
    "Function pointer syntax breakdown (step-by-step)",
    "Typedef for function pointers (making syntax cleaner)",
    "Function pointers in arrays (table-based dispatch)",
    "Function pointers in structs (OOP in C pattern)",
    "WHEN to use function pointers (decision tree)",
    "WHEN NOT to use (2-3 options use if-else instead)",
    "Runtime-unknown types (THE key use case)",
    "Callback registration pattern (impossible without function pointers)",
    "Set once, use forever pattern (performance optimization)",
    "Extensible plugin systems"
  ],
  "skills": [
    "Understanding function pointers as variables storing addresses",
    "Reading function pointer syntax (breaking down declarations)",
    "Using typedef to simplify function pointer declarations",
    "Assigning functions to function pointers",
    "Calling functions through pointers (indirect calls)",
    "Storing function pointers in arrays for dispatch tables",
    "Storing function pointers in structs for OOP patterns",
    "Applying decision tree for function pointer vs direct call choice",
    "Implementing callback registration systems (kernel pattern)",
    "Handling runtime-unknown handler types",
    "Understanding 'set once, use forever' performance optimization",
    "Recognizing when function pointers add unnecessary complexity",
    "Building extensible event handling systems"
  ],
  "validation": {
    "exactRequirements": {
      "functionNames": [
        "function_dispatch_init",
        "function_dispatch_exit",
        "register_event_handler",
        "dispatch_event",
        "show_registered_handlers",
        "sensor_event_handler",
        "motor_event_handler",
        "status_event_handler",
        "network_event_handler",
        "storage_event_handler"
      ],
      "function_declarations": [
        {
          "name": "register_event_handler",
          "returnType": "void",
          "parameters": ["uint8_t event_type", "event_handler_t handler", "const char* name"]
        },
        {
          "name": "dispatch_event",
          "returnType": "void",
          "parameters": ["uint8_t event_type", "void* data", "uint32_t size"]
        },
        {
          "name": "show_registered_handlers",
          "returnType": "void",
          "parameters": []
        }
      ],
      "variables_declarations": [
        {
          "name": "event_handler_t",
          "type": "typedef",
          "value": "void (*)(uint8_t event_type, void* event_data, uint32_t data_size)",
          "storageClass": "none"
        },
        {
          "name": "event_operations",
          "type": "typedef struct",
          "value": "{event_handler_t handler; char event_name[MAX_NAME_LEN]; uint32_t event_count;}",
          "storageClass": "none"
        },
        {
          "name": "event_ops_table",
          "type": "event_operations",
          "value": "[MAX_HANDLERS]",
          "storageClass": "extern"
        },
        {
          "name": "registered_handler_count",
          "type": "int",
          "storageClass": "extern"
        }
      ],
      "variables": [
        {
          "name": "event_ops_table",
          "type": "event_operations",
          "value": "[MAX_HANDLERS]",
          "storageClass": "none"
        },
        {
          "name": "registered_handler_count",
          "type": "int",
          "value": 0,
          "storageClass": "none"
        }
      ],
      "outputMessages": [
        "Function dispatch module loaded",
        "Demonstrating Runtime-Unknown Handler Registration",
        "Student doesn't know which handlers will be registered!",
        "Registered handler",
        "Registered Event Handlers",
        "Total registered handlers:",
        "Dispatching to Runtime-Unknown Types",
        "Will dispatch to",
        "Dispatching to type",
        "Final Handler Statistics",
        "Function dispatch demonstration complete",
        "Function dispatch module unloaded"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/types.h"
      ],
      "mustContain": [
        "event_ops_table[event_type].handler = handler",
        "event_ops_table[event_type].handler(event_type, data, size)",
        "if (event_ops_table[event_type].handler == NULL)",
        "event_ops_table[event_type].event_count++",
        "registered_handler_count++",
        "module_param_array(register_handler_types, int, NULL, 0644)",
        "module_param_array(test_dispatch_types, int"
      ],
      "moduleInfo": {
        "license": "GPL"
      }
    },
    "testCases": [
      {
        "id": "function_declarations",
        "name": "Function Declarations in Header",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "void register_event_handler(uint8_t event_type, event_handler_t handler, const char* name)",
          "void dispatch_event(uint8_t event_type, void* data, uint32_t size)",
          "void show_registered_handlers(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "function_signatures_source",
        "name": "Function Signatures in Source File",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "void register_event_handler(uint8_t event_type, event_handler_t handler, const char* name)",
          "void dispatch_event(uint8_t event_type, void* data, uint32_t size)",
          "void show_registered_handlers(void)",
          "static int __init function_dispatch_init(void)",
          "static void __exit function_dispatch_exit(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "callback_registration_implementation",
        "name": "Callback Registration Implementation",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "event_ops_table[event_type].handler = handler",
          "registered_handler_count++"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "function_pointer_dispatch",
        "name": "Function Pointer Dispatch (No If-Else)",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "event_ops_table[event_type].handler(event_type, data, size)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "exact_output",
        "name": "Exact Output Messages",
        "type": "output_match",
        "critical": true,
        "expected": [
          {
            "pattern": "Function dispatch module loaded",
            "exact": true,
            "linkedFunction": "static int __init function_dispatch_init(void)"
          },
          {
            "pattern": "Demonstrating Runtime-Unknown Handler Registration",
            "exact": true,
            "linkedFunction": "static int __init function_dispatch_init(void)"
          },
          {
            "pattern": "Student doesn't know which handlers will be registered!",
            "exact": true,
            "linkedFunction": "static int __init function_dispatch_init(void)"
          },
          {
            "pattern": "Registered handler .* for event type [0-9]+",
            "exact": false,
            "linkedFunction": "void register_event_handler(uint8_t event_type, event_handler_t handler, const char* name)"
          },
          {
            "pattern": "Registered Event Handlers",
            "exact": true,
            "linkedFunction": "void show_registered_handlers(void)"
          },
          {
            "pattern": "Total registered handlers: [0-9]+",
            "exact": false,
            "linkedFunction": "void show_registered_handlers(void)"
          },
          {
            "pattern": "Dispatching to Runtime-Unknown Types",
            "exact": true,
            "linkedFunction": "static int __init function_dispatch_init(void)"
          },
          {
            "pattern": "Will dispatch to [0-9]+ different event types",
            "exact": false,
            "linkedFunction": "static int __init function_dispatch_init(void)"
          },
          {
            "pattern": "Dispatching to type [0-9]+",
            "exact": false,
            "linkedFunction": "static int __init function_dispatch_init(void)"
          },
          {
            "pattern": "\\[(Sensor|Motor|Status|Network|Storage) Handler\\] Processing event type [0-9]+, data size: [0-9]+",
            "exact": false,
            "linkedFunction": "void dispatch_event(uint8_t event_type, void* data, uint32_t size)"
          },
          {
            "pattern": "Final Handler Statistics",
            "exact": true,
            "linkedFunction": "static int __init function_dispatch_init(void)"
          },
          {
            "pattern": "Function dispatch demonstration complete",
            "exact": true,
            "linkedFunction": "static int __init function_dispatch_init(void)"
          },
          {
            "pattern": "Function dispatch module unloaded",
            "exact": true,
            "linkedFunction": "static void __exit function_dispatch_exit(void)"
          }
        ]
      },
      {
        "id": "runtime_unknown_type_validation",
        "name": "Runtime-Unknown Multi-Type Dispatch (Proves Table Lookup)",
        "type": "kernel_project_test",
        "critical": true,
        "testScenario": {
          "userspaceApps": [
            {
              "name": "dynamic_handler_tester",
              "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\\\"=== Runtime-Unknown Handler Type Test ===\\\\n\\\");\\n    \\n    srand(time(NULL));\\n    \\n    /* Generate random handler combination (student doesn't know which!) */\\n    int handlers[5] = {0,0,0,0,0};\\n    int num_handlers = (rand() % 3) + 2;  /* Register 2-4 handlers */\\n    \\n    printf(\\\"Step 1: Randomly selecting %d handlers to register...\\\\n\\\", num_handlers);\\n    \\n    /* Randomly select which handlers to enable */\\n    for(int i = 0; i < num_handlers; i++) {\\n        int idx;\\n        do {\\n            idx = rand() % 5;\\n        } while(handlers[idx] == 1);\\n        handlers[idx] = 1;\\n        printf(\\\"  - Enabled handler %d\\\\n\\\", idx);\\n    }\\n    \\n    /* Generate dispatch sequence to MULTIPLE different types */\\n    int dispatch_count = (rand() % 3) + 3;  /* 3-5 dispatches */\\n    int dispatch_types[8] = {0};\\n    \\n    printf(\\\"\\\\nStep 2: Generating %d random dispatch operations...\\\\n\\\", dispatch_count);\\n    \\n    for(int i = 0; i < dispatch_count; i++) {\\n        /* Pick a random ENABLED handler to dispatch to */\\n        int attempts = 0;\\n        do {\\n            dispatch_types[i] = rand() % 5;\\n            attempts++;\\n        } while (!handlers[dispatch_types[i]] && attempts < 20);\\n        \\n        if (handlers[dispatch_types[i]]) {\\n            printf(\\\"  - Dispatch %d: type %d\\\\n\\\", i+1, dispatch_types[i]);\\n        } else {\\n            dispatch_types[i] = -1;\\n            dispatch_count = i;\\n            break;\\n        }\\n    }\\n    \\n    printf(\\\"\\\\nTest configuration:\\\\n\\\");\\n    printf(\\\"  handlers=\");\\n    for(int i=0; i<5; i++) printf(\\\"%d,\\\", handlers[i]);\\n    printf(\\\"\\\\n  dispatch_count=%d\\\\n\\\", dispatch_count);\\n    printf(\\\"  dispatch_types=\");\\n    for(int i=0; i<dispatch_count; i++) printf(\\\"%d,\\\", dispatch_types[i]);\\n    printf(\\\"\\\\n\\\\n\\\");\\n    \\n    system(\\\"rmmod function_dispatch 2>/dev/null\\\");\\n    \\n    /* Build module load command */\\n    char cmd[512];\\n    char types_str[128] = \\\"\\\";\\n    \\n    for(int i = 0; i < dispatch_count; i++) {\\n        if (dispatch_types[i] >= 0) {\\n            char buf[16];\\n            snprintf(buf, sizeof(buf), \\\"%s%d\\\", i > 0 ? \\\",\\\" : \\\"\\\", dispatch_types[i]);\\n            strcat(types_str, buf);\\n        }\\n    }\\n    \\n    snprintf(cmd, sizeof(cmd), \\n             \\\"insmod /lib/modules/function_dispatch.ko register_handler_types=%d,%d,%d,%d,%d test_dispatch_types=%s\\\",\\n             handlers[0], handlers[1], handlers[2], handlers[3], handlers[4], types_str);\\n    \\n    printf(\\\"Executing: %s\\\\n\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Multi-type dispatch test completed\\\\n\\\");\\n    printf(\\\"This PROVES function pointer table handles ANY type combination!\\\\n\\\");\\n    return 0;\\n}"
            }
          ],
          "setupCommands": [
            "echo 'Starting runtime-unknown multi-type dispatch validation'"
          ],
          "testCommands": [
            "echo 'Phase 1: TCC Header Validation'",
            "mkdir -p /tmp/linux",
            "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
            "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
            "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
            "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
            "echo '#define module_init(x)' >> /tmp/linux/module.h",
            "echo '#define module_exit(x)' >> /tmp/linux/module.h",
            "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
            "echo '#define module_param_array(name, type, nump, perm)' >> /tmp/linux/module.h",
            "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
            "echo '#define __init' > /tmp/linux/init.h",
            "echo '#define __exit' >> /tmp/linux/init.h",
            "echo 'typedef unsigned char uint8_t;' > /tmp/linux/types.h",
            "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
            "echo 'void* memset(void* s, int c, unsigned long n);' > /tmp/linux/string.h",
            "echo '#include \"/lib/modules/function_dispatch.h\"' > /tmp/test.c",
            "echo 'int main() { register_event_handler(1, (event_handler_t)0, \"test\"); dispatch_event(1, (void*)0, 128); show_registered_handlers(); return 0; }' >> /tmp/test.c",
            "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
            "TCC_EXIT_CODE=$?",
            "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing'; cat /tmp/tcc_error.log; else echo 'PASS: All declarations found'; fi",
            "",
            "echo 'Phase 2: Multi-Type Dispatch Test (Random Handler Combinations)'",
            "/bin/dynamic_handler_tester > /tmp/test_output.log 2>&1",
            "cat /tmp/test_output.log",
            "sleep 1",
            "",
            "echo 'Phase 3: Extract Test Configuration'",
            "DISPATCH_COUNT=$(grep -o 'dispatch_count=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
            "DISPATCH_TYPES=$(grep -o 'dispatch_types=[0-9,]*' /tmp/test_output.log | cut -d'=' -f2)",
            "HANDLER_CONFIG=$(grep -o 'handlers=[0-9,]*' /tmp/test_output.log | head -1 | cut -d'=' -f2)",
            "echo 'Test used: handlers='$HANDLER_CONFIG", 
            "echo 'Dispatch count: '$DISPATCH_COUNT",
            "echo 'Dispatch types: '$DISPATCH_TYPES",
            "if [ -z \"$DISPATCH_COUNT\" ]; then echo 'FAIL: Could not extract test config'; exit 1; else echo 'PASS: Test configuration extracted'; fi",
            "",
            "echo 'Phase 4: Verify Dynamic Registration'",
            "dmesg | grep 'Runtime-Unknown Handler Registration' && echo 'PASS: Dynamic registration pattern present' || echo 'FAIL: Missing pattern message'",
            "REGISTERED_COUNT=$(dmesg | grep -c 'Registered handler')",
            "echo 'Total handlers registered: '$REGISTERED_COUNT",
            "if [ \"$REGISTERED_COUNT\" -ge 2 ]; then echo 'PASS: Multiple handlers registered'; else echo 'FAIL: Too few handlers'; fi",
            "",
            "echo 'Phase 5: Validate Multi-Type Dispatch (THE KEY TEST!)'",
            "echo 'Verifying dispatches went to DIFFERENT handler types...'",
            "SENSOR_CALLS=$(dmesg | grep -c '\\[Sensor Handler\\] Processing')",
            "MOTOR_CALLS=$(dmesg | grep -c '\\[Motor Handler\\] Processing')",
            "STATUS_CALLS=$(dmesg | grep -c '\\[Status Handler\\] Processing')",
            "NETWORK_CALLS=$(dmesg | grep -c '\\[Network Handler\\] Processing')",
            "STORAGE_CALLS=$(dmesg | grep -c '\\[Storage Handler\\] Processing')",
            "TOTAL_CALLS=$((SENSOR_CALLS + MOTOR_CALLS + STATUS_CALLS + NETWORK_CALLS + STORAGE_CALLS))",
            "TYPES_USED=0",
            "[ \"$SENSOR_CALLS\" -gt 0 ] && TYPES_USED=$((TYPES_USED + 1))",
            "[ \"$MOTOR_CALLS\" -gt 0 ] && TYPES_USED=$((TYPES_USED + 1))",
            "[ \"$STATUS_CALLS\" -gt 0 ] && TYPES_USED=$((TYPES_USED + 1))",
            "[ \"$NETWORK_CALLS\" -gt 0 ] && TYPES_USED=$((TYPES_USED + 1))",
            "[ \"$STORAGE_CALLS\" -gt 0 ] && TYPES_USED=$((TYPES_USED + 1))",
            "echo 'Handler call counts: Sensor='$SENSOR_CALLS', Motor='$MOTOR_CALLS', Status='$STATUS_CALLS', Network='$NETWORK_CALLS', Storage='$STORAGE_CALLS",
            "echo 'Total handler calls: '$TOTAL_CALLS' (expected: '$DISPATCH_COUNT')'",
            "echo 'Unique types used: '$TYPES_USED",
            "if [ \"$TOTAL_CALLS\" -ge \"$DISPATCH_COUNT\" ]; then echo 'PASS: All dispatches completed'; else echo 'FAIL: Missing dispatches'; fi",
            "if [ \"$TYPES_USED\" -ge 1 ]; then echo 'PASS: Function pointer table working'; else echo 'FAIL: No handlers called'; fi",
            "",
            "echo 'Phase 6: Verify Statistics Tracking'",
            "dmesg | grep 'Final Handler Statistics' && echo 'PASS: Statistics present' || echo 'FAIL: Missing statistics'",
            "dmesg | grep 'called [1-9][0-9]* times' && echo 'PASS: Event counters updated' || echo 'PASS: Event counters show zero (might not have been called)'",
            "",
            "echo 'Phase 7: Critical Validation - Proves Function Pointers Necessary'",
            "dmesg | grep 'Dispatching to type' && echo 'PASS: Multi-type dispatch demonstrated' || echo 'FAIL: Only single type tested'",
            "echo ''",
            "echo '========================================='",
            "echo 'CRITICAL SUCCESS: This test PROVES that:'",
            "echo '1. Handlers are registered DYNAMICALLY'",
            "echo '2. Dispatches go to MULTIPLE types'",
            "echo '3. Function pointer table handles ANY combination'",
            "echo '4. If-else is IMPOSSIBLE (types unknown at compile time)'",
            "echo '========================================='",
            "echo ''",
            "echo 'PASS: All runtime-unknown multi-type validation successful'"
          ],
          "expected": {
            "dmesg": [
              "Function dispatch module loaded",
              "Runtime-Unknown Handler Registration",
              "Student doesn't know which handlers will be registered!",
              "Registered handler .* for event type [0-9]*",
              "Dispatching to Runtime-Unknown Types",
              "Will dispatch to [0-9]+ different event types",
              "Dispatching to type [0-9]+",
              "\\[(Sensor|Motor|Status|Network|Storage) Handler\\] Processing event type [0-9]*",
              "Final Handler Statistics",
              "Function dispatch demonstration complete"
            ],
            "stdout": [
              "PASS: All declarations found",
              "SUCCESS: Multi-type dispatch test completed",
              "PASS: Test configuration extracted",
              "PASS: Dynamic registration pattern present",
              "PASS: Multiple handlers registered",
              "PASS: All dispatches completed",
              "PASS: Function pointer table working",
              "PASS: Statistics present",
              "PASS: Multi-type dispatch demonstrated",
              "PASS: All runtime-unknown multi-type validation successful"
            ]
          },
          "timeout": 20
        }
      }
    ]
  }
}
