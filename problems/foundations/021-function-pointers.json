{
  "id": 21,
  "title": "Function Pointers - Runtime-Unknown Type Dispatch",
  "phase": "foundations",
  "difficulty": 6,
  "xp": 55,
  "description": "Master function pointers by handling RUNTIME-UNKNOWN event types! Learn WHAT function pointers are, HOW they work, WHY they're necessary (not just convenient), and WHEN they're required vs overkill. Build an extensible callback system where handlers are registered dynamically from EXTERNAL MODULES - proving function pointers handle types that DON'T EXIST at compile time. Handler modules load dynamically, making if-else IMPOSSIBLE. This is the exact pattern Linux uses for interrupt handlers, filesystem operations, and driver registration.",
  "mainFile": "function_dispatch.c",
  "files": [
    {
      "name": "function_dispatch.h",
      "content": "#ifndef FUNCTION_DISPATCH_H\n#define FUNCTION_DISPATCH_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n#define MAX_HANDLERS 8\n#define MAX_NAME_LEN 32\n#define MAX_HANDLER_TYPES 5\n\n/* Event handler function pointer type */\ntypedef void (*event_handler_t)(uint8_t event_type, void* event_data, uint32_t data_size);\n\n/* Event operations struct - demonstrates OOP in C pattern */\ntypedef struct {\n    event_handler_t handler;           /* Function pointer IN struct */\n    char event_name[MAX_NAME_LEN];   /* Event type name */\n    uint32_t event_count;             /* Number of times handled */\n} event_operations;\n\n/* Global event operations table */\nextern event_operations event_ops_table[MAX_HANDLERS];\nextern int registered_handler_count;\n\n/* TODO: Declare your callback registration function */\n/* void register_event_handler(uint8_t event_type, event_handler_t handler, const char* name); */\n\n/* TODO: Declare your dispatch function that uses the stored function pointer */\n/* void dispatch_event(uint8_t event_type, void* data, uint32_t size); */\n\n/* TODO: Declare your function to show all registered handlers */\n/* void show_registered_handlers(void); */\n\n#endif /* FUNCTION_DISPATCH_H */",
      "readOnly": false,
      "language": "h"
    },
    {
      "name": "function_dispatch.c",
      "content": "#include \"function_dispatch.h\"\n#include <linux/string.h>\n\n/* Global event operations table - each entry has function pointer */\nevent_operations event_ops_table[MAX_HANDLERS];\nint registered_handler_count = 0;\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: Complete Beginner's Guide to Function Pointers */\n/* ========================================================================== */\n/* This problem teaches function pointers from FIRST PRINCIPLES!\n *\n * LEARNING PATH:\n * 1. WHAT is a function pointer? (basics)\n * 2. HOW does it work? (memory and syntax)\n * 3. WHY use it? (decision tree)\n * 4. WHEN to use it? (patterns)\n * 5. HOW to implement? (callback system)\n *\n * CRITICAL DIFFERENCE FROM TYPICAL PROBLEMS:\n * Handler functions are in SEPARATE MODULES!\n * You CANNOT use if-else - handlers don't exist in this module!\n * This PROVES function pointers handle runtime-unknown types!\n */\n\n/* ========================================================================== */\n/* PART 1: WHAT IS A FUNCTION POINTER? */\n/* ========================================================================== */\n/* A function pointer is a VARIABLE that stores the MEMORY ADDRESS of a function.\n *\n * COMPARISON TO DATA POINTERS (from Problem 15):\n *\n * Data Pointer (you already know this!):\n *   int number = 42;\n *   int *ptr = &number;  // ptr stores ADDRESS of variable\n *   *ptr = 99;           // Change value through pointer\n *\n * Function Pointer (new concept!):\n *   void my_function(int x) { ... }\n *   void (*ptr)(int) = my_function;  // ptr stores ADDRESS of function!\n *   ptr(42);                          // Call function through pointer\n *\n * KEY INSIGHT: Functions have addresses in memory, just like variables!\n */\n\n/* ========================================================================== */\n/* PART 2: HOW FUNCTION POINTERS WORK - MEMORY LAYOUT */\n/* ========================================================================== */\n/* MEMORY VISUALIZATION:\n *\n * Code Segment (where functions live):\n * Address      Content\n * 0x401000:    [sensor_handler code]   ← In handler_sensor.ko module!\n * 0x401200:    [motor_handler code]    ← In handler_motor.ko module!\n * 0x401400:    [status_handler code]   ← In handler_status.ko module!\n * 0x401600:    [network_handler code]  ← In handler_network.ko module!\n * 0x401800:    [storage_handler code]  ← In handler_storage.ko module!\n *\n * Data Segment (where function pointers live):\n * Address      Content\n * 0x500000:    handler_ptr = 0x401000  // Points to sensor_handler\n *\n * WHEN YOU CALL handler_ptr():\n * 1. CPU reads value at 0x500000 → gets 0x401000\n * 2. CPU jumps to address 0x401000 (in external module!)\n * 3. Executes sensor_handler code\n * 4. Returns back\n *\n * This is called INDIRECT CALL (go through pointer first)\n * Direct call: my_function() → CPU knows address at compile time\n * Indirect call: ptr() → CPU must read pointer value first\n */\n\n/* ========================================================================== */\n/* PART 3: FUNCTION POINTER SYNTAX EXPLAINED */\n/* ========================================================================== */\n/* Function pointer declarations look scary, but follow a pattern!\n *\n * STEP-BY-STEP BREAKDOWN:\n *\n * 1. Start with a function signature:\n *    void sensor_handler(uint8_t type, void* data, uint32_t size);\n *    ↑         ↑            ↑\n *    return    name         parameters\n *\n * 2. Replace function name with (*pointer_name):\n *    void (*handler_ptr)(uint8_t type, void* data, uint32_t size);\n *    ↑     ↑              ↑\n *    return pointer name   parameters\n *\n * 3. That's it! Now handler_ptr can point to any function with this signature.\n *\n * WHY THE PARENTHESES (*handler_ptr)?\n * Without: void *handler_ptr(...) means \"function returning void*\"\n * With: void (*handler_ptr)(...) means \"pointer to function returning void\"\n */\n\n/* ========================================================================== */\n/* PART 4: ASSIGNING AND CALLING FUNCTION POINTERS */\n/* ========================================================================== */\n/* ASSIGNMENT (storing function address):\n *\n * void sensor_handler(uint8_t type, void* data, uint32_t size) {\n *     printk(\"Sensor handler called\\n\");\n * }\n *\n * // Declare pointer\n * void (*handler_ptr)(uint8_t, void*, uint32_t);\n *\n * // Assign function address (function name IS the address!)\n * handler_ptr = sensor_handler;  // Option 1: Direct\n * handler_ptr = &sensor_handler; // Option 2: Explicit (same thing!)\n *\n * CALLING (using stored address):\n *\n * handler_ptr(1, NULL, 256);  // Option 1: Direct\n * (*handler_ptr)(1, NULL, 256); // Option 2: Explicit (same!)\n *\n * Both work identically! Modern C allows the simpler syntax.\n */\n\n/* ========================================================================== */\n/* PART 5: TYPEDEF FOR FUNCTION POINTERS (Making Life Easier) */\n/* ========================================================================== */\n/* Raw function pointer syntax is hard to read:\n *\n * BAD (UGLY):\n * void (*handler1)(uint8_t, void*, uint32_t);\n * void (*handler2)(uint8_t, void*, uint32_t);\n * void (*handler3)(uint8_t, void*, uint32_t);\n * // Repetitive and error-prone!\n *\n * GOOD (CLEAN): Use typedef to create a type name\n * typedef void (*event_handler_t)(uint8_t, void*, uint32_t);\n * event_handler_t handler1;\n * event_handler_t handler2;\n * event_handler_t handler3;\n * // Much clearer!\n *\n * TYPEDEF SYNTAX BREAKDOWN:\n * typedef void (*event_handler_t)(uint8_t type, void* data, uint32_t size);\n * ↑       ↑     ↑                 ↑\n * keyword return type name        parameters\n *\n * Now event_handler_t is a TYPE, like int or char*!\n * We use this in function_dispatch.h!\n */\n\n/* ========================================================================== */\n/* PART 6: FUNCTION POINTERS IN ARRAYS (The Power Move) */\n/* ========================================================================== */\n/* You can store function pointers in arrays for table-based dispatch!\n *\n * EXAMPLE: Interrupt handler table (like real Linux kernel)\n *\n * typedef void (*irq_handler_t)(int irq_num);\n * irq_handler_t irq_handlers[256];  // Array of function pointers!\n *\n * // Setup (registration):\n * irq_handlers[5] = keyboard_interrupt_handler;\n * irq_handlers[14] = disk_interrupt_handler;\n *\n * // Usage (dispatch):\n * void handle_interrupt(int irq_num) {\n *     if (irq_handlers[irq_num]) {\n *         irq_handlers[irq_num](irq_num);  // Call stored function!\n *     }\n * }\n *\n * This is O(1) lookup - much faster than if-else chain!\n * We use this pattern in this problem with event_ops_table[]!\n */\n\n/* ========================================================================== */\n/* PART 7: FUNCTION POINTERS IN STRUCTS (OOP in C) */\n/* ========================================================================== */\n/* This is how Linux kernel does object-oriented programming!\n *\n * STRUCT WITH FUNCTION POINTER:\n * struct file_operations {\n *     int (*open)(struct file *f);\n *     ssize_t (*read)(struct file *f, char *buf, size_t len);\n *     ssize_t (*write)(struct file *f, const char *buf, size_t len);\n * };\n *\n * DIFFERENT IMPLEMENTATIONS:\n * struct file_operations ext4_ops = {\n *     .open = ext4_open,\n *     .read = ext4_read,\n *     .write = ext4_write\n * };\n *\n * struct file_operations ntfs_ops = {\n *     .open = ntfs_open,\n *     .read = ntfs_read,\n *     .write = ntfs_write\n * };\n *\n * USAGE (automatic dispatch):\n * struct file {\n *     struct file_operations *ops;\n * };\n *\n * // Setup once:\n * ext4_file->ops = &ext4_ops;\n * ntfs_file->ops = &ntfs_ops;\n *\n * // Use many times (NO TYPE CHECKING!):\n * ext4_file->ops->read(...)  // Automatically calls ext4_read()\n * ntfs_file->ops->read(...)  // Automatically calls ntfs_read()\n *\n * We use a similar pattern with event_operations struct!\n */\n\n/* ========================================================================== */\n/* PART 8: WHEN to Use Function Pointers vs Direct Calls */\n/* ========================================================================== */\n/* Now that you know HOW function pointers work, learn WHEN to use them!\n *\n * DECISION TREE:\n * \n * Q1: Do you need to select different functions at RUNTIME based on data?\n *     NO  -> Direct function calls are simpler (STOP: don't use function pointers)\n *     YES -> Continue to Q2\n *\n * Q2: Do you have only 2-3 function options?\n *     YES -> Simple if-else is clearer and faster (STOP: don't use function pointers)\n *     NO  -> Continue to Q3\n *\n * Q3: Is this one of these scenarios?\n *     - Callbacks (must STORE function for later use)\n *     - 5+ functions requiring table-based dispatch\n *     - Plugin/extensible systems (functions unknown at compile time)\n *     - OOP in C (function pointers in struct for polymorphism)\n *     YES -> Function pointers REQUIRED\n *     NO  -> Reconsider if complexity is justified\n *\n * EXAMPLES OF WHEN FUNCTION POINTERS ARE REQUIRED:\n *\n * 1. EXTERNAL MODULES (CANNOT use if-else - functions don't exist!):\n *    // Handler functions are in SEPARATE .ko files!\n *    // sensor_event_handler is in handler_sensor.ko\n *    // motor_event_handler is in handler_motor.ko\n *    // You CANNOT call them directly - they're not compiled into this module!\n *    // If you try: if (type == 0) sensor_handler(...); → LINKER ERROR!\n *    // MUST use function pointers: event_ops_table[type].handler(...);\n *\n * 2. CALLBACK REGISTRATION (Cannot use if-else):\n *    void register_handler(event_handler_t handler) {\n *        handlers[event_type] = handler;  // MUST store for later!\n *    }\n *    // Later, when event occurs:\n *    handlers[event_type](data);  // Call stored function\n *    // WRONG: IMPOSSIBLE with if-else - you don't know which function user registered!\n *\n * 3. OOP IN C - Function Pointers in Struct (\"Set Once, Use Forever\"):\n *    struct file {\n *        struct file_operations *f_op;  // Points to function table\n *    };\n *    // Setup ONCE when file is opened:\n *    file->f_op = &ext4_file_operations;  // → Decision made once!\n *    // Then all operations are automatic (no type checking!):\n *    file->f_op->read();   // No if-else needed!\n *    file->f_op->write();  // No if-else needed!\n *    file->f_op->close();  // No if-else needed!\n *\n * EXAMPLES OF WHEN DIRECT CALLS ARE BETTER:\n *\n * 1. FUNCTION KNOWN AT COMPILE TIME (No runtime selection):\n *    BAD:  handler = my_function; handler(data);  // Unnecessary indirection!\n *    GOOD: my_function(data);  // Direct call is faster!\n *\n * 2. ONLY 2-3 FUNCTION OPTIONS (Simple if-else is clearer):\n *    BAD:  Setup entire function pointer infrastructure for 2 functions\n *    GOOD: if (type == A) func_a(); else func_b();  // Simpler!\n *\n * 3. PERFORMANCE-CRITICAL INNER LOOPS (Every cycle matters):\n *    Function pointers have costs:\n *    - Indirect call overhead (CPU pipeline stall)\n *    - Compiler cannot inline\n *    - Harder branch prediction\n *    Use direct calls in hot paths!\n */\n\n/* ========================================================================== */\n/* PART 9: THE \"SET ONCE, USE FOREVER\" PATTERN */\n/* ========================================================================== */\n/* This is the KEY insight that makes function pointers worthwhile!\n *\n * WITHOUT function pointers (check type repeatedly):\n *   void process(struct data *d) {\n *       if (d->type == A) func_a(d);  // Check EVERY time\n *       else func_b(d);\n *   }\n *   // If you process 10,000 items: 10,000 type checks!\n *\n * WITH function pointers (decide once, use forever):\n *   // Setup ONCE:\n *   d->handler = (d->type == A) ? func_a : func_b;  // Decide once\n *   // Use MANY times (no type checking!):\n *   d->handler(d);  // Just call it - 0 type checks!\n *   // If you process 10,000 items: 0 type checks!\n *\n * PERFORMANCE COMPARISON:\n * Setup phase: 1 assignment vs 1 if-else (same cost)\n * Process phase (1000 calls):\n * - If-else: 1000 type checks\n * - Function pointer: 0 type checks, just 1000 indirect calls\n * Winner: Function pointer (when processing many times)\n */\n\n/* ========================================================================== */\n/* PART 10: EXTERNAL MODULES - WHY IF-ELSE IS IMPOSSIBLE */\n/* ========================================================================== */\n/* This problem demonstrates WHY function pointers are NECESSARY!\n *\n * THE SCENARIO:\n * - Core module (function_dispatch.ko) provides registration system\n * - Handler modules (handler_*.ko) provide actual handlers\n * - Handlers are in SEPARATE .ko files\n * - You DON'T KNOW which handlers will be loaded!\n *\n * IN THIS PROBLEM:\n * - 5 handler modules available: sensor, motor, status, network, storage\n * - Test randomly loads 2-4 handler modules\n * - You DON'T KNOW which combination will be used!\n * - Testing system uses RANDOM combinations you've never seen!\n *\n * THIS IS EXACTLY LIKE:\n * - Linux filesystem registration (ext4.ko, ntfs.ko, btrfs.ko, ...)\n * - Driver registration (usb-storage.ko, ahci.ko, ...)\n * - Interrupt handlers (keyboard.ko, disk.ko, network.ko, ...)\n *\n * You CAN'T use if-else because:\n * 1. Handler functions don't exist in this module (linker error!)\n * 2. You don't know which modules will be loaded (runtime-unknown!)\n * Function pointers are REQUIRED, not just convenient!\n */\n\n/* ========================================================================== */\n/* NOW LET'S IMPLEMENT IT! */\n/* ========================================================================== */\n\n/* PATTERN SCAFFOLDING: Callback Registration Pattern */\n/* TODO: Implement callback registration function */\nvoid register_event_handler(uint8_t event_type, event_handler_t handler, const char* name) {\n    /* STEP 1: VALIDATE EVENT TYPE */\n    /* TODO: Check if event_type is within valid range (0 to MAX_HANDLERS-1) */\n    /* TODO: if (event_type >= MAX_HANDLERS) { */\n    /* TODO:     printk(KERN_ERR \"Invalid event type %d (max: %d)\\n\", event_type, MAX_HANDLERS-1); */\n    /* TODO:     return; */\n    /* TODO: } */\n    \n    /* STEP 2: STORE THE FUNCTION POINTER (The Key Step!) */\n    /* This is where the MAGIC happens - we store the function address! */\n    /* TODO: event_ops_table[event_type].handler = handler; */\n    /* What this does: Saves the address of external module's function in our table */\n    /* Later we can call: event_ops_table[event_type].handler(data) */\n    \n    /* STEP 3: STORE THE HANDLER NAME (for debugging/display) */\n    /* TODO: Copy the handler name to event_ops_table[event_type].event_name */\n    /* TODO: Use snprintf for safety: */\n    /* TODO: snprintf(event_ops_table[event_type].event_name, MAX_NAME_LEN, \"%s\", name); */\n    \n    /* STEP 4: INITIALIZE EVENT COUNT */\n    /* TODO: event_ops_table[event_type].event_count = 0; */\n    \n    /* STEP 5: TRACK TOTAL REGISTERED HANDLERS */\n    /* TODO: Increment registered_handler_count */\n    /* TODO: registered_handler_count++; */\n    \n    /* STEP 6: CONFIRMATION MESSAGE */\n    /* TODO: Print confirmation message */\n    /* TODO: printk(KERN_INFO \"Registered handler '%s' for event type %d\\n\", name, event_type); */\n}\n\n/* Export symbol so handler modules can call this function */\nEXPORT_SYMBOL(register_event_handler);\n\n/* TODO: Implement event dispatch function using stored function pointer */\nvoid dispatch_event(uint8_t event_type, void* data, uint32_t size) {\n    /* STEP 1: VALIDATE EVENT TYPE */\n    /* TODO: Check if event_type is within valid range */\n    /* TODO: if (event_type >= MAX_HANDLERS) { */\n    /* TODO:     printk(KERN_ERR \"Invalid event type %d\\n\", event_type); */\n    /* TODO:     return; */\n    /* TODO: } */\n    \n    /* STEP 2: CHECK IF HANDLER IS REGISTERED */\n    /* This is CRITICAL - must check before calling! */\n    /* TODO: if (event_ops_table[event_type].handler == NULL) { */\n    /* TODO:     printk(KERN_ERR \"No handler registered for event type %d\\n\", event_type); */\n    /* TODO:     return; */\n    /* TODO: } */\n    \n    /* STEP 3: INCREMENT EVENT COUNTER (statistics) */\n    /* TODO: event_ops_table[event_type].event_count++; */\n    \n    /* STEP 4: CALL THE STORED FUNCTION POINTER! */\n    /* THIS IS THE MAGIC - No if-else needed! */\n    /* TODO: event_ops_table[event_type].handler(event_type, data, size); */\n    /*\n     * WHAT JUST HAPPENED?\n     * 1. event_ops_table[event_type].handler  → Read function pointer from table\n     * 2. .handler(event_type, data, size)     → Call function through pointer\n     *\n     * If event_type == 0 and handler_sensor.ko is loaded:\n     *   - handler points to sensor_event_handler (in external module!)\n     *   - Calls sensor_event_handler(0, data, size)\n     *\n     * If event_type == 1 and handler_motor.ko is loaded:\n     *   - handler points to motor_event_handler (in external module!)\n     *   - Calls motor_event_handler(1, data, size)\n     *\n     * NO IF-ELSE! The function pointer was set during module load!\n     * We just dereference and call - automatic dispatch to external code!\n     */\n}\n\n/* TODO: Implement function to show all registered handlers */\nvoid show_registered_handlers(void) {\n    int i;\n    \n    /* STEP 1: PRINT HEADER */\n    /* TODO: Print header message */\n    /* TODO: printk(KERN_INFO \"\\n=== Registered Event Handlers ===\\n\"); */\n    \n    /* STEP 2: LOOP THROUGH ALL POSSIBLE EVENT TYPES */\n    /* TODO: Loop through all possible event types (0 to MAX_HANDLERS-1) */\n    /* TODO: for (i = 0; i < MAX_HANDLERS; i++) { */\n    \n        /* STEP 3: CHECK IF HANDLER IS REGISTERED AT THIS INDEX */\n        /* TODO: Check if handler is registered at this index */\n        /* TODO: if (event_ops_table[i].handler != NULL) { */\n        \n            /* STEP 4: PRINT HANDLER INFORMATION */\n            /* TODO: Print handler info: event type, name, call count */\n            /* TODO: printk(KERN_INFO \"Event Type %d: %s (called %u times)\\n\",  */\n            /*              i, event_ops_table[i].event_name, event_ops_table[i].event_count); */\n        \n        /* TODO: } */\n    /* TODO: } */\n    \n    /* STEP 5: PRINT FOOTER WITH TOTAL COUNT */\n    /* TODO: Print footer message */\n    /* TODO: printk(KERN_INFO \"Total registered handlers: %d\\n\", registered_handler_count); */\n}\n\nstatic int __init function_dispatch_init(void)\n{\n    int i;\n    \n    printk(KERN_INFO \"Function dispatch core module loaded\\n\");\n    printk(KERN_INFO \"Waiting for handler modules to register...\\n\");\n    \n    /* Initialize the event operations table */\n    for (i = 0; i < MAX_HANDLERS; i++) {\n        event_ops_table[i].handler = NULL;\n        event_ops_table[i].event_count = 0;\n        memset(event_ops_table[i].event_name, 0, MAX_NAME_LEN);\n    }\n    \n    printk(KERN_INFO \"Event dispatch system ready!\\n\");\n    \n    return 0;\n}\n\nstatic void __exit function_dispatch_exit(void)\n{\n    printk(KERN_INFO \"Function dispatch core module unloaded\\n\");\n    registered_handler_count = 0;\n}\n\nmodule_init(function_dispatch_init);\nmodule_exit(function_dispatch_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning WHY function pointers are required for external module integration\");\nMODULE_VERSION(\"1.0\");",
      "readOnly": false,
      "language": "c"
    },
    {
      "name": "handler_sensor.c",
      "content": "#include \"function_dispatch.h\"\n\n/* Sensor event handler implementation */\nvoid sensor_event_handler(uint8_t type, void* data, uint32_t size) {\n    printk(KERN_INFO \"[Sensor Handler] Processing event type %d, data size: %u\\n\", type, size);\n}\n\nstatic int __init sensor_handler_init(void)\n{\n    printk(KERN_INFO \"Sensor handler module loaded\\n\");\n    register_event_handler(0, sensor_event_handler, \"Sensor\");\n    return 0;\n}\n\nstatic void __exit sensor_handler_exit(void)\n{\n    printk(KERN_INFO \"Sensor handler module unloaded\\n\");\n}\n\nmodule_init(sensor_handler_init);\nmodule_exit(sensor_handler_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"KernelQ\");\nMODULE_DESCRIPTION(\"Sensor event handler module\");\nMODULE_VERSION(\"1.0\");",
      "readOnly": true,
      "language": "c"
    },
    {
      "name": "handler_motor.c",
      "content": "#include \"function_dispatch.h\"\n\n/* Motor event handler implementation */\nvoid motor_event_handler(uint8_t type, void* data, uint32_t size) {\n    printk(KERN_INFO \"[Motor Handler] Processing event type %d, data size: %u\\n\", type, size);\n}\n\nstatic int __init motor_handler_init(void)\n{\n    printk(KERN_INFO \"Motor handler module loaded\\n\");\n    register_event_handler(1, motor_event_handler, \"Motor\");\n    return 0;\n}\n\nstatic void __exit motor_handler_exit(void)\n{\n    printk(KERN_INFO \"Motor handler module unloaded\\n\");\n}\n\nmodule_init(motor_handler_init);\nmodule_exit(motor_handler_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"KernelQ\");\nMODULE_DESCRIPTION(\"Motor event handler module\");\nMODULE_VERSION(\"1.0\");",
      "readOnly": true,
      "language": "c"
    },
    {
      "name": "handler_status.c",
      "content": "#include \"function_dispatch.h\"\n\n/* Status event handler implementation */\nvoid status_event_handler(uint8_t type, void* data, uint32_t size) {\n    printk(KERN_INFO \"[Status Handler] Processing event type %d, data size: %u\\n\", type, size);\n}\n\nstatic int __init status_handler_init(void)\n{\n    printk(KERN_INFO \"Status handler module loaded\\n\");\n    register_event_handler(2, status_event_handler, \"Status\");\n    return 0;\n}\n\nstatic void __exit status_handler_exit(void)\n{\n    printk(KERN_INFO \"Status handler module unloaded\\n\");\n}\n\nmodule_init(status_handler_init);\nmodule_exit(status_handler_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"KernelQ\");\nMODULE_DESCRIPTION(\"Status event handler module\");\nMODULE_VERSION(\"1.0\");",
      "readOnly": true,
      "language": "c"
    },
    {
      "name": "handler_network.c",
      "content": "#include \"function_dispatch.h\"\n\n/* Network event handler implementation */\nvoid network_event_handler(uint8_t type, void* data, uint32_t size) {\n    printk(KERN_INFO \"[Network Handler] Processing event type %d, data size: %u\\n\", type, size);\n}\n\nstatic int __init network_handler_init(void)\n{\n    printk(KERN_INFO \"Network handler module loaded\\n\");\n    register_event_handler(3, network_event_handler, \"Network\");\n    return 0;\n}\n\nstatic void __exit network_handler_exit(void)\n{\n    printk(KERN_INFO \"Network handler module unloaded\\n\");\n}\n\nmodule_init(network_handler_init);\nmodule_exit(network_handler_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"KernelQ\");\nMODULE_DESCRIPTION(\"Network event handler module\");\nMODULE_VERSION(\"1.0\");",
      "readOnly": true,
      "language": "c"
    },
    {
      "name": "handler_storage.c",
      "content": "#include \"function_dispatch.h\"\n\n/* Storage event handler implementation */\nvoid storage_event_handler(uint8_t type, void* data, uint32_t size) {\n    printk(KERN_INFO \"[Storage Handler] Processing event type %d, data size: %u\\n\", type, size);\n}\n\nstatic int __init storage_handler_init(void)\n{\n    printk(KERN_INFO \"Storage handler module loaded\\n\");\n    register_event_handler(4, storage_event_handler, \"Storage\");\n    return 0;\n}\n\nstatic void __exit storage_handler_exit(void)\n{\n    printk(KERN_INFO \"Storage handler module unloaded\\n\");\n}\n\nmodule_init(storage_handler_init);\nmodule_exit(storage_handler_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"KernelQ\");\nMODULE_DESCRIPTION(\"Storage event handler module\");\nMODULE_VERSION(\"1.0\");",
      "readOnly": true,
      "language": "c"
    },
    {
      "name": "test_dispatch.c",
      "content": "#include \"function_dispatch.h\"\n\nint test_dispatch_types[MAX_HANDLERS] = {0, 1, 2, 3, 4, 0, 1, 2};\nint test_dispatch_count = 5;\n\nmodule_param_array(test_dispatch_types, int, &test_dispatch_count, 0644);\nMODULE_PARM_DESC(test_dispatch_types, \"Array of event types to dispatch (runtime-unknown)\");\n\nstatic int __init test_dispatch_init(void)\n{\n    int i;\n    \n    printk(KERN_INFO \"\\n=== Test Dispatch Module Loaded ===\\n\");\n    printk(KERN_INFO \"Will dispatch to %d different event types\\n\", test_dispatch_count);\n    \n    /* Show registered handlers */\n    show_registered_handlers();\n    \n    printk(KERN_INFO \"\\n=== Dispatching to Runtime-Unknown Types ===\\n\");\n    \n    /* Dispatch to MULTIPLE different types (proves table lookup works!) */\n    for (i = 0; i < test_dispatch_count && i < MAX_HANDLERS; i++) {\n        uint8_t dispatch_type = test_dispatch_types[i];\n        printk(KERN_INFO \"\\nDispatching to type %d:\\n\", dispatch_type);\n        dispatch_event(dispatch_type, NULL, 128 + (i * 64));\n    }\n    \n    /* Show final statistics */\n    printk(KERN_INFO \"\\n=== Final Handler Statistics ===\\n\");\n    show_registered_handlers();\n    \n    printk(KERN_INFO \"\\nFunction dispatch demonstration complete\\n\");\n    \n    return 0;\n}\n\nstatic void __exit test_dispatch_exit(void)\n{\n    printk(KERN_INFO \"Test dispatch module unloaded\\n\");\n}\n\nmodule_init(test_dispatch_init);\nmodule_exit(test_dispatch_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"KernelQ\");\nMODULE_DESCRIPTION(\"Test module for multi-type dispatch\");\nMODULE_VERSION(\"1.0\");",
      "readOnly": true,
      "language": "c"
    },
    {
      "name": "Makefile",
      "content": "# Function dispatch multi-module Makefile\nobj-m += function_dispatch.o\nobj-m += handler_sensor.o\nobj-m += handler_motor.o\nobj-m += handler_status.o\nobj-m += handler_network.o\nobj-m += handler_storage.o\nobj-m += test_dispatch.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
      "readOnly": true,
      "language": "makefile"
    }
  ],
  "concepts": [
    "WHAT is a function pointer (variable storing function address)",
    "HOW function pointers work (memory layout and indirect calls)",
    "Function pointer syntax breakdown (step-by-step)",
    "Typedef for function pointers (making syntax cleaner)",
    "Function pointers in arrays (table-based dispatch)",
    "Function pointers in structs (OOP in C pattern)",
    "WHEN to use function pointers (decision tree)",
    "WHEN NOT to use (2-3 options use if-else instead)",
    "External module integration (THE key use case)",
    "Callback registration pattern (impossible without function pointers)",
    "Set once, use forever pattern (performance optimization)",
    "Extensible plugin systems",
    "Module dependencies and EXPORT_SYMBOL"
  ],
  "skills": [
    "Understanding function pointers as variables storing addresses",
    "Reading function pointer syntax (breaking down declarations)",
    "Using typedef to simplify function pointer declarations",
    "Assigning functions to function pointers",
    "Calling functions through pointers (indirect calls)",
    "Storing function pointers in arrays for dispatch tables",
    "Storing function pointers in structs for OOP patterns",
    "Applying decision tree for function pointer vs direct call choice",
    "Implementing callback registration systems (kernel pattern)",
    "Handling external module handlers",
    "Understanding 'set once, use forever' performance optimization",
    "Recognizing when function pointers add unnecessary complexity",
    "Building extensible event handling systems",
    "Using EXPORT_SYMBOL for cross-module functions"
  ],
  "validation": {
    "exactRequirements": {
      "functionNames": [
        "function_dispatch_init",
        "function_dispatch_exit",
        "register_event_handler",
        "dispatch_event",
        "show_registered_handlers"
      ],
      "function_declarations": [
        {
          "name": "register_event_handler",
          "returnType": "void",
          "parameters": ["uint8_t event_type", "event_handler_t handler", "const char* name"]
        },
        {
          "name": "dispatch_event",
          "returnType": "void",
          "parameters": ["uint8_t event_type", "void* data", "uint32_t size"]
        },
        {
          "name": "show_registered_handlers",
          "returnType": "void",
          "parameters": []
        }
      ],
      "variables_declarations": [
        {
          "name": "event_handler_t",
          "type": "typedef",
          "value": "void (*)(uint8_t event_type, void* event_data, uint32_t data_size)",
          "storageClass": "none"
        },
        {
          "name": "event_operations",
          "type": "typedef struct",
          "value": "{event_handler_t handler; char event_name[MAX_NAME_LEN]; uint32_t event_count;}",
          "storageClass": "none"
        },
        {
          "name": "event_ops_table",
          "type": "event_operations",
          "value": "[MAX_HANDLERS]",
          "storageClass": "extern"
        },
        {
          "name": "registered_handler_count",
          "type": "int",
          "storageClass": "extern"
        }
      ],
      "variables": [
        {
          "name": "event_ops_table",
          "type": "event_operations",
          "value": "[MAX_HANDLERS]",
          "storageClass": "none"
        },
        {
          "name": "registered_handler_count",
          "type": "int",
          "value": 0,
          "storageClass": "none"
        }
      ],
      "outputMessages": [
        "Function dispatch core module loaded",
        "Waiting for handler modules to register",
        "Event dispatch system ready",
        "handler module loaded",
        "Registered handler",
        "Registered Event Handlers",
        "Total registered handlers:",
        "Dispatching to Runtime-Unknown Types",
        "Will dispatch to",
        "Dispatching to type",
        "Final Handler Statistics",
        "Function dispatch demonstration complete"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/types.h"
      ],
      "mustContain": [
        "event_ops_table[event_type].handler = handler",
        "event_ops_table[event_type].handler(event_type, data, size)",
        "if (event_ops_table[event_type].handler == NULL)",
        "event_ops_table[event_type].event_count++",
        "registered_handler_count++",
        "EXPORT_SYMBOL(register_event_handler)"
      ],
      "moduleInfo": {
        "license": "GPL"
      }
    },
    "testCases": [
      {
        "id": "function_declarations",
        "name": "Function Declarations in Header",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "void register_event_handler(uint8_t event_type, event_handler_t handler, const char* name)",
          "void dispatch_event(uint8_t event_type, void* data, uint32_t size)",
          "void show_registered_handlers(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "function_signatures_source",
        "name": "Function Signatures in Source File",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "void register_event_handler(uint8_t event_type, event_handler_t handler, const char* name)",
          "void dispatch_event(uint8_t event_type, void* data, uint32_t size)",
          "void show_registered_handlers(void)",
          "static int __init function_dispatch_init(void)",
          "static void __exit function_dispatch_exit(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "callback_registration_implementation",
        "name": "Callback Registration Implementation",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "event_ops_table[event_type].handler = handler",
          "registered_handler_count++"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "function_pointer_dispatch",
        "name": "Function Pointer Dispatch (No If-Else)",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "event_ops_table[event_type].handler(event_type, data, size)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "export_symbol_check",
        "name": "EXPORT_SYMBOL for Cross-Module Access",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "EXPORT_SYMBOL(register_event_handler)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "exact_output",
        "name": "Exact Output Messages",
        "type": "output_match",
        "critical": true,
        "expected": [
          {
            "pattern": "Function dispatch core module loaded",
            "exact": true,
            "linkedFunction": "static int __init function_dispatch_init(void)"
          },
          {
            "pattern": "Waiting for handler modules to register",
            "exact": true,
            "linkedFunction": "static int __init function_dispatch_init(void)"
          },
          {
            "pattern": "Event dispatch system ready",
            "exact": true,
            "linkedFunction": "static int __init function_dispatch_init(void)"
          },
          {
            "pattern": ".*handler module loaded",
            "exact": false,
            "linkedFunction": "Handler module init functions"
          },
          {
            "pattern": "Registered handler .* for event type [0-9]+",
            "exact": false,
            "linkedFunction": "void register_event_handler(uint8_t event_type, event_handler_t handler, const char* name)"
          },
          {
            "pattern": "Registered Event Handlers",
            "exact": true,
            "linkedFunction": "void show_registered_handlers(void)"
          },
          {
            "pattern": "Total registered handlers: [0-9]+",
            "exact": false,
            "linkedFunction": "void show_registered_handlers(void)"
          },
          {
            "pattern": "Dispatching to Runtime-Unknown Types",
            "exact": true,
            "linkedFunction": "test_dispatch module"
          },
          {
            "pattern": "Will dispatch to [0-9]+ different event types",
            "exact": false,
            "linkedFunction": "test_dispatch module"
          },
          {
            "pattern": "Dispatching to type [0-9]+",
            "exact": false,
            "linkedFunction": "test_dispatch module"
          },
          {
            "pattern": "\\[(Sensor|Motor|Status|Network|Storage) Handler\\] Processing event type [0-9]+, data size: [0-9]+",
            "exact": false,
            "linkedFunction": "void dispatch_event(uint8_t event_type, void* data, uint32_t size)"
          },
          {
            "pattern": "Final Handler Statistics",
            "exact": true,
            "linkedFunction": "test_dispatch module"
          },
          {
            "pattern": "Function dispatch demonstration complete",
            "exact": true,
            "linkedFunction": "test_dispatch module"
          }
        ]
      },
      {
        "id": "multi_module_dispatch_validation",
        "name": "Multi-Module Dynamic Dispatch (Proves External Module Integration)",
        "type": "kernel_project_test",
        "critical": true,
        "testScenario": {
          "userspaceApps": [
            {
              "name": "multi_module_tester",
              "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\\\"=== Multi-Module Handler Integration Test ===\\\\n\\\");\\n    \\n    srand(time(NULL));\\n    \\n    /* Generate random handler module selection (2-4 modules) */\\n    const char *handlers[] = {\\\"handler_sensor\\\", \\\"handler_motor\\\", \\\"handler_status\\\", \\\"handler_network\\\", \\\"handler_storage\\\"};\\n    int num_handlers = (rand() % 3) + 2;\\n    int selected[5] = {0};\\n    \\n    printf(\\\"Step 1: Randomly selecting %d handler modules to load...\\\\n\\\", num_handlers);\\n    \\n    for(int i = 0; i < num_handlers; i++) {\\n        int idx;\\n        do { idx = rand() % 5; } while(selected[idx]);\\n        selected[idx] = 1;\\n        printf(\\\"  - Will load %s.ko\\\\n\\\", handlers[idx]);\\n    }\\n    \\n    /* Generate dispatch sequence */\\n    int dispatch_count = (rand() % 3) + 3;\\n    int dispatch_types[8];\\n    \\n    printf(\\\"\\\\nStep 2: Generating %d random dispatches...\\\\n\\\", dispatch_count);\\n    for(int i = 0; i < dispatch_count; i++) {\\n        int attempts = 0;\\n        do {\\n            dispatch_types[i] = rand() % 5;\\n            attempts++;\\n        } while (!selected[dispatch_types[i]] && attempts < 20);\\n        if (selected[dispatch_types[i]]) {\\n            printf(\\\"  - Dispatch %d: type %d\\\\n\\\", i+1, dispatch_types[i]);\\n        } else {\\n            dispatch_count = i;\\n            break;\\n        }\\n    }\\n    \\n    printf(\\\"\\\\nTest configuration: %d handlers, %d dispatches\\\\n\\\", num_handlers, dispatch_count);\\n    \\n    /* Build dispatch types string */\\n    char types_str[128] = \\\"\\\";\\n    for(int i = 0; i < dispatch_count; i++) {\\n        char buf[16];\\n        snprintf(buf, sizeof(buf), \\\"%s%d\\\", i > 0 ? \\\",\\\" : \\\"\\\", dispatch_types[i]);\\n        strcat(types_str, buf);\\n    }\\n    \\n    /* Unload any existing modules */\\n    system(\\\"rmmod test_dispatch 2>/dev/null\\\");\\n    system(\\\"rmmod handler_sensor handler_motor handler_status handler_network handler_storage 2>/dev/null\\\");\\n    system(\\\"rmmod function_dispatch 2>/dev/null\\\");\\n    \\n    /* Load core module */\\n    printf(\\\"\\\\nStep 3: Loading core module...\\\\n\\\");\\n    system(\\\"insmod /lib/modules/function_dispatch.ko\\\");\\n    \\n    /* Load selected handler modules */\\n    printf(\\\"Step 4: Loading selected handler modules...\\\\n\\\");\\n    for(int i = 0; i < 5; i++) {\\n        if (selected[i]) {\\n            char cmd[256];\\n            snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/%s.ko\\\", handlers[i]);\\n            printf(\\\"  - Loading %s.ko\\\\n\\\", handlers[i]);\\n            system(cmd);\\n        }\\n    }\\n    \\n    /* Load test dispatch module */\\n    printf(\\\"Step 5: Running dispatch test...\\\\n\\\");\\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/test_dispatch.ko test_dispatch_types=%s\\\", types_str);\\n    system(cmd);\\n    \\n    printf(\\\"\\\\nSUCCESS: Multi-module dispatch test completed!\\\\n\\\");\\n    printf(\\\"This PROVES function pointers handle external module functions!\\\\n\\\");\\n    return 0;\\n}"
            }
          ],
          "setupCommands": [
            "echo 'Starting multi-module external handler validation'"
          ],
          "testCommands": [
            "echo 'Phase 1: TCC Header Validation'",
            "mkdir -p /tmp/linux",
            "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
            "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
            "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
            "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
            "echo '#define module_init(x)' >> /tmp/linux/module.h",
            "echo '#define module_exit(x)' >> /tmp/linux/module.h",
            "echo '#define EXPORT_SYMBOL(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
            "echo '#define __init' > /tmp/linux/init.h",
            "echo '#define __exit' >> /tmp/linux/init.h",
            "echo 'typedef unsigned char uint8_t;' > /tmp/linux/types.h",
            "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
            "echo 'void* memset(void* s, int c, unsigned long n);' > /tmp/linux/string.h",
            "echo '#include \"/lib/modules/function_dispatch.h\"' > /tmp/test.c",
            "echo 'int main() { register_event_handler(1, (event_handler_t)0, \"test\"); dispatch_event(1, (void*)0, 128); show_registered_handlers(); return 0; }' >> /tmp/test.c",
            "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
            "TCC_EXIT_CODE=$?",
            "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing'; cat /tmp/tcc_error.log; else echo 'PASS: All declarations found'; fi",
            "",
            "echo 'Phase 2: Multi-Module Integration Test'",
            "/bin/multi_module_tester > /tmp/test_output.log 2>&1",
            "cat /tmp/test_output.log",
            "sleep 1",
            "",
            "echo 'Phase 3: Verify Core Module Loaded'",
            "dmesg | grep 'Function dispatch core module loaded' && echo 'PASS: Core module loaded' || echo 'FAIL: Core module not loaded'",
            "dmesg | grep 'Event dispatch system ready' && echo 'PASS: System initialized' || echo 'FAIL: System not ready'",
            "",
            "echo 'Phase 4: Verify Handler Modules Registered'",
            "REGISTERED_COUNT=$(dmesg | grep -c 'Registered handler')",
            "echo 'Handler modules registered: '$REGISTERED_COUNT",
            "if [ \"$REGISTERED_COUNT\" -ge 2 ]; then echo 'PASS: Multiple handler modules registered'; else echo 'FAIL: Too few handlers'; fi",
            "",
            "echo 'Phase 5: Validate External Module Dispatch (THE CRITICAL TEST!)'",
            "SENSOR_CALLS=$(dmesg | grep -c '\\[Sensor Handler\\] Processing')",
            "MOTOR_CALLS=$(dmesg | grep -c '\\[Motor Handler\\] Processing')",
            "STATUS_CALLS=$(dmesg | grep -c '\\[Status Handler\\] Processing')",
            "NETWORK_CALLS=$(dmesg | grep -c '\\[Network Handler\\] Processing')",
            "STORAGE_CALLS=$(dmesg | grep -c '\\[Storage Handler\\] Processing')",
            "TOTAL_CALLS=$((SENSOR_CALLS + MOTOR_CALLS + STATUS_CALLS + NETWORK_CALLS + STORAGE_CALLS))",
            "echo 'External handler calls: Sensor='$SENSOR_CALLS', Motor='$MOTOR_CALLS', Status='$STATUS_CALLS', Network='$NETWORK_CALLS', Storage='$STORAGE_CALLS",
            "echo 'Total external calls: '$TOTAL_CALLS",
            "if [ \"$TOTAL_CALLS\" -ge 3 ]; then echo 'PASS: External module functions called via function pointers'; else echo 'FAIL: External handlers not called'; fi",
            "",
            "echo 'Phase 6: Verify Statistics Tracking'",
            "dmesg | grep 'Final Handler Statistics' && echo 'PASS: Statistics tracking working' || echo 'FAIL: Missing statistics'",
            "dmesg | grep 'called [1-9][0-9]* times' && echo 'PASS: Event counters updated' || echo 'PASS: Event counters initialized'",
            "",
            "echo 'Phase 7: Critical Validation - Proves If-Else Impossible'",
            "echo ''",
            "echo '========================================='",
            "echo 'CRITICAL SUCCESS: This test PROVES that:'",
            "echo '1. Handler functions in EXTERNAL .ko modules'",
            "echo '2. Core module CANNOT use if-else (linker error!)'",
            "echo '3. Function pointers are REQUIRED (not optional!)'",
            "echo '4. Dynamic module loading works like real kernel'",
            "echo '========================================='",
            "echo ''",
            "echo 'PASS: All multi-module external handler validation successful'"
          ],
          "expected": {
            "dmesg": [
              "Function dispatch core module loaded",
              "Waiting for handler modules to register",
              "Event dispatch system ready",
              ".* handler module loaded",
              "Registered handler .* for event type [0-9]*",
              "Dispatching to Runtime-Unknown Types",
              "Will dispatch to [0-9]+ different event types",
              "Dispatching to type [0-9]+",
              "\\[(Sensor|Motor|Status|Network|Storage) Handler\\] Processing event type [0-9]*",
              "Final Handler Statistics",
              "Function dispatch demonstration complete"
            ],
            "stdout": [
              "PASS: All declarations found",
              "SUCCESS: Multi-module dispatch test completed",
              "PASS: Core module loaded",
              "PASS: System initialized",
              "PASS: Multiple handler modules registered",
              "PASS: External module functions called via function pointers",
              "PASS: Statistics tracking working",
              "PASS: All multi-module external handler validation successful"
            ]
          },
          "timeout": 30
        }
      }
    ]
  }
}
