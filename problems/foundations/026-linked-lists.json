{
  "id": 26,
  "title": "Linked Lists - Kernel List Patterns",
  "phase": "foundations",
  "difficulty": 4,
  "xp": 45,
  "description": "Master linked lists through two approaches: implement basic operations manually to understand fundamentals, then use real Linux kernel list macros. Learn the essential data structure pattern used throughout kernel development.",
  "mainFile": "linked_lists.c",
  "files": [
    {
      "name": "linked_lists.h",
      "content": "#ifndef LINKED_LISTS_H\n#define LINKED_LISTS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n\n#define MAX_DEVICE_NAME 16\n\n/* Basic list node structure (like kernel's list_head) */\nstruct list_head {\n    struct list_head *next, *prev;\n};\n\n/* Device entry structure with embedded list node */\nstruct device_entry {\n    int device_id;\n    char name[MAX_DEVICE_NAME];\n    int status;\n    struct list_head list;  /* Embedded list node - kernel pattern! */\n};\n\n/* Global list heads for testing */\nextern struct list_head manual_device_list;\nextern struct list_head kernel_device_list;\n\n/* TODO: Declare your manual list functions */\n/* void manual_init_list(struct list_head *head); */\n/* void manual_add_device(struct device_entry *dev, struct list_head *head); */\n/* void manual_remove_device(struct device_entry *dev); */\n/* int manual_is_empty(struct list_head *head); */\n/* void manual_traverse_list(struct list_head *head); */\n\n/* TODO: Declare your kernel macro functions */\n/* void kernel_add_device(struct device_entry *dev); */\n/* void kernel_traverse_list(void); */\n/* struct device_entry* find_device_by_id(int device_id); */\n/* int count_total_devices(void); */\n/* void cleanup_all_devices(void); */\n\n#endif /* LINKED_LISTS_H */",
      "readOnly": false,
      "language": "h"
    },
    {
      "name": "linked_lists.c",
      "content": "#include \"linked_lists.h\"\n\n/* Global list heads */\nstruct list_head manual_device_list;\nstruct list_head kernel_device_list;\n\nint test_device_id = 1001;\nint test_device_count = 3;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n */\nmodule_param(test_device_id, int, 0644);\nMODULE_PARM_DESC(test_device_id, \"Device ID for testing list operations\");\nmodule_param(test_device_count, int, 0644);\nMODULE_PARM_DESC(test_device_count, \"Number of devices for testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: How linked lists work in kernel development */\n/* This teaches the FOUNDATION for kernel data structures:\n *\n * Traditional Linked List (textbook approach):\n * struct node {\n *     int data;\n *     struct node *next;\n * };\n * Problem: Each data type needs its own list implementation\n *\n * Kernel Linked List (embedded approach):\n * struct list_head {\n *     struct list_head *next, *prev;\n * };\n * struct my_data {\n *     int value;\n *     struct list_head list;  // Embedded list node\n * };\n * Benefits: Generic operations, memory efficient, type flexible\n *\n * Why Kernel Pattern is Superior:\n * 1. Any struct can contain list nodes\n * 2. Same struct can be in multiple lists\n * 3. Generic list operations work on any type\n * 4. No separate memory allocation for list nodes\n * 5. Used everywhere: processes, devices, memory pages, files\n */\n\n/* MEMORY LAYOUT VISUALIZATION: */\n/* Traditional approach:\n * [data1|next] -> [data2|next] -> [data3|next] -> NULL\n * Each node allocated separately\n *\n * Kernel approach:\n * device_entry1: [device_id|name|status|list_node]\n * device_entry2: [device_id|name|status|list_node]\n * device_entry3: [device_id|name|status|list_node]\n * List nodes embedded in actual data structures\n */\n\n/* DOUBLE POINTER REVIEW FROM PREVIOUS PROBLEMS: */\n/* head->next points to first node\n * head->prev points to last node\n * node->next points to next node\n * node->prev points to previous node\n * Circular: last->next points back to head\n */\n\n/* TODO: Implement manual list initialization */\nvoid manual_init_list(struct list_head *head) {\n    /* TODO: Initialize head to point to itself (empty circular list) */\n    /* TODO: Set head->next = head */\n    /* TODO: Set head->prev = head */\n}\n\n/* TODO: Implement manual add to list */\nvoid manual_add_device(struct device_entry *dev, struct list_head *head) {\n    /* TODO: Initialize the device's list node */\n    /* TODO: Add device at the beginning of list (after head) */\n    /* TODO: Step 1: Set dev->list.next = head->next */\n    /* TODO: Step 2: Set dev->list.prev = head */\n    /* TODO: Step 3: Set head->next->prev = &dev->list */\n    /* TODO: Step 4: Set head->next = &dev->list */\n    /* TODO: Print \"Manually added device: %s (ID: %d)\" */\n}\n\n/* TODO: Implement manual remove from list */\nvoid manual_remove_device(struct device_entry *dev) {\n    /* TODO: Remove device from list by fixing pointers */\n    /* TODO: Step 1: Set dev->list.prev->next = dev->list.next */\n    /* TODO: Step 2: Set dev->list.next->prev = dev->list.prev */\n    /* TODO: Step 3: Set dev->list.next = &dev->list (reinitialize) */\n    /* TODO: Step 4: Set dev->list.prev = &dev->list (reinitialize) */\n    /* TODO: Print \"Manually removed device: %s (ID: %d)\" */\n}\n\n/* TODO: Implement manual empty check */\nint manual_is_empty(struct list_head *head) {\n    /* TODO: Return 1 if empty (head->next == head), 0 if not empty */\n    return 0;\n}\n\n/* TODO: Implement manual list traversal */\nvoid manual_traverse_list(struct list_head *head) {\n    /* TODO: Traverse list using manual pointer manipulation */\n    /* TODO: Create struct list_head *pos */\n    /* TODO: Loop: for (pos = head->next; pos != head; pos = pos->next) */\n    /* TODO: Inside loop: get device using container_of or list_entry */\n    /* TODO: Print \"Manual traversal - Device: %s (ID: %d, Status: %d)\" */\n    /* TODO: If empty list, print \"Manual list is empty\" */\n}\n\n/* TODO: Implement kernel macro add */\nvoid kernel_add_device(struct device_entry *dev) {\n    /* TODO: Use kernel macro to add device to kernel_device_list */\n    /* TODO: Use list_add(&dev->list, &kernel_device_list) */\n    /* TODO: Print \"Kernel added device: %s (ID: %d)\" */\n}\n\n/* TODO: Implement kernel macro traversal */\nvoid kernel_traverse_list(void) {\n    /* TODO: Use list_for_each_entry macro to traverse */\n    /* TODO: list_for_each_entry(entry, &kernel_device_list, list) */\n    /* TODO: Print \"Kernel traversal - Device: %s (ID: %d, Status: %d)\" */\n    /* TODO: If empty, print \"Kernel list is empty\" */\n}\n\n/* TODO: Implement device search */\nstruct device_entry* find_device_by_id(int device_id) {\n    /* TODO: Use list_for_each_entry to search for device_id */\n    /* TODO: Return pointer to device if found, NULL if not found */\n    return NULL;\n}\n\n/* TODO: Implement device counting */\nint count_total_devices(void) {\n    /* TODO: Use list_for_each_entry to count devices in kernel_device_list */\n    /* TODO: Return total count */\n    return 0;\n}\n\n/* TODO: Implement cleanup function */\nvoid cleanup_all_devices(void) {\n    /* TODO: Use list_for_each_entry_safe to safely remove and free all devices */\n    /* TODO: Use list_del to remove from list */\n    /* TODO: Use kfree to free memory */\n    /* TODO: Print \"Cleaned up device: %s\" for each device */\n}\n\n/* Helper function to create test devices */\nstatic struct device_entry* create_test_device(int id, const char* name, int status) {\n    struct device_entry *dev = kmalloc(sizeof(*dev), GFP_KERNEL);\n    if (!dev) {\n        return NULL;\n    }\n    \n    dev->device_id = id;\n    dev->status = status;\n    snprintf(dev->name, MAX_DEVICE_NAME, \"%s\", name);\n    INIT_LIST_HEAD(&dev->list);\n    \n    return dev;\n}\n\nstatic int __init linked_lists_init(void)\n{\n    struct device_entry *dev1, *dev2, *dev3;\n    struct device_entry *found_dev;\n    int total_devices;\n    \n    printk(KERN_INFO \"Linked lists module loaded\\n\");\n    \n    /* Initialize list heads */\n    manual_init_list(&manual_device_list);\n    INIT_LIST_HEAD(&kernel_device_list);\n    \n    printk(KERN_INFO \"Testing manual list operations\\n\");\n    \n    /* Test manual list operations */\n    dev1 = create_test_device(test_device_id, \"TempSensor\", 1);\n    dev2 = create_test_device(test_device_id + 1, \"MotorCtrl\", 1);\n    dev3 = create_test_device(test_device_id + 2, \"LEDStrip\", 0);\n    \n    if (!dev1 || !dev2 || !dev3) {\n        printk(KERN_ERR \"Failed to create test devices\\n\");\n        return -ENOMEM;\n    }\n    \n    /* Test manual operations */\n    manual_add_device(dev1, &manual_device_list);\n    manual_add_device(dev2, &manual_device_list);\n    manual_add_device(dev3, &manual_device_list);\n    \n    printk(KERN_INFO \"Manual list empty: %d\\n\", manual_is_empty(&manual_device_list));\n    manual_traverse_list(&manual_device_list);\n    \n    /* Remove one device manually */\n    manual_remove_device(dev2);\n    manual_traverse_list(&manual_device_list);\n    \n    printk(KERN_INFO \"Testing kernel macro operations\\n\");\n    \n    /* Test kernel macro operations */\n    kernel_add_device(dev1);\n    kernel_add_device(dev2);\n    kernel_add_device(dev3);\n    \n    kernel_traverse_list();\n    \n    /* Test search functionality */\n    found_dev = find_device_by_id(test_device_id);\n    if (found_dev) {\n        printk(KERN_INFO \"Found device: %s (ID: %d)\\n\", found_dev->name, found_dev->device_id);\n    } else {\n        printk(KERN_INFO \"Device ID %d not found\\n\", test_device_id);\n    }\n    \n    /* Test counting */\n    total_devices = count_total_devices();\n    printk(KERN_INFO \"Total devices in kernel list: %d\\n\", total_devices);\n    \n    printk(KERN_INFO \"Linked list demonstration completed\\n\");\n    \n    return 0;\n}\n\nstatic void __exit linked_lists_exit(void)\n{\n    printk(KERN_INFO \"Linked lists module unloading\\n\");\n    \n    /* Clean up all devices */\n    cleanup_all_devices();\n    \n    printk(KERN_INFO \"Linked lists module unloaded\\n\");\n}\n\nmodule_init(linked_lists_init);\nmodule_exit(linked_lists_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning linked list patterns for kernel development\");\nMODULE_VERSION(\"1.0\");",
      "readOnly": false,
      "language": "c"
    },
    {
      "name": "VISUAL_GUIDE.md",
      "content": "# Circular Doubly-Linked List - Visual Guide\n\n## Understanding the Pattern\n\nThis guide uses **generic examples** (not the specific problem solution) to help you understand circular doubly-linked list operations step-by-step.\n\n## Core Concept: Embedded List Pattern\n\nInstead of the traditional approach where list nodes contain data:\n```\nTraditional: [prev|data|next] -> [prev|data|next] -> NULL\n```\n\nKernel pattern embeds the list node INSIDE your data structure:\n```\nKernel: Your data structure contains a list_head member\nstruct person {\n    int age;\n    char name[32];\n    struct list_head list;  // <-- Just the links!\n};\n```\n\n---\n\n## Operation 1: Initialize Empty List\n\n**Goal:** Create an empty circular list where head points to itself.\n\n**Visual:**\n```\nBEFORE (uninitialized):\n         head\n    ┌──────────┐\n    │ next  = ???\n    │ prev  = ???\n    └──────────┘\n\nAFTER initialization:\n         ┌─────────┐\n         ↓         │\n        head       │\n    ┌──────────┐   │\n    │ next  ───┼───┘\n    │ prev  ───┼───┐\n    └──────────┘   │\n         ↑         │\n         └─────────┘\n\n(Circular: points to itself = empty list)\n```\n\n**Pattern to learn:**\n- Set `head->next = head`\n- Set `head->prev = head`\n- Result: head is both the \"next\" and \"prev\" of itself\n\n---\n\n## Operation 2: Add First Item to List\n\n**Goal:** Insert the first item right after head.\n\nLet's add a person named \"Alice\" (age 25):\n\n**Initial state (empty list):**\n```\n         ┌─────┐\n         ↓     │\n        head   │\n        ═══════┘  (points to itself)\n\nalice (not yet linked)\n    ┌──────────────────┐\n    │ age: 25          │\n    │ name: \"Alice\"    │\n    │ ┌──────────┐     │\n    │ │ next  = ???│   │\n    │ │ prev  = ???│   │\n    │ └──────────┘     │\n    └──────────────────┘\n```\n\n**Step 1: alice->list.next = head->next;**\n```\nalice now knows what comes \"next\" (currently head)\n\n        head\n    ┌──────────┐\n    │ next  ───┼────┐\n    └──────────┘    │\n                    │\n    alice           │\n    ┌──────────────────┐\n    │ age: 25          │\n    │ ┌──────────┐     │\n    │ │ next  ───┼─────┘\n    │ │ prev  = ???    │\n    │ └──────────┘     │\n    └──────────────────┘\n    Points to head\n```\n\n**Step 2: alice->list.prev = head;**\n```\nalice now knows what comes \"before\" (head)\n\n        head\n    ┌──────────┐\n         ↑\n         │\n    alice│\n    ┌────┼─────────────┐\n    │ age: 25          │\n    │ ┌──┼───────┐     │\n    │ │ next  → head   │\n    │ │ prev  → head   │\n    │ └──────────┘     │\n    └──────────────────┘\n    Points to head\n```\n\n**Step 3: head->next->prev = &alice->list;**\n```\nTell the old first node (currently head) that alice comes before it\n\n        head\n    ┌──────────┐\n    │ next  ───┼──→ (still points to head, will update next)\n    │ prev  ───┼──→ alice  ← CHANGED!\n    └──────────┘\n```\n\n**Step 4: head->next = &alice->list;**\n```\nUpdate head to point forward to alice\n\nFINAL STATE:\n        head ←─────────────────────┐\n    ┌──────────┐                   │\n    │ next  ───┼──┐                │\n    │ prev  ───┼──┼────────┐       │\n    └──────────┘  │        │       │\n                  │        │       │\n              alice        │       │\n         ┌──────────────────────┐  │\n         │ age: 25              │  │\n         │ name: \"Alice\"        │  │\n         │ ┌──────────┐         │  │\n         └─│ next  ───┼─────────┼──┘\n           │ prev  ───┼─────────┘\n           └──────────┘\n\nList: head ↔ alice ↔ head (circular)\n```\n\n**Why this order matters:**\n- If you did Step 4 BEFORE Step 3, you'd lose the reference to the old \"next\" node!\n- Always update the neighbors BEFORE updating the pointer that helps you find them\n\n---\n\n## Operation 3: Add Second Item\n\n**Goal:** Add \"Bob\" (age 30) to the list.\n\n**Current state:**\n```\nhead ↔ alice ↔ head\n```\n\n**After adding Bob using same 4-step pattern:**\n```\nhead ↔ bob ↔ alice ↔ head\n\n        head ←─────────────────────────────────┐\n    ┌──────────┐                               │\n    │ next  ───┼──┐                            │\n    │ prev  ───┼──┼────────┐                   │\n    └──────────┘  │        │                   │\n                  │        │                   │\n               bob│        │                   │\n         ┌────────────────┐│                   │\n         │ age: 30        ││                   │\n         │ name: \"Bob\"    ││                   │\n         │ ┌──────────┐   ││                   │\n         └─│ next  ───┼───┼┘                   │\n           │ prev  ───┼───┘                    │\n           └──────────┘                        │\n                  │                            │\n              alice                            │\n         ┌──────────────────────┐              │\n         │ age: 25              │              │\n         │ name: \"Alice\"        │              │\n         │ ┌──────────┐         │              │\n         └─│ next  ───┼─────────┼──────────────┘\n           │ prev  ───┼─────────┘\n           └──────────┘\n```\n\n**Pattern:** Adding at head always inserts at the FRONT of the list.\n\n---\n\n## Operation 4: Remove Item from List\n\n**Goal:** Remove Bob from the middle of the list.\n\n**Current state:**\n```\nhead ↔ bob ↔ alice ↔ head\n```\n\n**Step 1: bob->list.prev->next = bob->list.next;**\n```\nTell Bob's previous node (head) to skip Bob and point to Bob's next (alice)\n\n         head                     bob                       alice\n    ┌──────────┐         ┌──────────────────┐        ┌────────────┐\n    │ next  ───┼────────────────────────────────────→│            │\n    │ prev     │         │                  │        │            │\n    └──────────┘         └──────────────────┘        └────────────┘\n```\n\n**Step 2: bob->list.next->prev = bob->list.prev;**\n```\nTell Bob's next node (alice) to point back to Bob's previous (head)\n\n         head                     bob                       alice\n    ┌──────────┐         ┌──────────────────┐        ┌────────────┐\n    │ next  ───┼────────────────────────────────────→│            │\n    │          │         │                  │        │            │\n    │ prev  ←──┼─────────────────────────────────────┼─ prev      │\n    └──────────┘         └──────────────────┘        └────────────┘\n\nNow Bob is unlinked!\nList becomes: head ↔ alice ↔ head\n```\n\n**Step 3 & 4: Reinitialize Bob's pointers (safety)**\n```\nbob->list.next = &bob->list;\nbob->list.prev = &bob->list;\n\nBob is now isolated (points to itself):\n          ┌──────────────┐\n          ↓              │\n         bob             │\n    ┌──────────────────┐ │\n    │ age: 30          │ │\n    │ name: \"Bob\"      │ │\n    │ ┌──────────┐     │ │\n    │ │ next  ───┼─────┼─┘\n    │ │ prev  ───┼─────┼─┐\n    │ └──────────┘     │ │\n    └──────────────────┘ │\n          ↑              │\n          └──────────────┘\n```\n\n**Why reinitialize?** Makes the node safe to delete or re-add later.\n\n---\n\n## Operation 5: Check if List is Empty\n\n**Pattern:** A list is empty when `head->next == head`\n\n**Empty list:**\n```\n          ┌──────────┐\n          ↓          │\n         head        │\n    ┌──────────┐     │\n    │ next  ───┼─────┘\n    │ prev  ───┼─────┐\n    └──────────┘     │\n          ↑          │\n          └──────────┘\n\nPoints to itself\nhead->next == head  → TRUE → List is EMPTY\n```\n\n**Non-empty list:**\n```\nhead ↔ alice ↔ head\n\n         head              alice\n    ┌──────────┐     ┌──────────────┐\n    │ next  ───┼──→  │              │\n    │ prev     │     │              │\n    └──────────┘     └──────────────┘\n\nhead->next == head  → FALSE (points to alice) → List is NOT EMPTY\n```\n\n---\n\n## Operation 6: Traverse the List\n\n**Goal:** Visit every item in the list and access their data.\n\n**The Challenge:** When you traverse, you get pointers to `list_head`, but you need the full structure (person)!\n\n**Pattern:**\n```c\nstruct list_head *pos;\nstruct person *p;\n\nfor (pos = head->next; pos != head; pos = pos->next) {\n    // pos points to the 'list' member inside a person struct\n    // Use container_of to get the person struct!\n    p = container_of(pos, struct person, list);\n    //  ^             ^    ^             ^\n    //  |             |    |             |\n    //  result     pointer type       member name\n    \n    // Now you can access p->age, p->name, etc.\n}\n```\n\n**Visual explanation:**\n```\nList: head ↔ alice ↔ bob ↔ head\n\nITERATION 1:\n    pos = head->next  →  pos points to alice's list member\n\n         head              alice              bob\n    ┌──────────┐     ┌──────────────────┐\n    │ next  ───┼──→  │ age: 25          │\n    └──────────┘     │ name: \"Alice\"    │\n                     │ ┌──────────┐     │\n                     │ │  list    │ ←─── pos points HERE\n                     │ └──────────┘     │\n                     └──────────────────┘\n                              ↑\n                              │\n                container_of calculates THIS\n                (start of struct from list member)\n\n    p = container_of(pos, struct person, list);\n    // Now p points to the start of alice struct\n    // Can access: p->age (25), p->name (\"Alice\")\n\nITERATION 2:\n    pos = pos->next  →  pos points to bob's list member\n\n    p = container_of(pos, struct person, list);\n    // Now p points to start of bob struct\n    // Can access: p->age (30), p->name (\"Bob\")\n\nLOOP EXIT:\n    pos = pos->next  →  pos points back to head\n    Check: pos != head?  → FALSE\n    Loop exits!\n```\n\n**How container_of works (the math):**\n```\nMemory layout of struct person:\n    ┌──────────────┐ ← Start of struct (e.g., address 0x1000)\n    │ age          │\n    ├──────────────┤\n    │ name[32]     │\n    ├──────────────┤ ← offset of 'list' member (e.g., 0x1024)\n    │ list.next    │ ← pos points HERE\n    │ list.prev    │\n    └──────────────┘\n\ncontainer_of formula:\nstruct_address = pos - offset_of(list in person)\n0x1000 = 0x1024 - 0x24\n\nGives you the start of the person struct!\n```\n\n---\n\n## Operation 7: Count Items\n\n**Pattern:** Traverse the list and increment a counter.\n\n```c\nint count = 0;\nstruct list_head *pos;\n\nfor (pos = head->next; pos != head; pos = pos->next) {\n    count++;\n}\n\nreturn count;\n```\n\n**Visual:**\n```\nList: head ↔ alice ↔ bob ↔ charlie ↔ head\n\ncount = 0\n\nVisit alice   → count = 1\nVisit bob     → count = 2\nVisit charlie → count = 3\n\nReturn 3\n```\n\n---\n\n## Operation 8: Search for Specific Item\n\n**Pattern:** Traverse and compare each item's data.\n\n**Example: Find person with age 30**\n```c\nstruct list_head *pos;\nstruct person *p;\n\nfor (pos = head->next; pos != head; pos = pos->next) {\n    p = container_of(pos, struct person, list);\n    if (p->age == 30) {\n        return p;  // Found Bob!\n    }\n}\n\nreturn NULL;  // Not found\n```\n\n**Visual:**\n```\nSearching for age == 30:\n\nList: head ↔ alice(25) ↔ bob(30) ↔ charlie(35) ↔ head\n\nITERATION 1: Visit alice\n    p->age == 30?  → NO (25 != 30)\n    Continue...\n\nITERATION 2: Visit bob\n    p->age == 30?  → YES! ✓\n    return bob;\n\nCaller receives pointer to bob struct:\n    ┌──────────────────┐\n    │ age: 30          │ ← Can access all fields\n    │ name: \"Bob\"      │\n    │ list: {...}      │\n    └──────────────────┘\n```\n\n---\n\n## Operation 9: Safe Cleanup (Delete All)\n\n**The Problem:** You can't use regular traversal when deleting nodes!\n\n**Why?** After deleting a node, `pos->next` is invalid!\n\n**Solution:** Use \"safe\" traversal with TWO pointers:\n```c\nstruct person *p, *tmp;\n\nlist_for_each_entry_safe(p, tmp, &head, list) {\n    //                   ^   ^     ^\n    //                   |   |     |\n    //              current next   head\n    \n    list_del(&p->list);  // Remove from list\n    kfree(p);            // Free memory\n}\n```\n\n**Visual explanation:**\n```\nINITIAL:\nhead ↔ alice ↔ bob ↔ charlie ↔ head\n\nITERATION 1:\n    p = alice\n    tmp = bob  (saved for next iteration!)\n    \n    list_del(&alice->list)  → Remove alice\n    kfree(alice)            → Free alice's memory\n    \n    Result: head ↔ bob ↔ charlie ↔ head\n    alice is DELETED (memory freed)\n\nITERATION 2:\n    p = tmp (which is bob)\n    tmp = charlie  (saved!)\n    \n    list_del(&bob->list)\n    kfree(bob)\n    \n    Result: head ↔ charlie ↔ head\n    bob is DELETED\n\nITERATION 3:\n    p = tmp (which is charlie)\n    tmp = head  (no more items)\n    \n    list_del(&charlie->list)\n    kfree(charlie)\n    \n    Result: head ↔ head (empty!)\n    charlie is DELETED\n\nFINAL STATE:\n          ┌──────────┐\n          ↓          │\n         head        │\n    ┌──────────┐     │\n    │ next  ───┼─────┘\n    │ prev  ───┼─────┐\n    └──────────┘     │\n          ↑          │\n          └──────────┘\n    \nAll items freed!\nAll memory cleaned up!\n```\n\n**Why two pointers?**\n- `tmp` saves the next node BEFORE we delete the current node\n- Without this, we'd lose track of where to go next!\n\n---\n\n## Summary: The Four Pointer Operations\n\nEvery linked list operation boils down to updating pointers correctly:\n\n**1. Initialize:**\n```\nhead->next = head;\nhead->prev = head;\n```\n\n**2. Add (4 steps - ORDER MATTERS!):**\n```\nnew->list.next = head->next;     // Step 1: new knows next\nnew->list.prev = head;            // Step 2: new knows prev\nhead->next->prev = &new->list;    // Step 3: old first knows new\nhead->next = &new->list;          // Step 4: head knows new\n```\n\n**3. Remove (4 steps):**\n```\nnode->list.prev->next = node->list.next;  // Step 1: skip forward\nnode->list.next->prev = node->list.prev;  // Step 2: skip backward\nnode->list.next = &node->list;            // Step 3: reinit (safety)\nnode->list.prev = &node->list;            // Step 4: reinit (safety)\n```\n\n**4. Traverse:**\n```\nfor (pos = head->next; pos != head; pos = pos->next) {\n    item = container_of(pos, struct type, list);\n    // Use item->data\n}\n```\n\n---\n\n## Key Insights\n\n1. **Circular means no NULL** - Last node points back to head\n2. **Doubly-linked means bidirectional** - Can traverse forward AND backward\n3. **Embedded pattern is generic** - Same list_head works for ANY struct\n4. **Order matters when updating** - Update neighbors before losing references\n5. **container_of is magic** - Gets you from list member back to full struct\n6. **Safe deletion needs two pointers** - Save next pointer before deleting current\n\n---\n\nNow apply these patterns to your specific problem! The operations are the same, just adapt the struct name and field names.\n",
      "readOnly": true,
      "language": "txt"
    },
    {
      "name": "Makefile",
      "content": "# Linked lists module Makefile\nobj-m += linked_lists.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
      "readOnly": true,
      "language": "makefile"
    }
  ],
  "concepts": [
    "linked list fundamentals",
    "embedded list nodes",
    "kernel list patterns",
    "circular doubly-linked lists",
    "manual vs macro operations",
    "list traversal patterns",
    "memory management with lists"
  ],
  "skills": [
    "Implementing basic linked list operations",
    "Using kernel list macros",
    "Understanding embedded list node pattern",
    "Managing list node pointers",
    "Traversing lists safely",
    "Searching and counting list elements",
    "Cleaning up dynamic list structures"
  ],
  "validation": {
    "exactRequirements": {
      "functionNames": [
        "linked_lists_init",
        "linked_lists_exit",
        "manual_init_list",
        "manual_add_device",
        "manual_remove_device",
        "manual_is_empty",
        "manual_traverse_list",
        "kernel_add_device",
        "kernel_traverse_list",
        "find_device_by_id",
        "count_total_devices",
        "cleanup_all_devices"
      ],
      "function_declarations": [
        { "name": "manual_init_list", "returnType": "void", "parameters": ["struct list_head *head"] },
        { "name": "manual_add_device", "returnType": "void", "parameters": ["struct device_entry *dev", "struct list_head *head"] },
        { "name": "manual_remove_device", "returnType": "void", "parameters": ["struct device_entry *dev"] },
        { "name": "manual_is_empty", "returnType": "int", "parameters": ["struct list_head *head"] },
        { "name": "manual_traverse_list", "returnType": "void", "parameters": ["struct list_head *head"] },
        { "name": "kernel_add_device", "returnType": "void", "parameters": ["struct device_entry *dev"] },
        { "name": "kernel_traverse_list", "returnType": "void", "parameters": [] },
        { "name": "find_device_by_id", "returnType": "struct device_entry*", "parameters": ["int device_id"] },
        { "name": "count_total_devices", "returnType": "int", "parameters": [] },
        { "name": "cleanup_all_devices", "returnType": "void", "parameters": [] }
      ],
      "variables_declarations": [
        { "name": "device_entry", "type": "struct", "value": "{int device_id; char name[MAX_DEVICE_NAME]; int status; struct list_head list;}", "storageClass": "none" },
        { "name": "manual_device_list", "type": "struct list_head", "storageClass": "extern" },
        { "name": "kernel_device_list", "type": "struct list_head", "storageClass": "extern" }
      ],
      "variables": [
        { "name": "manual_device_list", "type": "struct list_head", "storageClass": "none" },
        { "name": "kernel_device_list", "type": "struct list_head", "storageClass": "none" }
      ],
      "outputMessages": [
        "Linked lists module loaded",
        "Testing manual list operations",
        "Manually added device: TempSensor (ID: 1001)",
        "Manually added device: MotorCtrl (ID: 1002)",
        "Manually added device: LEDStrip (ID: 1003)",
        "Manual list empty: 0",
        "Manual traversal - Device: LEDStrip (ID: 1003, Status: 0)",
        "Manual traversal - Device: MotorCtrl (ID: 1002, Status: 1)",
        "Manual traversal - Device: TempSensor (ID: 1001, Status: 1)",
        "Manually removed device: MotorCtrl (ID: 1002)",
        "Testing kernel macro operations",
        "Kernel added device: TempSensor (ID: 1001)",
        "Kernel added device: MotorCtrl (ID: 1002)",
        "Kernel added device: LEDStrip (ID: 1003)",
        "Kernel traversal - Device: LEDStrip (ID: 1003, Status: 0)",
        "Kernel traversal - Device: MotorCtrl (ID: 1002, Status: 1)",
        "Kernel traversal - Device: TempSensor (ID: 1001, Status: 1)",
        "Found device: TempSensor (ID: 1001)",
        "Total devices in kernel list: 3",
        "Linked list demonstration completed",
        "Linked lists module unloading",
        "Cleaned up device: LEDStrip",
        "Cleaned up device: MotorCtrl",
        "Cleaned up device: TempSensor",
        "Linked lists module unloaded"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/types.h",
        "linux/slab.h",
        "linux/list.h"
      ],
      "mustContain": [
        "head->next = head",
        "head->prev = head",
        "dev->list.next = head->next",
        "dev->list.prev = head",
        "head->next->prev = &dev->list",
        "head->next = &dev->list",
        "dev->list.prev->next = dev->list.next",
        "dev->list.next->prev = dev->list.prev",
        "head->next == head",
        "pos = head->next; pos != head; pos = pos->next",
        "list_add(&dev->list, &kernel_device_list)",
        "list_for_each_entry(",
        "list_for_each_entry_safe(",
        "list_del(",
        "kfree(",
        "INIT_LIST_HEAD(",
        "module_param(test_device_id, int, 0644)",
        "module_param(test_device_count, int, 0644)"
      ],
      "moduleInfo": {
        "license": "GPL"
      }
    },
    "testCases": [
      {
        "id": "function_declarations",
        "name": "Function Declarations in Header",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "void manual_init_list(struct list_head *head)",
          "void manual_add_device(struct device_entry *dev, struct list_head *head)",
          "void manual_remove_device(struct device_entry *dev)",
          "int manual_is_empty(struct list_head *head)",
          "void manual_traverse_list(struct list_head *head)",
          "void kernel_add_device(struct device_entry *dev)",
          "void kernel_traverse_list(void)",
          "struct device_entry* find_device_by_id(int device_id)",
          "int count_total_devices(void)",
          "void cleanup_all_devices(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "function_signatures_source",
        "name": "Function Signatures in Source File",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "void manual_init_list(struct list_head *head)",
          "void manual_add_device(struct device_entry *dev, struct list_head *head)",
          "void manual_remove_device(struct device_entry *dev)",
          "int manual_is_empty(struct list_head *head)",
          "void manual_traverse_list(struct list_head *head)",
          "void kernel_add_device(struct device_entry *dev)",
          "void kernel_traverse_list(void)",
          "struct device_entry* find_device_by_id(int device_id)",
          "int count_total_devices(void)",
          "void cleanup_all_devices(void)",
          "static int __init linked_lists_init(void)",
          "static void __exit linked_lists_exit(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "exact_output",
        "name": "Exact Output Messages",
        "type": "output_match",
        "critical": true,
        "expected": [
          { "pattern": "Linked lists module loaded", "exact": true, "linkedFunction": "static int __init linked_lists_init(void)" },
          { "pattern": "Testing manual list operations", "exact": true, "linkedFunction": "static int __init linked_lists_init(void)" },
          { "pattern": "Manually added device: TempSensor (ID: 1001)", "exact": true, "linkedFunction": "void manual_add_device(struct device_entry *dev, struct list_head *head)" },
          { "pattern": "Manually added device: MotorCtrl (ID: 1002)", "exact": true, "linkedFunction": "void manual_add_device(struct device_entry *dev, struct list_head *head)" },
          { "pattern": "Manually added device: LEDStrip (ID: 1003)", "exact": true, "linkedFunction": "void manual_add_device(struct device_entry *dev, struct list_head *head)" },
          { "pattern": "Manual list empty: 0", "exact": true, "linkedFunction": "static int __init linked_lists_init(void)" },
          { "pattern": "Manual traversal - Device: LEDStrip (ID: 1003, Status: 0)", "exact": true, "linkedFunction": "void manual_traverse_list(struct list_head *head)" },
          { "pattern": "Manual traversal - Device: MotorCtrl (ID: 1002, Status: 1)", "exact": true, "linkedFunction": "void manual_traverse_list(struct list_head *head)" },
          { "pattern": "Manual traversal - Device: TempSensor (ID: 1001, Status: 1)", "exact": true, "linkedFunction": "void manual_traverse_list(struct list_head *head)" },
          { "pattern": "Manually removed device: MotorCtrl (ID: 1002)", "exact": true, "linkedFunction": "void manual_remove_device(struct device_entry *dev)" },
          { "pattern": "Testing kernel macro operations", "exact": true, "linkedFunction": "static int __init linked_lists_init(void)" },
          { "pattern": "Kernel added device: TempSensor (ID: 1001)", "exact": true, "linkedFunction": "void kernel_add_device(struct device_entry *dev)" },
          { "pattern": "Kernel added device: MotorCtrl (ID: 1002)", "exact": true, "linkedFunction": "void kernel_add_device(struct device_entry *dev)" },
          { "pattern": "Kernel added device: LEDStrip (ID: 1003)", "exact": true, "linkedFunction": "void kernel_add_device(struct device_entry *dev)" },
          { "pattern": "Kernel traversal - Device: LEDStrip (ID: 1003, Status: 0)", "exact": true, "linkedFunction": "void kernel_traverse_list(void)" },
          { "pattern": "Kernel traversal - Device: MotorCtrl (ID: 1002, Status: 1)", "exact": true, "linkedFunction": "void kernel_traverse_list(void)" },
          { "pattern": "Kernel traversal - Device: TempSensor (ID: 1001, Status: 1)", "exact": true, "linkedFunction": "void kernel_traverse_list(void)" },
          { "pattern": "Found device: TempSensor (ID: 1001)", "exact": true, "linkedFunction": "static int __init linked_lists_init(void)" },
          { "pattern": "Total devices in kernel list: 3", "exact": true, "linkedFunction": "static int __init linked_lists_init(void)" },
          { "pattern": "Linked list demonstration completed", "exact": true, "linkedFunction": "static int __init linked_lists_init(void)" },
          { "pattern": "Linked lists module unloading", "exact": true, "linkedFunction": "static void __exit linked_lists_exit(void)" },
          { "pattern": "Cleaned up device: LEDStrip", "exact": true, "linkedFunction": "void cleanup_all_devices(void)" },
          { "pattern": "Cleaned up device: MotorCtrl", "exact": true, "linkedFunction": "void cleanup_all_devices(void)" },
          { "pattern": "Cleaned up device: TempSensor", "exact": true, "linkedFunction": "void cleanup_all_devices(void)" },
          { "pattern": "Linked lists module unloaded", "exact": true, "linkedFunction": "static void __exit linked_lists_exit(void)" }
        ]
      },
      {
        "id": "advanced_linked_list_validation",
        "name": "Advanced Linked List Implementation with Anti-Hardcoding Protection",
        "type": "kernel_project_test",
        "critical": true,
        "testScenario": {
          "userspaceApps": [
            {
              "name": "linked_list_dynamic_tester",
              "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Anti-Hardcoding Linked List Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate unpredictable test values\\n    int random_device_id = (rand() % 9000) + 1000;  // 1000-9999\\n    int random_device_count = (rand() % 3) + 2;     // 2-4 devices\\n    \\n    printf(\\\"Test 1: Random linked list operations (device_id=%d, count=%d)\\\\n\\\", random_device_id, random_device_count);\\n    \\n    // Test with random values\\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod linked_lists 2>/dev/null\\\");\\n    \\n    char cmd[256];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/linked_lists.ko test_device_id=%d test_device_count=%d\\\", random_device_id, random_device_count);\\n    printf(\\\"DEBUG: Command: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Anti-hardcoding linked list test completed\\\\n\\\");\\n    return 0;\\n}"
            }
          ],
          "setupCommands": [
            "echo 'Starting advanced linked list implementation validation'"
          ],
          "testCommands": [
            "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
            "echo 'Creating minimal kernel header stubs for TCC...'",
            "mkdir -p /tmp/linux",
            "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
            "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
            "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
            "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
            "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
            "echo '#define module_init(x)' >> /tmp/linux/module.h",
            "echo '#define module_exit(x)' >> /tmp/linux/module.h",
            "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
            "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
            "echo '#define __init' > /tmp/linux/init.h",
            "echo '#define __exit' >> /tmp/linux/init.h",
            "echo 'typedef unsigned char uint8_t;' > /tmp/linux/types.h",
            "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
            "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
            "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
            "echo '#define MAX_DEVICE_NAME 16' >> /tmp/linux/types.h",
            "echo 'void* kmalloc(size_t size, int flags);' > /tmp/linux/slab.h",
            "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
            "echo '#define GFP_KERNEL 0' >> /tmp/linux/slab.h",
            "echo 'struct list_head { struct list_head *next, *prev; };' > /tmp/linux/list.h",
            "echo '#define INIT_LIST_HEAD(ptr) do { (ptr)->next = (ptr); (ptr)->prev = (ptr); } while (0)' >> /tmp/linux/list.h",
            "echo '#define list_add(new, head) do { (new)->next = (head)->next; (new)->prev = (head); (head)->next->prev = (new); (head)->next = (new); } while (0)' >> /tmp/linux/list.h",
            "echo '#define list_for_each_entry(pos, head, member) for (pos = container_of((head)->next, typeof(*pos), member); &pos->member != (head); pos = container_of(pos->member.next, typeof(*pos), member))' >> /tmp/linux/list.h",
            "echo '#define list_for_each_entry_safe(pos, n, head, member) for (pos = container_of((head)->next, typeof(*pos), member), n = container_of(pos->member.next, typeof(*pos), member); &pos->member != (head); pos = n, n = container_of(n->member.next, typeof(*n), member))' >> /tmp/linux/list.h",
            "echo '#define list_del(entry) do { (entry)->next->prev = (entry)->prev; (entry)->prev->next = (entry)->next; } while (0)' >> /tmp/linux/list.h",
            "echo '#define container_of(ptr, type, member) ((type *)((char *)(ptr) - offsetof(type, member)))' >> /tmp/linux/list.h",
            "echo '#define offsetof(type, member) ((size_t) &((type *)0)->member)' >> /tmp/linux/list.h",
            "echo 'Creating test file that includes linked lists header...'",
            "echo '#include \"/lib/modules/linked_lists.h\"' > /tmp/test.c",
            "echo 'int main() { struct list_head head; struct device_entry *dev; manual_init_list(&head); manual_add_device(dev, &head); manual_remove_device(dev); manual_is_empty(&head); manual_traverse_list(&head); kernel_add_device(dev); kernel_traverse_list(); find_device_by_id(1001); count_total_devices(); cleanup_all_devices(); return 0; }' >> /tmp/test.c",
            "echo 'Running TCC validation...'",
            "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
            "TCC_EXIT_CODE=$?",
            "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
            "echo 'Phase 2: Anti-Hardcoding Dynamic Linked List Test'",
            "/bin/linked_list_dynamic_tester > /tmp/test_output.log",
            "cat /tmp/test_output.log",
            "echo 'Phase 3: Random Value Extraction and Validation'",
            "echo 'Adding delay to ensure dmesg messages are written...'",
            "sleep 1",
            "echo 'Extracting random test values from output...'",
            "DEVICE_ID=$(grep -o 'Random linked list operations (device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
            "DEVICE_COUNT=$(grep -o 'count=[0-9]*)' /tmp/test_output.log | cut -d'=' -f2 | cut -d')' -f1)",
            "echo 'Extracted values: DEVICE_ID='$DEVICE_ID', DEVICE_COUNT='$DEVICE_COUNT",
            "if [ -z \"$DEVICE_ID\" ] || [ -z \"$DEVICE_COUNT\" ]; then echo 'FAIL: Could not extract random test values'; else echo 'PASS: Random values extracted successfully'; fi",
            "echo 'Phase 4: Anti-Hardcoding Validation with Random Values'",
            "echo 'Validating linked list operations with random device ID '$DEVICE_ID",
            "dmesg | grep \"TempSensor (ID: $DEVICE_ID)\" && echo 'PASS: Linked list operations with random device ID working' || echo 'FAIL: Linked list operations with random device ID broken'",
            "echo 'Phase 5: Linked List Implementation Validation'",
            "dmesg | grep 'Manually added device:' && echo 'PASS: Manual add operations working' || echo 'FAIL: Manual add operations broken'",
            "dmesg | grep 'Manual traversal - Device:' && echo 'PASS: Manual traversal working' || echo 'FAIL: Manual traversal broken'",
            "dmesg | grep 'Manually removed device:' && echo 'PASS: Manual remove operations working' || echo 'FAIL: Manual remove operations broken'",
            "dmesg | grep 'Kernel added device:' && echo 'PASS: Kernel macro operations working' || echo 'FAIL: Kernel macro operations broken'",
            "dmesg | grep 'Kernel traversal - Device:' && echo 'PASS: Kernel traversal working' || echo 'FAIL: Kernel traversal broken'",
            "echo 'Phase 6: Advanced List Operations Validation'",
            "dmesg | grep 'Found device:' && echo 'PASS: Device search working' || echo 'FAIL: Device search broken'",
            "dmesg | grep 'Total devices in kernel list: 3' && echo 'PASS: Device counting working' || echo 'FAIL: Device counting broken'",
            "dmesg | grep 'Cleaned up device:' && echo 'PASS: Device cleanup working' || echo 'FAIL: Device cleanup broken'",
            "echo 'Phase 7: Module Operations Validation'",
            "dmesg | grep 'Linked lists module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
            "dmesg | grep 'Linked lists module unloaded' && echo 'PASS: Module cleanup working' || echo 'FAIL: Module cleanup broken'",
            "echo 'All linked list implementation validations completed'"
          ],
          "expected": {
            "dmesg": [
              "Linked lists module loaded",
              "Testing manual list operations",
              "Manually added device: .*",
              "Manual list empty: 0",
              "Manual traversal - Device: .*",
              "Manually removed device: .*",
              "Testing kernel macro operations",
              "Kernel added device: .*",
              "Kernel traversal - Device: .*",
              "Found device: .*",
              "Total devices in kernel list: .*",
              "Linked list demonstration completed",
              "Linked lists module unloading",
              "Cleaned up device: .*",
              "Linked lists module unloaded"
            ],
            "stdout": [
              "PASS: All function and variable declarations found in header file",
              "SUCCESS: Anti-hardcoding linked list test completed",
              "PASS: Random values extracted successfully",
              "PASS: Linked list operations with random device ID working",
              "PASS: Manual add operations working",
              "PASS: Manual traversal working",
              "PASS: Manual remove operations working",
              "PASS: Kernel macro operations working",
              "PASS: Kernel traversal working",
              "PASS: Device search working",
              "PASS: Device counting working",
              "PASS: Device cleanup working",
              "PASS: Module initialization working",
              "PASS: Module cleanup working"
            ]
          },
          "timeout": 15
        }
      }
    ]
  }
}
