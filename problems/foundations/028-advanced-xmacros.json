{
  "id": 28,
  "title": "Advanced X-Macros - Multi-Target Code Generation",
  "phase": "foundations",
  "difficulty": 8,
  "xp": 80,
  "description": "Master advanced X-macro patterns for sophisticated code generation. Learn to create single-source tables that generate multiple related structures: enums, switch statements, if-else chains, struct arrays, and function pointer tables. This powerful kernel programming technique is used extensively in driver registration, system call tables, and device management.",
  "mainFile": "driver_registry.c",
  "files": [
    {
      "name": "driver_registry.h",
      "content": "#ifndef DRIVER_REGISTRY_H\n#define DRIVER_REGISTRY_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* LEARNING PROGRESSION: From Simple X-Macros to Multi-Target Generation */\n/* This problem advances X-macro mastery from Problem 25's fundamentals */\n\n/* KERNEL PATTERN: Driver Registration System */\n/* Real Linux kernel uses this pattern for:\n * - PCI device tables (pci_device_id)\n * - USB device tables (usb_device_id)\n * - Platform driver registration\n * - System call tables\n * - Error code definitions\n */\n\n/* Driver capability flags */\n#define DRV_HOTPLUG  (1 << 0)  /* Supports hot-plug/unplug */\n#define DRV_IRQ      (1 << 1)  /* Uses interrupts */\n#define DRV_DMA      (1 << 2)  /* Supports DMA */\n#define DRV_POWER    (1 << 3)  /* Power management capable */\n#define DRV_STATIC   0          /* Static device, no special flags */\n\n/* Forward declarations */\nstruct driver_info;\nstruct driver_ops;\n\n/* TODO: Define driver type enum using X-macro */\n/* Create enum driver_type that will be auto-generated from DRIVER_TABLE */\n/* Pattern: Use MAKE_ENUM helper macro to extract first parameter */\n/* Enum values: DRV_SERIAL_USB, DRV_SERIAL_UART, DRV_GPIO_PIN, etc. */\n\n/* TODO: Define the master X-macro table with 5 parameters */\n/* Format: DRIVER(name, type_code, init_func, cleanup_func, flags) */\n/* \n * name: Enum identifier (e.g., SERIAL_USB)\n * type_code: 16-bit device type code (e.g., 0x0100)\n * init_func: Initialization function name\n * cleanup_func: Cleanup function name\n * flags: Device capability flags (e.g., DRV_HOTPLUG | DRV_IRQ)\n */\n\n/* Example entries for DRIVER_TABLE: */\n/* DRIVER(SERIAL_USB,  0x0100, init_usb_serial,  cleanup_usb_serial,  DRV_HOTPLUG | DRV_IRQ)  \\ */\n/* DRIVER(SERIAL_UART, 0x0101, init_uart_serial, cleanup_uart_serial, DRV_STATIC)             \\ */\n/* DRIVER(GPIO_PIN,    0x0200, init_gpio_pin,    cleanup_gpio_pin,    DRV_STATIC)             \\ */\n/* DRIVER(GPIO_LED,    0x0201, init_gpio_led,    cleanup_gpio_led,    DRV_STATIC)             \\ */\n/* DRIVER(SPI_FLASH,   0x0300, init_spi_flash,   cleanup_spi_flash,   DRV_HOTPLUG)            */\n\n/* TODO: Generate enum using X-macro */\n/* Use this pattern:\n * #define MAKE_ENUM(name, ...) DRV_##name,\n * enum driver_type {\n *     DRIVER_TABLE(MAKE_ENUM)\n *     DRV_UNKNOWN\n * };\n * #undef MAKE_ENUM\n */\n\n/* Driver metadata structure */\nstruct driver_info {\n    enum driver_type type;\n    uint16_t type_code;\n    const char *name;\n    uint32_t flags;\n};\n\n/* Driver operation function pointers */\ntypedef int (*init_func_t)(void);\ntypedef void (*cleanup_func_t)(void);\n\nstruct driver_ops {\n    init_func_t init;\n    cleanup_func_t cleanup;\n};\n\n/* Global driver tables */\nextern struct driver_info driver_table[];\nextern struct driver_ops ops_table[];\nextern const int driver_count;\n\n/* TODO: Declare your driver functions */\n/* Initialization functions (return int for error codes) */\n/* int init_usb_serial(void); */\n/* int init_uart_serial(void); */\n/* int init_gpio_pin(void); */\n/* int init_gpio_led(void); */\n/* int init_spi_flash(void); */\n\n/* Cleanup functions (return void) */\n/* void cleanup_usb_serial(void); */\n/* void cleanup_uart_serial(void); */\n/* void cleanup_gpio_pin(void); */\n/* void cleanup_gpio_led(void); */\n/* void cleanup_spi_flash(void); */\n\n/* TODO: Declare your multi-target generation functions */\n/* int initialize_driver(enum driver_type type); */\n/* void cleanup_driver(enum driver_type type); */\n/* enum driver_type detect_driver_by_code(uint16_t type_code); */\n/* int count_drivers_by_flag(uint32_t flag); */\n/* void print_driver_table(void); */\n/* const char* get_driver_name(enum driver_type type); */\n\n#endif /* DRIVER_REGISTRY_H */\n",
      "readOnly": false,
      "language": "h"
    },
    {
      "name": "driver_registry.c",
      "content": "#include \"driver_registry.h\"\n\nint test_driver_type = 0;  /* DRV_SERIAL_USB */\nint test_type_code = 0x0100;\nint test_flag = DRV_HOTPLUG;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n */\nmodule_param(test_driver_type, int, 0644);\nMODULE_PARM_DESC(test_driver_type, \"Driver type for testing dispatch logic\");\nmodule_param(test_type_code, int, 0644);\nMODULE_PARM_DESC(test_type_code, \"Type code for testing detection logic\");\nmodule_param(test_flag, int, 0644);\nMODULE_PARM_DESC(test_flag, \"Flag for testing count logic\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: Advanced X-Macro Code Generation */\n/* This teaches PRODUCTION-LEVEL patterns from kernel development:\n *\n * EVOLUTION OF CODE GENERATION:\n *\n * Problem 25 (Basic X-Macros):\n * - 3 parameters per entry\n * - Generates: enum + string array + ID array\n * - Single purpose: data synchronization\n *\n * Problem 26 (Advanced X-Macros):\n * - 5 parameters per entry\n * - Generates: enum + 2 switches + if-chain + struct array + function pointer table\n * - Multiple purposes: full driver registration system\n *\n * KERNEL REAL-WORLD EXAMPLES:\n *\n * 1. PCI Device Registration:\n *    PCI_DEVICE(vendor, device) macro generates pci_device_id structs\n *\n * 2. System Call Tables:\n *    SYSCALL_DEFINEx() generates function prototypes and syscall table entries\n *\n * 3. Error Code Management:\n *    Single errno.h generates both error numbers and error string arrays\n *\n * 4. Driver Subsystems:\n *    platform_driver struct registration from single device table\n */\n\n/* TODO: Implement stub driver initialization functions */\n/* Each returns 0 for success, negative errno for failure */\n/* Print: \"Initializing <driver_name> driver\" */\n/* Examples:\n * int init_usb_serial(void) {\n *     printk(KERN_INFO \"Initializing USB Serial driver\\n\");\n *     return 0;\n * }\n */\n\n/* TODO: Implement stub driver cleanup functions */\n/* Each returns void */\n/* Print: \"Cleaning up <driver_name> driver\" */\n/* Examples:\n * void cleanup_usb_serial(void) {\n *     printk(KERN_INFO \"Cleaning up USB Serial driver\\n\");\n * }\n */\n\n/* ========================================================================== */\n/* TARGET 1: Driver Metadata Table Generation */\n/* ========================================================================== */\n/* TODO: Generate driver_table using X-macro */\n/* Pattern:\n * struct driver_info driver_table[] = {\n *     #define MAKE_INFO(name, code, init, cleanup, flags) \\\n *         { DRV_##name, code, #name, flags },\n *     DRIVER_TABLE(MAKE_INFO)\n *     #undef MAKE_INFO\n * };\n */\n\n/* TODO: Calculate driver count */\n/* const int driver_count = sizeof(driver_table) / sizeof(driver_table[0]); */\n\n/* ========================================================================== */\n/* TARGET 2: Function Pointer Table Generation */\n/* ========================================================================== */\n/* TODO: Generate ops_table using X-macro */\n/* Pattern:\n * struct driver_ops ops_table[] = {\n *     #define MAKE_OPS(name, code, init, cleanup, flags) \\\n *         { init, cleanup },\n *     DRIVER_TABLE(MAKE_OPS)\n *     #undef MAKE_OPS\n * };\n */\n\n/* ========================================================================== */\n/* TARGET 3: Switch Statement for Initialization Dispatch */\n/* ========================================================================== */\n/* TODO: Implement initialize_driver() using switch statement */\n/* Generate switch cases from DRIVER_TABLE */\n/* Pattern:\n * int initialize_driver(enum driver_type type) {\n *     switch(type) {\n *         #define MAKE_INIT_CASE(name, code, init, cleanup, flags) \\\n *             case DRV_##name: return init();\n *         DRIVER_TABLE(MAKE_INIT_CASE)\n *         #undef MAKE_INIT_CASE\n *         default: return -ENODEV;\n *     }\n * }\n */\n\n/* ========================================================================== */\n/* TARGET 4: Switch Statement for Cleanup Dispatch */\n/* ========================================================================== */\n/* TODO: Implement cleanup_driver() using switch statement */\n/* Pattern:\n * void cleanup_driver(enum driver_type type) {\n *     switch(type) {\n *         #define MAKE_CLEANUP_CASE(name, code, init, cleanup, flags) \\\n *             case DRV_##name: cleanup(); break;\n *         DRIVER_TABLE(MAKE_CLEANUP_CASE)\n *         #undef MAKE_CLEANUP_CASE\n *         default: break;\n *     }\n * }\n */\n\n/* ========================================================================== */\n/* TARGET 5: If-Else Chain for Type Detection */\n/* ========================================================================== */\n/* TODO: Implement detect_driver_by_code() using if-else chain */\n/* Pattern:\n * enum driver_type detect_driver_by_code(uint16_t type_code) {\n *     #define MAKE_DETECT(name, code, init, cleanup, flags) \\\n *         if (type_code == code) return DRV_##name;\n *     DRIVER_TABLE(MAKE_DETECT)\n *     #undef MAKE_DETECT\n *     return DRV_UNKNOWN;\n * }\n */\n\n/* ========================================================================== */\n/* TARGET 6: Dynamic Iteration for Flag Counting */\n/* ========================================================================== */\n/* TODO: Implement count_drivers_by_flag() */\n/* Use driver_table array to count matching flags */\n/* Pattern:\n * int count_drivers_by_flag(uint32_t flag) {\n *     int count = 0;\n *     for (int i = 0; i < driver_count; i++) {\n *         if (driver_table[i].flags & flag) {\n *             count++;\n *         }\n *     }\n *     return count;\n * }\n */\n\n/* TODO: Implement print_driver_table() */\n/* Print all drivers in the driver_table */\n/* Format: \"Driver: <name> (Type: 0x%04x, Flags: 0x%02x)\" */\n\n/* TODO: Implement get_driver_name() */\n/* Use driver_table to look up name by enum value */\n/* Return driver_table[type].name if valid, \"Unknown\" otherwise */\n\nstatic int __init driver_registry_init(void)\n{\n    int ret;\n    int count;\n    enum driver_type detected;\n    \n    printk(KERN_INFO \"Driver registry module loaded\\n\");\n    \n    /* Test TARGET 1 & 2: Driver table generation */\n    printk(KERN_INFO \"Total drivers registered: %d\\n\", driver_count);\n    print_driver_table();\n    \n    /* Test TARGET 3: Switch-based initialization */\n    printk(KERN_INFO \"Testing driver initialization with type %d\\n\", test_driver_type);\n    ret = initialize_driver(test_driver_type);\n    if (ret == 0) {\n        printk(KERN_INFO \"Driver initialization succeeded\\n\");\n    } else {\n        printk(KERN_ERR \"Driver initialization failed: %d\\n\", ret);\n    }\n    \n    /* Test TARGET 5: Type code detection */\n    printk(KERN_INFO \"Testing type detection with code 0x%04x\\n\", test_type_code);\n    detected = detect_driver_by_code(test_type_code);\n    printk(KERN_INFO \"Detected driver: %s\\n\", get_driver_name(detected));\n    \n    /* Test TARGET 6: Flag-based counting */\n    printk(KERN_INFO \"Testing flag counting with flag 0x%02x\\n\", test_flag);\n    count = count_drivers_by_flag(test_flag);\n    printk(KERN_INFO \"Drivers with flag 0x%02x: %d\\n\", test_flag, count);\n    \n    /* Test TARGET 4: Cleanup dispatch */\n    cleanup_driver(test_driver_type);\n    \n    printk(KERN_INFO \"Driver registry demonstration completed\\n\");\n    \n    return 0;\n}\n\nstatic void __exit driver_registry_exit(void)\n{\n    printk(KERN_INFO \"Driver registry module unloaded\\n\");\n}\n\nmodule_init(driver_registry_init);\nmodule_exit(driver_registry_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning advanced X-macros for multi-target code generation\");\nMODULE_VERSION(\"1.0\");\n",
      "readOnly": false,
      "language": "c"
    },
    {
      "name": "Makefile",
      "content": "# Driver registry module Makefile\nobj-m += driver_registry.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help\n",
      "readOnly": true,
      "language": "makefile"
    }
  ],
  "concepts": [
    "advanced X-macros",
    "multi-parameter macros",
    "code generation patterns",
    "switch statement generation",
    "if-else chain generation",
    "struct array generation",
    "function pointer tables",
    "driver registration systems",
    "define-once-use-everywhere"
  ],
  "skills": [
    "Creating 5-parameter X-macro tables",
    "Generating enums from X-macros",
    "Generating switch statements from X-macros",
    "Generating if-else chains from X-macros",
    "Creating struct arrays with X-macros",
    "Building function pointer tables",
    "Implementing kernel driver registration patterns",
    "Understanding multi-target code generation"
  ],
  "validation": {
    "exactRequirements": {
      "functionNames": [
        "driver_registry_init",
        "driver_registry_exit",
        "init_usb_serial",
        "init_uart_serial",
        "init_gpio_pin",
        "init_gpio_led",
        "init_spi_flash",
        "cleanup_usb_serial",
        "cleanup_uart_serial",
        "cleanup_gpio_pin",
        "cleanup_gpio_led",
        "cleanup_spi_flash",
        "initialize_driver",
        "cleanup_driver",
        "detect_driver_by_code",
        "count_drivers_by_flag",
        "print_driver_table",
        "get_driver_name"
      ],
      "macro_declarations": [
        {
          "name": "DRIVER_TABLE",
          "type": "constant",
          "value": "(X) \\\nX(SERIAL_USB, 0x0100, init_usb_serial, cleanup_usb_serial, DRV_HOTPLUG | DRV_IRQ) \\\nX(SERIAL_UART, 0x0101, init_uart_serial, cleanup_uart_serial, DRV_STATIC) \\\nX(GPIO_PIN, 0x0200, init_gpio_pin, cleanup_gpio_pin, DRV_STATIC) \\\nX(GPIO_LED, 0x0201, init_gpio_led, cleanup_gpio_led, DRV_STATIC) \\\nX(SPI_FLASH, 0x0300, init_spi_flash, cleanup_spi_flash, DRV_HOTPLUG)",
          "description": "Master X-macro table defining all drivers with 5 parameters each"
        }
      ],
      "function_declarations": [
        { "name": "init_usb_serial", "returnType": "int", "parameters": ["void"] },
        { "name": "init_uart_serial", "returnType": "int", "parameters": ["void"] },
        { "name": "init_gpio_pin", "returnType": "int", "parameters": ["void"] },
        { "name": "init_gpio_led", "returnType": "int", "parameters": ["void"] },
        { "name": "init_spi_flash", "returnType": "int", "parameters": ["void"] },
        { "name": "cleanup_usb_serial", "returnType": "void", "parameters": ["void"] },
        { "name": "cleanup_uart_serial", "returnType": "void", "parameters": ["void"] },
        { "name": "cleanup_gpio_pin", "returnType": "void", "parameters": ["void"] },
        { "name": "cleanup_gpio_led", "returnType": "void", "parameters": ["void"] },
        { "name": "cleanup_spi_flash", "returnType": "void", "parameters": ["void"] },
        { "name": "initialize_driver", "returnType": "int", "parameters": ["enum driver_type type"] },
        { "name": "cleanup_driver", "returnType": "void", "parameters": ["enum driver_type type"] },
        { "name": "detect_driver_by_code", "returnType": "enum driver_type", "parameters": ["uint16_t type_code"] },
        { "name": "count_drivers_by_flag", "returnType": "int", "parameters": ["uint32_t flag"] },
        { "name": "print_driver_table", "returnType": "void", "parameters": ["void"] },
        { "name": "get_driver_name", "returnType": "const char*", "parameters": ["enum driver_type type"] }
      ],
      "variables_declarations": [
        {
          "name": "driver_type",
          "type": "enum",
          "value": "{DRV_SERIAL_USB, DRV_SERIAL_UART, DRV_GPIO_PIN, DRV_GPIO_LED, DRV_SPI_FLASH, DRV_UNKNOWN}",
          "storageClass": "none"
        },
        {
          "name": "driver_info",
          "type": "struct",
          "value": "{enum driver_type type; uint16_t type_code; const char *name; uint32_t flags;}",
          "storageClass": "none"
        },
        {
          "name": "driver_ops",
          "type": "struct",
          "value": "{init_func_t init; cleanup_func_t cleanup;}",
          "storageClass": "none"
        },
        {
          "name": "driver_table",
          "type": "struct driver_info",
          "value": "[]",
          "storageClass": "extern"
        },
        {
          "name": "ops_table",
          "type": "struct driver_ops",
          "value": "[]",
          "storageClass": "extern"
        },
        {
          "name": "driver_count",
          "type": "const int",
          "storageClass": "extern"
        }
      ],
      "variables": [
        {
          "name": "driver_table",
          "type": "struct driver_info",
          "value": "[]",
          "storageClass": "none"
        },
        {
          "name": "ops_table",
          "type": "struct driver_ops",
          "value": "[]",
          "storageClass": "none"
        },
        {
          "name": "driver_count",
          "type": "const int",
          "storageClass": "none"
        }
      ],
      "outputMessages": [
        "Driver registry module loaded",
        "Total drivers registered: 5",
        "Driver: SERIAL_USB (Type: 0x0100, Flags: 0x03)",
        "Driver: SERIAL_UART (Type: 0x0101, Flags: 0x00)",
        "Driver: GPIO_PIN (Type: 0x0200, Flags: 0x00)",
        "Driver: GPIO_LED (Type: 0x0201, Flags: 0x00)",
        "Driver: SPI_FLASH (Type: 0x0300, Flags: 0x01)",
        "Testing driver initialization with type 0",
        "Initializing USB Serial driver",
        "Driver initialization succeeded",
        "Testing type detection with code 0x0100",
        "Detected driver: SERIAL_USB",
        "Testing flag counting with flag",
        "Drivers with flag",
        "Cleaning up USB Serial driver",
        "Driver registry demonstration completed",
        "Driver registry module unloaded"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/types.h"
      ],
      "mustContain": [
        "#define DRIVER_TABLE(X)",
        "X(SERIAL_USB, 0x0100, init_usb_serial, cleanup_usb_serial, DRV_HOTPLUG | DRV_IRQ)",
        "X(SERIAL_UART, 0x0101, init_uart_serial, cleanup_uart_serial, DRV_STATIC)",
        "X(GPIO_PIN, 0x0200, init_gpio_pin, cleanup_gpio_pin, DRV_STATIC)",
        "X(GPIO_LED, 0x0201, init_gpio_led, cleanup_gpio_led, DRV_STATIC)",
        "X(SPI_FLASH, 0x0300, init_spi_flash, cleanup_spi_flash, DRV_HOTPLUG)",
        "#define MAKE_ENUM(name, ...) DRV_##name,",
        "enum driver_type",
        "DRIVER_TABLE(MAKE_ENUM)",
        "#undef MAKE_ENUM",
        "#define MAKE_INFO",
        "DRIVER_TABLE(MAKE_INFO)",
        "#define MAKE_OPS",
        "DRIVER_TABLE(MAKE_OPS)",
        "#define MAKE_INIT_CASE",
        "case DRV_##name: return init();",
        "DRIVER_TABLE(MAKE_INIT_CASE)",
        "#define MAKE_CLEANUP_CASE",
        "case DRV_##name: cleanup(); break;",
        "DRIVER_TABLE(MAKE_CLEANUP_CASE)",
        "#define MAKE_DETECT",
        "if (type_code == code) return DRV_##name;",
        "DRIVER_TABLE(MAKE_DETECT)",
        "sizeof(driver_table) / sizeof(driver_table[0])",
        "driver_table[i].flags & flag",
        "module_param(test_driver_type, int, 0644)",
        "module_param(test_type_code, int, 0644)",
        "module_param(test_flag, int, 0644)"
      ],
      "moduleInfo": {
        "license": "GPL"
      }
    },
    "testCases": [
      {
        "id": "function_declarations",
        "name": "Function Declarations in Header",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "int init_usb_serial(void)",
          "int init_uart_serial(void)",
          "int init_gpio_pin(void)",
          "int init_gpio_led(void)",
          "int init_spi_flash(void)",
          "void cleanup_usb_serial(void)",
          "void cleanup_uart_serial(void)",
          "void cleanup_gpio_pin(void)",
          "void cleanup_gpio_led(void)",
          "void cleanup_spi_flash(void)",
          "int initialize_driver(enum driver_type type)",
          "void cleanup_driver(enum driver_type type)",
          "enum driver_type detect_driver_by_code(uint16_t type_code)",
          "int count_drivers_by_flag(uint32_t flag)",
          "void print_driver_table(void)",
          "const char* get_driver_name(enum driver_type type)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "xmacro_table_definition",
        "name": "X-Macro Table with 5 Parameters",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "#define DRIVER_TABLE(X)",
          "X(SERIAL_USB,",
          "X(SERIAL_UART,",
          "X(GPIO_PIN,",
          "X(GPIO_LED,",
          "X(SPI_FLASH,"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "enum_generation",
        "name": "Enum Generation from X-Macro",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "#define MAKE_ENUM",
          "enum driver_type",
          "DRIVER_TABLE(MAKE_ENUM)",
          "#undef MAKE_ENUM"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "struct_array_generation",
        "name": "Struct Array Generation",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "#define MAKE_INFO",
          "struct driver_info driver_table",
          "DRIVER_TABLE(MAKE_INFO)",
          "#define MAKE_OPS",
          "struct driver_ops ops_table",
          "DRIVER_TABLE(MAKE_OPS)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "switch_generation",
        "name": "Switch Statement Generation",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "#define MAKE_INIT_CASE",
          "case DRV_",
          "DRIVER_TABLE(MAKE_INIT_CASE)",
          "#define MAKE_CLEANUP_CASE",
          "DRIVER_TABLE(MAKE_CLEANUP_CASE)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "ifelse_generation",
        "name": "If-Else Chain Generation",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "#define MAKE_DETECT",
          "if (type_code == code)",
          "DRIVER_TABLE(MAKE_DETECT)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "function_signatures_source",
        "name": "Function Signatures in Source File",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "int init_usb_serial(void)",
          "int init_uart_serial(void)",
          "void cleanup_usb_serial(void)",
          "void cleanup_uart_serial(void)",
          "int initialize_driver(enum driver_type type)",
          "void cleanup_driver(enum driver_type type)",
          "enum driver_type detect_driver_by_code(uint16_t type_code)",
          "int count_drivers_by_flag(uint32_t flag)",
          "void print_driver_table(void)",
          "const char* get_driver_name(enum driver_type type)",
          "static int __init driver_registry_init(void)",
          "static void __exit driver_registry_exit(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "exact_output",
        "name": "Exact Output Messages",
        "type": "output_match",
        "critical": true,
        "expected": [
          { "pattern": "Driver registry module loaded", "exact": true, "linkedFunction": "static int __init driver_registry_init(void)" },
          { "pattern": "Total drivers registered: 5", "exact": true, "linkedFunction": "static int __init driver_registry_init(void)" },
          { "pattern": "Driver: SERIAL_USB (Type: 0x0100, Flags: 0x03)", "exact": true, "linkedFunction": "void print_driver_table(void)" },
          { "pattern": "Driver: SERIAL_UART (Type: 0x0101, Flags: 0x00)", "exact": true, "linkedFunction": "void print_driver_table(void)" },
          { "pattern": "Driver: GPIO_PIN (Type: 0x0200, Flags: 0x00)", "exact": true, "linkedFunction": "void print_driver_table(void)" },
          { "pattern": "Driver: GPIO_LED (Type: 0x0201, Flags: 0x00)", "exact": true, "linkedFunction": "void print_driver_table(void)" },
          { "pattern": "Driver: SPI_FLASH (Type: 0x0300, Flags: 0x01)", "exact": true, "linkedFunction": "void print_driver_table(void)" },
          { "pattern": "Testing driver initialization with type 0", "exact": true, "linkedFunction": "static int __init driver_registry_init(void)" },
          { "pattern": "Initializing USB Serial driver", "exact": true, "linkedFunction": "int init_usb_serial(void)" },
          { "pattern": "Driver initialization succeeded", "exact": true, "linkedFunction": "static int __init driver_registry_init(void)" },
          { "pattern": "Testing type detection with code 0x0100", "exact": true, "linkedFunction": "static int __init driver_registry_init(void)" },
          { "pattern": "Detected driver: SERIAL_USB", "exact": true, "linkedFunction": "static int __init driver_registry_init(void)" },
          { "pattern": "Cleaning up USB Serial driver", "exact": true, "linkedFunction": "void cleanup_usb_serial(void)" },
          { "pattern": "Driver registry demonstration completed", "exact": true, "linkedFunction": "static int __init driver_registry_init(void)" },
          { "pattern": "Driver registry module unloaded", "exact": true, "linkedFunction": "static void __exit driver_registry_exit(void)" }
        ]
      },
      {
        "id": "advanced_xmacro_validation",
        "name": "Advanced X-Macro Multi-Target Validation",
        "type": "kernel_project_test",
        "critical": true,
        "testScenario": {
          "userspaceApps": [
            {
              "name": "xmacro_dynamic_tester",
              "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Advanced X-Macro Dynamic Test ===\\\\n\\\");\\n    \\n    srand(time(NULL));\\n    \\n    // Test different driver types\\n    int driver_types[] = {0, 1, 2, 3, 4};  // All 5 drivers\\n    int type_codes[] = {0x0100, 0x0101, 0x0200, 0x0201, 0x0300};\\n    int flags[] = {1, 0, 1};  // HOTPLUG=1, STATIC=0\\n    \\n    int random_driver = driver_types[rand() % 5];\\n    int random_code = type_codes[rand() % 5];\\n    int random_flag = flags[rand() % 3];\\n    \\n    printf(\\\"Test: driver_type=%d, type_code=0x%04x, flag=%d\\\\n\\\", random_driver, random_code, random_flag);\\n    \\n    system(\\\"rmmod driver_registry 2>/dev/null\\\");\\n    \\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/driver_registry.ko test_driver_type=%d test_type_code=%d test_flag=%d\\\", random_driver, random_code, random_flag);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: X-macro test completed\\\\n\\\");\\n    return 0;\\n}"
            }
          ],
          "setupCommands": [
            "echo 'Starting advanced X-macro validation'"
          ],
          "testCommands": [
            "echo 'Phase 1: TCC Header Validation'",
            "mkdir -p /tmp/linux",
            "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
            "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
            "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
            "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
            "echo '#define module_init(x)' >> /tmp/linux/module.h",
            "echo '#define module_exit(x)' >> /tmp/linux/module.h",
            "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
            "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
            "echo '#define __init' > /tmp/linux/init.h",
            "echo '#define __exit' >> /tmp/linux/init.h",
            "echo 'typedef unsigned short uint16_t;' > /tmp/linux/types.h",
            "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
            "echo '#include \"/lib/modules/driver_registry.h\"' > /tmp/test.c",
            "echo 'int main() { struct driver_info info; struct driver_ops ops; initialize_driver(DRV_SERIAL_USB); cleanup_driver(DRV_SERIAL_USB); detect_driver_by_code(0x0100); count_drivers_by_flag(1); print_driver_table(); get_driver_name(DRV_SERIAL_USB); return 0; }' >> /tmp/test.c",
            "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
            "TCC_EXIT_CODE=$?",
            "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing'; cat /tmp/tcc_error.log; else echo 'PASS: All declarations found'; fi",
            "echo 'Phase 2: Dynamic X-Macro Test'",
            "/bin/xmacro_dynamic_tester > /tmp/test_output.log",
            "cat /tmp/test_output.log",
            "echo 'Phase 3: X-Macro Generation Validation'",
            "sleep 1",
            "dmesg | grep 'Driver registry module loaded' && echo 'PASS: Module loading' || echo 'FAIL: Module loading'",
            "dmesg | grep 'Total drivers registered: 5' && echo 'PASS: Driver count correct' || echo 'FAIL: Driver count wrong'",
            "dmesg | grep 'Driver: SERIAL_USB' && echo 'PASS: Struct array generation' || echo 'FAIL: Struct array generation'",
            "dmesg | grep 'Driver: GPIO_PIN' && echo 'PASS: X-macro expansion' || echo 'FAIL: X-macro expansion'",
            "dmesg | grep 'Initializing.*driver' && echo 'PASS: Switch dispatch working' || echo 'FAIL: Switch dispatch broken'",
            "dmesg | grep 'Driver initialization succeeded' && echo 'PASS: Function pointer table' || echo 'FAIL: Function pointer table'",
            "dmesg | grep 'Detected driver:' && echo 'PASS: If-else chain generation' || echo 'FAIL: If-else chain generation'",
            "dmesg | grep 'Drivers with flag' && echo 'PASS: Flag counting logic' || echo 'FAIL: Flag counting logic'",
            "dmesg | grep 'Cleaning up.*driver' && echo 'PASS: Cleanup dispatch' || echo 'FAIL: Cleanup dispatch'",
            "dmesg | grep 'Driver registry demonstration completed' && echo 'PASS: All targets validated' || echo 'FAIL: Some targets missing'",
            "echo 'PASS: All advanced X-macro validation successful'"
          ],
          "expected": {
            "dmesg": [
              "Driver registry module loaded",
              "Total drivers registered: 5",
              "Driver: SERIAL_USB.*Type: 0x0100.*Flags: 0x03",
              "Driver: SERIAL_UART.*Type: 0x0101.*Flags: 0x00",
              "Driver: GPIO_PIN.*Type: 0x0200.*Flags: 0x00",
              "Driver: GPIO_LED.*Type: 0x0201.*Flags: 0x00",
              "Driver: SPI_FLASH.*Type: 0x0300.*Flags: 0x01",
              "Testing driver initialization with type.*",
              "Initializing.*driver",
              "Driver initialization succeeded",
              "Testing type detection with code.*",
              "Detected driver:.*",
              "Testing flag counting with flag.*",
              "Drivers with flag.*",
              "Cleaning up.*driver",
              "Driver registry demonstration completed",
              "Driver registry module unloaded"
            ],
            "stdout": [
              "PASS: All declarations found",
              "SUCCESS: X-macro test completed",
              "PASS: Module loading",
              "PASS: Driver count correct",
              "PASS: Struct array generation",
              "PASS: X-macro expansion",
              "PASS: Switch dispatch working",
              "PASS: Function pointer table",
              "PASS: If-else chain generation",
              "PASS: Flag counting logic",
              "PASS: Cleanup dispatch",
              "PASS: All targets validated",
              "PASS: All advanced X-macro validation successful"
            ]
          },
          "timeout": 30
        }
      }
    ]
  }
}
