{
  "id": 28,
  "title": "Advanced X-Macros - Multi-Target Code Generation",
  "phase": "foundations",
  "difficulty": 8,
  "xp": 80,
  "description": "Master advanced X-macro patterns for sophisticated code generation. Learn to create single-source tables that auto-generate multiple related structures: enums, function stubs, switch statements, if-else chains, struct arrays, and function pointer tables. This powerful kernel programming technique is used extensively in driver registration, system call tables (SYSCALL_DEFINEx), tracepoint generation (TRACE_EVENT), and device management - eliminating repetitive code and preventing synchronization errors.",
  "mainFile": "driver_registry.c",
  "files": [
    {
      "name": "driver_registry.h",
      "content": "#ifndef DRIVER_REGISTRY_H\n#define DRIVER_REGISTRY_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* LEARNING PROGRESSION: From Simple X-Macros to Multi-Target Generation */\n/* This problem advances X-macro mastery from Problem 25's fundamentals */\n\n/* KERNEL PATTERN: Driver Registration System */\n/* Real Linux kernel uses this pattern for:\n * - PCI device tables (pci_device_id)\n * - USB device tables (usb_device_id)\n * - Platform driver registration\n * - System call tables\n * - Error code definitions\n * - Tracepoint function generation (trace_sched_switch auto-generated)\n */\n\n/* Driver capability flags */\n#define DRV_HOTPLUG  (1 << 0)  /* Supports hot-plug/unplug */\n#define DRV_IRQ      (1 << 1)  /* Uses interrupts */\n#define DRV_DMA      (1 << 2)  /* Supports DMA */\n#define DRV_POWER    (1 << 3)  /* Power management capable */\n#define DRV_STATIC   0          /* Static device, no special flags */\n\n/* Forward declarations */\nstruct driver_info;\nstruct driver_ops;\n\n/* ========================================================================== */\n/* TODO: Define DRIVER_TABLE X-macro */\n/* ========================================================================== */\n/* This is the master table that drives all code generation.\n * It should take a macro X as parameter and call it for each driver entry.\n *\n * Format: Each X() call should pass 5 parameters:\n *   X(name, type_code, init_func, cleanup_func, flags)\n *\n * Required driver entries (5 total):\n *   1. SERIAL_USB:  type_code=0x0100, init=init_usb_serial,  cleanup=cleanup_usb_serial,  flags=DRV_HOTPLUG|DRV_IRQ\n *   2. SERIAL_UART: type_code=0x0101, init=init_uart_serial, cleanup=cleanup_uart_serial, flags=DRV_STATIC\n *   3. GPIO_PIN:    type_code=0x0200, init=init_gpio_pin,    cleanup=cleanup_gpio_pin,    flags=DRV_STATIC\n *   4. GPIO_LED:    type_code=0x0201, init=init_gpio_led,    cleanup=cleanup_gpio_led,    flags=DRV_STATIC\n *   5. SPI_FLASH:   type_code=0x0300, init=init_spi_flash,   cleanup=cleanup_spi_flash,   flags=DRV_HOTPLUG\n *\n * Pattern:\n *   #define DRIVER_TABLE(X) \\\n *       X(SERIAL_USB, 0x0100, init_usb_serial, cleanup_usb_serial, DRV_HOTPLUG | DRV_IRQ) \\\n *       X(SERIAL_UART, ...) \\\n *       ...\n */\n#define DRIVER_TABLE(X) /* YOUR CODE HERE */\n\n/* ========================================================================== */\n/* TODO: Define MAKE_ENUM helper macro */\n/* ========================================================================== */\n/* Takes: name and variadic parameters (...)\n * Generates: DRV_<name> with trailing comma\n * Pattern: Use token pasting (##) to create DRV_ prefix\n *\n * Example usage:\n *   MAKE_ENUM(SERIAL_USB, 0x0100, init_usb_serial, cleanup_usb_serial, DRV_HOTPLUG)\n *   Should expand to: DRV_SERIAL_USB,\n *\n * Hint: DRV_##name creates \"DRV_SERIAL_USB\" from \"SERIAL_USB\"\n *       The ... ignores all other parameters (we only need name)\n */\n#define MAKE_ENUM(name, ...) /* YOUR CODE HERE */\n\n/* TODO: Generate enum driver_type using DRIVER_TABLE(MAKE_ENUM) */\n/* Pattern:\n *   enum driver_type {\n *       DRIVER_TABLE(MAKE_ENUM)\n *       DRV_UNKNOWN\n *   };\n */\nenum driver_type {\n    /* YOUR CODE HERE */\n    DRV_UNKNOWN\n};\n\n#undef MAKE_ENUM\n\n/* Driver metadata structure */\nstruct driver_info {\n    enum driver_type type;\n    uint16_t type_code;\n    const char *name;\n    uint32_t flags;\n};\n\n/* Driver operation function pointers */\ntypedef int (*init_func_t)(void);\ntypedef void (*cleanup_func_t)(void);\n\nstruct driver_ops {\n    init_func_t init;\n    cleanup_func_t cleanup;\n};\n\n/* Global driver tables */\nextern struct driver_info driver_table[];\nextern struct driver_ops ops_table[];\nextern const int driver_count;\n\n/* ========================================================================== */\n/* TODO: Auto-generate init function declarations */\n/* ========================================================================== */\n/* Define MAKE_INIT_DECL macro that:\n *   Takes: name, code, init, cleanup, flags\n *   Generates: int init(void);\n *\n * Then use: DRIVER_TABLE(MAKE_INIT_DECL)\n *\n * This will auto-generate all 5 init function declarations:\n *   int init_usb_serial(void);\n *   int init_uart_serial(void);\n *   int init_gpio_pin(void);\n *   int init_gpio_led(void);\n *   int init_spi_flash(void);\n */\n#define MAKE_INIT_DECL(name, code, init, cleanup, flags) /* YOUR CODE HERE */\n\n/* YOUR CODE HERE: Use DRIVER_TABLE(MAKE_INIT_DECL) */\n\n#undef MAKE_INIT_DECL\n\n/* ========================================================================== */\n/* TODO: Auto-generate cleanup function declarations */\n/* ========================================================================== */\n/* Define MAKE_CLEANUP_DECL macro that:\n *   Takes: name, code, init, cleanup, flags\n *   Generates: void cleanup(void);\n *\n * Then use: DRIVER_TABLE(MAKE_CLEANUP_DECL)\n *\n * This will auto-generate all 5 cleanup function declarations:\n *   void cleanup_usb_serial(void);\n *   void cleanup_uart_serial(void);\n *   void cleanup_gpio_pin(void);\n *   void cleanup_gpio_led(void);\n *   void cleanup_spi_flash(void);\n */\n#define MAKE_CLEANUP_DECL(name, code, init, cleanup, flags) /* YOUR CODE HERE */\n\n/* YOUR CODE HERE: Use DRIVER_TABLE(MAKE_CLEANUP_DECL) */\n\n#undef MAKE_CLEANUP_DECL\n\n/* ========================================================================== */\n/* TODO: Declare multi-target generation functions */\n/* ========================================================================== */\nint initialize_driver(enum driver_type type);\nvoid cleanup_driver(enum driver_type type);\nenum driver_type detect_driver_by_code(uint16_t type_code);\nint count_drivers_by_flag(uint32_t flag);\nvoid print_driver_table(void);\nconst char* get_driver_name(enum driver_type type);\n\n#endif /* DRIVER_REGISTRY_H */\n",
      "readOnly": false,
      "language": "h"
    },
    {
      "name": "driver_registry.c",
      "content": "#include \"driver_registry.h\"\n\nint test_driver_type = 0;  /* DRV_SERIAL_USB */\nint test_type_code = 0x0100;\nint test_flag = DRV_HOTPLUG;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n */\nmodule_param(test_driver_type, int, 0644);\nMODULE_PARM_DESC(test_driver_type, \"Driver type for testing dispatch logic\");\nmodule_param(test_type_code, int, 0644);\nMODULE_PARM_DESC(test_type_code, \"Type code for testing detection logic\");\nmodule_param(test_flag, int, 0644);\nMODULE_PARM_DESC(test_flag, \"Flag for testing count logic\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: Advanced X-Macro Multi-Target Code Generation */\n/* This teaches PRODUCTION-LEVEL patterns from real Linux kernel development:\n *\n * EVOLUTION OF CODE GENERATION:\n * Problem 25 (Basic X-Macros):\n *   - 3 parameters per entry (name, id, description)\n *   - Generates 3 targets: enum + string array + ID array\n *   - Single purpose: data synchronization\n *\n * Problem 28 (Advanced X-Macros):\n *   - 5 parameters per entry (name, type_code, init_func, cleanup_func, flags)\n *   - Generates 7+ targets: enum + function stubs + switches + if-chain + struct arrays\n *   - Multiple purposes: complete driver registration system\n *\n * REAL LINUX KERNEL EXAMPLES:\n * 1. PCI Device Registration:\n *    PCI_DEVICE(vendor, device) macro generates pci_device_id structs\n *\n * 2. System Call Tables:\n *    SYSCALL_DEFINEx() generates BOTH function prototypes AND syscall table entries\n *\n * 3. Tracepoint System:\n *    TRACE_EVENT(sched_switch, ...) AUTO-GENERATES trace_sched_switch() function!\n *\n * 4. Error Code Management:\n *    Single errno.h generates error numbers AND error string arrays\n */\n\n/* ========================================================================== */\n/* TARGET 0: Auto-Generate Function Implementations (ADVANCED PATTERN!) */\n/* ========================================================================== */\n/* WHAT THIS TARGET TEACHES: Generating entire FUNCTION BODIES from X-macros */\n\n/* UNDERSTANDING THE PROBLEM: */\n/* We need to create 5 init functions:\n *   int init_usb_serial(void) { ... }\n *   int init_uart_serial(void) { ... }\n *   int init_gpio_pin(void) { ... }\n *   int init_gpio_led(void) { ... }\n *   int init_spi_flash(void) { ... }\n *\n * Each function needs different data embedded (name, code, flags)\n * Writing them manually = 50+ lines of repetitive code\n * Using X-macro = 5-line macro + 1-line invocation!\n */\n\n/* HOW X-MACRO FUNCTION GENERATION WORKS: */\n/* Step 1: DRIVER_TABLE calls our macro for each driver */\n/*   DRIVER_TABLE(MAKE_INIT_FUNC) expands to: */\n/*   MAKE_INIT_FUNC(SERIAL_USB, 0x0100, init_usb_serial, cleanup_usb_serial, 0x03) */\n/*   MAKE_INIT_FUNC(SERIAL_UART, 0x0101, init_uart_serial, cleanup_uart_serial, 0x00) */\n/*   ... */\n/*\n * Step 2: Each MAKE_INIT_FUNC invocation generates a complete function */\n/*   For SERIAL_USB: */\n/*     name=SERIAL_USB, code=0x0100, init=init_usb_serial, cleanup=cleanup_usb_serial, flags=0x03 */\n/*     Macro expands to: */\n/*     int init_usb_serial(void) { */\n/*         printk(KERN_INFO \"Initializing SERIAL_USB driver\\n\"); */\n/*         printk(KERN_INFO \"  Type code: 0x0100\\n\"); */\n/*         printk(KERN_INFO \"  Flags: 0x03\\n\"); */\n/*         return 0; */\n/*     } */\n\n/* WHAT EACH PARAMETER CONTAINS AND HOW TO USE IT: */\n/* 1. name parameter (e.g., SERIAL_USB) */\n/*    Contains: Plain identifier token */\n/*    Use #name to convert to string: \"SERIAL_USB\" */\n/*    Example: printk(\"Initializing \" #name \" driver\\n\"); */\n/*\n * 2. code parameter (e.g., 0x0100) */\n/*    Contains: Numeric value */\n/*    Use code directly in expressions: printk(\"Type: 0x%04x\\n\", code); */\n/*\n * 3. init parameter (e.g., init_usb_serial) */\n/*    Contains: Function name identifier */\n/*    Use init as function name: int init(void) { ... } */\n/*\n * 4. flags parameter (e.g., DRV_HOTPLUG | DRV_IRQ which is 0x03) */\n/*    Contains: Numeric expression */\n/*    Use flags directly: printk(\"Flags: 0x%02x\\n\", flags); */\n\n/* STRINGIFICATION OPERATOR (#) EXPLAINED: */\n/* #parameter converts macro parameter to string literal */\n/* Example: */\n/*   #define MAKE_STRING(x) #x */\n/*   MAKE_STRING(SERIAL_USB) expands to \"SERIAL_USB\" */\n/*   MAKE_STRING(hello world) expands to \"hello world\" */\n/*\n * In our case: */\n/*   When name=SERIAL_USB: */\n/*   #name → \"SERIAL_USB\" */\n/*   \"Initializing \" #name \" driver\" → \"Initializing SERIAL_USB driver\" */\n\n/* PARAMETER EMBEDDING IN FUNCTION BODY: */\n/* Macro parameters can be used anywhere in the macro expansion */\n/* Example: */\n/*   #define MAKE_FUNC(fname, val) \\ */\n/*   int fname(void) { \\ */\n/*       return val; \\ */\n/*   } */\n/*\n * MAKE_FUNC(get_magic, 42) expands to: */\n/*   int get_magic(void) { */\n/*       return 42; */\n/*   } */\n\n/* MULTI-LINE MACRO SYNTAX: */\n/* Use \\ at end of each line to continue macro definition */\n/* Example: */\n/*   #define MULTI_LINE \\ */\n/*   first line \\ */\n/*   second line */\n/*\n * IMPORTANT: */\n/*   - NO \\ on the last line! */\n/*   - \\ must be LAST character on line (no spaces after it!) */\n\n/* COMMON MISTAKES AND SOLUTIONS: */\n/* MISTAKE 1: Using macro parameter as string without # */\n/*   printk(\"Initializing name driver\");  // WRONG - prints literal \"name\" */\n/* SOLUTION: */\n/*   printk(\"Initializing \" #name \" driver\");  // CORRECT - stringifies parameter */\n/*\n * MISTAKE 2: Not using backslashes on multi-line macros */\n/*   #define MY_MACRO(x)     // WRONG */\n/*   int x(void) { */\n/*   return 0; */\n/*   } */\n/* SOLUTION: */\n/*   #define MY_MACRO(x) \\    // CORRECT */\n/*   int x(void) { \\          // CORRECT */\n/*       return 0; \\          // CORRECT */\n/*   }                       // NO \\ on last line */\n/*\n * MISTAKE 3: Extra spaces after backslash */\n/*   #define MACRO \\ [space]  // WRONG - compiler error */\n/* SOLUTION: */\n/*   #define MACRO \\          // CORRECT - \\ is last character */\n\n/* TODO: Define MAKE_INIT_FUNC macro that generates complete init functions\n *\n * Requirements:\n * - Function signature: int <init_name>(void)\n * - Print driver name (use stringification #name)\n * - Print type code in hex format (0x%04x)\n * - Print flags in hex format (0x%02x)\n * - Return 0 for success\n *\n * Remember:\n * - Use backslash \\ at end of each line except last\n * - Double backslash \\\\n in strings for macro expansion\n * - Embed code and flags parameters directly in printk\n *\n * Expected output for SERIAL_USB:\n *   \"Initializing SERIAL_USB driver\"\n *   \"  Type code: 0x0100\"\n *   \"  Flags: 0x03\"\n */\n#define MAKE_INIT_FUNC(name, code, init, cleanup, flags) /* YOUR CODE HERE */\n\n/* TODO: Use DRIVER_TABLE to generate all 5 init functions */\n\n#undef MAKE_INIT_FUNC\n\n/* TODO: Define MAKE_CLEANUP_FUNC macro that generates cleanup functions\n *\n * Requirements:\n * - Function signature: void <cleanup_name>(void)\n * - Print driver name (use stringification #name)\n * - Print type code in hex format (0x%04x)\n * - No return value needed (void function)\n *\n * Expected output for SERIAL_USB:\n *   \"Cleaning up SERIAL_USB driver\"\n *   \"  Type code: 0x0100\"\n */\n#define MAKE_CLEANUP_FUNC(name, code, init, cleanup, flags) /* YOUR CODE HERE */\n\n/* TODO: Use DRIVER_TABLE to generate all 5 cleanup functions */\n\n#undef MAKE_CLEANUP_FUNC\n\n/* ========================================================================== */\n/* TARGET 1 & 2: Struct Array Generation */\n/* ========================================================================== */\n/* WHAT THIS TARGET TEACHES: Generating struct array initializers */\n\n/* HOW STRUCT ARRAY GENERATION WORKS: */\n/* Given struct driver_info definition from .h file: */\n/*   struct driver_info { */\n/*       enum driver_type type; */\n/*       uint16_t type_code; */\n/*       const char *name; */\n/*       uint32_t flags; */\n/*   }; */\n/*\n * We want to generate: */\n/*   struct driver_info driver_table[] = { */\n/*       { DRV_SERIAL_USB, 0x0100, \"SERIAL_USB\", 0x03 }, */\n/*       { DRV_SERIAL_UART, 0x0101, \"SERIAL_UART\", 0x00 }, */\n/*       { DRV_GPIO_PIN, 0x0200, \"GPIO_PIN\", 0x00 }, */\n/*       { DRV_GPIO_LED, 0x0201, \"GPIO_LED\", 0x00 }, */\n/*       { DRV_SPI_FLASH, 0x0300, \"SPI_FLASH\", 0x01 } */\n/*   }; */\n\n/* STRUCT INITIALIZER SYNTAX: */\n/* C designated initializers: { .field1 = value1, .field2 = value2 } */\n/* C positional initializers: { value1, value2, value3 } */\n/*\n * For driver_info: */\n/*   { DRV_SERIAL_USB, 0x0100, \"SERIAL_USB\", 0x03 } */\n/*    ↑               ↑       ↑             ↑        */\n/*    type            code    name          flags    */\n\n/* TOKEN PASTING REVIEW (##): */\n/* DRV_##name creates DRV_SERIAL_USB from name=SERIAL_USB */\n/* Example: */\n/*   #define MAKE_ENUM_VAL(x) DRV_##x */\n/*   MAKE_ENUM_VAL(SERIAL_USB) → DRV_SERIAL_USB */\n\n/* COMBINING TOKEN PASTING AND STRINGIFICATION: */\n/* For SERIAL_USB entry: */\n/*   DRV_##name → DRV_SERIAL_USB (enum value) */\n/*   #name → \"SERIAL_USB\" (string literal) */\n\n/* TODO: Define MAKE_INFO macro that generates struct initializers\n *\n * Requirements:\n * - Generate positional struct initializer for driver_info\n * - Field order: type (enum), type_code, name (string), flags\n * - Use token pasting (DRV_##name) for enum value\n * - Use stringification (#name) for name field\n * - Include trailing comma\n *\n * Expected result for SERIAL_USB:\n *   { DRV_SERIAL_USB, 0x0100, \"SERIAL_USB\", 0x03 },\n */\n#define MAKE_INFO(name, code, init, cleanup, flags) /* YOUR CODE HERE */\n\nstruct driver_info driver_table[] = {\n    /* YOUR CODE HERE: Use DRIVER_TABLE(MAKE_INFO) to populate array */\n};\n\n#undef MAKE_INFO\n\n/* TODO: Calculate driver_count\n * Hint: Total array size divided by size of one element\n */\nconst int driver_count = /* YOUR CODE HERE */;\n\n/* TODO: Define MAKE_OPS macro that generates function pointer table entries\n *\n * Requirements:\n * - Generate positional struct initializer for driver_ops\n * - Field order: init (function pointer), cleanup (function pointer)\n * - Use the init and cleanup parameters directly (they're already function names)\n * - Include trailing comma\n *\n * Expected result for SERIAL_USB:\n *   { init_usb_serial, cleanup_usb_serial },\n */\n#define MAKE_OPS(name, code, init, cleanup, flags) /* YOUR CODE HERE */\n\nstruct driver_ops ops_table[] = {\n    /* YOUR CODE HERE: Use DRIVER_TABLE(MAKE_OPS) */\n};\n\n#undef MAKE_OPS\n\n/* ========================================================================== */\n/* TARGET 3 & 4: Switch Statement Generation */\n/* ========================================================================== */\n/* WHAT THIS TARGET TEACHES: Generating switch-case statements */\n\n/* HOW SWITCH GENERATION WORKS: */\n/* We want to generate: */\n/*   switch(type) { */\n/*       case DRV_SERIAL_USB: return init_usb_serial(); */\n/*       case DRV_SERIAL_UART: return init_uart_serial(); */\n/*       case DRV_GPIO_PIN: return init_gpio_pin(); */\n/*       case DRV_GPIO_LED: return init_gpio_led(); */\n/*       case DRV_SPI_FLASH: return init_spi_flash(); */\n/*       default: return -ENODEV; */\n/*   } */\n\n/* SWITCH CASE SYNTAX: */\n/* case CONSTANT: statement; */\n/* For our case: case DRV_##name: return init(); */\n/*\n * Breaking it down: */\n/*   case DRV_##name:  // Match this enum value */\n/*   return init();    // Call the init function */\n\n/* TODO: Implement initialize_driver() with X-macro generated switch cases\n *\n * Requirements:\n * - Create switch statement on type parameter\n * - Define MAKE_INIT_CASE macro that generates: case DRV_##name: return init();\n * - Use DRIVER_TABLE(MAKE_INIT_CASE) inside switch to generate all cases\n * - Add default case returning -ENODEV for unknown types\n * - Remember to #undef MAKE_INIT_CASE after use\n *\n * Expected behavior:\n * - DRV_SERIAL_USB calls init_usb_serial() and returns result\n * - DRV_SERIAL_UART calls init_uart_serial() and returns result\n * - And so on for all 5 drivers\n */\nint initialize_driver(enum driver_type type)\n{\n    /* YOUR CODE HERE */\n}\n\n/* TODO: Implement cleanup_driver() with X-macro generated switch cases\n *\n * Requirements:\n * - Create switch statement on type parameter\n * - Define MAKE_CLEANUP_CASE macro that generates: case DRV_##name: cleanup(); break;\n * - Use DRIVER_TABLE(MAKE_CLEANUP_CASE) inside switch\n * - Add default case (can be empty break)\n * - Remember to #undef MAKE_CLEANUP_CASE after use\n *\n * Note: Use break (not return) since function returns void\n */\nvoid cleanup_driver(enum driver_type type)\n{\n    /* YOUR CODE HERE */\n}\n\n/* ========================================================================== */\n/* TARGET 5: If-Else Chain Generation */\n/* ========================================================================== */\n/* WHAT THIS TARGET TEACHES: Generating sequential if statements */\n\n/* HOW IF-CHAIN GENERATION WORKS: */\n/* We want to generate: */\n/*   if (type_code == 0x0100) return DRV_SERIAL_USB; */\n/*   if (type_code == 0x0101) return DRV_SERIAL_UART; */\n/*   if (type_code == 0x0200) return DRV_GPIO_PIN; */\n/*   if (type_code == 0x0201) return DRV_GPIO_LED; */\n/*   if (type_code == 0x0300) return DRV_SPI_FLASH; */\n/*   return DRV_UNKNOWN; */\n\n/* WHY CHAIN OF IFS (NOT IF-ELSE-IF): */\n/* Each if statement contains a return, so execution stops on match */\n/* This is simpler than if-else-if and works identically */\n\n/* TODO: Implement detect_driver_by_code() with X-macro generated if-chain\n *\n * Requirements:\n * - Define MAKE_DETECT macro that generates: if (type_code == code) return DRV_##name;\n * - Use DRIVER_TABLE(MAKE_DETECT) to generate all if statements\n * - Remember to #undef MAKE_DETECT after use\n * - Return DRV_UNKNOWN if no match found\n *\n * Expected behavior:\n * - type_code 0x0100 returns DRV_SERIAL_USB\n * - type_code 0x0101 returns DRV_SERIAL_UART\n * - Unknown codes return DRV_UNKNOWN\n */\nenum driver_type detect_driver_by_code(uint16_t type_code)\n{\n    /* YOUR CODE HERE */\n    return DRV_UNKNOWN;\n}\n\n/* ========================================================================== */\n/* TARGET 6: Table Iteration Functions */\n/* ========================================================================== */\n/* WHAT THIS TARGET TEACHES: Using the generated tables dynamically */\n\n/* TODO: Implement count_drivers_by_flag()\n *\n * Requirements:\n * - Count how many drivers in driver_table have matching flags\n * - Use bitwise AND (&) to check flag matches\n * - Loop through all driver_count entries\n *\n * Example:\n * - Flag DRV_HOTPLUG (0x01) should match SERIAL_USB and SPI_FLASH\n * - Returns 2\n */\nint count_drivers_by_flag(uint32_t flag)\n{\n    /* YOUR CODE HERE */\n}\n\n/* TODO: Implement print_driver_table()\n *\n * Requirements:\n * - Print all entries in driver_table\n * - Format: \"Driver: <name> (Type: 0x%04x, Flags: 0x%02x)\"\n * - Loop through all driver_count entries\n *\n * Expected output for first entry:\n *   \"Driver: SERIAL_USB (Type: 0x0100, Flags: 0x03)\"\n */\nvoid print_driver_table(void)\n{\n    /* YOUR CODE HERE */\n}\n\n/* TODO: Implement get_driver_name()\n *\n * Requirements:\n * - Return driver name string from driver_table for given enum value\n * - Validate that type is within valid range (0 to driver_count-1)\n * - Return \"Unknown\" for invalid types\n *\n * Example:\n * - get_driver_name(DRV_SERIAL_USB) returns \"SERIAL_USB\"\n * - get_driver_name(999) returns \"Unknown\"\n */\nconst char* get_driver_name(enum driver_type type)\n{\n    /* YOUR CODE HERE */\n}\n\n/* ========================================================================== */\n/* Module Init/Exit */\n/* ========================================================================== */\nstatic int __init driver_registry_init(void)\n{\n    int ret;\n    int count;\n    enum driver_type detected;\n    \n    printk(KERN_INFO \"Driver registry module loaded\\n\");\n    \n    /* Test TARGET 1 & 2: Driver table generation */\n    printk(KERN_INFO \"Total drivers registered: %d\\n\", driver_count);\n    print_driver_table();\n    \n    /* Test TARGET 3: Switch-based initialization */\n    printk(KERN_INFO \"Testing driver initialization with type %d\\n\", test_driver_type);\n    ret = initialize_driver(test_driver_type);\n    if (ret == 0) {\n        printk(KERN_INFO \"Driver initialization succeeded\\n\");\n    } else {\n        printk(KERN_ERR \"Driver initialization failed: %d\\n\", ret);\n    }\n    \n    /* Test TARGET 5: Type code detection */\n    printk(KERN_INFO \"Testing type detection with code 0x%04x\\n\", test_type_code);\n    detected = detect_driver_by_code(test_type_code);\n    printk(KERN_INFO \"Detected driver: %s\\n\", get_driver_name(detected));\n    \n    /* Test TARGET 6: Flag-based counting */\n    printk(KERN_INFO \"Testing flag counting with flag 0x%02x\\n\", test_flag);\n    count = count_drivers_by_flag(test_flag);\n    printk(KERN_INFO \"Drivers with flag 0x%02x: %d\\n\", test_flag, count);\n    \n    /* Test TARGET 4: Cleanup dispatch */\n    cleanup_driver(test_driver_type);\n    \n    printk(KERN_INFO \"Driver registry demonstration completed\\n\");\n    \n    return 0;\n}\n\nstatic void __exit driver_registry_exit(void)\n{\n    printk(KERN_INFO \"Driver registry module unloaded\\n\");\n}\n\nmodule_init(driver_registry_init);\nmodule_exit(driver_registry_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning advanced X-macros for multi-target code generation\");\nMODULE_VERSION(\"1.0\");\n",
      "readOnly": false,
      "language": "c"
    },
    {
      "name": "Makefile",
      "content": "# Driver registry module Makefile\nobj-m += driver_registry.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help\n",
      "readOnly": true,
      "language": "makefile"
    }
  ],
  "concepts": [
    "advanced X-macros",
    "multi-parameter macros",
    "code generation patterns",
    "function stub generation",
    "switch statement generation",
    "if-else chain generation",
    "struct array generation",
    "function pointer tables",
    "driver registration systems",
    "define-once-use-everywhere",
    "DRY principle in kernel development"
  ],
  "skills": [
    "Creating 5-parameter X-macro tables",
    "Auto-generating function stubs from tables",
    "Generating enums from X-macros",
    "Generating switch statements from X-macros",
    "Generating if-else chains from X-macros",
    "Creating struct arrays with X-macros",
    "Building function pointer tables",
    "Implementing kernel driver registration patterns",
    "Understanding multi-target code generation",
    "Embedding table data in generated functions"
  ],
  "validation": {
    "exactRequirements": {
      "functionNames": [
        "driver_registry_init",
        "driver_registry_exit",
        "initialize_driver",
        "cleanup_driver",
        "detect_driver_by_code",
        "count_drivers_by_flag",
        "print_driver_table",
        "get_driver_name"
      ],
      "macro_declarations": [
        {
          "name": "DRIVER_TABLE",
          "type": "function-like",
          "parameters": ["X"]
        },
        {
          "name": "MAKE_ENUM",
          "type": "function-like",
          "parameters": ["name", "..."]
        },
        {
          "name": "MAKE_INIT_DECL",
          "type": "function-like",
          "parameters": ["name", "code", "init", "cleanup", "flags"]
        },
        {
          "name": "MAKE_CLEANUP_DECL",
          "type": "function-like",
          "parameters": ["name", "code", "init", "cleanup", "flags"]
        }
      ],
      "macro_definitions": [
        {
          "name": "MAKE_INIT_FUNC",
          "type": "function-like",
          "parameters": ["name", "code", "init", "cleanup", "flags"]
        },
        {
          "name": "MAKE_CLEANUP_FUNC",
          "type": "function-like",
          "parameters": ["name", "code", "init", "cleanup", "flags"]
        },
        {
          "name": "MAKE_INFO",
          "type": "function-like",
          "parameters": ["name", "code", "init", "cleanup", "flags"]
        },
        {
          "name": "MAKE_OPS",
          "type": "function-like",
          "parameters": ["name", "code", "init", "cleanup", "flags"]
        },
        {
          "name": "MAKE_INIT_CASE",
          "type": "function-like",
          "parameters": ["name", "code", "init", "cleanup", "flags"]
        },
        {
          "name": "MAKE_CLEANUP_CASE",
          "type": "function-like",
          "parameters": ["name", "code", "init", "cleanup", "flags"]
        },
        {
          "name": "MAKE_DETECT",
          "type": "function-like",
          "parameters": ["name", "code", "init", "cleanup", "flags"]
        }
      ],
      "variables_declarations": [
        {
          "name": "driver_type",
          "type": "enum",
          "value": "{\n    DRIVER_TABLE(MAKE_ENUM)\n    DRV_UNKNOWN\n}",
          "storageClass": "none"
        },
        {
          "name": "driver_info",
          "type": "struct",
          "value": "{enum driver_type type; uint16_t type_code; const char *name; uint32_t flags;}",
          "storageClass": "none"
        },
        {
          "name": "driver_ops",
          "type": "struct",
          "value": "{init_func_t init; cleanup_func_t cleanup;}",
          "storageClass": "none"
        },
        {
          "name": "driver_table",
          "type": "struct driver_info",
          "value": "[]",
          "storageClass": "extern"
        },
        {
          "name": "ops_table",
          "type": "struct driver_ops",
          "value": "[]",
          "storageClass": "extern"
        },
        {
          "name": "driver_count",
          "type": "const int",
          "storageClass": "extern"
        }
      ],
      "variables": [
        {
          "name": "driver_table[]",
          "type": "struct driver_info",
          "value": "{\n    DRIVER_TABLE(MAKE_INFO)\n}",
          "storageClass": "none"
        },
        {
          "name": "ops_table[]",
          "type": "struct driver_ops",
          "value": "{\n    DRIVER_TABLE(MAKE_OPS)\n}",
          "storageClass": "none"
        },
        {
          "name": "driver_count",
          "type": "const int",
          "value": "sizeof(driver_table) / sizeof(driver_table[0])",
          "storageClass": "none"
        }
      ],
      "outputMessages": [
        "Driver registry module loaded",
        "Total drivers registered: 5",
        "Driver: SERIAL_USB (Type: 0x0100, Flags: 0x03)",
        "Driver: SERIAL_UART (Type: 0x0101, Flags: 0x00)",
        "Driver: GPIO_PIN (Type: 0x0200, Flags: 0x00)",
        "Driver: GPIO_LED (Type: 0x0201, Flags: 0x00)",
        "Driver: SPI_FLASH (Type: 0x0300, Flags: 0x01)",
        "Testing driver initialization with type 0",
        "Initializing SERIAL_USB driver",
        "Type code: 0x0100",
        "Flags: 0x03",
        "Driver initialization succeeded",
        "Testing type detection with code 0x0100",
        "Detected driver: SERIAL_USB",
        "Testing flag counting with flag",
        "Drivers with flag",
        "Cleaning up SERIAL_USB driver",
        "Type code: 0x0100",
        "Driver registry demonstration completed",
        "Driver registry module unloaded"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/types.h"
      ],
      "mustContain": [
        "#define DRIVER_TABLE(X)",
        "X(SERIAL_USB, 0x0100, init_usb_serial, cleanup_usb_serial, DRV_HOTPLUG | DRV_IRQ)",
        "X(SERIAL_UART, 0x0101, init_uart_serial, cleanup_uart_serial, DRV_STATIC)",
        "X(GPIO_PIN, 0x0200, init_gpio_pin, cleanup_gpio_pin, DRV_STATIC)",
        "X(GPIO_LED, 0x0201, init_gpio_led, cleanup_gpio_led, DRV_STATIC)",
        "X(SPI_FLASH, 0x0300, init_spi_flash, cleanup_spi_flash, DRV_HOTPLUG)",
        "#define MAKE_ENUM(name, ...) DRV_##name,",
        "enum driver_type",
        "DRIVER_TABLE(MAKE_ENUM)",
        "#undef MAKE_ENUM",
        "#define MAKE_INIT_DECL(name, code, init, cleanup, flags)",
        "int init(void);",
        "DRIVER_TABLE(MAKE_INIT_DECL)",
        "#undef MAKE_INIT_DECL",
        "#define MAKE_CLEANUP_DECL(name, code, init, cleanup, flags)",
        "void cleanup(void);",
        "DRIVER_TABLE(MAKE_CLEANUP_DECL)",
        "#undef MAKE_CLEANUP_DECL",
        "#define MAKE_INIT_FUNC(name, code, init, cleanup, flags)",
        "int init(void)",
        "printk.*#name",
        "Type code.*0x%04x.*code",
        "Flags.*0x%02x.*flags",
        "DRIVER_TABLE(MAKE_INIT_FUNC)",
        "#undef MAKE_INIT_FUNC",
        "#define MAKE_CLEANUP_FUNC(name, code, init, cleanup, flags)",
        "void cleanup(void)",
        "DRIVER_TABLE(MAKE_CLEANUP_FUNC)",
        "#undef MAKE_CLEANUP_FUNC",
        "#define MAKE_INFO",
        "DRIVER_TABLE(MAKE_INFO)",
        "#define MAKE_OPS",
        "DRIVER_TABLE(MAKE_OPS)",
        "#define MAKE_INIT_CASE",
        "case DRV_##name: return init();",
        "DRIVER_TABLE(MAKE_INIT_CASE)",
        "#define MAKE_CLEANUP_CASE",
        "case DRV_##name: cleanup(); break;",
        "DRIVER_TABLE(MAKE_CLEANUP_CASE)",
        "#define MAKE_DETECT",
        "if (type_code == code) return DRV_##name;",
        "DRIVER_TABLE(MAKE_DETECT)",
        "sizeof(driver_table) / sizeof(driver_table[0])",
        "driver_table[i].flags & flag",
        "module_param(test_driver_type, int, 0644)",
        "module_param(test_type_code, int, 0644)",
        "module_param(test_flag, int, 0644)"
      ],
      "moduleInfo": {
        "license": "GPL"
      }
    },
    "testCases": [
      {
        "id": "function_declarations",
        "name": "Function Declarations in Header",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "int initialize_driver(enum driver_type type)",
          "void cleanup_driver(enum driver_type type)",
          "enum driver_type detect_driver_by_code(uint16_t type_code)",
          "int count_drivers_by_flag(uint32_t flag)",
          "void print_driver_table(void)",
          "const char* get_driver_name(enum driver_type type)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "xmacro_table_definition",
        "name": "X-Macro Table with 5 Parameters",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "#define DRIVER_TABLE(X)",
          "X(SERIAL_USB,",
          "X(SERIAL_UART,",
          "X(GPIO_PIN,",
          "X(GPIO_LED,",
          "X(SPI_FLASH,"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "enum_generation",
        "name": "Enum Generation from X-Macro",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "#define MAKE_ENUM",
          "enum driver_type",
          "DRIVER_TABLE(MAKE_ENUM)",
          "#undef MAKE_ENUM"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "struct_array_generation",
        "name": "Struct Array Generation",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "#define MAKE_INFO",
          "struct driver_info driver_table",
          "DRIVER_TABLE(MAKE_INFO)",
          "#define MAKE_OPS",
          "struct driver_ops ops_table",
          "DRIVER_TABLE(MAKE_OPS)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "switch_generation",
        "name": "Switch Statement Generation",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "#define MAKE_INIT_CASE",
          "case DRV_",
          "DRIVER_TABLE(MAKE_INIT_CASE)",
          "#define MAKE_CLEANUP_CASE",
          "DRIVER_TABLE(MAKE_CLEANUP_CASE)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "ifelse_generation",
        "name": "If-Else Chain Generation",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "#define MAKE_DETECT",
          "if (type_code == code)",
          "DRIVER_TABLE(MAKE_DETECT)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "function_declaration_generation",
        "name": "Function Declaration Auto-Generation in Header",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "#define MAKE_INIT_DECL(name, code, init, cleanup, flags)",
          "int init(void);",
          "DRIVER_TABLE(MAKE_INIT_DECL)",
          "#undef MAKE_INIT_DECL",
          "#define MAKE_CLEANUP_DECL(name, code, init, cleanup, flags)",
          "void cleanup(void);",
          "DRIVER_TABLE(MAKE_CLEANUP_DECL)",
          "#undef MAKE_CLEANUP_DECL"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "function_implementation_generation",
        "name": "Function Implementation Auto-Generation in Source",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "#define MAKE_INIT_FUNC(name, code, init, cleanup, flags)",
          "int init(void)",
          "#name",
          "0x%04x",
          "0x%02x",
          "DRIVER_TABLE(MAKE_INIT_FUNC)",
          "#undef MAKE_INIT_FUNC",
          "#define MAKE_CLEANUP_FUNC(name, code, init, cleanup, flags)",
          "void cleanup(void)",
          "DRIVER_TABLE(MAKE_CLEANUP_FUNC)",
          "#undef MAKE_CLEANUP_FUNC"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "function_signatures_source",
        "name": "Function Implementations in Source File",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "int initialize_driver(enum driver_type type)",
          "void cleanup_driver(enum driver_type type)",
          "enum driver_type detect_driver_by_code(uint16_t type_code)",
          "int count_drivers_by_flag(uint32_t flag)",
          "void print_driver_table(void)",
          "const char* get_driver_name(enum driver_type type)",
          "static int __init driver_registry_init(void)",
          "static void __exit driver_registry_exit(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "exact_output",
        "name": "Exact Output Messages",
        "type": "output_match",
        "critical": true,
        "expected": [
          { "pattern": "Driver registry module loaded", "exact": true, "linkedFunction": "static int __init driver_registry_init(void)" },
          { "pattern": "Total drivers registered: 5", "exact": true, "linkedFunction": "static int __init driver_registry_init(void)" },
          { "pattern": "Driver: SERIAL_USB (Type: 0x0100, Flags: 0x03)", "exact": true, "linkedFunction": "void print_driver_table(void)" },
          { "pattern": "Driver: SERIAL_UART (Type: 0x0101, Flags: 0x00)", "exact": true, "linkedFunction": "void print_driver_table(void)" },
          { "pattern": "Driver: GPIO_PIN (Type: 0x0200, Flags: 0x00)", "exact": true, "linkedFunction": "void print_driver_table(void)" },
          { "pattern": "Driver: GPIO_LED (Type: 0x0201, Flags: 0x00)", "exact": true, "linkedFunction": "void print_driver_table(void)" },
          { "pattern": "Driver: SPI_FLASH (Type: 0x0300, Flags: 0x01)", "exact": true, "linkedFunction": "void print_driver_table(void)" },
          { "pattern": "Testing driver initialization with type 0", "exact": true, "linkedFunction": "static int __init driver_registry_init(void)" },
          { "pattern": "Initializing SERIAL_USB driver", "exact": true, "linkedFunction": "int init_usb_serial(void)" },
          { "pattern": "Type code: 0x0100", "exact": true, "linkedFunction": "int init_usb_serial(void)" },
          { "pattern": "Flags: 0x03", "exact": true, "linkedFunction": "int init_usb_serial(void)" },
          { "pattern": "Driver initialization succeeded", "exact": true, "linkedFunction": "static int __init driver_registry_init(void)" },
          { "pattern": "Testing type detection with code 0x0100", "exact": true, "linkedFunction": "static int __init driver_registry_init(void)" },
          { "pattern": "Detected driver: SERIAL_USB", "exact": true, "linkedFunction": "static int __init driver_registry_init(void)" },
          { "pattern": "Cleaning up SERIAL_USB driver", "exact": true, "linkedFunction": "void cleanup_usb_serial(void)" },
          { "pattern": "Type code: 0x0100", "exact": true, "linkedFunction": "void cleanup_usb_serial(void)" },
          { "pattern": "Driver registry demonstration completed", "exact": true, "linkedFunction": "static int __init driver_registry_init(void)" },
          { "pattern": "Driver registry module unloaded", "exact": true, "linkedFunction": "static void __exit driver_registry_exit(void)" }
        ]
      },
      {
        "id": "advanced_xmacro_validation",
        "name": "Advanced X-Macro Multi-Target Validation",
        "type": "kernel_project_test",
        "critical": true,
        "testScenario": {
          "userspaceApps": [
            {
              "name": "xmacro_dynamic_tester",
              "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Advanced X-Macro Dynamic Test ===\\\\n\\\");\\n    \\n    srand(time(NULL));\\n    \\n    // Test different driver types\\n    int driver_types[] = {0, 1, 2, 3, 4};  // All 5 drivers\\n    int type_codes[] = {0x0100, 0x0101, 0x0200, 0x0201, 0x0300};\\n    int flags[] = {1, 0, 1};  // HOTPLUG=1, STATIC=0\\n    \\n    int random_driver = driver_types[rand() % 5];\\n    int random_code = type_codes[rand() % 5];\\n    int random_flag = flags[rand() % 3];\\n    \\n    printf(\\\"Test: driver_type=%d, type_code=0x%04x, flag=%d\\\\n\\\", random_driver, random_code, random_flag);\\n    \\n    system(\\\"rmmod driver_registry 2>/dev/null\\\");\\n    \\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/driver_registry.ko test_driver_type=%d test_type_code=%d test_flag=%d\\\", random_driver, random_code, random_flag);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: X-macro test completed\\\\n\\\");\\n    return 0;\\n}"
            }
          ],
          "setupCommands": [
            "echo 'Starting advanced X-macro validation'"
          ],
          "testCommands": [
            "echo 'Phase 1: TCC Header Validation'",
            "mkdir -p /tmp/linux",
            "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
            "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
            "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
            "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
            "echo '#define module_init(x)' >> /tmp/linux/module.h",
            "echo '#define module_exit(x)' >> /tmp/linux/module.h",
            "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
            "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
            "echo '#define __init' > /tmp/linux/init.h",
            "echo '#define __exit' >> /tmp/linux/init.h",
            "echo 'typedef unsigned short uint16_t;' > /tmp/linux/types.h",
            "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
            "echo '#include \"/lib/modules/driver_registry.h\"' > /tmp/test.c",
            "echo 'int main() { struct driver_info info; struct driver_ops ops; initialize_driver(DRV_SERIAL_USB); cleanup_driver(DRV_SERIAL_USB); detect_driver_by_code(0x0100); count_drivers_by_flag(1); print_driver_table(); get_driver_name(DRV_SERIAL_USB); return 0; }' >> /tmp/test.c",
            "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
            "TCC_EXIT_CODE=$?",
            "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declaration missing'; cat /tmp/tcc_error.log; else echo 'PASS: All declarations found'; fi",
            "echo 'Phase 2: Dynamic X-Macro Test'",
            "/bin/xmacro_dynamic_tester > /tmp/test_output.log",
            "cat /tmp/test_output.log",
            "echo 'Phase 3: X-Macro Function Generation Validation (CRITICAL)'",
            "sleep 1",
            "echo 'Extracting test driver type from output...'",
            "TEST_DRIVER=$(grep -o 'driver_type=[0-9]*' /tmp/test_output.log | head -1 | cut -d'=' -f2)",
            "echo 'Testing with driver type '$TEST_DRIVER",
            "echo 'Validating macro-generated function output (must include type code and flags)...'",
            "dmesg | grep 'Type code: 0x' && echo 'PASS: Functions include type code (proves macro generation)' || echo 'FAIL: Missing type code (manual implementation detected)'",
            "dmesg | grep 'Flags: 0x' && echo 'PASS: Functions include flags (proves macro generation)' || echo 'FAIL: Missing flags (manual implementation detected)'",
            "echo 'Validating flag values match DRIVER_TABLE entries...'",
            "case $TEST_DRIVER in",
            "  0) dmesg | grep 'Flags: 0x03' && echo 'PASS: USB Serial flags correct (DRV_HOTPLUG|DRV_IRQ=0x03)' || echo 'FAIL: USB Serial flags wrong' ;;",
            "  1) dmesg | grep 'Flags: 0x00' && echo 'PASS: UART Serial flags correct (DRV_STATIC=0x00)' || echo 'FAIL: UART Serial flags wrong' ;;",
            "  2) dmesg | grep 'Flags: 0x00' && echo 'PASS: GPIO PIN flags correct (DRV_STATIC=0x00)' || echo 'FAIL: GPIO PIN flags wrong' ;;",
            "  3) dmesg | grep 'Flags: 0x00' && echo 'PASS: GPIO LED flags correct (DRV_STATIC=0x00)' || echo 'FAIL: GPIO LED flags wrong' ;;",
            "  4) dmesg | grep 'Flags: 0x01' && echo 'PASS: SPI Flash flags correct (DRV_HOTPLUG=0x01)' || echo 'FAIL: SPI Flash flags wrong' ;;",
            "esac",
            "echo 'Phase 4: Multi-Target Generation Validation'",
            "dmesg | grep 'Driver registry module loaded' && echo 'PASS: Module loading' || echo 'FAIL: Module loading'",
            "dmesg | grep 'Total drivers registered: 5' && echo 'PASS: Driver count correct' || echo 'FAIL: Driver count wrong'",
            "dmesg | grep 'Driver: SERIAL_USB' && echo 'PASS: Struct array generation' || echo 'FAIL: Struct array generation'",
            "dmesg | grep 'Driver: GPIO_PIN' && echo 'PASS: X-macro expansion' || echo 'FAIL: X-macro expansion'",
            "dmesg | grep 'Initializing.*driver' && echo 'PASS: Switch dispatch working' || echo 'FAIL: Switch dispatch broken'",
            "dmesg | grep 'Driver initialization succeeded' && echo 'PASS: Function pointer table' || echo 'FAIL: Function pointer table'",
            "dmesg | grep 'Detected driver:' && echo 'PASS: If-else chain generation' || echo 'FAIL: If-else chain generation'",
            "dmesg | grep 'Drivers with flag' && echo 'PASS: Flag counting logic' || echo 'FAIL: Flag counting logic'",
            "dmesg | grep 'Cleaning up.*driver' && echo 'PASS: Cleanup dispatch' || echo 'FAIL: Cleanup dispatch'",
            "dmesg | grep 'Driver registry demonstration completed' && echo 'PASS: All targets validated' || echo 'FAIL: Some targets missing'",
            "echo 'PASS: All advanced X-macro validation successful (including function generation)'"
          ],
          "expected": {
            "dmesg": [
              "Driver registry module loaded",
              "Total drivers registered: 5",
              "Driver: SERIAL_USB.*Type: 0x0100.*Flags: 0x03",
              "Driver: SERIAL_UART.*Type: 0x0101.*Flags: 0x00",
              "Driver: GPIO_PIN.*Type: 0x0200.*Flags: 0x00",
              "Driver: GPIO_LED.*Type: 0x0201.*Flags: 0x00",
              "Driver: SPI_FLASH.*Type: 0x0300.*Flags: 0x01",
              "Testing driver initialization with type.*",
              "Initializing.*driver",
              "Type code: 0x.*",
              "Flags: 0x.*",
              "Driver initialization succeeded",
              "Testing type detection with code.*",
              "Detected driver:.*",
              "Testing flag counting with flag.*",
              "Drivers with flag.*",
              "Cleaning up.*driver",
              "Type code: 0x.*",
              "Driver registry demonstration completed",
              "Driver registry module unloaded"
            ],
            "stdout": [
              "PASS: All declarations found",
              "SUCCESS: X-macro test completed",
              "PASS: Functions include type code \\(proves macro generation\\)",
              "PASS: Functions include flags \\(proves macro generation\\)",
              "PASS:.*flags correct",
              "PASS: Module loading",
              "PASS: Driver count correct",
              "PASS: Struct array generation",
              "PASS: X-macro expansion",
              "PASS: Switch dispatch working",
              "PASS: Function pointer table",
              "PASS: If-else chain generation",
              "PASS: Flag counting logic",
              "PASS: Cleanup dispatch",
              "PASS: All targets validated",
              "PASS: All advanced X-macro validation successful \\(including function generation\\)"
            ]
          },
          "timeout": 30
        }
      }
    ]
  }
}
