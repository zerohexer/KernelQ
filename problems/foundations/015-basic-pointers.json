{
  "id": 15,
  "title": "Basic Pointers - Introduction to Memory Addresses",
  "phase": "foundations", 
  "difficulty": 3,
  "xp": 25,
  "description": "Learn the fundamental concepts of pointers in C. Understand what pointers are, how to declare them, use the address-of operator (&), dereference operator (*), and perform basic operations with integers and arrays through pointers.",
  "mainFile": "basic_pointers.c",
  "files": [
    {
      "name": "basic_pointers.h",
      "content": "#ifndef BASIC_POINTERS_H\n#define BASIC_POINTERS_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n\n/* Global variables for testing */\nextern int number;\nextern int array[5];\nextern int *number_ptr;\nextern int *array_ptr;\n\n/* TODO: Declare your pointer functions */\n/* void print_number_info(void); */\n/* void modify_through_pointer(int *ptr, int new_value); */\n/* void print_array_through_pointer(int *ptr); */\n\n#endif /* BASIC_POINTERS_H */",
      "readOnly": false,
      "language": "h"
    },
    {
      "name": "basic_pointers.c",
      "content": "#include \"basic_pointers.h\"\n\n/* Global variables */\nint number = 42;\nint array[5] = {10, 20, 30, 40, 50};\nint *number_ptr = NULL;\nint *array_ptr = NULL;\n\nint test_value = 42;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your pointer logic works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(test_value, int, 0644);\nMODULE_PARM_DESC(test_value, \"Test value for anti-hardcoding validation\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: Complete Beginner's Guide to Pointers */\n/* WHAT IS A POINTER? */\n/* A pointer is a variable that stores a MEMORY ADDRESS of another variable */\n/* Think of it like a home address - it tells you WHERE something is located */\n\n/* SIMPLE EXAMPLE TO UNDERSTAND POINTERS: */\n/* int a = 5; */\n/* int* ptr = &a;      // ptr points to a */\n/* */\n/* What Each Contains: */\n/* a = 5                    // The value */\n/* ptr = &a                 // Address of a (like 0x1000) */\n/* *ptr = 5                 // Value at the address ptr points to */\n\n/* THE TWO IMPORTANT OPERATORS: */\n/* & = \"address-of\" operator - gets the address where a variable lives */\n/* * = \"dereference\" operator - gets the value at an address */\n\n/* REAL WORLD ANALOGY: */\n/* Variable 'a' is like a house with the number 5 painted on it */\n/* &a is like the street address of that house (e.g., \"123 Main St\") */\n/* ptr is like writing down that address on paper */\n/* *ptr is like going to that address and reading the number on the house */\n\n/* DETAILED EXPLANATION OF POINTER DECLARATION: */\n/* int* ptr;        // Declares a pointer that can point to an integer */\n/*                  // ptr can store the address of an int variable */\n/*                  // RIGHT NOW ptr contains garbage - don't use it yet! */\n/* */\n/* int a = 5;       // Create an integer variable with value 5 */\n/* ptr = &a;        // Make ptr point to variable a */\n/*                  // Now ptr contains the address where a lives */\n\n/* WHAT HAPPENS IN MEMORY: */\n/* Memory Address: 0x1000    0x2000 */\n/* ┌─────────────┐  ┌─────────────────┐ */\n/* │ a = 5       │  │ ptr = 0x1000    │ */\n/* └─────────────┘  └─────────────────┘ */\n/*   ↑                ↑ */\n/*   │                └─ ptr points to this address */\n/*   └─ a lives here */\n\n/* THE & OPERATOR (ADDRESS-OF): */\n/* &a means \"give me the address where variable a is stored\" */\n/* If a is stored at memory address 0x1000, then &a = 0x1000 */\n/* */\n/* EXAMPLES: */\n/* int a = 5; */\n/* printf(\"%d\", a);    // Prints: 5 (the value) */\n/* printf(\"%p\", &a);   // Prints: 0x1000 (the address) */\n\n/* THE * OPERATOR (DEREFERENCE): */\n/* *ptr means \"go to the address stored in ptr and get the value there\" */\n/* If ptr contains 0x1000, then *ptr gets the value at address 0x1000 */\n/* */\n/* EXAMPLES: */\n/* int a = 5; */\n/* int* ptr = &a; */\n/* printf(\"%p\", ptr);   // Prints: 0x1000 (the address) */\n/* printf(\"%d\", *ptr);  // Prints: 5 (the value at that address) */\n\n/* COMMON BEGINNER MISTAKES: */\n/* MISTAKE 1: Confusing & and * */\n/*   int a = 5; */\n/*   int* ptr = a;        // WRONG: ptr expects an address, not a value */\n/* CORRECT: */\n/*   int* ptr = &a;       // CORRECT: ptr gets the address of a */\n/* */\n/* MISTAKE 2: Using * when you want the address */\n/*   printf(\"%p\", *ptr);  // WRONG: *ptr gives value, not address */\n/* CORRECT: */\n/*   printf(\"%p\", ptr);   // CORRECT: ptr contains the address */\n/* */\n/* MISTAKE 3: Using uninitialized pointers */\n/*   int* ptr;            // ptr contains garbage */\n/*   *ptr = 5;            // WRONG: writing to random memory! */\n/* CORRECT: */\n/*   int a; */\n/*   int* ptr = &a;       // Initialize ptr first */\n/*   *ptr = 5;            // CORRECT: now a = 5 */\n\n/* POINTER ARITHMETIC WITH ARRAYS: */\n/* Arrays and pointers are closely related in C */\n/* */\n/* int arr[5] = {10, 20, 30, 40, 50}; */\n/* int* ptr = arr;              // Same as ptr = &arr[0] */\n/* */\n/* printf(\"%d\", *ptr);         // Prints: 10 (first element) */\n/* printf(\"%d\", *(ptr + 1));   // Prints: 20 (second element) */\n/* printf(\"%d\", *(ptr + 2));   // Prints: 30 (third element) */\n/* */\n/* WHY ptr + 1 WORKS: */\n/* - ptr points to arr[0] at address 0x1000 */\n/* - ptr + 1 points to arr[1] at address 0x1004 (4 bytes later for int) */\n/* - *(ptr + 1) gets the value at arr[1] */\n\n/* VISUALIZING ARRAY POINTER ARITHMETIC: */\n/* Array: [10][20][30][40][50] */\n/* Addr:  1000 1004 1008 1012 1016 */\n/* */\n/* ptr + 0 → 1000 → *ptr = 10 */\n/* ptr + 1 → 1004 → *(ptr+1) = 20 */\n/* ptr + 2 → 1008 → *(ptr+2) = 30 */\n\n/* MODIFYING VALUES THROUGH POINTERS: */\n/* Once you have a pointer, you can change the original variable */\n/* */\n/* int a = 5; */\n/* int* ptr = &a; */\n/* *ptr = 10;               // Changes a to 10! */\n/* printf(\"%d\", a);         // Prints: 10 */\n/* */\n/* This is powerful because functions can modify caller's variables */\n\n/* PRACTICAL EXAMPLES FOR THIS PROBLEM: */\n/* Example 1: Basic pointer operations */\n/* int number = 42; */\n/* int* number_ptr = &number;       // Point to number */\n/* printf(\"Value: %d\", *number_ptr); // Prints: 42 */\n/* *number_ptr = 100;               // Changes number to 100 */\n/* */\n/* Example 2: Array access through pointers */\n/* int array[5] = {10, 20, 30, 40, 50}; */\n/* int* array_ptr = array;          // Point to first element */\n/* printf(\"First: %d\", *array_ptr); // Prints: 10 */\n/* printf(\"Second: %d\", *(array_ptr + 1)); // Prints: 20 */\n\n/* MEMORY SAFETY REMINDERS: */\n/* - Always initialize pointers before using them */\n/* - Don't dereference NULL pointers */\n/* - Don't access array elements beyond bounds */\n/* - In kernel space, use proper allocation/deallocation */\n\n/* WHY LEARN POINTERS? */\n/* Pointers are fundamental to: */\n/* - Dynamic memory allocation */\n/* - Passing large data structures efficiently */\n/* - Implementing data structures (linked lists, trees) */\n/* - System programming and kernel development */\n/* - Understanding how computers actually work */\n\n/* TODO: Implement function to print number and pointer info */\nvoid print_number_info(void) {\n    /* TODO: Print the value of 'number' using direct access */\n    /* TODO: Print the address of 'number' using &number */\n    /* TODO: Print the value of 'number_ptr' (should be address of number) */\n    /* TODO: Print the value that number_ptr points to using *number_ptr */\n    /* Use printk(KERN_INFO \"...\", ...) for each line */\n    /* Example format: \"Number value: %d\", number */\n}\n\n/* TODO: Implement function to modify value through pointer */\nvoid modify_through_pointer(int *ptr, int new_value) {\n    /* TODO: Check if ptr is not NULL */\n    /* TODO: Use *ptr = new_value to modify the value at the address */\n    /* TODO: Print confirmation message with new value */\n    /* Format: \"Modified value through pointer to: %d\" */\n}\n\n/* TODO: Implement function to print array elements through pointer */\nvoid print_array_through_pointer(int *ptr) {\n    /* TODO: Print first element using *ptr */\n    /* TODO: Print second element using *(ptr + 1) */\n    /* TODO: Print third element using *(ptr + 2) */\n    /* Use format: \"Array element %d: %d\" where first %d is position (0,1,2) */\n    /* This demonstrates basic pointer arithmetic */\n}\n\nstatic int __init basic_pointers_init(void)\n{\n    printk(KERN_INFO \"Basic pointers module loaded\\n\");\n    \n    /* Step 1: Initialize pointers */\n    number = test_value;  /* Use dynamic test value */\n    number_ptr = &number;  /* Point to number variable */\n    array_ptr = array;     /* Point to first element of array */\n    \n    printk(KERN_INFO \"=== Basic Pointer Demonstration ===\");\n    \n    /* Step 2: Show basic pointer information */\n    print_number_info();\n    \n    /* Step 3: Modify value through pointer */\n    modify_through_pointer(number_ptr, 999);\n    \n    /* Step 4: Show array access through pointer */\n    printk(KERN_INFO \"Array elements through pointer:\");\n    print_array_through_pointer(array_ptr);\n    \n    /* Step 5: Show final state */\n    printk(KERN_INFO \"Final number value: %d\", number);\n    \n    return 0;\n}\n\nstatic void __exit basic_pointers_exit(void)\n{\n    printk(KERN_INFO \"Basic pointers module unloaded\\n\");\n    \n    /* Reset pointers to NULL for safety */\n    number_ptr = NULL;\n    array_ptr = NULL;\n}\n\nmodule_init(basic_pointers_init);\nmodule_exit(basic_pointers_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning basic pointer concepts with integers and arrays\");\nMODULE_VERSION(\"1.0\");",
      "readOnly": false,
      "language": "c"
    },
    {
      "name": "Makefile", 
      "content": "# Basic pointers module Makefile\nobj-m += basic_pointers.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
      "readOnly": true,
      "language": "makefile"
    }
  ],
  "concepts": [
    "basic pointer declaration",
    "address-of operator (&)",
    "dereference operator (*)",
    "pointer initialization",
    "array access through pointers",
    "modifying values through pointers"
  ],
  "skills": [
    "Understanding what pointers are",
    "Declaring and initializing pointers",
    "Using & to get addresses",
    "Using * to access values through pointers",
    "Basic pointer arithmetic with arrays",
    "Modifying variables through pointers"
  ],
  "validation": {
    "exactRequirements": {
      "functionNames": [
        "basic_pointers_init",
        "basic_pointers_exit", 
        "print_number_info",
        "modify_through_pointer",
        "print_array_through_pointer"
      ],
      "function_declarations": [
        {
          "name": "print_number_info",
          "returnType": "void",
          "parameters": []
        },
        {
          "name": "modify_through_pointer", 
          "returnType": "void",
          "parameters": [
            "int *ptr",
            "int new_value"
          ]
        },
        {
          "name": "print_array_through_pointer",
          "returnType": "void", 
          "parameters": [
            "int *ptr"
          ]
        }
      ],
      "variables_declarations": [
        {
          "name": "number",
          "type": "int",
          "storageClass": "extern"
        },
        {
          "name": "array",
          "type": "int",
          "storageClass": "extern"
        },
        {
          "name": "number_ptr",
          "type": "int *",
          "storageClass": "extern"
        },
        {
          "name": "array_ptr",
          "type": "int *", 
          "storageClass": "extern"
        }
      ],
      "variables": [
        {
          "name": "number",
          "type": "int",
          "value": "42",
          "storageClass": "none"
        },
        {
          "name": "array",
          "type": "int",
          "value": "{10, 20, 30, 40, 50}",
          "storageClass": "none"
        },
        {
          "name": "number_ptr",
          "type": "int *",
          "value": "NULL",
          "storageClass": "none"
        },
        {
          "name": "array_ptr",
          "type": "int *",
          "value": "NULL", 
          "storageClass": "none"
        }
      ],
      "outputMessages": [
        "Basic pointers module loaded",
        "=== Basic Pointer Demonstration ===",
        "Number value: 42",
        "Modified value through pointer to: 999",
        "Array elements through pointer:",
        "Array element 0: 10",
        "Array element 1: 20", 
        "Array element 2: 30",
        "Final number value: 999",
        "Basic pointers module unloaded"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/types.h"
      ],
      "mustContain": [
        "&number",
        "*number_ptr",
        "number_ptr = &number",
        "array_ptr = array",
        "*(ptr + 1)",
        "*(ptr + 2)",
        "*ptr = new_value",
        "module_param(test_value, int, 0644)"
      ],
      "moduleInfo": {
        "license": "GPL"
      }
    },
    "testCases": [
      {
        "id": "function_declarations",
        "name": "Function Declarations in Header",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "void print_number_info(void)",
          "void modify_through_pointer(int *ptr, int new_value)",
          "void print_array_through_pointer(int *ptr)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "function_signatures_source",
        "name": "Function Signatures in Source File", 
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "void print_number_info(void)",
          "void modify_through_pointer(int *ptr, int new_value)",
          "void print_array_through_pointer(int *ptr)",
          "static int __init basic_pointers_init(void)",
          "static void __exit basic_pointers_exit(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "exact_output",
        "name": "Exact Output Messages",
        "type": "output_match",
        "critical": true,
        "expected": [
          {
            "pattern": "Basic pointers module loaded",
            "exact": true,
            "linkedFunction": "static int __init basic_pointers_init(void)"
          },
          {
            "pattern": "=== Basic Pointer Demonstration ===",
            "exact": true,
            "linkedFunction": "static int __init basic_pointers_init(void)"
          },
          {
            "pattern": "Number value: 42",
            "exact": true,
            "linkedFunction": "void print_number_info(void)"
          },
          {
            "pattern": "Modified value through pointer to: 999",
            "exact": true,
            "linkedFunction": "void modify_through_pointer(int *ptr, int new_value)"
          },
          {
            "pattern": "Array elements through pointer:",
            "exact": true,
            "linkedFunction": "static int __init basic_pointers_init(void)"
          },
          {
            "pattern": "Array element 0: 10",
            "exact": true,
            "linkedFunction": "void print_array_through_pointer(int *ptr)"
          },
          {
            "pattern": "Array element 1: 20",
            "exact": true,
            "linkedFunction": "void print_array_through_pointer(int *ptr)"
          },
          {
            "pattern": "Array element 2: 30",
            "exact": true,
            "linkedFunction": "void print_array_through_pointer(int *ptr)"
          },
          {
            "pattern": "Final number value: 999",
            "exact": true,
            "linkedFunction": "static int __init basic_pointers_init(void)"
          },
          {
            "pattern": "Basic pointers module unloaded",
            "exact": true,
            "linkedFunction": "static void __exit basic_pointers_exit(void)"
          }
        ]
      },
      {
        "id": "basic_pointer_validation",
        "name": "Basic Pointer Operations with Anti-Hardcoding Protection",
        "type": "kernel_project_test",
        "critical": true,
        "testScenario": {
          "userspaceApps": [
            {
              "name": "basic_pointer_tester",
              "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Basic Pointer Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate unpredictable test values\\n    int random_value = (rand() % 900) + 100;  // 100-999\\n    \\n    printf(\\\"Test 1: Random pointer operations (value=%d)\\\\n\\\", random_value);\\n    \\n    // Test with random values\\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod basic_pointers 2>/dev/null\\\");\\n    \\n    char cmd[256];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/basic_pointers.ko test_value=%d\\\", random_value);\\n    printf(\\\"DEBUG: Command: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Anti-hardcoding basic pointer test completed\\\\n\\\");\\n    return 0;\\n}"
            }
          ],
          "setupCommands": [
            "echo 'Starting basic pointer implementation validation'"
          ],
          "testCommands": [
            "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
            "echo 'Creating minimal kernel header stubs for TCC...'",
            "mkdir -p /tmp/linux",
            "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
            "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
            "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
            "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
            "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
            "echo '#define module_init(x)' >> /tmp/linux/module.h",
            "echo '#define module_exit(x)' >> /tmp/linux/module.h",
            "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
            "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
            "echo '#define __init' > /tmp/linux/init.h",
            "echo '#define __exit' >> /tmp/linux/init.h",
            "echo 'typedef unsigned char uint8_t;' > /tmp/linux/types.h",
            "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
            "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
            "echo 'Creating test file that includes basic pointers header...'",
            "echo '#include \"/lib/modules/basic_pointers.h\"' > /tmp/test.c",
            "echo 'int main() { number = 123; print_number_info(); modify_through_pointer(&number, 456); print_array_through_pointer(array); return 0; }' >> /tmp/test.c",
            "echo 'Running TCC validation...'",
            "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
            "TCC_EXIT_CODE=$?",
            "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
            "echo 'Phase 2: Anti-Hardcoding Dynamic Basic Pointer Test'",
            "/bin/basic_pointer_tester > /tmp/test_output.log",
            "cat /tmp/test_output.log",
            "echo 'Phase 3: Random Value Extraction and Validation'",
            "echo 'Adding delay to ensure dmesg messages are written...'",
            "sleep 1",
            "echo 'Extracting random test values from output...'",
            "TEST_VALUE=$(grep -o 'Random pointer operations (value=[0-9]*)' /tmp/test_output.log | cut -d'=' -f2 | cut -d')' -f1)",
            "echo 'Extracted values: TEST_VALUE='$TEST_VALUE",
            "if [ -z \"$TEST_VALUE\" ]; then echo 'FAIL: Could not extract random test values'; else echo 'PASS: Random values extracted successfully'; fi",
            "echo 'Phase 4: Anti-Hardcoding Validation with Random Values'",
            "echo 'Validating basic pointer operations with random value '$TEST_VALUE",
            "dmesg | grep \"Number value: $TEST_VALUE\" && echo 'PASS: Basic pointer dereference with random value working' || echo 'FAIL: Basic pointer dereference with random value broken'",
            "echo 'Phase 5: Static Field Validation (Non-Randomized Fields)'",
            "dmesg | grep 'Modified value through pointer to: 999' && echo 'PASS: Pointer modification working' || echo 'FAIL: Pointer modification broken'",
            "dmesg | grep 'Array element 0: 10' && echo 'PASS: Array pointer access working' || echo 'FAIL: Array pointer access broken'",
            "dmesg | grep 'Array element 1: 20' && echo 'PASS: Pointer arithmetic working' || echo 'FAIL: Pointer arithmetic broken'",
            "dmesg | grep 'Final number value: 999' && echo 'PASS: Pointer modification persistent' || echo 'FAIL: Pointer modification not persistent'",
            "echo 'Phase 6: Basic Pointer Logic Validation'",
            "dmesg | grep '=== Basic Pointer Demonstration ===' && echo 'PASS: Module demonstration working' || echo 'FAIL: Module demonstration broken'",
            "dmesg | grep 'Basic pointers module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
            "dmesg | grep 'Basic pointers module unloaded' && echo 'PASS: Module cleanup working' || echo 'FAIL: Module cleanup broken'",
            "echo 'Phase 7: Final Validation Summary'",
            "echo 'All phases completed successfully - anti-hardcoding basic pointer protection verified'",
            "echo 'PASS: All anti-hardcoding basic pointer validation successful'"
          ],
          "expected": {
            "dmesg": [
              "Basic pointers module loaded",
              "=== Basic Pointer Demonstration ===",
              "Number value: .*",
              "Modified value through pointer to: 999",
              "Array elements through pointer:",
              "Array element 0: 10",
              "Array element 1: 20",
              "Array element 2: 30",
              "Final number value: 999",
              "Basic pointers module unloaded"
            ],
            "stdout": [
              "PASS: All function and variable declarations found in header file",
              "SUCCESS: Anti-hardcoding basic pointer test completed",
              "PASS: Random values extracted successfully",
              "PASS: Basic pointer dereference with random value working",
              "PASS: Pointer modification working",
              "PASS: Array pointer access working",
              "PASS: Pointer arithmetic working",
              "PASS: Pointer modification persistent",
              "PASS: Module demonstration working",
              "PASS: Module initialization working",
              "PASS: Module cleanup working",
              "PASS: All anti-hardcoding basic pointer validation successful"
            ]
          },
          "timeout": 15
        }
      }
    ]
  }
}