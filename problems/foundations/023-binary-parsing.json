{
  "id": 23,
  "title": "Raw Byte Parsing - Binary Data Extraction",
  "phase": "foundations",
  "difficulty": 8,
  "xp": 75,
  "description": "Master sequential byte parsing and pointer arithmetic to extract structured data from raw binary buffers. Learn the fundamental techniques used in all production kernel parsers (STDF, network protocols, file formats) to convert raw bytes into meaningful data types.",
  "mainFile": "binary_parser.c",
  "files": [
    {
      "name": "binary_parser.h",
      "content": "#ifndef BINARY_PARSER_H\n#define BINARY_PARSER_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#define MAX_NAME_LEN 32\n#define RECORD_HEADER_SIZE 4\n\n/* Binary record structure (what we parse TO) */\ntypedef struct {\n    uint32_t sensor_id;\n    uint16_t measurement;\n    char sensor_name[MAX_NAME_LEN];\n    uint8_t name_length;\n} sensor_record;\n\n/* Global variables for testing */\nextern sensor_record *parsed_sensor;\nextern uint8_t *test_buffer;\nextern size_t buffer_size;\n\n/* Declare your parsing functions */\nuint32_t read_uint32_from_buffer(uint8_t **buffer_ptr);\nuint16_t read_uint16_from_buffer(uint8_t **buffer_ptr);\nchar* read_string_from_buffer(uint8_t **buffer_ptr, uint8_t *out_length);\nsensor_record* parse_sensor_record(uint8_t *raw_buffer);\nvoid print_parsed_record(sensor_record *record);\n\n#endif /* BINARY_PARSER_H */",
      "readOnly": false,
      "language": "h"
    },
    {
      "name": "binary_parser.c",
      "content": "#include \"binary_parser.h\"\n\n/* Global variables */\nsensor_record *parsed_sensor = NULL;\nuint8_t *test_buffer = NULL;\nsize_t buffer_size = 0;\n\nint test_sensor_id = 1001;\nint test_measurement = 255;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your byte parsing logic works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(test_sensor_id, int, 0644);\nMODULE_PARM_DESC(test_sensor_id, \"Sensor ID for anti-hardcoding testing\");\nmodule_param(test_measurement, int, 0644);\nMODULE_PARM_DESC(test_measurement, \"Measurement value for anti-hardcoding testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: How raw byte parsing works in production systems */\n/* This is the CORE technique used in all binary parsers:\n *\n * Raw Binary Buffer: [0x01][0x00][0x00][0x00][0xFF][0x00][0x0B][T][e][m][p]...\n *                     ↑ 4 bytes = uint32_t    ↑ 2 bytes = uint16_t   ↑ string\n *\n * Step 1: Read bytes sequentially using pointer arithmetic\n * Step 2: Convert raw bytes to proper data types\n * Step 3: Advance buffer pointer to next field\n * Step 4: Repeat until complete record is parsed\n */\n\n/* WHAT EACH PARSING FUNCTION DOES AND HOW TO USE IT: */\n\n/* 1. uint32_t read_uint32_from_buffer(uint8_t **buffer_ptr) */\n/*    Purpose: Read 4 consecutive bytes and convert to uint32_t */\n/*    Input: Pointer to buffer pointer (double pointer for modification) */\n/*    Output: 32-bit unsigned integer value */\n/*    Side Effect: Advances buffer_ptr by 4 bytes */\n/*    Usage: uint32_t id = read_uint32_from_buffer(&buffer_pos); */\n\n/* 2. uint16_t read_uint16_from_buffer(uint8_t **buffer_ptr) */\n/*    Purpose: Read 2 consecutive bytes and convert to uint16_t */\n/*    Input: Pointer to buffer pointer (double pointer for modification) */\n/*    Output: 16-bit unsigned integer value */\n/*    Side Effect: Advances buffer_ptr by 2 bytes */\n/*    Usage: uint16_t measurement = read_uint16_from_buffer(&buffer_pos); */\n\n/* 3. char* read_string_from_buffer(uint8_t **buffer_ptr, uint8_t *out_length) */\n/*    Purpose: Read length-prefixed string (1 byte length + string data) */\n/*    Input: Pointer to buffer pointer + pointer to store string length */\n/*    Output: Pointer to newly allocated string (caller must free) */\n/*    Side Effect: Advances buffer_ptr by (1 + string_length) bytes */\n/*    Usage: char* name = read_string_from_buffer(&buffer_pos, &len); */\n\n/* POINTER ARITHMETIC EXPLAINED IN DETAIL: */\n\n/* DOUBLE POINTER (**) - Why We Need It: */\n/* Function parameter: uint8_t **buffer_ptr */\n/*                     ↑ pointer to a pointer */\n/* */\n/* Why double pointer? We need to MODIFY the caller's pointer! */\n/* */\n/* WRONG approach (single pointer): */\n/* void bad_function(uint8_t *buffer_ptr) { */\n/*     buffer_ptr += 4;  // Only modifies LOCAL copy */\n/* } */\n/* // Caller's pointer unchanged - BAD! */\n/* */\n/* CORRECT approach (double pointer): */\n/* void good_function(uint8_t **buffer_ptr) { */\n/*     *buffer_ptr += 4;  // Modifies caller's actual pointer */\n/* } */\n/* // Caller's pointer advanced by 4 bytes - GOOD! */\n\n/* POINTER ARITHMETIC OPERATIONS: */\n/* uint8_t *ptr = buffer;           // ptr points to buffer[0] */\n/* ptr += 4;                        // ptr now points to buffer[4] */\n/* uint32_t value = *(uint32_t*)ptr; // Read 4 bytes as uint32_t */\n/* */\n/* STEP BY STEP: */\n/* 1. ptr points to memory address (e.g., 0x1000) */\n/* 2. ptr += 4 changes ptr to point to (0x1000 + 4 = 0x1004) */\n/* 3. *(uint32_t*)ptr reads 4 bytes starting at 0x1004 */\n/* 4. Bytes are interpreted as uint32_t (little-endian) */\n\n/* CASTING FOR TYPE CONVERSION: */\n/* *(uint32_t*)ptr means: */\n/*   1. Cast ptr (uint8_t*) to (uint32_t*) */\n/*   2. Dereference (*) to read the value */\n/*   3. Result: 4 bytes interpreted as uint32_t */\n/* */\n/* *(uint16_t*)ptr means: */\n/*   1. Cast ptr (uint8_t*) to (uint16_t*) */\n/*   2. Dereference (*) to read the value */\n/*   3. Result: 2 bytes interpreted as uint16_t */\n\n/* MEMORY LAYOUT VISUALIZATION: */\n/* Binary Buffer: [0x01][0x00][0x00][0x00][0xFF][0x00][0x0B][T][e][m][p] */\n/* Address:        0x1000              0x1004  0x1006 0x1007         */\n/* */\n/* Reading uint32_t at 0x1000: */\n/* Bytes: [0x01][0x00][0x00][0x00] = 0x00000001 (little-endian) = 1 */\n/* */\n/* Reading uint16_t at 0x1004: */\n/* Bytes: [0xFF][0x00] = 0x00FF (little-endian) = 255 */\n/* */\n/* Reading string at 0x1006: */\n/* Length byte: [0x0B] = 11 */\n/* String data: [T][e][m][p]... = \"Temp_Sensor\" */\n\n/* BUFFER POINTER ADVANCEMENT PATTERN: */\n/* uint8_t *buffer_pos = raw_buffer;                    // Start at beginning */\n/* uint32_t id = read_uint32_from_buffer(&buffer_pos);  // buffer_pos += 4 */\n/* uint16_t val = read_uint16_from_buffer(&buffer_pos); // buffer_pos += 2 */\n/* char *name = read_string_from_buffer(&buffer_pos);   // buffer_pos += (1 + len) */\n/* // Now buffer_pos points to next record (if any) */\n\n/* LITTLE-ENDIAN BYTE ORDER EXPLAINED: */\n/* Intel/ARM processors use little-endian: least significant byte first */\n/* */\n/* Number 1 (0x00000001) stored as: [0x01][0x00][0x00][0x00] */\n/* Number 255 (0x00FF) stored as: [0xFF][0x00] */\n/* */\n/* When we cast and dereference, CPU automatically handles endianness */\n\n/* COMMON MISTAKES AND SOLUTIONS: */\n/* MISTAKE 1: Using single pointer instead of double pointer */\n/*   void read_data(uint8_t *ptr) { ptr += 4; }  // WRONG - doesn't modify caller */\n/* SOLUTION: */\n/*   void read_data(uint8_t **ptr) { *ptr += 4; }  // CORRECT - modifies caller */\n/* */\n/* MISTAKE 2: Forgetting to advance pointer */\n/*   uint32_t val = *(uint32_t*)*buffer_ptr;  // Read value */\n/*   // Forgot: *buffer_ptr += 4;              // WRONG - pointer not advanced */\n/* SOLUTION: Always advance after reading */\n/* */\n/* MISTAKE 3: Wrong casting or dereferencing */\n/*   uint32_t val = (uint32_t)*buffer_ptr;    // WRONG - casts pointer address */\n/* SOLUTION: */\n/*   uint32_t val = *(uint32_t*)*buffer_ptr;  // CORRECT - reads 4 bytes as uint32_t */\n\n/* PRODUCTION PATTERN EXAMPLES: */\n/* This exact pattern is used in: */\n/* - STDF parsers (semiconductor test data) */\n/* - Network protocol parsers (TCP/IP headers) */\n/* - File format parsers (ELF, PE, etc.) */\n/* - Device driver data processing */\n/* - Kernel message parsing */\n\n/* TODO: Implement byte reading function */\nuint32_t read_uint32_from_buffer(uint8_t **buffer_ptr) {\n    /* TODO: Read 4 bytes from buffer as uint32_t */\n    /* TODO: Cast *buffer_ptr to uint32_t* and dereference to get value */\n    /* TODO: Advance *buffer_ptr by 4 bytes for next read */\n    /* TODO: Return the uint32_t value */\n    return 0;\n}\n\n/* TODO: Implement byte reading function */\nuint16_t read_uint16_from_buffer(uint8_t **buffer_ptr) {\n    /* TODO: Read 2 bytes from buffer as uint16_t */\n    /* TODO: Cast *buffer_ptr to uint16_t* and dereference to get value */\n    /* TODO: Advance *buffer_ptr by 2 bytes for next read */\n    /* TODO: Return the uint16_t value */\n    return 0;\n}\n\n/* TODO: Implement string reading function */\nchar* read_string_from_buffer(uint8_t **buffer_ptr, uint8_t *out_length) {\n    /* TODO: Read first byte as string length */\n    /* TODO: Allocate memory for string using kmalloc(length + 1, GFP_KERNEL) */\n    /* TODO: Copy string data from buffer to allocated memory */\n    /* TODO: Add null terminator to string */\n    /* TODO: Advance *buffer_ptr by (1 + length) bytes */\n    /* TODO: Store length in *out_length */\n    /* TODO: Return pointer to allocated string */\n    return NULL;\n}\n\n/* TODO: Implement complete record parsing */\nsensor_record* parse_sensor_record(uint8_t *raw_buffer) {\n    /* TODO: Allocate memory for sensor_record using kmalloc */\n    /* TODO: Create buffer position pointer: uint8_t *buffer_pos = raw_buffer */\n    /* TODO: Use read_uint32_from_buffer to read sensor_id */\n    /* TODO: Use read_uint16_from_buffer to read measurement */\n    /* TODO: Use read_string_from_buffer to read sensor_name and name_length */\n    /* TODO: Copy string to record->sensor_name (max MAX_NAME_LEN-1 chars) */\n    /* TODO: Free the temporary string from read_string_from_buffer */\n    /* TODO: Return the populated sensor_record */\n    return NULL;\n}\n\nvoid print_parsed_record(sensor_record *record) {\n    if (!record) {\n        printk(KERN_ERR \"No record to print\\n\");\n        return;\n    }\n    \n    printk(KERN_INFO \"Parsed Binary Record:\\n\");\n    printk(KERN_INFO \"Sensor ID: %u\\n\", record->sensor_id);\n    printk(KERN_INFO \"Measurement: %u\\n\", record->measurement);\n    printk(KERN_INFO \"Sensor Name: %s\\n\", record->sensor_name);\n    printk(KERN_INFO \"Name Length: %u\\n\", record->name_length);\n}\n\n/* Helper function to create dynamic test buffer */\nstatic uint8_t* create_test_buffer(uint32_t sensor_id, uint16_t measurement) {\n    const char *sensor_name = \"Temp_Sensor\";\n    uint8_t name_len = strlen(sensor_name);\n    \n    buffer_size = 4 + 2 + 1 + name_len;  /* uint32_t + uint16_t + length + string */\n    test_buffer = kmalloc(buffer_size, GFP_KERNEL);\n    if (!test_buffer) {\n        return NULL;\n    }\n    \n    uint8_t *pos = test_buffer;\n    \n    /* Write sensor_id (4 bytes, little-endian) */\n    *(uint32_t*)pos = sensor_id;\n    pos += 4;\n    \n    /* Write measurement (2 bytes, little-endian) */\n    *(uint16_t*)pos = measurement;\n    pos += 2;\n    \n    /* Write string length (1 byte) */\n    *pos = name_len;\n    pos += 1;\n    \n    /* Write string data */\n    memcpy(pos, sensor_name, name_len);\n    \n    return test_buffer;\n}\n\nstatic int __init binary_parser_init(void)\n{\n    printk(KERN_INFO \"Binary parser module loaded\\n\");\n    \n    /* Create test buffer with dynamic parameter values */\n    if (!create_test_buffer(test_sensor_id, test_measurement)) {\n        printk(KERN_ERR \"Failed to create test buffer\\n\");\n        return -ENOMEM;\n    }\n    \n    printk(KERN_INFO \"Created binary buffer with sensor_id=%d, measurement=%d\\n\", \n           test_sensor_id, test_measurement);\n    \n    /* Parse the binary record */\n    parsed_sensor = parse_sensor_record(test_buffer);\n    if (!parsed_sensor) {\n        printk(KERN_ERR \"Failed to parse sensor record\\n\");\n        kfree(test_buffer);\n        return -EINVAL;\n    }\n    \n    /* Print results */\n    print_parsed_record(parsed_sensor);\n    \n    return 0;\n}\n\nstatic void __exit binary_parser_exit(void)\n{\n    printk(KERN_INFO \"Binary parser module unloaded\\n\");\n    \n    /* Clean up allocated memory */\n    if (parsed_sensor) {\n        kfree(parsed_sensor);\n        parsed_sensor = NULL;\n    }\n    \n    if (test_buffer) {\n        kfree(test_buffer);\n        test_buffer = NULL;\n    }\n}\n\nmodule_init(binary_parser_init);\nmodule_exit(binary_parser_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning raw byte parsing and pointer arithmetic for binary data extraction\");\nMODULE_VERSION(\"1.0\");",
      "readOnly": false,
      "language": "c"
    },
    {
      "name": "Makefile",
      "content": "# Binary parser module Makefile\nobj-m += binary_parser.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
      "readOnly": true,
      "language": "makefile"
    }
  ],
  "concepts": [
    "raw byte parsing",
    "pointer arithmetic",
    "sequential data extraction",
    "double pointer modification",
    "binary data type conversion",
    "production parsing patterns"
  ],
  "skills": [
    "Reading bytes sequentially with pointer arithmetic",
    "Converting raw bytes to proper data types",
    "Using double pointers to modify caller's pointer",
    "Implementing production-style binary parsers",
    "Understanding little-endian byte order",
    "Memory management in parsing contexts"
  ],
  "validation": {
    "exactRequirements": {
      "functionNames": [
        "binary_parser_init",
        "binary_parser_exit",
        "read_uint32_from_buffer",
        "read_uint16_from_buffer", 
        "read_string_from_buffer",
        "parse_sensor_record",
        "print_parsed_record"
      ],
      "function_declarations": [
        {
          "name": "read_uint32_from_buffer",
          "returnType": "uint32_t",
          "parameters": [
            "uint8_t **buffer_ptr"
          ]
        },
        {
          "name": "read_uint16_from_buffer", 
          "returnType": "uint16_t",
          "parameters": [
            "uint8_t **buffer_ptr"
          ]
        },
        {
          "name": "read_string_from_buffer",
          "returnType": "char*",
          "parameters": [
            "uint8_t **buffer_ptr",
            "uint8_t *out_length"
          ]
        },
        {
          "name": "parse_sensor_record",
          "returnType": "sensor_record*",
          "parameters": [
            "uint8_t *raw_buffer"
          ]
        },
        {
          "name": "print_parsed_record",
          "returnType": "void",
          "parameters": [
            "sensor_record *record"
          ]
        }
      ],
      "variables_declarations": [
        {
          "name": "sensor_record",
          "type": "typedef struct",
          "value": "{uint32_t sensor_id; uint16_t measurement; char sensor_name[MAX_NAME_LEN]; uint8_t name_length;}",
          "storageClass": "none"
        },
        {
          "name": "parsed_sensor",
          "type": "sensor_record *",
          "storageClass": "extern"
        },
        {
          "name": "test_buffer",
          "type": "uint8_t *",
          "storageClass": "extern"
        }
      ],
      "variables": [
        {
          "name": "parsed_sensor",
          "type": "sensor_record *",
          "value": "NULL",
          "storageClass": "none"
        },
        {
          "name": "test_buffer",
          "type": "uint8_t *",
          "value": "NULL",
          "storageClass": "none"
        }
      ],
      "outputMessages": [
        "Binary parser module loaded",
        "Created binary buffer with sensor_id=1001, measurement=255",
        "Parsed Binary Record:",
        "Sensor ID: 1001",
        "Measurement: 255", 
        "Sensor Name: Temp_Sensor",
        "Name Length: 11",
        "Binary parser module unloaded"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h", 
        "linux/init.h",
        "linux/types.h",
        "linux/slab.h"
      ],
      "mustContain": [
        "*(uint32_t*)*buffer_ptr",
        "*buffer_ptr += 4",
        "*(uint16_t*)*buffer_ptr", 
        "*buffer_ptr += 2",
        "kmalloc",
        "kfree",
        "read_uint32_from_buffer(&buffer_pos)",
        "read_uint16_from_buffer(&buffer_pos)",
        "read_string_from_buffer(&buffer_pos",
        "module_param(test_sensor_id, int, 0644)",
        "module_param(test_measurement, int, 0644)"
      ],
      "moduleInfo": {
        "license": "GPL"
      }
    },
    "testCases": [
      {
        "id": "function_declarations",
        "name": "Function Declarations in Header",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "uint32_t read_uint32_from_buffer(uint8_t **buffer_ptr)",
          "uint16_t read_uint16_from_buffer(uint8_t **buffer_ptr)",
          "char* read_string_from_buffer(uint8_t **buffer_ptr, uint8_t *out_length)",
          "sensor_record* parse_sensor_record(uint8_t *raw_buffer)",
          "void print_parsed_record(sensor_record *record)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "function_signatures_source",
        "name": "Function Signatures in Source File",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "uint32_t read_uint32_from_buffer(uint8_t **buffer_ptr)",
          "uint16_t read_uint16_from_buffer(uint8_t **buffer_ptr)",
          "char* read_string_from_buffer(uint8_t **buffer_ptr, uint8_t *out_length)",
          "sensor_record* parse_sensor_record(uint8_t *raw_buffer)",
          "void print_parsed_record(sensor_record *record)",
          "static int __init binary_parser_init(void)",
          "static void __exit binary_parser_exit(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "exact_output",
        "name": "Exact Output Messages",
        "type": "output_match",
        "critical": true,
        "expected": [
          {
            "pattern": "Binary parser module loaded",
            "exact": true,
            "linkedFunction": "static int __init binary_parser_init(void)"
          },
          {
            "pattern": "Created binary buffer with sensor_id=1001, measurement=255",
            "exact": true,
            "linkedFunction": "static int __init binary_parser_init(void)"
          },
          {
            "pattern": "Parsed Binary Record:",
            "exact": true,
            "linkedFunction": "void print_parsed_record(sensor_record *record)"
          },
          {
            "pattern": "Sensor ID: 1001",
            "exact": true,
            "linkedFunction": "void print_parsed_record(sensor_record *record)"
          },
          {
            "pattern": "Measurement: 255",
            "exact": true,
            "linkedFunction": "void print_parsed_record(sensor_record *record)"
          },
          {
            "pattern": "Sensor Name: Temp_Sensor",
            "exact": true,
            "linkedFunction": "void print_parsed_record(sensor_record *record)"
          },
          {
            "pattern": "Name Length: 11",
            "exact": true,
            "linkedFunction": "void print_parsed_record(sensor_record *record)"
          },
          {
            "pattern": "Binary parser module unloaded",
            "exact": true,
            "linkedFunction": "static void __exit binary_parser_exit(void)"
          }
        ]
      },
      {
        "id": "advanced_byte_parsing_validation",
        "name": "Advanced Byte Parsing with Anti-Hardcoding Protection",
        "type": "kernel_project_test",
        "critical": true,
        "testScenario": {
          "userspaceApps": [
            {
              "name": "byte_parsing_dynamic_tester",
              "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Anti-Hardcoding Byte Parsing Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate unpredictable test values\\n    int random_sensor_id = (rand() % 9000) + 1000;  // 1000-9999\\n    int random_measurement = (rand() % 500) + 100;   // 100-599\\n    \\n    printf(\\\"Test 1: Random byte parsing (sensor_id=%d, measurement=%d)\\\\n\\\", random_sensor_id, random_measurement);\\n    \\n    // Test with random values\\n    printf(\\\"DEBUG: Unloading previous module...\\\\n\\\");\\n    system(\\\"rmmod binary_parser 2>/dev/null\\\");\\n    \\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/binary_parser.ko test_sensor_id=%d test_measurement=%d\\\", random_sensor_id, random_measurement);\\n    printf(\\\"DEBUG: Command: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Anti-hardcoding byte parsing test completed\\\\n\\\");\\n    return 0;\\n}"
            }
          ],
          "setupCommands": [
            "echo 'Starting advanced byte parsing implementation validation'"
          ],
          "testCommands": [
            "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
            "echo 'Creating minimal kernel header stubs for TCC...'",
            "mkdir -p /tmp/linux",
            "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
            "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
            "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
            "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
            "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
            "echo '#define module_init(x)' >> /tmp/linux/module.h",
            "echo '#define module_exit(x)' >> /tmp/linux/module.h",
            "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
            "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
            "echo '#define __init' > /tmp/linux/init.h",
            "echo '#define __exit' >> /tmp/linux/init.h",
            "echo 'typedef unsigned char uint8_t;' > /tmp/linux/types.h",
            "echo 'typedef unsigned short uint16_t;' >> /tmp/linux/types.h",
            "echo 'typedef unsigned int uint32_t;' >> /tmp/linux/types.h",
            "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
            "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
            "echo 'void* kmalloc(size_t size, int flags);' > /tmp/linux/slab.h",
            "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
            "echo '#define GFP_KERNEL 0' >> /tmp/linux/slab.h",
            "echo 'void* memcpy(void *dest, const void *src, size_t n);' >> /tmp/linux/slab.h",
            "echo 'size_t strlen(const char *s);' >> /tmp/linux/slab.h",
            "echo 'void* memcpy(void *dest, const void *src, size_t n);' > /tmp/linux/string.h",
            "echo 'size_t strlen(const char *s);' >> /tmp/linux/string.h",
            "echo 'char* strcpy(char *dest, const char *src);' >> /tmp/linux/string.h",
            "echo 'Creating test file that includes byte parsing header...'",
            "echo '#include \"/lib/modules/binary_parser.h\"' > /tmp/test.c",
            "echo 'int main() { uint8_t *buf; uint8_t len; parsed_sensor = (sensor_record*)0; read_uint32_from_buffer(&buf); read_uint16_from_buffer(&buf); read_string_from_buffer(&buf, &len); parse_sensor_record(buf); print_parsed_record((sensor_record*)0); return 0; }' >> /tmp/test.c",
            "echo 'Running TCC validation...'",
            "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
            "TCC_EXIT_CODE=$?",
            "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
            "echo 'Phase 2: Anti-Hardcoding Dynamic Byte Parsing Test'",
            "/bin/byte_parsing_dynamic_tester > /tmp/test_output.log",
            "cat /tmp/test_output.log",
            "echo 'Phase 3: Random Value Extraction and Validation'",
            "echo 'Adding delay to ensure dmesg messages are written...'",
            "sleep 1",
            "echo 'Extracting random test values from output...'",
            "SENSOR_ID=$(grep -o 'Random byte parsing (sensor_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
            "MEASUREMENT=$(grep -o 'measurement=[0-9]*)' /tmp/test_output.log | cut -d'=' -f2 | cut -d')' -f1)",
            "echo 'Extracted values: SENSOR_ID='$SENSOR_ID', MEASUREMENT='$MEASUREMENT",
            "if [ -z \"$SENSOR_ID\" ] || [ -z \"$MEASUREMENT\" ]; then echo 'FAIL: Could not extract random test values'; else echo 'PASS: Random values extracted successfully'; fi",
            "echo 'Phase 4: Anti-Hardcoding Validation with Random Values'",
            "echo 'Validating sensor ID parsing with random value '$SENSOR_ID",
            "dmesg | grep \"Sensor ID: $SENSOR_ID\" && echo 'PASS: Sensor ID byte parsing with random value working' || echo 'FAIL: Sensor ID byte parsing with random value broken'",
            "echo 'Validating measurement parsing with random value '$MEASUREMENT",
            "dmesg | grep \"Measurement: $MEASUREMENT\" && echo 'PASS: Measurement byte parsing with random value working' || echo 'FAIL: Measurement byte parsing with random value broken'",
            "echo 'Phase 5: Static Field Validation (Non-Randomized Fields)'",
            "dmesg | grep 'Sensor Name: Temp_Sensor' && echo 'PASS: String parsing working' || echo 'FAIL: String parsing broken'",
            "dmesg | grep 'Name Length: 11' && echo 'PASS: String length parsing working' || echo 'FAIL: String length parsing broken'",
            "echo 'Phase 6: Byte Parsing Logic Validation'",
            "dmesg | grep 'Parsed Binary Record:' && echo 'PASS: Record parsing logic working' || echo 'FAIL: Record parsing logic broken'",
            "dmesg | grep 'Binary parser module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
            "dmesg | grep 'Binary parser module unloaded' && echo 'PASS: Module cleanup working' || echo 'FAIL: Module cleanup broken'",
            "echo 'Phase 7: Final Validation Summary'",
            "echo 'All phases completed successfully - anti-hardcoding byte parsing protection verified'",
            "echo 'PASS: All anti-hardcoding byte parsing validation successful'"
          ],
          "expected": {
            "dmesg": [
              "Binary parser module loaded",
              "Created binary buffer with sensor_id=.*, measurement=.*",
              "Parsed Binary Record:",
              "Sensor ID: .*",
              "Measurement: .*",
              "Sensor Name: Temp_Sensor",
              "Name Length: 11",
              "Binary parser module unloaded"
            ],
            "stdout": [
              "PASS: All function and variable declarations found in header file",
              "SUCCESS: Anti-hardcoding byte parsing test completed",
              "PASS: Random values extracted successfully",
              "PASS: Sensor ID byte parsing with random value working",
              "PASS: Measurement byte parsing with random value working",
              "PASS: String parsing working",
              "PASS: String length parsing working",
              "PASS: Record parsing logic working",
              "PASS: Module initialization working",
              "PASS: Module cleanup working",
              "PASS: All anti-hardcoding byte parsing validation successful"
            ]
          },
          "timeout": 15
        }
      }
    ]
  }
}