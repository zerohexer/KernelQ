{
  "id": 18,
  "title": "Dynamic Memory - kmalloc and kfree Essentials",
  "phase": "foundations",
  "difficulty": 4,
  "xp": 40,
  "description": "Master the essential dynamic memory pattern: kmalloc(sizeof(Device), GFP_KERNEL) to allocate and kfree() to clean up. Learn the fundamental runtime allocation pattern used throughout kernel development.",
  "mainFile": "dynamic_memory.c",
  "files": [
    {
      "name": "dynamic_memory.h",
      "content": "#ifndef DYNAMIC_MEMORY_H\n#define DYNAMIC_MEMORY_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n\ntypedef struct {\n    int device_id;\n    int status;\n    bool is_active;\n} Device;\n\n/* Global device pointer - starts as NULL */\nextern Device *my_device;\n\n/* TODO: Declare your functions */\n/* Device* create_device(int id); */\n/* void print_device_info(Device* dev); */\n/* void cleanup_device(void); */\n\n#endif /* DYNAMIC_MEMORY_H */",
      "readOnly": false,
      "language": "h"
    },
    {
      "name": "dynamic_memory.c",
      "content": "#include \"dynamic_memory.h\"\n\n/* Global device pointer - starts as NULL */\nDevice *my_device = NULL;\n\nint device_id = 1001;\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your dynamic allocation works\n * with different input values. Removing them will cause test failures.\n */\nmodule_param(device_id, int, 0644);\nMODULE_PARM_DESC(device_id, \"Device ID for testing dynamic allocation\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* PATTERN SCAFFOLDING: How dynamic memory allocation works in C */\n/* Basic pattern for kmalloc and kfree:\n *\n * Device *ptr = kmalloc(sizeof(Device), GFP_KERNEL);  // Allocate memory\n * if (!ptr) {\n *     return -ENOMEM;  // Check for allocation failure\n * }\n * ptr->field = value;  // Use the allocated memory\n * kfree(ptr);  // Free the memory when done\n * ptr = NULL;  // Prevent accidental reuse\n *\n * This is the fundamental kernel memory pattern!\n */\n\n/* MEMORY OPERATORS: */\n/* kmalloc(size, flags) - allocates 'size' bytes, returns pointer */\n/* kfree(ptr) - frees memory pointed to by 'ptr' */\n/* GFP_KERNEL - standard allocation flag for kernel code */\n\n/* TODO: Implement device creation function */\nDevice* create_device(int id) {\n    printk(KERN_INFO \"Creating device with ID: %d\\n\", id);\n    \n    // Step 1: Allocate memory for one Device struct\n    /* TODO: my_device = kmalloc(sizeof(Device), GFP_KERNEL); */\n    \n    // Step 2: Check if allocation succeeded\n    if (!my_device) {\n        printk(KERN_ERR \"Failed to allocate device memory!\\n\");\n        return NULL;\n    }\n    \n    // Step 3: Initialize the allocated device\n    my_device->device_id = id;\n    my_device->status = 200;\n    my_device->is_active = true;\n    \n    printk(KERN_INFO \"Device allocated successfully!\\n\");\n    return my_device;\n}\n\n/* TODO: Implement device info function */\nvoid print_device_info(Device* dev) {\n    // Check if device pointer is valid\n    if (!dev) {\n        printk(KERN_ERR \"Cannot print info: device is NULL\\n\");\n        return;\n    }\n    \n    printk(KERN_INFO \"=== Device Info ===\\n\");\n    printk(KERN_INFO \"Device ID: %d\\n\", dev->device_id);\n    printk(KERN_INFO \"Status: %d\\n\", dev->status);\n    printk(KERN_INFO \"Active: %s\\n\", dev->is_active ? \"YES\" : \"NO\");\n}\n\n/* TODO: Implement cleanup function */\nvoid cleanup_device(void) {\n    if (my_device) {\n        printk(KERN_INFO \"Freeing device memory...\\n\");\n        /* TODO: kfree(my_device); */\n        my_device = NULL;  // Prevent accidental reuse\n        printk(KERN_INFO \"Device memory freed\\n\");\n    }\n}\n\nstatic int __init dynamic_memory_init(void)\n{\n    printk(KERN_INFO \"Dynamic memory module loaded\\n\");\n    printk(KERN_INFO \"Learning kmalloc and kfree!\\n\");\n    \n    /* Create device using runtime parameter */\n    my_device = create_device(device_id);\n    if (!my_device) {\n        printk(KERN_ERR \"Failed to create device\\n\");\n        return -ENOMEM;\n    }\n    \n    /* Print device information */\n    print_device_info(my_device);\n    \n    return 0;\n}\n\nstatic void __exit dynamic_memory_exit(void)\n{\n    printk(KERN_INFO \"Dynamic memory module unloading\\n\");\n    \n    /* Clean up allocated memory */\n    cleanup_device();\n    \n    printk(KERN_INFO \"Module unloaded cleanly\\n\");\n}\n\nmodule_init(dynamic_memory_init);\nmodule_exit(dynamic_memory_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning kmalloc and kfree essentials\");\nMODULE_VERSION(\"1.0\");",
      "readOnly": false,
      "language": "c"
    },
    {
      "name": "Makefile",
      "content": "# Dynamic memory module Makefile\nobj-m += dynamic_memory.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
      "readOnly": true,
      "language": "makefile"
    }
  ],
  "concepts": [
    "kmalloc() function and GFP_KERNEL",
    "kfree() function and memory cleanup", 
    "NULL pointer checking",
    "Error handling with -ENOMEM",
    "Memory lifecycle: allocate, use, free"
  ],
  "skills": [
    "Using kmalloc(sizeof(Device), GFP_KERNEL)",
    "Proper error handling for memory failures",
    "Cleaning up with kfree()",
    "Setting pointers to NULL after freeing"
  ],
  "validation": {
    "exactRequirements": {
      "functionNames": ["dynamic_memory_init", "dynamic_memory_exit", "create_device", "print_device_info", "cleanup_device"],
      "function_declarations": [
        { "name": "create_device", "returnType": "Device*", "parameters": ["int id"] },
        { "name": "print_device_info", "returnType": "void", "parameters": ["Device* dev"] },
        { "name": "cleanup_device", "returnType": "void", "parameters": [] }
      ],
      "variables_declarations": [
        { "name": "Device", "type": "typedef struct", "value": "{int device_id; int status; bool is_active;}", "storageClass": "none" },
        { "name": "my_device", "type": "Device *", "storageClass": "extern" }
      ],
      "variables": [
        { "name": "my_device", "type": "Device *", "value": "NULL", "storageClass": "none" }
      ],
      "outputMessages": [
        "Dynamic memory module loaded",
        "Learning kmalloc and kfree!",
        "Creating device with ID: 1001",
        "Device allocated successfully!",
        "=== Device Info ===",
        "Device ID: 1001",
        "Status: 200",
        "Active: YES",
        "Dynamic memory module unloading",
        "Device memory freed",
        "Module unloaded cleanly"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/types.h",
        "linux/slab.h",
        "linux/string.h"
      ],
      "mustContain": [
        "kmalloc(sizeof(Device), GFP_KERNEL)",
        "kfree(my_device)",
        "if (!my_device)",
        "my_device = NULL",
        "module_param(device_id, int, 0644)"
      ],
      "moduleInfo": {
        "license": "GPL"
      }
    },
    "testCases": [
      {
        "id": "function_declarations",
        "name": "Function Declarations in Header",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "Device* create_device(int id)",
          "void print_device_info(Device* dev)",
          "void cleanup_device(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "function_signatures_source",
        "name": "Function Signatures in Source File",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "Device* create_device(int id)",
          "void print_device_info(Device* dev)",
          "void cleanup_device(void)",
          "static int __init dynamic_memory_init(void)",
          "static void __exit dynamic_memory_exit(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "exact_output",
        "name": "Exact Output Messages",
        "type": "output_match",
        "critical": true,
        "expected": [
          { "pattern": "Dynamic memory module loaded", "exact": true, "linkedFunction": "static int __init dynamic_memory_init(void)" },
          { "pattern": "Learning kmalloc and kfree!", "exact": true, "linkedFunction": "static int __init dynamic_memory_init(void)" },
          { "pattern": "Creating device with ID: 1001", "exact": true, "linkedFunction": "Device* create_device(int id)" },
          { "pattern": "Device allocated successfully!", "exact": true, "linkedFunction": "Device* create_device(int id)" },
          { "pattern": "=== Device Info ===", "exact": true, "linkedFunction": "void print_device_info(Device* dev)" },
          { "pattern": "Device ID: 1001", "exact": true, "linkedFunction": "void print_device_info(Device* dev)" },
          { "pattern": "Status: 200", "exact": true, "linkedFunction": "void print_device_info(Device* dev)" },
          { "pattern": "Active: YES", "exact": true, "linkedFunction": "void print_device_info(Device* dev)" },
          { "pattern": "Dynamic memory module unloading", "exact": true, "linkedFunction": "static void __exit dynamic_memory_exit(void)" },
          { "pattern": "Device memory freed", "exact": true, "linkedFunction": "void cleanup_device(void)" },
          { "pattern": "Module unloaded cleanly", "exact": true, "linkedFunction": "static void __exit dynamic_memory_exit(void)" }
        ]
      },
      {
        "id": "advanced_dynamic_memory_validation",
        "name": "Advanced Dynamic Memory Implementation with TCC Header Validation",
        "type": "kernel_project_test",
        "critical": true,
        "testScenario": {
          "userspaceApps": [
            {
              "name": "memory_dynamic_tester",
              "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Memory Anti-Hardcoding Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random device IDs\\n    int test_device_id1 = (rand() % 9000) + 1000;   // 1000-9999\\n    int test_device_id2 = (rand() % 5000) + 20000;  // 20000-24999\\n    \\n    printf(\\\"Test 1: Testing kmalloc with device_id=%d\\\\n\\\", test_device_id1);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/dynamic_memory.ko device_id=%d\\\", test_device_id1);\\n    system(\\\"rmmod dynamic_memory 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    printf(\\\"Test 2: Testing kmalloc with device_id=%d\\\\n\\\", test_device_id2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/dynamic_memory.ko device_id=%d\\\", test_device_id2);\\n    system(\\\"rmmod dynamic_memory\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Anti-hardcoding memory test completed\\\\n\\\");\\n    return 0;\\n}"
            }
          ],
          "setupCommands": [
            "echo 'Starting advanced dynamic memory implementation validation'"
          ],
          "testCommands": [
            "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
            "echo 'Creating minimal kernel header stubs for TCC...'",
            "mkdir -p /tmp/linux",
            "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
            "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
            "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
            "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
            "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
            "echo '#define module_init(x)' >> /tmp/linux/module.h",
            "echo '#define module_exit(x)' >> /tmp/linux/module.h",
            "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
            "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
            "echo '#define __init' > /tmp/linux/init.h",
            "echo '#define __exit' >> /tmp/linux/init.h",
            "echo 'typedef int bool;' > /tmp/linux/types.h",
            "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
            "echo '#define true 1' >> /tmp/linux/types.h",
            "echo '#define false 0' >> /tmp/linux/types.h",
            "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
            "echo '#define MAX_DEVICES 5' >> /tmp/linux/types.h",
            "echo '#define GFP_KERNEL 0' > /tmp/linux/slab.h",
            "echo '#define ENOMEM 12' >> /tmp/linux/slab.h",
            "echo 'void *kmalloc(size_t size, int flags);' >> /tmp/linux/slab.h",
            "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
            "echo 'Creating test file that includes dynamic memory header...'",
            "echo '#include \"/lib/modules/dynamic_memory.h\"' > /tmp/test.c",
            "echo 'int main() { create_device(123); print_device_info(my_device); cleanup_device(); return 0; }' >> /tmp/test.c",
            "echo 'Running TCC validation...'",
            "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
            "TCC_EXIT_CODE=$?",
            "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
            "echo 'Phase 2: Anti-Hardcoding Dynamic Memory Testing'",
            "/bin/memory_dynamic_tester > /tmp/test_output.log",
            "cat /tmp/test_output.log",
            "echo 'Phase 3: Random Value Extraction and Validation'",
            "echo 'Adding delay to ensure dmesg messages are written...'",
            "sleep 1",
            "echo 'Extracting random test values from output...'",
            "DEVICE_ID1=$(grep -o 'Test 1: Testing kmalloc with device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
            "DEVICE_ID2=$(grep -o 'Test 2: Testing kmalloc with device_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2)",
            "echo 'Extracted values: DEVICE_ID1='$DEVICE_ID1', DEVICE_ID2='$DEVICE_ID2",
            "if [ -z \"$DEVICE_ID1\" ] || [ -z \"$DEVICE_ID2\" ]; then echo 'FAIL: Could not extract random test values'; else echo 'PASS: Random values extracted successfully'; fi",
            "echo 'Phase 4: Anti-Hardcoding Memory Allocation Validation'",
            "echo 'Validating kmalloc with random device ID '$DEVICE_ID1",
            "dmesg | grep \"Creating device with ID: $DEVICE_ID1\" && echo 'PASS: Device creation with random ID working' || echo 'FAIL: Device creation with random ID broken'",
            "dmesg | grep \"Device allocated successfully!\" && echo 'PASS: kmalloc allocation working' || echo 'FAIL: kmalloc allocation broken'",
            "dmesg | grep \"Device ID: $DEVICE_ID1\" && echo 'PASS: Device data access working with '$DEVICE_ID1 || echo 'FAIL: Device data access broken'",
            "echo 'Validating kmalloc with random device ID '$DEVICE_ID2",
            "dmesg | grep \"Creating device with ID: $DEVICE_ID2\" && echo 'PASS: Device creation with random ID working' || echo 'FAIL: Device creation with random ID broken'",
            "dmesg | grep \"Device ID: $DEVICE_ID2\" && echo 'PASS: Device data access working with '$DEVICE_ID2 || echo 'FAIL: Device data access broken'",
            "echo 'Phase 5: Memory Cleanup Validation'",
            "dmesg | grep 'Device memory freed' && echo 'PASS: kfree cleanup working' || echo 'FAIL: kfree cleanup broken'",
            "dmesg | grep 'Module unloaded cleanly' && echo 'PASS: Complete cleanup working' || echo 'FAIL: Complete cleanup broken'",
            "echo 'Phase 6: Function Logic Validation'",
            "dmesg | grep 'Learning kmalloc and kfree!' && echo 'PASS: Module messaging working' || echo 'FAIL: Module messaging broken'",
            "dmesg | grep 'Active: YES' && echo 'PASS: Device status working' || echo 'FAIL: Device status broken'",
            "echo 'Phase 7: Final Validation Summary'",
            "echo 'All phases completed successfully - kmalloc/kfree pattern verified'",
            "echo 'PASS: All anti-hardcoding memory validation successful'"
          ],
          "expected": {
            "dmesg": [
              "Dynamic memory module loaded",
              "Learning kmalloc and kfree!",
              "Creating device with ID: .*",
              "Device allocated successfully!",
              "Device ID: .*",
              "Active: YES",
              "Device memory freed",
              "Module unloaded cleanly"
            ],
            "stdout": [
              "PASS: All function and variable declarations found in header file",
              "SUCCESS: Anti-hardcoding memory test completed",
              "PASS: Random values extracted successfully",
              "PASS: Device creation with random ID working",
              "PASS: kmalloc allocation working",
              "PASS: Device data access working",
              "PASS: kfree cleanup working",
              "PASS: Complete cleanup working",
              "PASS: All anti-hardcoding memory validation successful"
            ]
          },
          "timeout": 15
        }
      }
    ]
  }
}
