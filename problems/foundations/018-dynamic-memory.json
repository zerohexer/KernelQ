{
  "id": 18,
  "title": "Dynamic Memory - Why and How to Allocate at Runtime",
  "phase": "foundations",
  "difficulty": 4,
  "xp": 40,
  "description": "Learn WHY and HOW to use dynamic memory allocation with kmalloc() and kfree(). Sometimes you don't know how much memory you need until runtime - static arrays can't solve this! Learn to allocate exactly what you need, when you need it, and properly clean up afterwards. This is essential for real kernel development where resource usage must adapt to system needs.",
  "mainFile": "dynamic_memory.c",
  "files": [
    {
      "name": "dynamic_memory.h",
      "content": "#ifndef DYNAMIC_MEMORY_H\n#define DYNAMIC_MEMORY_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#define MAX_NAME_LEN 32\n\n/* EDUCATIONAL CONTEXT: Why do we need dynamic allocation?\n * \n * PROBLEM WITH STATIC ALLOCATION:\n * static Device my_device;  // This is fixed at compile time!\n * \n * What if:\n * - User wants different device configurations at runtime?\n * - Number of devices depends on hardware detection?\n * - We want to save memory when devices aren't needed?\n * \n * SOLUTION: Dynamic allocation lets us create exactly what we need!\n */\n\ntypedef struct {\n    int device_id;\n    char name[MAX_NAME_LEN];\n    int status_code;\n    bool is_active;\n} Device;\n\n/* Global pointers for dynamic allocation - start as NULL */\nextern Device *primary_device;\nextern Device *backup_device;\nextern int device_count;\n\n/* TODO: Declare your functions */\n/* int create_primary_device(int id, const char *name); */\n/* int create_backup_device(int id, const char *name); */\n/* void print_device_info(Device *dev, const char *label); */\n/* void cleanup_devices(void); */\n\n#endif /* DYNAMIC_MEMORY_H */",
      "readOnly": false,
      "language": "h"
    },
    {
      "name": "dynamic_memory.c",
      "content": "#include \"dynamic_memory.h\"\n\n/* THE MAIN LESSON: These pointers start as NULL!\n * We don't have any memory allocated yet.\n * We must allocate it when we need it, and free it when done.\n */\nDevice *primary_device = NULL;  // No memory allocated yet!\nDevice *backup_device = NULL;   // No memory allocated yet!\nint device_count = 0;           // Track how many devices we created\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW!\n * These module parameter declarations are required for validation testing.\n * The testing system uses these to verify your dynamic allocation works\n * with different input values. Removing them will cause test failures.\n */\nstatic int primary_id = 1001;\nmodule_param(primary_id, int, 0644);\nMODULE_PARM_DESC(primary_id, \"Primary device ID for testing dynamic allocation\");\nstatic int backup_id = 2001;\nmodule_param(backup_id, int, 0644);\nMODULE_PARM_DESC(backup_id, \"Backup device ID for testing dynamic allocation\");\nstatic int enable_backup = 1;\nmodule_param(enable_backup, int, 0644);\nMODULE_PARM_DESC(enable_backup, \"Whether to create backup device (0=no, 1=yes)\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/* TODO: Complete this function - uncomment the kmalloc line */\nint create_primary_device(int id, const char *name) {\n    printk(KERN_INFO \"Creating primary device with ID=%d, Name=%s\\n\", id, name);\n    \n    // STEP 1: Allocate memory for exactly one Device struct\n    // This asks the kernel: \"Please give me enough memory for one Device\"\n    /* TODO: primary_device = kmalloc(sizeof(Device), GFP_KERNEL); */\n    \n    // STEP 2: Check if allocation succeeded\n    if (!primary_device) {\n        printk(KERN_ERR \"Failed to allocate primary device - not enough memory!\\n\");\n        return -ENOMEM;  // Return error code\n    }\n    \n    // STEP 3: Initialize the allocated memory\n    primary_device->device_id = id;\n    strncpy(primary_device->name, name, MAX_NAME_LEN - 1);\n    primary_device->name[MAX_NAME_LEN - 1] = '\\0';\n    primary_device->status_code = 200;  // Active status\n    primary_device->is_active = true;\n    \n    device_count++;\n    printk(KERN_INFO \"Primary device allocated successfully!\\n\");\n    return 0;  // Success\n}\n\n/* TODO: Complete this function - uncomment the kmalloc line */\nint create_backup_device(int id, const char *name) {\n    printk(KERN_INFO \"Creating backup device with ID=%d, Name=%s\\n\", id, name);\n    \n    // Same pattern: allocate, check, initialize\n    /* TODO: backup_device = kmalloc(sizeof(Device), GFP_KERNEL); */\n    \n    if (!backup_device) {\n        printk(KERN_ERR \"Failed to allocate backup device - not enough memory!\\n\");\n        return -ENOMEM;\n    }\n    \n    backup_device->device_id = id;\n    strncpy(backup_device->name, name, MAX_NAME_LEN - 1);\n    backup_device->name[MAX_NAME_LEN - 1] = '\\0';\n    backup_device->status_code = 404;  // Standby status\n    backup_device->is_active = false;\n    \n    device_count++;\n    printk(KERN_INFO \"Backup device allocated successfully!\\n\");\n    return 0;\n}\n\nvoid print_device_info(Device *dev, const char *label) {\n    // IMPORTANT: Always check pointers before using them!\n    if (!dev) {\n        printk(KERN_ERR \"Cannot print %s info: device is NULL (not allocated)\\n\", label);\n        return;\n    }\n    \n    printk(KERN_INFO \"=== %s Device Info ===\\n\", label);\n    printk(KERN_INFO \"Device ID: %d\\n\", dev->device_id);\n    printk(KERN_INFO \"Device Name: %s\\n\", dev->name);\n    printk(KERN_INFO \"Status Code: %d\\n\", dev->status_code);\n    printk(KERN_INFO \"Status: %s\\n\", dev->is_active ? \"ACTIVE\" : \"STANDBY\");\n}\n\n/* TODO: Complete this function - uncomment the kfree lines */\nvoid cleanup_devices(void) {\n    printk(KERN_INFO \"Starting device cleanup...\\n\");\n    \n    // Clean up primary device\n    if (primary_device) {\n        printk(KERN_INFO \"Freeing primary device memory...\\n\");\n        /* TODO: kfree(primary_device); */  // Return memory to kernel\n        primary_device = NULL;  // Prevent accidental reuse\n        device_count--;\n        printk(KERN_INFO \"Primary device freed\\n\");\n    }\n    \n    // Clean up backup device\n    if (backup_device) {\n        printk(KERN_INFO \"Freeing backup device memory...\\n\");\n        /* TODO: kfree(backup_device); */  // Return memory to kernel\n        backup_device = NULL;  // Prevent accidental reuse\n        device_count--;\n        printk(KERN_INFO \"Backup device freed\\n\");\n    }\n    \n    printk(KERN_INFO \"Device cleanup complete. %d devices remaining.\\n\", device_count);\n}\n\nstatic int __init dynamic_memory_init(void)\n{\n    int ret;\n    \n    printk(KERN_INFO \"Dynamic memory module loaded\\n\");\n    printk(KERN_INFO \"Why dynamic allocation? Because users can configure devices at runtime!\\n\");\n    printk(KERN_INFO \"User settings: primary_id=%d, backup_id=%d, enable_backup=%d\\n\", \n           primary_id, backup_id, enable_backup);\n    \n    // Always create primary device\n    ret = create_primary_device(primary_id, \"primary_sensor\");\n    if (ret) {\n        printk(KERN_ERR \"Failed to create primary device\\n\");\n        goto cleanup;\n    }\n    print_device_info(primary_device, \"Primary\");\n    \n    // Only create backup if user enabled it (dynamic decision!)\n    if (enable_backup) {\n        ret = create_backup_device(backup_id, \"backup_sensor\");\n        if (ret) {\n            printk(KERN_ERR \"Failed to create backup device\\n\");\n            goto cleanup;\n        }\n        print_device_info(backup_device, \"Backup\");\n    } else {\n        printk(KERN_INFO \"Backup device disabled by user - saving memory!\\n\");\n    }\n    \n    printk(KERN_INFO \"Total devices created: %d\\n\", device_count);\n    printk(KERN_INFO \"This demonstrates why dynamic allocation is powerful!\\n\");\n    return 0;\n    \ncleanup:\n    cleanup_devices();\n    return ret;\n}\n\nstatic void __exit dynamic_memory_exit(void)\n{\n    printk(KERN_INFO \"Dynamic memory module unloading\\n\");\n    printk(KERN_INFO \"WHY cleanup? Because we must return borrowed memory to the kernel!\\n\");\n    \n    cleanup_devices();\n    \n    printk(KERN_INFO \"All memory returned to kernel. Module unloaded cleanly.\\n\");\n}\n\nmodule_init(dynamic_memory_init);\nmodule_exit(dynamic_memory_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning WHY and HOW to use dynamic memory allocation\");\nMODULE_VERSION(\"1.0\");",
      "readOnly": false,
      "language": "c"
    },
    {
      "name": "Makefile",
      "content": "# Dynamic memory module Makefile\nobj-m += dynamic_memory.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help",
      "readOnly": true,
      "language": "makefile"
    }
  ],
  "concepts": [
    "Why dynamic allocation is needed",
    "kmalloc() function and GFP_KERNEL",
    "kfree() function and memory cleanup", 
    "NULL pointer checking",
    "Error handling with -ENOMEM",
    "Runtime decision making",
    "Memory lifecycle management",
    "Dynamic vs static allocation tradeoffs"
  ],
  "skills": [
    "Understanding when to use dynamic allocation",
    "Allocating memory at runtime with kmalloc()",
    "Proper error handling for memory failures",
    "Cleaning up allocated resources with kfree()",
    "Setting pointers to NULL after freeing",
    "Making runtime decisions based on parameters"
  ],
  "validation": {
    "exactRequirements": {
      "functionNames": ["dynamic_memory_init", "dynamic_memory_exit", "create_primary_device", "create_backup_device", "print_device_info", "cleanup_devices"],
      "function_declarations": [
        { "name": "create_primary_device", "returnType": "int", "parameters": ["int id", "const char *name"] },
        { "name": "create_backup_device", "returnType": "int", "parameters": ["int id", "const char *name"] },
        { "name": "print_device_info", "returnType": "void", "parameters": ["Device *dev", "const char *label"] },
        { "name": "cleanup_devices", "returnType": "void", "parameters": [] }
      ],
      "variables_declarations": [
        { "name": "Device", "type": "typedef struct", "value": "{int device_id; char name[MAX_NAME_LEN]; int status_code; bool is_active;}", "storageClass": "none" },
        { "name": "primary_device", "type": "Device *", "storageClass": "extern" },
        { "name": "backup_device", "type": "Device *", "storageClass": "extern" },
        { "name": "device_count", "type": "int", "storageClass": "extern" }
      ],
      "variables": [
        { "name": "primary_device", "type": "Device *", "value": "NULL", "storageClass": "none" },
        { "name": "backup_device", "type": "Device *", "value": "NULL", "storageClass": "none" },
        { "name": "device_count", "type": "int", "value": "0", "storageClass": "none" }
      ],
      "outputMessages": [
        "Dynamic memory module loaded",
        "Why dynamic allocation? Because users can configure devices at runtime!",
        "Creating primary device with ID=1001, Name=primary_sensor",
        "Primary device allocated successfully!",
        "=== Primary Device Info ===",
        "Device ID: 1001",
        "Device Name: primary_sensor",
        "Status Code: 200",
        "Status: ACTIVE",
        "Creating backup device with ID=2001, Name=backup_sensor",
        "Backup device allocated successfully!",
        "=== Backup Device Info ===",
        "Device ID: 2001",
        "Device Name: backup_sensor",
        "Status Code: 404",
        "Status: STANDBY",
        "Total devices created: 2",
        "This demonstrates why dynamic allocation is powerful!",
        "Dynamic memory module unloading",
        "WHY cleanup? Because we must return borrowed memory to the kernel!",
        "Primary device freed",
        "Backup device freed",
        "All memory returned to kernel. Module unloaded cleanly."
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/types.h",
        "linux/slab.h",
        "linux/string.h"
      ],
      "mustContain": [
        "kmalloc(sizeof(Device), GFP_KERNEL)",
        "kfree(primary_device)",
        "kfree(backup_device)",
        "if (!primary_device)",
        "if (!backup_device)",
        "return -ENOMEM",
        "primary_device = NULL",
        "backup_device = NULL",
        "module_param(primary_id, int, 0644)",
        "module_param(backup_id, int, 0644)",
        "module_param(enable_backup, int, 0644)"
      ],
      "moduleInfo": {
        "license": "GPL"
      }
    },
    "testCases": [
      {
        "id": "function_declarations",
        "name": "Function Declarations in Header",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "int create_primary_device(int id, const char *name)",
          "int create_backup_device(int id, const char *name)",
          "void print_device_info(Device *dev, const char *label)",
          "void cleanup_devices(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "function_signatures_source",
        "name": "Function Signatures in Source File",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "int create_primary_device(int id, const char *name)",
          "int create_backup_device(int id, const char *name)",
          "void print_device_info(Device *dev, const char *label)",
          "void cleanup_devices(void)",
          "static int __init dynamic_memory_init(void)",
          "static void __exit dynamic_memory_exit(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "exact_output",
        "name": "Exact Output Messages",
        "type": "output_match",
        "critical": true,
        "expected": [
          { "pattern": "Dynamic memory module loaded", "exact": true, "linkedFunction": "static int __init dynamic_memory_init(void)" },
          { "pattern": "Why dynamic allocation? Because users can configure devices at runtime!", "exact": true, "linkedFunction": "static int __init dynamic_memory_init(void)" },
          { "pattern": "Creating primary device with ID=1001, Name=primary_sensor", "exact": true, "linkedFunction": "int create_primary_device(int id, const char *name)" },
          { "pattern": "Primary device allocated successfully!", "exact": true, "linkedFunction": "int create_primary_device(int id, const char *name)" },
          { "pattern": "=== Primary Device Info ===", "exact": true, "linkedFunction": "void print_device_info(Device *dev, const char *label)" },
          { "pattern": "Device ID: 1001", "exact": true, "linkedFunction": "void print_device_info(Device *dev, const char *label)" },
          { "pattern": "Device Name: primary_sensor", "exact": true, "linkedFunction": "void print_device_info(Device *dev, const char *label)" },
          { "pattern": "Status Code: 200", "exact": true, "linkedFunction": "void print_device_info(Device *dev, const char *label)" },
          { "pattern": "Status: ACTIVE", "exact": true, "linkedFunction": "void print_device_info(Device *dev, const char *label)" },
          { "pattern": "Creating backup device with ID=2001, Name=backup_sensor", "exact": true, "linkedFunction": "int create_backup_device(int id, const char *name)" },
          { "pattern": "Backup device allocated successfully!", "exact": true, "linkedFunction": "int create_backup_device(int id, const char *name)" },
          { "pattern": "=== Backup Device Info ===", "exact": true, "linkedFunction": "void print_device_info(Device *dev, const char *label)" },
          { "pattern": "Device ID: 2001", "exact": true, "linkedFunction": "void print_device_info(Device *dev, const char *label)" },
          { "pattern": "Device Name: backup_sensor", "exact": true, "linkedFunction": "void print_device_info(Device *dev, const char *label)" },
          { "pattern": "Status Code: 404", "exact": true, "linkedFunction": "void print_device_info(Device *dev, const char *label)" },
          { "pattern": "Status: STANDBY", "exact": true, "linkedFunction": "void print_device_info(Device *dev, const char *label)" },
          { "pattern": "Total devices created: 2", "exact": true, "linkedFunction": "static int __init dynamic_memory_init(void)" },
          { "pattern": "This demonstrates why dynamic allocation is powerful!", "exact": true, "linkedFunction": "static int __init dynamic_memory_init(void)" },
          { "pattern": "Dynamic memory module unloading", "exact": true, "linkedFunction": "static void __exit dynamic_memory_exit(void)" },
          { "pattern": "WHY cleanup? Because we must return borrowed memory to the kernel!", "exact": true, "linkedFunction": "static void __exit dynamic_memory_exit(void)" },
          { "pattern": "Primary device freed", "exact": true, "linkedFunction": "void cleanup_devices(void)" },
          { "pattern": "Backup device freed", "exact": true, "linkedFunction": "void cleanup_devices(void)" },
          { "pattern": "All memory returned to kernel. Module unloaded cleanly.", "exact": true, "linkedFunction": "static void __exit dynamic_memory_exit(void)" }
        ]
      },
      {
        "id": "advanced_dynamic_memory_validation",
        "name": "Advanced Dynamic Memory Implementation with TCC Header Validation",
        "type": "kernel_project_test",
        "critical": true,
        "testScenario": {
          "userspaceApps": [
            {
              "name": "memory_dynamic_tester",
              "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\\\"=== Dynamic Memory Implementation Test ===\\\\n\\\");\\n    \\n    // Seed random number generator\\n    srand(time(NULL));\\n    \\n    // Generate random test data\\n    int test_primary_id = (rand() % 9000) + 1000;   // 1000-9999\\n    int test_backup_id = (rand() % 9000) + 10000;   // 10000-18999\\n    int test_enable_backup = rand() % 2;            // 0 or 1\\n    \\n    printf(\\\"Test 1: Testing with primary_id=%d, backup_id=%d, enable_backup=%d\\\\n\\\", test_primary_id, test_backup_id, test_enable_backup);\\n    char cmd1[256];\\n    snprintf(cmd1, sizeof(cmd1), \\\"insmod /lib/modules/dynamic_memory.ko primary_id=%d backup_id=%d enable_backup=%d\\\", test_primary_id, test_backup_id, test_enable_backup);\\n    system(\\\"rmmod dynamic_memory 2>/dev/null\\\");\\n    system(cmd1);\\n    \\n    // Generate second test\\n    int test_primary_id2 = (rand() % 5000) + 20000; // 20000-24999\\n    int test_backup_id2 = (rand() % 5000) + 25000;  // 25000-29999\\n    int test_enable_backup2 = rand() % 2;           // 0 or 1\\n    \\n    printf(\\\"Test 2: Testing with primary_id=%d, backup_id=%d, enable_backup=%d\\\\n\\\", test_primary_id2, test_backup_id2, test_enable_backup2);\\n    char cmd2[256];\\n    snprintf(cmd2, sizeof(cmd2), \\\"insmod /lib/modules/dynamic_memory.ko primary_id=%d backup_id=%d enable_backup=%d\\\", test_primary_id2, test_backup_id2, test_enable_backup2);\\n    system(\\\"rmmod dynamic_memory\\\");\\n    system(cmd2);\\n    \\n    printf(\\\"SUCCESS: Dynamic memory test completed\\\\n\\\");\\n    return 0;\\n}"
            }
          ],
          "setupCommands": [
            "echo 'Starting advanced dynamic memory implementation validation'"
          ],
          "testCommands": [
            "echo 'Phase 1: Ultra-Fast TCC Header Validation'",
            "echo 'Creating minimal kernel header stubs for TCC...'",
            "mkdir -p /tmp/linux",
            "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
            "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
            "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
            "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
            "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
            "echo '#define module_init(x)' >> /tmp/linux/module.h",
            "echo '#define module_exit(x)' >> /tmp/linux/module.h",
            "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
            "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
            "echo '#define __init' > /tmp/linux/init.h",
            "echo '#define __exit' >> /tmp/linux/init.h",
            "echo 'typedef int bool;' > /tmp/linux/types.h",
            "echo 'typedef unsigned long size_t;' >> /tmp/linux/types.h",
            "echo '#define true 1' >> /tmp/linux/types.h",
            "echo '#define false 0' >> /tmp/linux/types.h",
            "echo '#define MAX_NAME_LEN 32' >> /tmp/linux/types.h",
            "echo '#define MAX_DEVICES 5' >> /tmp/linux/types.h",
            "echo '#define GFP_KERNEL 0' > /tmp/linux/slab.h",
            "echo '#define ENOMEM 12' >> /tmp/linux/slab.h",
            "echo 'void *kmalloc(size_t size, int flags);' >> /tmp/linux/slab.h",
            "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
            "echo 'char *strncpy(char *dest, const char *src, size_t n);' > /tmp/linux/string.h",
            "echo 'int snprintf(char *str, size_t size, const char *format, ...);' >> /tmp/linux/string.h",
            "echo 'Creating test file that includes dynamic memory header...'",
            "echo '#include \"/lib/modules/dynamic_memory.h\"' > /tmp/test.c",
            "echo 'int main() { create_primary_device(999, \"test\"); create_backup_device(888, \"backup\"); print_device_info(primary_device, \"Test\"); cleanup_devices(); return 0; }' >> /tmp/test.c",
            "echo 'Running TCC validation...'",
            "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
            "TCC_EXIT_CODE=$?",
            "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function or variable declaration missing or commented in header'; echo 'TCC Error Details:'; cat /tmp/tcc_error.log; else echo 'PASS: All function and variable declarations found in header file'; fi",
            "echo 'Phase 2: Dynamic Memory Implementation Testing'",
            "/bin/memory_dynamic_tester > /tmp/test_output.log",
            "cat /tmp/test_output.log",
            "echo 'Phase 3: Dynamic Value Extraction and Validation'",
            "echo 'Adding delay to ensure dmesg messages are written...'",
            "sleep 1",
            "echo 'Extracting random test values from output...'",
            "TEST1_PRIMARY=$(grep -o 'Test 1: Testing with primary_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
            "TEST1_BACKUP=$(grep -o 'backup_id=[0-9]*' /tmp/test_output.log | head -1 | cut -d'=' -f2 | cut -d',' -f1)",
            "TEST1_ENABLE=$(grep -o 'enable_backup=[0-9]*' /tmp/test_output.log | head -1 | cut -d'=' -f2)",
            "TEST2_PRIMARY=$(grep -o 'Test 2: Testing with primary_id=[0-9]*' /tmp/test_output.log | cut -d'=' -f2 | cut -d',' -f1)",
            "TEST2_BACKUP=$(grep -o 'backup_id=[0-9]*' /tmp/test_output.log | tail -1 | cut -d'=' -f2 | cut -d',' -f1)",
            "TEST2_ENABLE=$(grep -o 'enable_backup=[0-9]*' /tmp/test_output.log | tail -1 | cut -d'=' -f2)",
            "echo 'Test values: Primary1='$TEST1_PRIMARY', Backup1='$TEST1_BACKUP', Enable1='$TEST1_ENABLE', Primary2='$TEST2_PRIMARY', Backup2='$TEST2_BACKUP', Enable2='$TEST2_ENABLE",
            "echo 'Phase 3.1: Dynamic Memory Allocation Validation'",
            "dmesg | grep 'Creating primary device with ID='$TEST1_PRIMARY && echo 'PASS: Primary device creation working with '$TEST1_PRIMARY || echo 'FAIL: Primary device creation broken for '$TEST1_PRIMARY",
            "dmesg | grep 'Primary device allocated successfully!' && echo 'PASS: Primary device allocation working' || echo 'FAIL: Primary device allocation broken'",
            "dmesg | grep 'Device ID: '$TEST1_PRIMARY && echo 'PASS: Primary device data access working' || echo 'FAIL: Primary device data access broken'",
            "if [ \"$TEST1_ENABLE\" = \"1\" ]; then dmesg | grep 'Creating backup device with ID='$TEST1_BACKUP && echo 'PASS: Backup device creation working with '$TEST1_BACKUP || echo 'FAIL: Backup device creation broken for '$TEST1_BACKUP; else echo 'PASS: Backup device correctly disabled for test 1'; fi",
            "if [ \"$TEST1_ENABLE\" = \"1\" ]; then dmesg | grep 'Backup device allocated successfully!' && echo 'PASS: Backup device allocation working' || echo 'FAIL: Backup device allocation broken'; else echo 'PASS: Backup device allocation skipped as expected'; fi",
            "if [ \"$TEST1_ENABLE\" = \"1\" ]; then dmesg | grep 'Device ID: '$TEST1_BACKUP && echo 'PASS: Backup device data access working' || echo 'FAIL: Backup device data access broken'; else echo 'PASS: Backup device data access skipped as expected'; fi",
            "dmesg | grep 'Creating primary device with ID='$TEST2_PRIMARY && echo 'PASS: Primary device creation working with '$TEST2_PRIMARY || echo 'FAIL: Primary device creation broken for '$TEST2_PRIMARY",
            "if [ \"$TEST2_ENABLE\" = \"1\" ]; then dmesg | grep 'Creating backup device with ID='$TEST2_BACKUP && echo 'PASS: Backup device creation working with '$TEST2_BACKUP || echo 'FAIL: Backup device creation broken for '$TEST2_BACKUP; else echo 'PASS: Backup device correctly disabled for test 2'; fi",
            "echo 'Phase 3.2: Memory Cleanup Validation'",
            "dmesg | grep 'Primary device freed' && echo 'PASS: Primary device cleanup working' || echo 'FAIL: Primary device cleanup broken'",
            "if [ \"$TEST1_ENABLE\" = \"1\" ] || [ \"$TEST2_ENABLE\" = \"1\" ]; then dmesg | grep 'Backup device freed' && echo 'PASS: Backup device cleanup working' || echo 'FAIL: Backup device cleanup broken'; else echo 'PASS: Backup device cleanup skipped (no backup devices created)'; fi",
            "dmesg | grep 'All memory returned to kernel. Module unloaded cleanly.' && echo 'PASS: Complete cleanup working' || echo 'FAIL: Complete cleanup broken'",
            "echo 'Phase 3.3: Function Logic Validation'",
            "dmesg | grep 'Device Name: primary_sensor' && echo 'PASS: Primary device initialization working' || echo 'FAIL: Primary device initialization broken'",
            "if [ \"$TEST1_ENABLE\" = \"1\" ] || [ \"$TEST2_ENABLE\" = \"1\" ]; then dmesg | grep 'Device Name: backup_sensor' && echo 'PASS: Backup device initialization working' || echo 'FAIL: Backup device initialization broken'; else echo 'PASS: Backup device initialization skipped (no backup devices created)'; fi",
            "dmesg | grep 'Status: ACTIVE' && echo 'PASS: Device active status working' || echo 'FAIL: Device active status broken'",
            "if [ \"$TEST1_ENABLE\" = \"1\" ] || [ \"$TEST2_ENABLE\" = \"1\" ]; then dmesg | grep 'Status: STANDBY' && echo 'PASS: Device standby status working' || echo 'FAIL: Device standby status broken'; else echo 'PASS: Device standby status skipped (no backup devices created)'; fi",
            "echo 'Phase 4: Memory Management Validation'",
            "dmesg | grep 'Dynamic memory module loaded' && echo 'PASS: Module initialization working' || echo 'FAIL: Module initialization broken'",
            "dmesg | grep 'All memory returned to kernel. Module unloaded cleanly.' && echo 'PASS: Module cleanup working' || echo 'FAIL: Module cleanup broken'",
            "echo 'All dynamic memory implementation validations completed'"
          ],
          "expected": {
            "dmesg": [
              "Dynamic memory module loaded",
              "Why dynamic allocation\\? Because users can configure devices at runtime!",
              "Creating primary device with ID=.*",
              "Primary device allocated successfully!",
              "Device ID: .*",
              "Device Name: primary_sensor",
              "Creating backup device with ID=.*",
              "Backup device allocated successfully!",
              "Primary device freed",
              "Backup device freed",
              "All memory returned to kernel. Module unloaded cleanly."
            ],
            "stdout": [
              "PASS: All function and variable declarations found in header file",
              "SUCCESS: Dynamic memory test completed",
              "PASS: Primary device creation working with",
              "PASS: Primary device allocation working",
              "PASS: Primary device data access working",
              "PASS: Primary device cleanup working",
              "PASS: Complete cleanup working",
              "PASS: Primary device initialization working",
              "PASS: Device active status working"
            ]
          },
          "timeout": 15
        }
      }
    ]
  }
}