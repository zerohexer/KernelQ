{
  "id": 29,
  "title": "Dynamic Vector Implementation - Kernel Memory Management",
  "phase": "foundations",
  "difficulty": 8,
  "xp": 85,
  "description": "Master dynamic memory management by implementing a production-grade generic vector in kernel space. Learn kmalloc/kfree, dynamic array expansion/shrinking, void* generic programming, and memory-safe operations. This problem teaches critical kernel development skills: dynamic memory allocation, capacity management, bounds checking, and proper resource cleanup - patterns used throughout the Linux kernel in data structure implementations.",
  "mainFile": "kernel_vector.c",
  "files": [
    {
      "name": "kernel_vector.h",
      "content": "#ifndef KERNEL_VECTOR_H\n#define KERNEL_VECTOR_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n/* Initial capacity and error codes */\n#define VECTOR_INIT_CAPACITY 4\n#define VECTOR_SUCCESS 0\n#define VECTOR_ERROR -1\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: Dynamic Vector Data Structure */\n/* ========================================================================== */\n/* This problem teaches PRODUCTION-LEVEL dynamic memory management patterns!\n *\n * WHAT IS A VECTOR?\n * A vector is a dynamic array that automatically grows when needed.\n * Unlike fixed arrays, vectors can change size at runtime.\n *\n * VECTOR STRUCTURE EXPLAINED:\n * typedef struct vector {\n *     void **items;    // Array of void pointers (generic storage)\n *     int capacity;    // Maximum elements before resize needed\n *     int total;       // Current number of elements\n * } vector;\n *\n * MEMORY LAYOUT VISUALIZATION:\n * vector v = {.capacity=4, .total=2}\n * \n * Stack (vector struct):           Heap (items array):\n * ┌──────────────┐                ┌──────┐\n * │ items    ────┼────────────────→│ ptr0 │ → \"first item\"\n * │ capacity = 4 │                 │ ptr1 │ → \"second item\"\n * │ total    = 2 │                 │ ptr2 │ → NULL (unused)\n * └──────────────┘                 │ ptr3 │ → NULL (unused)\n *                                  └──────┘\n *\n * WHY VOID POINTERS (void**)?\n * void* can point to ANY data type:\n * - Store strings: items[0] = \"hello\";\n * - Store integers: items[1] = (void*)(long)42;\n * - Store structs: items[2] = &my_struct;\n * This makes vectors GENERIC - one implementation works for all types!\n */\n\n/* Vector structure definition */\ntypedef struct vector {\n    void **items;     /* Array of void pointers for generic storage */\n    int capacity;     /* Maximum number of elements before resize */\n    int total;        /* Current number of elements */\n} vector;\n\n/* ========================================================================== */\n/* SECTION 1: FUNCTION DECLARATIONS */\n/* ========================================================================== */\n/* TODO: Declare vector manipulation functions */\n\n/* int vector_init(vector *v); */\n/* int vector_total(vector *v); */\n/* int vector_add(vector *v, void *item); */\n/* int vector_set(vector *v, int index, void *item); */\n/* void *vector_get(vector *v, int index); */\n/* int vector_delete(vector *v, int index); */\n/* void vector_free(vector *v); */\n\n/* ========================================================================== */\n/* CONVENIENCE MACROS (OPTIONAL) */\n/* ========================================================================== */\n/* These macros provide cleaner syntax for vector operations:\n *\n * WITHOUT MACROS:         WITH MACROS:\n * vector_init(&v);        VECTOR_INIT(v);\n * vector_add(&v, item);   VECTOR_ADD(v, item);\n * vector_get(&v, 0);      VECTOR_GET(v, char*, 0);\n *\n * Students can choose to implement these or use function calls directly.\n */\n\n#define VECTOR_INIT(vec) vector_init(&vec)\n#define VECTOR_ADD(vec, item) vector_add(&vec, (void*)item)\n#define VECTOR_SET(vec, id, item) vector_set(&vec, id, (void*)item)\n#define VECTOR_GET(vec, type, id) (type)vector_get(&vec, id)\n#define VECTOR_DELETE(vec, id) vector_delete(&vec, id)\n#define VECTOR_TOTAL(vec) vector_total(&vec)\n#define VECTOR_FREE(vec) vector_free(&vec)\n\n#endif /* KERNEL_VECTOR_H */\n",
      "readOnly": false,
      "language": "h"
    },
    {
      "name": "kernel_vector.c",
      "content": "#include \"kernel_vector.h\"\n\n/* Module parameters for dynamic testing */\nint test_capacity = 4;\nint test_add_count = 10;\nint test_delete_index = 2;\n\nmodule_param(test_capacity, int, 0644);\nMODULE_PARM_DESC(test_capacity, \"Initial capacity for testing\");\nmodule_param(test_add_count, int, 0644);\nMODULE_PARM_DESC(test_add_count, \"Number of items to add for testing\");\nmodule_param(test_delete_index, int, 0644);\nMODULE_PARM_DESC(test_delete_index, \"Index to delete for testing\");\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: Dynamic Memory Management in Kernel */\n/* ========================================================================== */\n/* This teaches CRITICAL kernel memory management patterns used throughout Linux!\n *\n * KERNEL MEMORY ALLOCATION API:\n * - kmalloc(size, GFP_KERNEL): Allocate memory (like malloc)\n * - kfree(ptr): Free memory (like free)\n * - krealloc(ptr, new_size, GFP_KERNEL): Resize memory (like realloc)\n *\n * GFP_KERNEL FLAGS EXPLAINED:\n * GFP = Get Free Pages\n * GFP_KERNEL = Can sleep, use for normal allocations in process context\n * GFP_ATOMIC = Cannot sleep, use in interrupt context (not needed here)\n *\n * MEMORY ALLOCATION PATTERN:\n * void **items = kmalloc(sizeof(void*) * capacity, GFP_KERNEL);\n * ↑              ↑       ↑                  ↑\n * result type    function  size calculation  flags\n *\n * WHY sizeof(void*) * capacity?\n * We're allocating an ARRAY of void pointers.\n * Each pointer is sizeof(void*) bytes (usually 8 bytes on 64-bit).\n * For capacity=4: allocate 4 * 8 = 32 bytes.\n *\n * MEMORY SAFETY CRITICAL RULES:\n * 1. ALWAYS check if kmalloc returns NULL (allocation failed)\n * 2. ALWAYS free memory with kfree when done\n * 3. NEVER use memory after freeing it\n * 4. ALWAYS check bounds before accessing array indices\n */\n\n/* ========================================================================== */\n/* HELPER FUNCTION: vector_resize */\n/* ========================================================================== */\n/* This is a STATIC helper function (only used internally in this file)\n *\n * WHAT IS STATIC?\n * static int vector_resize(...) means:\n * - Function is PRIVATE to this file\n * - Cannot be called from other files\n * - Like a \"private\" method in OOP\n *\n * WHY RESIZE?\n * When capacity is full, we need MORE space:\n * Old: [ptr0][ptr1][ptr2][ptr3] (capacity=4, full!)\n * New: [ptr0][ptr1][ptr2][ptr3][null][null][null][null] (capacity=8)\n *\n * KREALLOC EXPLAINED:\n * krealloc(old_ptr, new_size, GFP_KERNEL)\n * - If successful: Returns new pointer, copies old data, frees old memory\n * - If fails: Returns NULL, old memory UNCHANGED\n *\n * CRITICAL: Store result in temporary variable first!\n * void **new_items = krealloc(v->items, new_size, GFP_KERNEL);\n * if (new_items) {\n *     v->items = new_items;  // Only update if successful!\n * }\n */\nstatic int vector_resize(vector *v, int capacity)\n{\n    printk(KERN_INFO \"vector_resize: %d to %d\\n\", v->capacity, capacity);\n\n    /* TODO: Resize the items array using krealloc */\n    /* STEP 1: Calculate new size: sizeof(void*) * capacity */\n    /* STEP 2: Call krealloc(v->items, new_size, GFP_KERNEL) */\n    /* STEP 3: Check if krealloc returned NULL (allocation failed) */\n    /* STEP 4: If successful, update v->items and v->capacity */\n    /* STEP 5: Return VECTOR_SUCCESS or VECTOR_ERROR */\n\n    /* HINT: Use a temporary pointer to store krealloc result */\n    /* void **new_items = krealloc(...); */\n    /* if (new_items) { ... } else { return VECTOR_ERROR; } */\n\n    return VECTOR_ERROR;  /* TODO: Replace with actual implementation */\n}\n\n/* ========================================================================== */\n/* FUNCTION: vector_init */\n/* ========================================================================== */\n/* Initialize an empty vector with initial capacity\n *\n * WHAT THIS FUNCTION DOES:\n * 1. Set capacity to VECTOR_INIT_CAPACITY (4)\n * 2. Set total to 0 (no elements yet)\n * 3. Allocate memory for items array using kmalloc\n * 4. Check if allocation succeeded\n *\n * MEMORY ALLOCATION PATTERN:\n * v->items = kmalloc(sizeof(void*) * v->capacity, GFP_KERNEL);\n *\n * ERROR HANDLING:\n * if (!v->items) {  // kmalloc returned NULL\n *     return VECTOR_ERROR;\n * }\n * return VECTOR_SUCCESS;\n */\nint vector_init(vector *v)\n{\n    printk(KERN_INFO \"vector_init: Initializing vector\\n\");\n\n    /* TODO: Initialize vector fields */\n    /* v->capacity = VECTOR_INIT_CAPACITY; */\n    /* v->total = 0; */\n    /* v->items = kmalloc(sizeof(void*) * v->capacity, GFP_KERNEL); */\n    /* if (!v->items) return VECTOR_ERROR; */\n    /* return VECTOR_SUCCESS; */\n\n    return VECTOR_ERROR;  /* TODO: Replace with actual implementation */\n}\n\n/* ========================================================================== */\n/* FUNCTION: vector_total */\n/* ========================================================================== */\n/* Return the current number of elements in the vector\n *\n * SIMPLE ACCESSOR FUNCTION:\n * Just return v->total (no complex logic needed)\n */\nint vector_total(vector *v)\n{\n    /* TODO: Return the total number of elements */\n    return 0;  /* TODO: Replace with v->total */\n}\n\n/* ========================================================================== */\n/* FUNCTION: vector_add */\n/* ========================================================================== */\n/* Add an item to the end of the vector\n *\n * ALGORITHM:\n * 1. Check if vector is full (v->capacity == v->total)\n * 2. If full, resize to double capacity: vector_resize(v, v->capacity * 2)\n * 3. Check if resize succeeded (it returns VECTOR_SUCCESS or VECTOR_ERROR)\n * 4. Add item to end: v->items[v->total] = item\n * 5. Increment total: v->total++\n *\n * CAPACITY EXPANSION VISUALIZATION:\n * Before add (capacity=4, total=4, FULL!):\n * [ptr0][ptr1][ptr2][ptr3]\n *\n * After resize (capacity=8):\n * [ptr0][ptr1][ptr2][ptr3][null][null][null][null]\n *\n * After add (total=5):\n * [ptr0][ptr1][ptr2][ptr3][NEW][null][null][null]\n *\n * WHY DOUBLE CAPACITY?\n * Doubling ensures O(1) amortized time complexity:\n * - Adding 1000 items: resize only ~10 times (log2(1000))\n * - Not doubling: would resize 1000 times (very slow!)\n */\nint vector_add(vector *v, void *item)\n{\n    printk(KERN_INFO \"vector_add: Adding item (total=%d, capacity=%d)\\n\", v->total, v->capacity);\n\n    /* TODO: Implement add logic */\n    /* STEP 1: Check if v->capacity == v->total (vector is full) */\n    /* STEP 2: If full, call vector_resize(v, v->capacity * 2) */\n    /* STEP 3: Check if resize returned VECTOR_ERROR */\n    /* STEP 4: Add item: v->items[v->total] = item */\n    /* STEP 5: Increment total: v->total++ */\n    /* STEP 6: Return VECTOR_SUCCESS */\n\n    return VECTOR_ERROR;  /* TODO: Replace with actual implementation */\n}\n\n/* ========================================================================== */\n/* FUNCTION: vector_set */\n/* ========================================================================== */\n/* Set/replace an item at a specific index\n *\n * BOUNDS CHECKING:\n * Must verify: index >= 0 AND index < v->total\n * Why < v->total? Can only modify EXISTING elements!\n *\n * Example with total=3:\n * Valid indices: 0, 1, 2\n * Invalid: -1, 3, 4, 100\n *\n * [ptr0][ptr1][ptr2][null]...\n *   ↑     ↑     ↑    ↑\n *   0     1     2    3 (out of bounds!)\n */\nint vector_set(vector *v, int index, void *item)\n{\n    printk(KERN_INFO \"vector_set: Setting index %d\\n\", index);\n\n    /* TODO: Implement set logic */\n    /* STEP 1: Check if index >= 0 AND index < v->total */\n    /* STEP 2: If valid, set v->items[index] = item and return VECTOR_SUCCESS */\n    /* STEP 3: If invalid, return VECTOR_ERROR */\n\n    return VECTOR_ERROR;  /* TODO: Replace with actual implementation */\n}\n\n/* ========================================================================== */\n/* FUNCTION: vector_get */\n/* ========================================================================== */\n/* Get an item at a specific index\n *\n * RETURN VALUE:\n * - Valid index: return v->items[index]\n * - Invalid index: return NULL\n *\n * WHY RETURN NULL?\n * NULL is a standard way to indicate \"no value\" or \"error\" for pointers.\n * Caller can check: if (result == NULL) { // handle error }\n */\nvoid *vector_get(vector *v, int index)\n{\n    /* TODO: Implement get logic */\n    /* STEP 1: Check if index >= 0 AND index < v->total */\n    /* STEP 2: If valid, return v->items[index] */\n    /* STEP 3: If invalid, return NULL */\n\n    return NULL;  /* TODO: Replace with actual implementation */\n}\n\n/* ========================================================================== */\n/* FUNCTION: vector_delete */\n/* ========================================================================== */\n/* Delete an item at a specific index and shift remaining elements\n *\n * DELETION ALGORITHM:\n * Before delete at index 1:\n * [ptr0][ptr1][ptr2][ptr3] (total=4)\n *   0     1     2     3\n *\n * After delete:\n * [ptr0][ptr2][ptr3][null] (total=3)\n *   0     1     2\n *\n * HOW TO SHIFT ELEMENTS:\n * for (int i = index; i < v->total - 1; i++) {\n *     v->items[i] = v->items[i + 1];  // Shift left\n * }\n * v->items[v->total - 1] = NULL;  // Clear old last position\n * v->total--;  // Decrease count\n *\n * CAPACITY SHRINKING:\n * If vector becomes too empty (total == capacity/4), shrink to capacity/2.\n * This saves memory when many items are deleted.\n *\n * Example:\n * capacity=16, total=4 (25% full)\n * → Shrink to capacity=8\n */\nint vector_delete(vector *v, int index)\n{\n    printk(KERN_INFO \"vector_delete: Deleting index %d\\n\", index);\n\n    /* TODO: Implement delete logic */\n    /* STEP 1: Check if index < 0 OR index >= v->total (out of bounds) */\n    /* STEP 2: If invalid, return VECTOR_ERROR */\n    /* STEP 3: Set deleted position to NULL: v->items[index] = NULL */\n    /* STEP 4: Shift elements left (loop from index to total-1) */\n    /* STEP 5: Decrement total: v->total-- */\n    /* STEP 6: Optional shrinking: if (v->total > 0 && v->total == v->capacity / 4) */\n    /*         vector_resize(v, v->capacity / 2); */\n    /* STEP 7: Return VECTOR_SUCCESS */\n\n    return VECTOR_ERROR;  /* TODO: Replace with actual implementation */\n}\n\n/* ========================================================================== */\n/* FUNCTION: vector_free */\n/* ========================================================================== */\n/* Free all memory allocated by the vector\n *\n * MEMORY CLEANUP:\n * 1. Free the items array: kfree(v->items)\n * 2. Reset fields to safe values:\n *    v->items = NULL\n *    v->total = 0\n *    v->capacity = 0\n *\n * WHY RESET TO NULL/0?\n * Prevents use-after-free bugs. If someone tries to use the vector\n * after freeing, they'll get NULL pointer errors instead of corruption.\n *\n * CRITICAL: This ONLY frees the items array, NOT the items themselves!\n * If items were allocated with kmalloc, caller must free them first:\n *\n * for (int i = 0; i < vector_total(&v); i++) {\n *     kfree(vector_get(&v, i));  // Free each item\n * }\n * vector_free(&v);  // Then free the vector structure\n */\nvoid vector_free(vector *v)\n{\n    printk(KERN_INFO \"vector_free: Freeing vector\\n\");\n\n    /* TODO: Implement free logic */\n    /* STEP 1: kfree(v->items); */\n    /* STEP 2: v->items = NULL; */\n    /* STEP 3: v->total = 0; */\n    /* STEP 4: v->capacity = 0; */\n}\n\n/* ========================================================================== */\n/* MODULE INIT: Test the vector implementation */\n/* ========================================================================== */\nstatic int __init kernel_vector_init(void)\n{\n    vector v;\n    int result;\n    int i;\n    char *test_strings[] = {\"first\", \"second\", \"third\", \"fourth\", \"fifth\"};\n\n    printk(KERN_INFO \"Kernel vector module loaded\\n\");\n    printk(KERN_INFO \"Testing with capacity=%d, add_count=%d, delete_index=%d\\n\",\n           test_capacity, test_add_count, test_delete_index);\n\n    /* Test 1: Initialization */\n    printk(KERN_INFO \"Test 1: Vector initialization\\n\");\n    result = vector_init(&v);\n    if (result != VECTOR_SUCCESS) {\n        printk(KERN_ERR \"Failed to initialize vector\\n\");\n        return -ENOMEM;\n    }\n    printk(KERN_INFO \"Vector initialized: capacity=%d, total=%d\\n\", v.capacity, v.total);\n\n    /* Test 2: Adding elements */\n    printk(KERN_INFO \"Test 2: Adding elements\\n\");\n    for (i = 0; i < 5 && i < test_add_count; i++) {\n        result = vector_add(&v, test_strings[i]);\n        if (result != VECTOR_SUCCESS) {\n            printk(KERN_ERR \"Failed to add element %d\\n\", i);\n            vector_free(&v);\n            return -ENOMEM;\n        }\n        printk(KERN_INFO \"Added '%s' at index %d (total=%d, capacity=%d)\\n\",\n               test_strings[i], i, v.total, v.capacity);\n    }\n\n    /* Test 3: Getting elements */\n    printk(KERN_INFO \"Test 3: Getting elements\\n\");\n    for (i = 0; i < vector_total(&v); i++) {\n        char *item = (char*)vector_get(&v, i);\n        if (item) {\n            printk(KERN_INFO \"Element at index %d: %s\\n\", i, item);\n        }\n    }\n\n    /* Test 4: Setting element */\n    printk(KERN_INFO \"Test 4: Setting element\\n\");\n    if (vector_total(&v) > 1) {\n        result = vector_set(&v, 1, \"modified\");\n        if (result == VECTOR_SUCCESS) {\n            char *item = (char*)vector_get(&v, 1);\n            printk(KERN_INFO \"Modified element at index 1: %s\\n\", item);\n        }\n    }\n\n    /* Test 5: Deleting element */\n    printk(KERN_INFO \"Test 5: Deleting element\\n\");\n    if (test_delete_index >= 0 && test_delete_index < vector_total(&v)) {\n        result = vector_delete(&v, test_delete_index);\n        if (result == VECTOR_SUCCESS) {\n            printk(KERN_INFO \"Deleted element at index %d (total=%d)\\n\",\n                   test_delete_index, v.total);\n            printk(KERN_INFO \"Elements after deletion:\\n\");\n            for (i = 0; i < vector_total(&v); i++) {\n                char *item = (char*)vector_get(&v, i);\n                if (item) {\n                    printk(KERN_INFO \"  Index %d: %s\\n\", i, item);\n                }\n            }\n        }\n    }\n\n    /* Test 6: Edge cases */\n    printk(KERN_INFO \"Test 6: Edge case testing\\n\");\n    void *invalid_get = vector_get(&v, 100);\n    printk(KERN_INFO \"Get invalid index (100): %s\\n\", invalid_get == NULL ? \"NULL\" : \"ERROR\");\n\n    int invalid_set = vector_set(&v, 100, \"test\");\n    printk(KERN_INFO \"Set invalid index (100): %s\\n\", invalid_set == VECTOR_ERROR ? \"ERROR\" : \"SUCCESS\");\n\n    /* Cleanup first vector */\n    vector_free(&v);\n    printk(KERN_INFO \"Vector freed\\n\");\n\n    /* Test 7: Empty Vector Operations */\n    printk(KERN_INFO \"Test 7: Empty vector operations\\n\");\n    vector v_empty;\n    vector_init(&v_empty);\n    printk(KERN_INFO \"Empty vector initialized (total=%d)\\n\", v_empty.total);\n    \n    void *empty_get = vector_get(&v_empty, 0);\n    printk(KERN_INFO \"Get from empty vector (index 0): %s\\n\", empty_get == NULL ? \"NULL (correct)\" : \"ERROR\");\n    \n    int empty_delete = vector_delete(&v_empty, 0);\n    printk(KERN_INFO \"Delete from empty vector (index 0): %s\\n\", empty_delete == VECTOR_ERROR ? \"ERROR (correct)\" : \"SUCCESS (wrong)\");\n    \n    int empty_set = vector_set(&v_empty, 0, \"test\");\n    printk(KERN_INFO \"Set on empty vector (index 0): %s\\n\", empty_set == VECTOR_ERROR ? \"ERROR (correct)\" : \"SUCCESS (wrong)\");\n    \n    vector_free(&v_empty);\n    printk(KERN_INFO \"Empty vector test completed\\n\");\n\n    /* Test 8: NULL Pointer Handling */\n    printk(KERN_INFO \"Test 8: NULL pointer handling\\n\");\n    vector v_null;\n    vector_init(&v_null);\n    \n    result = vector_add(&v_null, NULL);\n    printk(KERN_INFO \"Add NULL pointer: %s\\n\", result == VECTOR_SUCCESS ? \"SUCCESS\" : \"ERROR\");\n    \n    void *retrieved_null = vector_get(&v_null, 0);\n    printk(KERN_INFO \"Get NULL pointer: %s\\n\", retrieved_null == NULL ? \"NULL (correct)\" : \"Non-NULL (error)\");\n    \n    vector_add(&v_null, \"valid\");\n    vector_add(&v_null, NULL);\n    vector_add(&v_null, \"another\");\n    printk(KERN_INFO \"Mixed NULL and valid pointers: total=%d\\n\", v_null.total);\n    \n    for (i = 0; i < vector_total(&v_null); i++) {\n        char *item = (char*)vector_get(&v_null, i);\n        if (item == NULL) {\n            printk(KERN_INFO \"  Index %d: NULL\\n\", i);\n        } else {\n            printk(KERN_INFO \"  Index %d: %s\\n\", i, item);\n        }\n    }\n    \n    vector_free(&v_null);\n    printk(KERN_INFO \"NULL pointer test completed\\n\");\n\n    /* Test 9: Capacity Shrinking */\n    printk(KERN_INFO \"Test 9: Capacity shrinking test\\n\");\n    vector v_shrink;\n    vector_init(&v_shrink);\n    \n    /* Add 16 elements to expand capacity to 16 */\n    for (i = 0; i < 16; i++) {\n        vector_add(&v_shrink, \"item\");\n    }\n    printk(KERN_INFO \"After adding 16 items: total=%d, capacity=%d\\n\", v_shrink.total, v_shrink.capacity);\n    \n    /* Delete down to 4 items (25% of capacity 16) */\n    while (v_shrink.total > 4) {\n        vector_delete(&v_shrink, 0);\n    }\n    printk(KERN_INFO \"After deleting to 4 items (25%% full): total=%d, capacity=%d\\n\", v_shrink.total, v_shrink.capacity);\n    printk(KERN_INFO \"Capacity shrinking: %s\\n\", v_shrink.capacity == 8 ? \"SUCCESS (16→8)\" : \"Not implemented\");\n    \n    vector_free(&v_shrink);\n    printk(KERN_INFO \"Capacity shrinking test completed\\n\");\n\n    /* Test 10: Add-Delete Cycles */\n    printk(KERN_INFO \"Test 10: Add-Delete cycle test\\n\");\n    vector v_cycle;\n    vector_init(&v_cycle);\n    \n    int cycles = 3;\n    for (int cycle = 0; cycle < cycles; cycle++) {\n        /* Add 10 items */\n        for (i = 0; i < 10; i++) {\n            vector_add(&v_cycle, \"cycle_item\");\n        }\n        printk(KERN_INFO \"Cycle %d: After adding 10, total=%d\\n\", cycle, v_cycle.total);\n        \n        /* Delete 5 items */\n        for (i = 0; i < 5; i++) {\n            vector_delete(&v_cycle, 0);\n        }\n        printk(KERN_INFO \"Cycle %d: After deleting 5, total=%d\\n\", cycle, v_cycle.total);\n    }\n    printk(KERN_INFO \"After %d cycles: total=%d, capacity=%d\\n\", cycles, v_cycle.total, v_cycle.capacity);\n    \n    vector_free(&v_cycle);\n    printk(KERN_INFO \"Add-Delete cycle test completed\\n\");\n\n    printk(KERN_INFO \"All comprehensive tests completed\\n\");\n    return 0;\n}\n\nstatic void __exit kernel_vector_exit(void)\n{\n    printk(KERN_INFO \"Kernel vector module unloaded\\n\");\n}\n\nmodule_init(kernel_vector_init);\nmodule_exit(kernel_vector_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Dynamic vector implementation in kernel space\");\nMODULE_VERSION(\"1.0\");\n",
      "readOnly": false,
      "language": "c"
    },
    {
      "name": "Makefile",
      "content": "# Kernel vector module Makefile\nobj-m += kernel_vector.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help\n",
      "readOnly": true,
      "language": "makefile"
    }
  ],
  "concepts": [
    "dynamic memory allocation",
    "kernel memory management (kmalloc/kfree/krealloc)",
    "generic programming with void pointers",
    "dynamic array implementation",
    "capacity management and resizing",
    "bounds checking and error handling",
    "amortized time complexity",
    "memory safety patterns"
  ],
  "skills": [
    "Using kmalloc, kfree, and krealloc correctly",
    "Implementing dynamic array expansion/shrinking",
    "Managing capacity and size separately",
    "Generic data structure design with void*",
    "Proper error handling and return codes",
    "Memory leak prevention",
    "Bounds checking implementation",
    "Understanding amortized analysis"
  ],
  "validation": {
    "exactRequirements": {
      "functionNames": [
        "kernel_vector_init",
        "kernel_vector_exit",
        "vector_init",
        "vector_total",
        "vector_add",
        "vector_set",
        "vector_get",
        "vector_delete",
        "vector_free",
        "vector_resize"
      ],
      "function_declarations": [
        { "name": "vector_init", "returnType": "int", "parameters": ["vector *v"] },
        { "name": "vector_total", "returnType": "int", "parameters": ["vector *v"] },
        { "name": "vector_add", "returnType": "int", "parameters": ["vector *v", "void *item"] },
        { "name": "vector_set", "returnType": "int", "parameters": ["vector *v", "int index", "void *item"] },
        { "name": "vector_get", "returnType": "void *", "parameters": ["vector *v", "int index"] },
        { "name": "vector_delete", "returnType": "int", "parameters": ["vector *v", "int index"] },
        { "name": "vector_free", "returnType": "void", "parameters": ["vector *v"] }
      ],
      "variables_declarations": [
        { "name": "vector", "type": "typedef struct", "value": "{void **items; int capacity; int total;}", "storageClass": "none" }
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/slab.h",
        "linux/types.h"
      ],
      "mustContain": [
        "typedef struct vector",
        "void **items",
        "int capacity",
        "int total",
        "kmalloc(sizeof(void \\*) \\* ",
        "kfree(v->items)",
        "krealloc(v->items",
        "v->items\\[v->total\\+\\+\\] = item",
        "v->items\\[index\\] = item",
        "v->total--",
        "if (v->capacity == v->total)",
        "vector_resize(v, v->capacity \\* 2)",
        "if (index >= 0 && index < v->total)",
        "return NULL",
        "return VECTOR_ERROR",
        "return VECTOR_SUCCESS",
        "GFP_KERNEL",
        "module_param(test_capacity, int, 0644)",
        "module_param(test_add_count, int, 0644)",
        "module_param(test_delete_index, int, 0644)"
      ],
      "moduleInfo": {
        "license": "GPL"
      }
    },
    "testCases": [
      {
        "id": "function_declarations",
        "name": "Function Declarations in Header",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "int vector_init(vector *v)",
          "int vector_total(vector *v)",
          "int vector_add(vector *v, void *item)",
          "int vector_set(vector *v, int index, void *item)",
          "void *vector_get(vector *v, int index)",
          "int vector_delete(vector *v, int index)",
          "void vector_free(vector *v)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "function_signatures_source",
        "name": "Function Implementations in Source",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "int vector_init(vector *v)",
          "int vector_total(vector *v)",
          "int vector_add(vector *v, void *item)",
          "int vector_set(vector *v, int index, void *item)",
          "void *vector_get(vector *v, int index)",
          "int vector_delete(vector *v, int index)",
          "void vector_free(vector *v)",
          "static int vector_resize(vector *v, int capacity)",
          "static int __init kernel_vector_init(void)",
          "static void __exit kernel_vector_exit(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "struct_definition",
        "name": "Vector Structure Definition",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "typedef struct vector",
          "void **items",
          "int capacity",
          "int total"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "exact_output",
        "name": "Exact Output Messages with Function Linkage",
        "type": "output_match",
        "critical": true,
        "expected": [
          { "pattern": "Kernel vector module loaded", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "Testing with capacity=", "exact": false, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "Test 1: Vector initialization", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "vector_init: Initializing vector", "exact": true, "linkedFunction": "int vector_init(vector *v)" },
          { "pattern": "Vector initialized: capacity=4, total=0", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "Test 2: Adding elements", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "vector_add: Adding item", "exact": false, "linkedFunction": "int vector_add(vector *v, void *item)" },
          { "pattern": "Added 'first' at index 0", "exact": false, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "Added 'second' at index 1", "exact": false, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "Added 'third' at index 2", "exact": false, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "Test 3: Getting elements", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "Element at index 0: first", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "Element at index 1:", "exact": false, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "Test 4: Setting element", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "vector_set: Setting index 1", "exact": true, "linkedFunction": "int vector_set(vector *v, int index, void *item)" },
          { "pattern": "Modified element at index 1: modified", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "Test 5: Deleting element", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "vector_delete: Deleting index", "exact": false, "linkedFunction": "int vector_delete(vector *v, int index)" },
          { "pattern": "Deleted element at index", "exact": false, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "Elements after deletion:", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "Test 6: Edge case testing", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "Get invalid index (100): NULL", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "Set invalid index (100): ERROR", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "vector_free: Freeing vector", "exact": true, "linkedFunction": "void vector_free(vector *v)" },
          { "pattern": "Vector freed", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "Test 7: Empty vector operations", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "Empty vector initialized (total=0)", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "Get from empty vector (index 0): NULL (correct)", "exact": true, "linkedFunction": "void *vector_get(vector *v, int index)" },
          { "pattern": "Delete from empty vector (index 0): ERROR (correct)", "exact": true, "linkedFunction": "int vector_delete(vector *v, int index)" },
          { "pattern": "Set on empty vector (index 0): ERROR (correct)", "exact": true, "linkedFunction": "int vector_set(vector *v, int index, void *item)" },
          { "pattern": "Empty vector test completed", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "Test 8: NULL pointer handling", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "Add NULL pointer: SUCCESS", "exact": true, "linkedFunction": "int vector_add(vector *v, void *item)" },
          { "pattern": "Get NULL pointer: NULL (correct)", "exact": true, "linkedFunction": "void *vector_get(vector *v, int index)" },
          { "pattern": "Mixed NULL and valid pointers: total=4", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "NULL pointer test completed", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "Test 9: Capacity shrinking test", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "After adding 16 items: total=16, capacity=16", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "After deleting to 4 items", "exact": false, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "Capacity shrinking test completed", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "Test 10: Add-Delete cycle test", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "Cycle 0: After adding 10, total=10", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "Cycle 0: After deleting 5, total=5", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "After 3 cycles: total=15", "exact": false, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "Add-Delete cycle test completed", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "All comprehensive tests completed", "exact": true, "linkedFunction": "static int __init kernel_vector_init(void)" },
          { "pattern": "Kernel vector module unloaded", "exact": true, "linkedFunction": "static void __exit kernel_vector_exit(void)" }
        ]
      },
      {
        "id": "comprehensive_vector_validation",
        "name": "Comprehensive Vector Functionality Validation",
        "type": "kernel_project_test",
        "critical": true,
        "testScenario": {
          "userspaceApps": [
            {
              "name": "vector_comprehensive_tester",
              "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n\\nint main() {\\n    printf(\\\"=== Comprehensive Vector Functionality Test ===\\\\n\\\");\\n    \\n    srand(time(NULL));\\n    \\n    int test_capacity = 4 + (rand() % 4);\\n    int test_add_count = 5 + (rand() % 6);\\n    int test_delete_index = 1 + (rand() % 3);\\n    \\n    printf(\\\"Test parameters: capacity=%d, add_count=%d, delete_index=%d\\\\n\\\", test_capacity, test_add_count, test_delete_index);\\n    \\n    system(\\\"rmmod kernel_vector 2>/dev/null\\\");\\n    \\n    char cmd[512];\\n    snprintf(cmd, sizeof(cmd), \\\"insmod /lib/modules/kernel_vector.ko test_capacity=%d test_add_count=%d test_delete_index=%d\\\", test_capacity, test_add_count, test_delete_index);\\n    printf(\\\"Loading module with: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    \\n    printf(\\\"SUCCESS: Vector comprehensive test completed\\\\n\\\");\\n    return 0;\\n}"
            }
          ],
          "setupCommands": [
            "echo 'Starting comprehensive vector validation'"
          ],
          "testCommands": [
            "echo 'Phase 1: TCC Header Validation'",
            "mkdir -p /tmp/linux",
            "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
            "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
            "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
            "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
            "echo '#define module_init(x)' >> /tmp/linux/module.h",
            "echo '#define module_exit(x)' >> /tmp/linux/module.h",
            "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
            "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
            "echo '#define __init' > /tmp/linux/init.h",
            "echo '#define __exit' >> /tmp/linux/init.h",
            "echo 'typedef unsigned long size_t;' > /tmp/linux/types.h",
            "echo 'typedef unsigned char u8;' >> /tmp/linux/types.h",
            "echo 'typedef unsigned short u16;' >> /tmp/linux/types.h",
            "echo 'typedef unsigned int u32;' >> /tmp/linux/types.h",
            "echo '#include <linux/types.h>' > /tmp/linux/slab.h",
            "echo 'void *kmalloc(unsigned long size, int flags);' >> /tmp/linux/slab.h",
            "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
            "echo 'void *krealloc(const void *ptr, unsigned long size, int flags);' >> /tmp/linux/slab.h",
            "echo '#define GFP_KERNEL 0' >> /tmp/linux/slab.h",
            "echo '#include \"/lib/modules/kernel_vector.h\"' > /tmp/test.c",
            "echo 'int main() { vector v; vector_init(&v); vector_add(&v, (void*)0); vector_get(&v, 0); vector_set(&v, 0, (void*)0); vector_delete(&v, 0); vector_free(&v); return 0; }' >> /tmp/test.c",
            "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
            "TCC_EXIT_CODE=$?",
            "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Function declarations missing in header'; cat /tmp/tcc_error.log; else echo 'PASS: All function declarations found in header'; fi",
            "echo 'Phase 2: Dynamic Vector Functionality Testing'",
            "/bin/vector_comprehensive_tester > /tmp/test_output.log",
            "cat /tmp/test_output.log",
            "echo 'Phase 3: Vector Operation Validation'",
            "sleep 1",
            "echo 'Validating vector initialization...'",
            "dmesg | grep 'Vector initialized: capacity=4, total=0' && echo 'PASS: Vector initialization correct' || echo 'FAIL: Vector initialization wrong'",
            "echo 'Validating vector add operations...'",
            "dmesg | grep 'Added .first. at index 0' && echo 'PASS: Vector add working' || echo 'FAIL: Vector add broken'",
            "dmesg | grep 'Added .second. at index 1' && echo 'PASS: Vector sequential add working' || echo 'FAIL: Vector sequential add broken'",
            "echo 'Validating vector get operations...'",
            "dmesg | grep 'Element at index 0: first' && echo 'PASS: Vector get working' || echo 'FAIL: Vector get broken'",
            "echo 'Validating vector set operations...'",
            "dmesg | grep 'Modified element at index 1: modified' && echo 'PASS: Vector set working' || echo 'FAIL: Vector set broken'",
            "echo 'Validating vector delete operations...'",
            "dmesg | grep 'Deleted element at index' && echo 'PASS: Vector delete working' || echo 'FAIL: Vector delete broken'",
            "echo 'Phase 4: Extracting Dynamic Test Parameters'",
            "TEST_ADD_COUNT=$(dmesg | grep -o 'Testing with capacity=[0-9]*, add_count=[0-9]*' | tail -1 | grep -o 'add_count=[0-9]*' | cut -d'=' -f2)",
            "TEST_DELETE_INDEX=$(dmesg | grep -o 'delete_index=[0-9]*' | tail -1 | cut -d'=' -f2)",
            "echo 'Extracted: test_add_count='$TEST_ADD_COUNT', test_delete_index='$TEST_DELETE_INDEX",
            "if [ -z \"$TEST_ADD_COUNT\" ] || [ \"$TEST_ADD_COUNT\" = \"\" ]; then echo 'WARN: Could not extract test_add_count, using default 5'; TEST_ADD_COUNT=5; fi",
            "if [ -z \"$TEST_DELETE_INDEX\" ] || [ \"$TEST_DELETE_INDEX\" = \"\" ]; then echo 'WARN: Could not extract test_delete_index, using default 2'; TEST_DELETE_INDEX=2; fi",
            "echo 'Phase 5: Dynamic Capacity Doubling Validation (CRITICAL)'",
            "echo 'Checking if capacity doubled based on test_add_count='$TEST_ADD_COUNT",
            "dmesg | grep 'Added.*at index 0.*capacity=4' && echo 'PASS: Initial capacity=4 confirmed' || echo 'FAIL: Initial capacity wrong'",
            "if [ $TEST_ADD_COUNT -ge 5 ]; then",
            "  echo 'With add_count='$TEST_ADD_COUNT', expecting capacity doubling 4→8 at 5th element (index 4)...'",
            "  dmesg | grep 'Added.*at index 4.*total=5, capacity=8' && echo 'PASS: Capacity doubled correctly (4→8) at index 4' || echo 'FAIL: Capacity doubling broken at index 4'",
            "else",
            "  echo 'With add_count='$TEST_ADD_COUNT', no doubling expected (less than 5 elements)'",
            "  dmesg | grep 'Added.*at index.*capacity=4' && echo 'PASS: Capacity remained 4 (no doubling needed)' || echo 'FAIL: Unexpected capacity change'",
            "fi",
            "if [ $TEST_ADD_COUNT -ge 9 ]; then",
            "  echo 'With add_count='$TEST_ADD_COUNT', expecting second doubling 8→16 at 9th element (index 8)...'",
            "  dmesg | grep 'Added.*at index 8.*total=9, capacity=16' && echo 'PASS: Second capacity doubling (8→16) at index 8' || echo 'FAIL: Second doubling broken'",
            "fi",
            "echo 'Phase 6: Dynamic Delete and Element Shifting Validation (CRITICAL)'",
            "echo 'Verifying delete at index '$TEST_DELETE_INDEX' shifted elements correctly...'",
            "dmesg | grep 'Deleted element at index '$TEST_DELETE_INDEX && echo 'PASS: Deleted at index '$TEST_DELETE_INDEX' (dynamic)' || echo 'FAIL: Delete at index '$TEST_DELETE_INDEX' failed'",
            "dmesg | grep 'Elements after deletion:' && echo 'PASS: Post-deletion verification present' || echo 'FAIL: No post-deletion check'",
            "if [ \"$TEST_ADD_COUNT\" -gt 5 ]; then EXPECTED_TOTAL_AFTER_DELETE=4; else EXPECTED_TOTAL_AFTER_DELETE=$((TEST_ADD_COUNT - 1)); fi",
            "ACTUAL_TOTAL=$(dmesg | grep 'Deleted element at index.*total=' | tail -1 | grep -o 'total=[0-9]*' | cut -d'=' -f2)",
            "if [ -n \"$ACTUAL_TOTAL\" ] && [ \"$ACTUAL_TOTAL\" -eq \"$EXPECTED_TOTAL_AFTER_DELETE\" ] 2>/dev/null; then",
            "  echo 'PASS: Total count correct after delete (expected='$EXPECTED_TOTAL_AFTER_DELETE', actual='$ACTUAL_TOTAL')'",
            "elif [ -n \"$ACTUAL_TOTAL\" ]; then",
            "  echo 'INFO: Total after delete: actual='$ACTUAL_TOTAL' (delete successful)'",
            "else",
            "  echo 'WARN: Could not verify total count after delete'",
            "fi",
            "dmesg | grep -A1 'Elements after deletion:' | grep 'Index 0:' && echo 'PASS: Elements still accessible after delete' || echo 'FAIL: Elements missing after delete'",
            "echo 'Phase 7: Dynamic Resize Function Validation (CRITICAL)'",
            "dmesg | grep 'vector_resize:' && echo 'PASS: vector_resize() function called' || echo 'FAIL: vector_resize() never called'",
            "if [ $TEST_ADD_COUNT -ge 5 ]; then",
            "  dmesg | grep 'vector_resize: 4 to 8' && echo 'PASS: Resize from 4→8 confirmed (dynamic test)' || echo 'FAIL: Expected resize 4→8 missing'",
            "fi",
            "if [ $TEST_ADD_COUNT -ge 9 ]; then",
            "  dmesg | grep 'vector_resize: 8 to 16' && echo 'PASS: Resize from 8→16 confirmed (dynamic test)' || echo 'FAIL: Expected resize 8→16 missing'",
            "fi",
            "RESIZE_COUNT=$(dmesg | grep -c 'vector_resize:')",
            "EXPECTED_RESIZES=0",
            "if [ $TEST_ADD_COUNT -ge 5 ]; then EXPECTED_RESIZES=1; fi",
            "if [ $TEST_ADD_COUNT -ge 9 ]; then EXPECTED_RESIZES=2; fi",
            "echo 'Expected resizes: '$EXPECTED_RESIZES', Actual resizes: '$RESIZE_COUNT",
            "if [ $RESIZE_COUNT -ge $EXPECTED_RESIZES ]; then echo 'PASS: Dynamic resizing implemented correctly ('$RESIZE_COUNT' resize(s))'; else echo 'FAIL: Insufficient resizes (expected >='$EXPECTED_RESIZES', got '$RESIZE_COUNT')'; fi",
            "echo 'Phase 8: Edge Case Validation'",
            "dmesg | grep 'Get invalid index.*100.*: NULL' && echo 'PASS: Invalid get returns NULL' || echo 'FAIL: Invalid get handling broken'",
            "dmesg | grep 'Set invalid index.*100.*: ERROR' && echo 'PASS: Invalid set returns ERROR' || echo 'FAIL: Invalid set handling broken'",
            "echo 'Phase 9: Memory Management Validation'",
            "dmesg | grep 'vector_free: Freeing vector' && echo 'PASS: vector_free() called' || echo 'FAIL: vector_free() not called'",
            "dmesg | grep 'Vector freed' && echo 'PASS: Vector cleanup completed' || echo 'FAIL: Vector cleanup broken'",
            "echo 'Phase 10: Empty Vector Operations Validation (COMPREHENSIVE)'",
            "dmesg | grep 'Test 7: Empty vector operations' && echo 'PASS: Empty vector test present' || echo 'FAIL: Empty vector test missing'",
            "dmesg | grep 'Empty vector initialized.*total=0' && echo 'PASS: Empty vector init correct' || echo 'FAIL: Empty vector init wrong'",
            "dmesg | grep 'Get from empty vector.*NULL.*correct' && echo 'PASS: Empty get returns NULL' || echo 'FAIL: Empty get broken'",
            "dmesg | grep 'Delete from empty vector.*ERROR.*correct' && echo 'PASS: Empty delete returns ERROR' || echo 'FAIL: Empty delete broken'",
            "dmesg | grep 'Set on empty vector.*ERROR.*correct' && echo 'PASS: Empty set returns ERROR' || echo 'FAIL: Empty set broken'",
            "dmesg | grep 'Empty vector test completed' && echo 'PASS: Empty vector comprehensive test passed' || echo 'FAIL: Empty vector test incomplete'",
            "echo 'Phase 11: NULL Pointer Handling Validation (COMPREHENSIVE)'",
            "dmesg | grep 'Test 8: NULL pointer handling' && echo 'PASS: NULL test present' || echo 'FAIL: NULL test missing'",
            "dmesg | grep 'Add NULL pointer: SUCCESS' && echo 'PASS: Can add NULL pointers' || echo 'FAIL: Cannot add NULL'",
            "dmesg | grep 'Get NULL pointer: NULL.*correct' && echo 'PASS: NULL retrieved correctly' || echo 'FAIL: NULL retrieval broken'",
            "dmesg | grep 'Mixed NULL and valid pointers: total=4' && echo 'PASS: Mixed NULL/valid storage' || echo 'FAIL: Mixed storage broken'",
            "dmesg | grep 'Index 0: NULL' && echo 'PASS: NULL at index 0 detected' || echo 'FAIL: NULL detection broken'",
            "dmesg | grep 'Index 1: valid' && echo 'PASS: Valid pointer after NULL' || echo 'FAIL: Valid after NULL broken'",
            "dmesg | grep 'NULL pointer test completed' && echo 'PASS: NULL comprehensive test passed' || echo 'FAIL: NULL test incomplete'",
            "echo 'Phase 12: Capacity Shrinking Validation (COMPREHENSIVE)'",
            "dmesg | grep 'Test 9: Capacity shrinking test' && echo 'PASS: Shrinking test present' || echo 'FAIL: Shrinking test missing'",
            "dmesg | grep 'After adding 16 items: total=16, capacity=16' && echo 'PASS: Expanded to capacity=16' || echo 'FAIL: Expansion to 16 wrong'",
            "dmesg | grep 'After deleting to 4 items.*total=4, capacity=8' && echo 'PASS: Shrinking 16→8 WORKS!' || echo 'INFO: Shrinking not implemented (optional)'",
            "dmesg | grep 'Capacity shrinking: SUCCESS' && echo 'PASS: Shrinking algorithm implemented' || echo 'INFO: Shrinking optional feature'",
            "dmesg | grep 'Capacity shrinking test completed' && echo 'PASS: Shrinking test completed' || echo 'FAIL: Shrinking test incomplete'",
            "echo 'Phase 13: Add-Delete Cycle Validation (COMPREHENSIVE)'",
            "dmesg | grep 'Test 10: Add-Delete cycle test' && echo 'PASS: Cycle test present' || echo 'FAIL: Cycle test missing'",
            "dmesg | grep 'Cycle 0: After adding 10, total=10' && echo 'PASS: Cycle 0 add phase' || echo 'FAIL: Cycle 0 add broken'",
            "dmesg | grep 'Cycle 0: After deleting 5, total=5' && echo 'PASS: Cycle 0 delete phase' || echo 'FAIL: Cycle 0 delete broken'",
            "dmesg | grep 'Cycle 2: After adding 10' && echo 'PASS: Multiple cycles executed' || echo 'FAIL: Only single cycle'",
            "dmesg | grep 'After 3 cycles: total=15' && echo 'PASS: Final total correct (3 cycles, +5 each)' || echo 'FAIL: Cycle math wrong'",
            "dmesg | grep 'Add-Delete cycle test completed' && echo 'PASS: Cycle test passed' || echo 'FAIL: Cycle test incomplete'",
            "echo 'Phase 14: Comprehensive Test Summary'",
            "dmesg | grep 'All comprehensive tests completed' && echo 'PASS: All 10 comprehensive tests completed' || echo 'FAIL: Not all tests completed'",
            "TOTAL_TESTS=$(dmesg | grep -c 'Test [0-9]*:')",
            "echo 'Total test suites detected: '$TOTAL_TESTS",
            "if [ $TOTAL_TESTS -ge 10 ]; then echo 'PASS: All 10 test suites present'; else echo 'FAIL: Missing test suites (found '$TOTAL_TESTS'/10)'; fi",
            "echo '======================================================================'",
            "echo 'COMPREHENSIVE VALIDATION SUMMARY'",
            "echo '======================================================================'",
            "echo 'PASS: Core Operations: init, add, get, set, delete, free'",
            "echo 'PASS: Dynamic Expansion: Capacity doubling (4->8->16->32...)'",
            "echo 'PASS: Dynamic Shrinking: Capacity halving at 25% full'",
            "echo 'PASS: Empty Vector Ops: NULL returns, ERROR codes'",
            "echo 'PASS: NULL Handling: Store and retrieve NULL pointers'",
            "echo 'PASS: Cycle Testing: Add-delete patterns'",
            "echo 'PASS: Edge Cases: Invalid indices, bounds checking'",
            "echo 'PASS: Memory Management: Proper cleanup, no leaks'",
            "echo '======================================================================'",
            "echo 'PASS: All comprehensive vector validation phases completed successfully'"
          ],
          "expected": {
            "dmesg": [
              "Kernel vector module loaded",
              "Testing with capacity=",
              "Test 1: Vector initialization",
              "vector_init: Initializing vector",
              "Vector initialized: capacity=4, total=0",
              "Test 2: Adding elements",
              "vector_add: Adding item",
              "Added 'first' at index 0",
              "Added 'second' at index 1",
              "Test 3: Getting elements",
              "Element at index 0: first",
              "Test 4: Setting element",
              "vector_set: Setting index 1",
              "Modified element at index 1: modified",
              "Test 5: Deleting element",
              "vector_delete: Deleting index",
              "Deleted element at index",
              "Elements after deletion:",
              "Test 6: Edge case testing",
              "Get invalid index.*: NULL",
              "Set invalid index.*: ERROR",
              "vector_resize:",
              "vector_free: Freeing vector",
              "Vector freed",
              "Test 7: Empty vector operations",
              "Empty vector initialized.*total=0",
              "Get from empty vector.*NULL.*correct",
              "Delete from empty vector.*ERROR.*correct",
              "Set on empty vector.*ERROR.*correct",
              "Empty vector test completed",
              "Test 8: NULL pointer handling",
              "Add NULL pointer: SUCCESS",
              "Get NULL pointer: NULL.*correct",
              "Mixed NULL and valid pointers: total=4",
              "Index 0: NULL",
              "Index 1: valid",
              "NULL pointer test completed",
              "Test 9: Capacity shrinking test",
              "After adding 16 items: total=16, capacity=16",
              "After deleting to 4 items.*total=4",
              "Capacity shrinking test completed",
              "Test 10: Add-Delete cycle test",
              "Cycle 0: After adding 10, total=10",
              "Cycle 0: After deleting 5, total=5",
              "After 3 cycles: total=15",
              "Add-Delete cycle test completed",
              "All comprehensive tests completed",
              "Kernel vector module unloaded"
            ],
            "stdout": [
              "PASS: All function declarations found in header",
              "SUCCESS: Vector comprehensive test completed",
              "PASS: Vector initialization correct",
              "PASS: Vector add working",
              "PASS: Vector sequential add working",
              "PASS: Vector get working",
              "PASS: Vector set working",
              "PASS: Vector delete working",
              "Extracted: test_add_count=.*delete_index=",
              "PASS: Initial capacity=4 confirmed",
              "Capacity doubled correctly.*at index 4|Capacity remained 4",
              "PASS: Deleted at index.*dynamic",
              "PASS: Post-deletion verification present",
              "Total count correct after delete|Total after delete.*delete successful",
              "PASS: Elements still accessible after delete",
              "PASS: vector_resize\\(\\) function called",
              "Resize from 4.*8 confirmed.*dynamic|Expected resizes: 0",
              "PASS: Dynamic resizing implemented correctly.*resize",
              "PASS: Invalid get returns NULL",
              "PASS: Invalid set returns ERROR",
              "PASS: vector_free\\(\\) called",
              "PASS: Vector cleanup completed",
              "PASS: Empty vector test present",
              "PASS: Empty vector init correct",
              "PASS: Empty get returns NULL",
              "PASS: Empty delete returns ERROR",
              "PASS: Empty set returns ERROR",
              "PASS: Empty vector comprehensive test passed",
              "PASS: NULL test present",
              "PASS: Can add NULL pointers",
              "PASS: NULL retrieved correctly",
              "PASS: Mixed NULL/valid storage",
              "PASS: NULL at index 0 detected",
              "PASS: Valid pointer after NULL",
              "PASS: NULL comprehensive test passed",
              "PASS: Shrinking test present",
              "PASS: Expanded to capacity=16",
              "PASS: Shrinking test completed",
              "PASS: Cycle test present",
              "PASS: Cycle 0 add phase",
              "PASS: Cycle 0 delete phase",
              "PASS: Multiple cycles executed",
              "PASS: Final total correct.*3 cycles",
              "PASS: Cycle test passed",
              "PASS: All 10 comprehensive tests completed",
              "Total test suites detected:",
              "PASS: All 10 test suites present",
              "COMPREHENSIVE VALIDATION SUMMARY",
              "PASS: Core Operations:",
              "PASS: Dynamic Expansion:",
              "PASS: Dynamic Shrinking:",
              "PASS: Empty Vector Ops:",
              "PASS: NULL Handling:",
              "PASS: Cycle Testing:",
              "PASS: Edge Cases:",
              "PASS: Memory Management:",
              "PASS: All comprehensive vector validation phases completed successfully"
            ]
          },
          "timeout": 30
        }
      }
    ]
  }
}
