{
  "id": 27,
  "title": "Hash Tables - Key-Value Store",
  "phase": "foundations",
  "difficulty": 4,
  "xp": 45,
  "description": "Implement a simple hash table key-value store in kernel space. Learn how hash tables provide O(1) average-case lookups using hash functions and collision handling with chaining. This is the same pattern used for caches, symbol tables, and fast lookups throughout the kernel.",
  "mainFile": "kv_store.c",
  "files": [
    {
      "name": "kv_store.h",
      "content": "#ifndef KV_STORE_H\n#define KV_STORE_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#define HASH_TABLE_SIZE 16\n#define MAX_KEY_LEN 32\n#define MAX_VALUE_LEN 64\n\n/* Key-value entry with chaining for collisions */\nstruct kv_entry {\n    char *key;\n    char *value;\n    struct kv_entry *next;\n};\n\n/* Hash table structure */\nstruct kv_table {\n    int size;\n    struct kv_entry **buckets;\n};\n\n/* Global table for testing */\nextern struct kv_table *global_table;\n\n/* TODO: Declare your functions here */\n/* unsigned int kv_hash(const char *key); */\n/* struct kv_table *kv_table_create(int size); */\n/* int kv_set(struct kv_table *ht, const char *key, const char *value); */\n/* char *kv_get(struct kv_table *ht, const char *key); */\n/* int kv_delete(struct kv_table *ht, const char *key); */\n/* void kv_table_destroy(struct kv_table *ht); */\n\n#endif /* KV_STORE_H */",
      "readOnly": false,
      "language": "h"
    },
    {
      "name": "kv_store.c",
      "content": "#include \"kv_store.h\"\n\n/* Global table */\nstruct kv_table *global_table;\n\nchar *test_key = \"username\";\nchar *test_value = \"zerohexer\";\n\n/* IMPORTANT: DO NOT REMOVE OR MODIFY THE LINES BELOW! */\nmodule_param(test_key, charp, 0644);\nMODULE_PARM_DESC(test_key, \"Key for testing\");\nmodule_param(test_value, charp, 0644);\nMODULE_PARM_DESC(test_value, \"Value for testing\");\n/* END OF REQUIRED MODULE PARAMETER SECTION */\n\n/*\n * Hash function - convert string to bucket index\n *\n * Simple algorithm: h = h * 31 + char\n * Same key always returns same number (deterministic)\n *\n * Example trace for \"foo\":\n *   h = 0\n *   h = 0 * 31 + 'f' = 102\n *   h = 102 * 31 + 'o' = 3273\n *   h = 3273 * 31 + 'o' = 101472\n *   return 101472\n */\nunsigned int kv_hash(const char *key)\n{\n    /* TODO: Implement hash function */\n    /* TODO: Loop through each character */\n    /* TODO: h = h * 31 + *key */\n    /* TODO: Return h */\n    return 0;\n}\n\n/*\n * Create hash table with n buckets\n *\n * Memory layout after create(4):\n *\n * ht:\n * +------------------+\n * | size: 4          |\n * | buckets: --------+--> [NULL][NULL][NULL][NULL]\n * +------------------+       [0]   [1]   [2]   [3]\n */\nstruct kv_table *kv_table_create(int size)\n{\n    /* TODO: Allocate kv_table struct with kmalloc */\n    /* TODO: If NULL, return NULL */\n    /* TODO: Set ht->size = size */\n    /* TODO: Allocate buckets array with kcalloc (all NULL) */\n    /* TODO: If NULL, free ht and return NULL */\n    /* TODO: Print \"KV table created with %d buckets\" */\n    /* TODO: Return ht */\n    return NULL;\n}\n\n/*\n * Set key-value pair (insert or update)\n *\n * Two cases:\n * 1. Key exists -> update value (kfree old, kstrdup new)\n * 2. Key doesn't exist -> create entry, head insert\n *\n * Head insertion pattern:\n *   entry->next = bucket[index]\n *   bucket[index] = entry\n */\nint kv_set(struct kv_table *ht, const char *key, const char *value)\n{\n    /* TODO: Check for NULL parameters, return -EINVAL */\n    /* TODO: Calculate bucket index: hash(key) % size */\n    \n    /* TODO: Search for existing key in chain */\n    /* TODO: If found, update value (kfree old, kstrdup new) */\n    /* TODO: Print \"Updated key: %s\" and return 0 */\n    \n    /* TODO: Key not found - create new entry */\n    /* TODO: Allocate entry with kmalloc */\n    /* TODO: entry->key = kstrdup(key) */\n    /* TODO: entry->value = kstrdup(value) */\n    /* TODO: Head insert: entry->next = bucket, bucket = entry */\n    /* TODO: Print \"Inserted key: %s at bucket %d\" */\n    /* TODO: Return 0 on success, -ENOMEM on allocation failure */\n    return -ENOSYS;\n}\n\n/*\n * Get value by key\n *\n * 1. Hash key to find bucket\n * 2. Walk chain, strcmp each key\n * 3. Return value if found, NULL if not\n */\nchar *kv_get(struct kv_table *ht, const char *key)\n{\n    /* TODO: Check for NULL parameters */\n    /* TODO: Calculate bucket index */\n    /* TODO: Walk the chain at that bucket */\n    /* TODO: If strcmp(entry->key, key) == 0, return entry->value */\n    /* TODO: Return NULL if not found */\n    return NULL;\n}\n\n/*\n * Delete entry by key\n *\n * Must handle two cases:\n * - Entry is head: bucket[index] = entry->next\n * - Entry in middle: prev->next = entry->next\n */\nint kv_delete(struct kv_table *ht, const char *key)\n{\n    /* TODO: Check for NULL parameters */\n    /* TODO: Calculate bucket index */\n    /* TODO: Walk chain, keep track of prev pointer */\n    /* TODO: When found:\n     *       - Unlink: if prev==NULL then bucket=next, else prev->next=next\n     *       - Free: kfree(key), kfree(value), kfree(entry)\n     *       - Print \"Deleted key: %s\"\n     *       - Return 0 */\n    /* TODO: Return -ENOENT if not found */\n    return -ENOSYS;\n}\n\n/*\n * Destroy table and free all memory\n *\n * Pattern: save next BEFORE freeing current\n */\nvoid kv_table_destroy(struct kv_table *ht)\n{\n    /* TODO: Check for NULL */\n    /* TODO: For each bucket:\n     *       - Walk the chain\n     *       - Save next = current->next BEFORE freeing\n     *       - kfree(key), kfree(value), kfree(entry)\n     *       - current = next */\n    /* TODO: kfree(buckets) */\n    /* TODO: kfree(ht) */\n    /* TODO: Print \"KV table destroyed\" */\n}\n\nstatic int __init kv_store_init(void)\n{\n    char *result;\n    \n    printk(KERN_INFO \"KV Store module loaded\\n\");\n    printk(KERN_INFO \"Testing with key=%s, value=%s\\n\", test_key, test_value);\n    \n    /* Create table */\n    global_table = kv_table_create(HASH_TABLE_SIZE);\n    if (!global_table) {\n        printk(KERN_ERR \"Failed to create table\\n\");\n        return -ENOMEM;\n    }\n    \n    /* Test set */\n    kv_set(global_table, test_key, test_value);\n    kv_set(global_table, \"project\", \"kernelq\");\n    kv_set(global_table, \"version\", \"1.0\");\n    \n    /* Test get */\n    result = kv_get(global_table, test_key);\n    if (result)\n        printk(KERN_INFO \"Get %s = %s\\n\", test_key, result);\n    else\n        printk(KERN_INFO \"Get %s = (not found)\\n\", test_key);\n    \n    /* Test update */\n    kv_set(global_table, test_key, \"newvalue\");\n    result = kv_get(global_table, test_key);\n    printk(KERN_INFO \"After update: %s = %s\\n\", test_key, result ? result : \"(null)\");\n    \n    /* Test delete */\n    kv_delete(global_table, \"project\");\n    result = kv_get(global_table, \"project\");\n    printk(KERN_INFO \"After delete: project = %s\\n\", result ? result : \"(not found)\");\n    \n    printk(KERN_INFO \"KV Store tests completed\\n\");\n    \n    return 0;\n}\n\nstatic void __exit kv_store_exit(void)\n{\n    printk(KERN_INFO \"KV Store module unloading\\n\");\n    \n    if (global_table)\n        kv_table_destroy(global_table);\n    \n    printk(KERN_INFO \"KV Store module unloaded\\n\");\n}\n\nmodule_init(kv_store_init);\nmodule_exit(kv_store_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Simple key-value store using hash table\");\nMODULE_VERSION(\"1.0\");",
      "readOnly": false,
      "language": "c"
    },
    {
      "name": "VISUAL_GUIDE.md",
      "content": "# Hash Table Key-Value Store - Visual Guide\n\n## Understanding the Pattern\n\nThis guide uses **generic examples** (not the specific problem solution) to help you understand hash table operations step-by-step.\n\n---\n\n## CRITICAL CONCEPTS: Tables, Buckets, and Entries\n\nBefore diving into operations, you MUST understand these fundamental concepts, as they're the source of most confusion:\n\n### What is a \"Hash Table\"?\n\nA **hash table** is a data structure that provides O(1) average-case lookup by converting keys directly into array indices using a hash function.\n\n```\nKey insight: Instead of searching through all items...\n    Linear search: Check item 0, 1, 2, 3... until found → O(n)\n\nHash tables compute WHERE the item should be:\n    hash(\"username\") % 16 = 7  → Go directly to bucket 7! → O(1)\n```\n\n### What is a \"Bucket\"?\n\nA **bucket** is a slot in the hash table's array. Each bucket can hold a chain of entries (linked list):\n\n```\nHash Table with 4 buckets:\n\nbuckets array:\n┌─────────┬─────────┬─────────┬─────────┐\n│    0    │    1    │    2    │    3    │\n├─────────┼─────────┼─────────┼─────────┤\n│  NULL   │  entry  │  NULL   │  entry  │\n└─────────┴────┬────┴─────────┴────┬────┘\n               │                   │\n               ↓                   ↓\n           [k:v pair]          [k:v pair]\n               │                   │\n               ↓                   ↓\n           [k:v pair]            NULL\n               │\n               ↓\n             NULL\n```\n\n**Key Point:** Each bucket is either NULL (empty) or points to the first entry in a chain.\n\n### What is an \"Entry\"?\n\nAn **entry** holds one key-value pair plus a pointer to the next entry (for chaining):\n\n```c\nstruct entry {\n    char *key;      // The lookup key (e.g., \"username\")\n    char *value;    // The stored value (e.g., \"admin\")\n    struct entry *next;  // Next entry in this bucket's chain\n};\n```\n\n**Visual of single entry:**\n```\n    entry\n┌──────────────────┐\n│ key: ────────────┼──→ \"username\"\n│ value: ──────────┼──→ \"admin\"\n│ next: ───────────┼──→ NULL (or next entry)\n└──────────────────┘\n```\n\n### Memory Layout: What's Actually in Memory?\n\n```\nhash_table structure:\n┌──────────────────┐\n│ size: 4          │   ← Number of buckets\n│ buckets: ────────┼───┐\n└──────────────────┘   │\n                       ↓\nbuckets array (4 pointers):\n┌─────────┬─────────┬─────────┬─────────┐\n│  [0]    │  [1]    │  [2]    │  [3]    │\n│  NULL   │   •     │  NULL   │   •     │\n└─────────┴───┬─────┴─────────┴───┬─────┘\n              │                   │\n              ↓                   ↓\n         entry_A             entry_C\n    ┌──────────────┐    ┌──────────────┐\n    │ key:\"foo\"    │    │ key:\"baz\"    │\n    │ value:\"111\"  │    │ value:\"333\"  │\n    │ next: •      │    │ next: NULL   │\n    └───────┬──────┘    └──────────────┘\n            │\n            ↓\n         entry_B\n    ┌──────────────┐\n    │ key:\"bar\"    │\n    │ value:\"222\"  │\n    │ next: NULL   │\n    └──────────────┘\n\nBucket 1 has a CHAIN: entry_A → entry_B → NULL\nBucket 3 has one entry: entry_C → NULL\nBuckets 0 and 2 are empty (NULL)\n```\n\n### Why Chaining?\n\nDifferent keys can produce the same bucket index (collision). Chaining solves this:\n\n```\nhash(\"foo\") % 4 = 1\nhash(\"bar\") % 4 = 1   ← COLLISION! Same bucket!\n\nSolution: Both entries go in bucket 1's chain:\n    buckets[1] → [\"foo\":\"111\"] → [\"bar\":\"222\"] → NULL\n```\n\n---\n\n## THE HASH FUNCTION: Converting Keys to Numbers\n\nA hash function converts a string key into a number (bucket index).\n\n### The Algorithm\n\nSimple and effective hash (djb2-like):\n```\nh = 0\nfor each character c in key:\n    h = h * 31 + c\nreturn h\n```\n\n### Visual Trace\n\n```\nComputing hash(\"cat\"):\n\nStep 0: h = 0\n\nStep 1: Process 'c' (ASCII 99)\n        h = 0 * 31 + 99\n        h = 99\n\nStep 2: Process 'a' (ASCII 97)\n        h = 99 * 31 + 97\n        h = 3069 + 97\n        h = 3166\n\nStep 3: Process 't' (ASCII 116)\n        h = 3166 * 31 + 116\n        h = 98146 + 116\n        h = 98262\n\nResult: hash(\"cat\") = 98262\n\nBucket index: 98262 % 16 = 6\n                     ↑\n            table size (modulo)\n```\n\n### Why This Works\n\n1. **Deterministic**: Same key ALWAYS produces same number\n2. **Distribution**: Different keys spread across buckets (fewer collisions)\n3. **Fast**: Simple arithmetic, O(n) where n = key length\n\n### Why Multiply by 31?\n\n```\nIf we just added characters:\n    hash(\"abc\") = 97 + 98 + 99 = 294\n    hash(\"cba\") = 99 + 98 + 97 = 294  ← COLLISION!\n\nWith multiplication, position matters:\n    hash(\"abc\") = 0*31 + 97 = 97, then 97*31 + 98 = 3105, then...\n    hash(\"cba\") = 0*31 + 99 = 99, then 99*31 + 98 = 3167, then...\n    Different results! Position matters now.\n```\n\n---\n\n## OPERATION 1: Create Table\n\n**Goal:** Allocate the hash table structure and its bucket array.\n\n### Memory Allocation Steps\n\n```\nSTEP 1: Allocate the table structure\n┌──────────────────┐\n│ size: ???        │   ← Uninitialized\n│ buckets: ???     │   ← Uninitialized\n└──────────────────┘\n\nSTEP 2: Set the size\n┌──────────────────┐\n│ size: 16         │   ← Set to requested size\n│ buckets: ???     │\n└──────────────────┘\n\nSTEP 3: Allocate bucket array (all NULL)\n┌──────────────────┐\n│ size: 16         │\n│ buckets: ────────┼───→ [NULL][NULL][NULL]...[NULL]\n└──────────────────┘        0    1    2   ...   15\n\n                    ↑ kcalloc zeros all pointers!\n```\n\n### Why kcalloc for Buckets?\n\n```\nkmalloc: Allocates memory with GARBAGE values\n    buckets[0] = 0x7fff8234  ← Random! Will crash if dereferenced!\n    buckets[1] = 0xdeadbeef\n    buckets[2] = 0x00000042\n\nkcalloc: Allocates memory with ALL ZEROS\n    buckets[0] = NULL  ← Safe! Means \"empty bucket\"\n    buckets[1] = NULL\n    buckets[2] = NULL\n```\n\n### Error Handling Pattern\n\n```\nAllocate table\n    ↓\nFailed? → Return NULL (nothing to clean up)\n    ↓\nSuccess → Set size\n    ↓\nAllocate buckets\n    ↓\nFailed? → Free table, then return NULL\n    ↓       ↑\n    │   CRITICAL: Clean up partial allocation!\n    ↓\nSuccess → Return table pointer\n```\n\n---\n\n## OPERATION 2: Set (Insert or Update)\n\n**Goal:** Store a key-value pair. If key exists, update value. Otherwise, insert new entry.\n\n### Case 1: Key Doesn't Exist (INSERT)\n\n**Scenario:** Setting \"user\" → \"alice\" in an empty bucket\n\n```\nBEFORE:\nbuckets[3] = NULL  (empty bucket, hash(\"user\") % 16 = 3)\n\nSTEP 1: Allocate new entry\n┌──────────────────┐\n│ key: ???         │\n│ value: ???       │\n│ next: ???        │\n└──────────────────┘\n\nSTEP 2: Set key and value (using string duplication)\n┌──────────────────┐\n│ key: ────────────┼──→ \"user\"  (kstrdup created this copy)\n│ value: ──────────┼──→ \"alice\" (kstrdup created this copy)\n│ next: ???        │\n└──────────────────┘\n\nSTEP 3: Head insertion\n    entry->next = buckets[3];  // Point to old head (NULL)\n    buckets[3] = entry;        // Entry becomes new head\n\nAFTER:\nbuckets[3] ──→ ┌──────────────────┐\n               │ key: \"user\"      │\n               │ value: \"alice\"   │\n               │ next: NULL       │\n               └──────────────────┘\n```\n\n### Case 2: Collision (INSERT into existing chain)\n\n**Scenario:** Setting \"name\" → \"bob\" when bucket already has entries\n\n```\nBEFORE:\nbuckets[3] ──→ [\"user\":\"alice\"] ──→ NULL\n\nhash(\"name\") % 16 = 3  ← Same bucket! Collision!\n\nSTEP 1: Create new entry for \"name\":\"bob\"\n\nSTEP 2: Head insertion (NEW entry goes at FRONT)\n    entry->next = buckets[3];   // Point to old head\n    buckets[3] = entry;         // Entry becomes new head\n\nAFTER:\nbuckets[3] ──→ [\"name\":\"bob\"] ──→ [\"user\":\"alice\"] ──→ NULL\n               ↑ NEW (head)       ↑ OLD (pushed back)\n```\n\n**Why head insertion?**\n- O(1) time - no need to traverse to end\n- Recently added items often accessed soon (cache-friendly)\n- Same pattern as linked list add-at-head from Problem 26!\n\n### Case 3: Key Exists (UPDATE)\n\n**Scenario:** Setting \"user\" → \"charlie\" when \"user\" already exists\n\n```\nBEFORE:\nbuckets[3] ──→ [\"name\":\"bob\"] ──→ [\"user\":\"alice\"] ──→ NULL\n\nhash(\"user\") % 16 = 3\n\nSTEP 1: Walk chain, looking for matching key\n    Check \"name\" - strcmp(\"name\", \"user\") != 0, continue\n    Check \"user\" - strcmp(\"user\", \"user\") == 0, FOUND!\n\nSTEP 2: Update value (NOT insert!)\n    kfree(entry->value);              // Free old \"alice\"\n    entry->value = kstrdup(\"charlie\"); // Set new \"charlie\"\n\nAFTER:\nbuckets[3] ──→ [\"name\":\"bob\"] ──→ [\"user\":\"charlie\"] ──→ NULL\n                                        ↑ UPDATED!\n\nNO new entry created - just updated existing!\n```\n\n### String Duplication: Why kstrdup?\n\n```\nWRONG approach (storing pointer directly):\n    entry->key = key;  // Points to caller's memory!\n    \n    Problem: If caller's string is freed or modified,\n             our hash table now has dangling/wrong pointer!\n\nRIGHT approach (making our own copy):\n    entry->key = kstrdup(key, GFP_KERNEL);\n    \n    Now we OWN this copy. Safe even if caller's string changes.\n```\n\n---\n\n## OPERATION 3: Get (Lookup)\n\n**Goal:** Find and return the value for a given key.\n\n### The Algorithm\n\n```\n1. Hash the key to find bucket index\n2. Walk the chain at that bucket\n3. Compare each entry's key using strcmp\n4. Return value if found, NULL if not found\n```\n\n### Visual Walkthrough\n\n**Scenario:** Looking up \"user\"\n\n```\nbuckets[3] ──→ [\"name\":\"bob\"] ──→ [\"user\":\"charlie\"] ──→ NULL\n\nSTEP 1: Calculate bucket\n    hash(\"user\") % 16 = 3\n\nSTEP 2: Start at buckets[3]\n    current = buckets[3]  → points to [\"name\":\"bob\"]\n\nSTEP 3: Check first entry\n    strcmp(\"name\", \"user\") = -1  ← NOT EQUAL (non-zero)\n    current = current->next       → points to [\"user\":\"charlie\"]\n\nSTEP 4: Check second entry\n    strcmp(\"user\", \"user\") = 0   ← EQUAL! (zero means match)\n    FOUND! Return \"charlie\"\n```\n\n### Not Found Case\n\n```\nLooking for \"email\" (doesn't exist):\n\nbuckets[3] ──→ [\"name\":\"bob\"] ──→ [\"user\":\"charlie\"] ──→ NULL\n\nSTEP 1: hash(\"email\") % 16 = 3\n\nSTEP 2: Check \"name\" - not equal\nSTEP 3: Check \"user\" - not equal\nSTEP 4: current = NULL (end of chain)\n\nNOT FOUND - Return NULL\n```\n\n### Empty Bucket Case\n\n```\nLooking for \"xyz\":\n\nhash(\"xyz\") % 16 = 7\nbuckets[7] = NULL  (empty bucket)\n\nSTEP 1: current = buckets[7] = NULL\nSTEP 2: Loop doesn't execute (current is NULL)\n\nNOT FOUND - Return NULL (immediately, no comparisons needed)\n```\n\n---\n\n## OPERATION 4: Delete\n\n**Goal:** Remove an entry by key, freeing all associated memory.\n\n### Challenge: Head vs Middle Deletion\n\nDeletion requires different handling based on position:\n\n```\nDeleting HEAD:        buckets[i] must be updated\nDeleting MIDDLE:      previous->next must be updated\n```\n\n### Case 1: Deleting HEAD Entry\n\n**Scenario:** Delete \"name\" (first in chain)\n\n```\nBEFORE:\nbuckets[3] ──→ [\"name\":\"bob\"] ──→ [\"user\":\"alice\"] ──→ NULL\n               ↑ DELETE THIS\n\nSTEP 1: Find entry, track previous\n    prev = NULL  (nothing before head)\n    current = buckets[3]  → [\"name\":\"bob\"]\n    strcmp(\"name\", \"name\") == 0  → FOUND!\n\nSTEP 2: Unlink (prev is NULL, so update bucket)\n    buckets[3] = current->next;  // Bucket now points to \"user\"\n\nSTEP 3: Free memory\n    kfree(current->key);     // Free \"name\" string\n    kfree(current->value);   // Free \"bob\" string\n    kfree(current);          // Free entry struct\n\nAFTER:\nbuckets[3] ──→ [\"user\":\"alice\"] ──→ NULL\n               ↑ Now the head\n```\n\n### Case 2: Deleting MIDDLE Entry\n\n**Scenario:** Delete \"user\" (second in chain)\n\n```\nBEFORE:\nbuckets[3] ──→ [\"name\":\"bob\"] ──→ [\"user\":\"alice\"] ──→ [\"role\":\"admin\"] ──→ NULL\n                                  ↑ DELETE THIS\n\nSTEP 1: Find entry, track previous\n    prev = NULL, current = [\"name\":\"bob\"]\n    strcmp(\"name\", \"user\") != 0, continue\n    \n    prev = [\"name\":\"bob\"], current = [\"user\":\"alice\"]\n    strcmp(\"user\", \"user\") == 0  → FOUND!\n\nSTEP 2: Unlink (prev is NOT NULL, so update prev->next)\n    prev->next = current->next;  // \"name\" now points to \"role\"\n\n    Visual of the unlink:\n    [\"name\":\"bob\"] ──→ [\"user\":\"alice\"] ──→ [\"role\":\"admin\"]\n          │                    ↑                    ↑\n          │               being deleted             │\n          └─────────────────────────────────────────┘\n                    prev->next = current->next\n\nSTEP 3: Free memory\n    kfree(current->key);     // Free \"user\" string\n    kfree(current->value);   // Free \"alice\" string\n    kfree(current);          // Free entry struct\n\nAFTER:\nbuckets[3] ──→ [\"name\":\"bob\"] ──→ [\"role\":\"admin\"] ──→ NULL\n                      │                   ↑\n                      └───────────────────┘\n                      Direct link now!\n```\n\n### The prev Pointer Pattern\n\n```\nKeep TWO pointers while walking:\n    prev = NULL\n    current = buckets[index]\n    \n    while (current != NULL) {\n        if (strcmp(current->key, target) == 0) {\n            // FOUND! Now unlink based on prev\n            if (prev == NULL) {\n                // Deleting head - update bucket\n                buckets[index] = current->next;\n            } else {\n                // Deleting middle - update prev\n                prev->next = current->next;\n            }\n            // Free and return\n        }\n        prev = current;\n        current = current->next;\n    }\n```\n\n---\n\n## OPERATION 5: Destroy (Free Everything)\n\n**Goal:** Clean up the entire hash table, freeing ALL allocated memory.\n\n### The Critical Pattern: Save Next BEFORE Freeing\n\n```\nWRONG (use-after-free bug):\n    while (current != NULL) {\n        kfree(current);           // Memory freed!\n        current = current->next;  // CRASH! Accessing freed memory!\n    }\n\nRIGHT (save next pointer first):\n    while (current != NULL) {\n        next = current->next;     // Save BEFORE free!\n        kfree(current->key);\n        kfree(current->value);\n        kfree(current);           // Now safe to free\n        current = next;           // Use saved pointer\n    }\n```\n\n### Visual Walkthrough\n\n**Scenario:** Destroying table with entries\n\n```\nINITIAL STATE:\n┌──────────────────┐\n│ size: 4          │\n│ buckets: ────────┼──→ [NULL][•][NULL][•]\n└──────────────────┘         │        │\n                             ↓        ↓\n                          [A]──→[B]  [C]\n                                 │\n                                 ↓\n                               NULL\n\nPHASE 1: Process bucket 0\n    buckets[0] = NULL\n    Nothing to free, skip\n\nPHASE 2: Process bucket 1\n    current = [A]\n    \n    Iteration 1:\n        next = [B]           // Save!\n        kfree([A]->key)\n        kfree([A]->value)\n        kfree([A])           // [A] is gone\n        current = [B]        // Move to saved next\n    \n    Iteration 2:\n        next = NULL          // Save!\n        kfree([B]->key)\n        kfree([B]->value)\n        kfree([B])           // [B] is gone\n        current = NULL       // Exit loop\n\nPHASE 3: Process bucket 2\n    buckets[2] = NULL\n    Nothing to free, skip\n\nPHASE 4: Process bucket 3\n    current = [C]\n    \n    Iteration 1:\n        next = NULL\n        kfree([C]->key)\n        kfree([C]->value)\n        kfree([C])\n        current = NULL\n\nPHASE 5: Free the buckets array\n    kfree(buckets);\n\nPHASE 6: Free the table structure\n    kfree(table);\n\nFINAL STATE:\n    All memory returned to system!\n    No leaks!\n```\n\n### Memory Free Order\n\n```\nFor each entry:\n    1. kfree(entry->key)     // Free the key string\n    2. kfree(entry->value)   // Free the value string  \n    3. kfree(entry)          // Free the entry struct\n    \nFor the table:\n    4. kfree(table->buckets) // Free the bucket array\n    5. kfree(table)          // Free the table struct\n\nCRITICAL: Free in order of dependency!\n    - Free strings before entry (entry holds the pointers)\n    - Free entries before buckets (buckets hold entry pointers)\n    - Free buckets before table (table holds buckets pointer)\n```\n\n---\n\n## CONNECTING TO LINKED LISTS (Problem 26)\n\nHash table chaining uses the same patterns you learned in Problem 26!\n\n### Same Concepts, Different Context\n\n```\nLinked List (Problem 26):       Hash Table Chain:\n┌────────────────────────────┬────────────────────────────┐\n│ head → node1 → node2 → ... │ bucket[i] → entry1 → ...  │\n├────────────────────────────┼────────────────────────────┤\n│ Add at head                │ Head insertion             │\n│ head->next = node          │ bucket = entry             │\n├────────────────────────────┼────────────────────────────┤\n│ Delete: update prev->next  │ Same pattern!              │\n├────────────────────────────┼────────────────────────────┤\n│ Traverse: walk next ptrs   │ Same pattern!              │\n├────────────────────────────┼────────────────────────────┤\n│ Safe delete: save next     │ Same pattern!              │\n└────────────────────────────┴────────────────────────────┘\n```\n\n### Key Difference\n\n```\nLinked List:\n    ONE list starting from head\n    All items in sequential order\n\nHash Table:\n    MULTIPLE independent lists (one per bucket)\n    Items grouped by hash value\n    \n    bucket[0] → chain0\n    bucket[1] → chain1  ← Each is its own linked list!\n    bucket[2] → chain2\n    ...\n```\n\n---\n\n## KERNEL MEMORY FUNCTIONS\n\n### Allocation Functions\n\n| Function | Purpose | Returns |\n|----------|---------|--------|\n| `kmalloc(size, flags)` | Allocate size bytes | Pointer or NULL |\n| `kcalloc(n, size, flags)` | Allocate n×size bytes, zeroed | Pointer or NULL |\n| `kstrdup(str, flags)` | Duplicate string | New string or NULL |\n| `kfree(ptr)` | Free memory | void |\n\n### When to Use Each\n\n```\nkmalloc:  Single struct allocation\n    struct entry *e = kmalloc(sizeof(*e), GFP_KERNEL);\n\nkcalloc:  Array allocation (auto-zeroed)\n    void **buckets = kcalloc(size, sizeof(void*), GFP_KERNEL);\n\nkstrdup:  String duplication\n    entry->key = kstrdup(key, GFP_KERNEL);\n\nkfree:    ALL allocated memory must be freed!\n    kfree(entry->key);\n    kfree(entry);\n```\n\n### GFP_KERNEL Flag\n\n```\nGFP_KERNEL = \"Get Free Pages - KERNEL context\"\n\nMeaning:\n- Can sleep while waiting for memory\n- Appropriate for normal kernel code\n- Use this unless you have a specific reason not to\n```\n\n---\n\n## COMMON MISTAKES AND SOLUTIONS\n\n### Mistake 1: Forgetting to Check NULL\n\n```\nWRONG:\n    struct table *t = kmalloc(...);\n    t->size = 16;  // CRASH if kmalloc failed!\n\nRIGHT:\n    struct table *t = kmalloc(...);\n    if (!t)\n        return NULL;  // Handle failure first!\n    t->size = 16;\n```\n\n### Mistake 2: Use-After-Free in Destroy\n\n```\nWRONG:\n    kfree(current);\n    current = current->next;  // CRASH!\n\nRIGHT:\n    next = current->next;\n    kfree(current);\n    current = next;\n```\n\n### Mistake 3: Storing Pointer Instead of Copy\n\n```\nWRONG:\n    entry->key = key;  // Just stores pointer!\n\nRIGHT:\n    entry->key = kstrdup(key, GFP_KERNEL);  // Makes copy!\n```\n\n### Mistake 4: Memory Leak on Error\n\n```\nWRONG:\n    table = kmalloc(...);\n    table->buckets = kcalloc(...);\n    if (!table->buckets)\n        return NULL;  // LEAK! table not freed!\n\nRIGHT:\n    table = kmalloc(...);\n    table->buckets = kcalloc(...);\n    if (!table->buckets) {\n        kfree(table);  // Clean up partial allocation!\n        return NULL;\n    }\n```\n\n### Mistake 5: Wrong Delete When Head\n\n```\nWRONG (always using prev):\n    prev->next = current->next;  // CRASH if prev is NULL!\n\nRIGHT (check for head case):\n    if (prev == NULL)\n        buckets[index] = current->next;  // Update bucket\n    else\n        prev->next = current->next;       // Update chain\n```\n\n---\n\n## KEY INSIGHTS\n\n1. **Hash function is deterministic** - Same key ALWAYS produces same bucket index\n\n2. **Collisions are handled by chaining** - Multiple entries can share a bucket\n\n3. **Head insertion is O(1)** - New entries go at front of chain, no traversal needed\n\n4. **Lookup walks the chain** - Hash gives O(1) bucket access, then linear chain search\n\n5. **Delete needs two cases** - Head deletion updates bucket, middle deletion updates prev->next\n\n6. **Save next before freeing** - Essential pattern to avoid use-after-free bugs\n\n7. **kstrdup owns the copy** - We allocate our own key/value strings for safety\n\n8. **kcalloc zeros memory** - Empty buckets are safely NULL, not garbage pointers\n\n9. **Free in dependency order** - Strings → entries → buckets → table\n\n10. **Chaining is just linked lists** - Same patterns from Problem 26 apply!\n\n---\n\nNow apply these patterns to your specific problem! The operations are the same, just adapt the struct names and function names.\n",
      "readOnly": true,
      "language": "txt"
    },
    {
      "name": "Makefile",
      "content": "obj-m += kv_store.o\n\nKDIR := /lib/modules/$(shell uname -r)/build\n\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\n.PHONY: all clean",
      "readOnly": true,
      "language": "makefile"
    }
  ],
  "concepts": [
    "hash table fundamentals",
    "hash functions",
    "collision handling with chaining",
    "head insertion pattern",
    "key-value storage",
    "O(1) lookup operations",
    "memory management patterns"
  ],
  "skills": [
    "Implementing hash functions",
    "Managing linked list chains",
    "Handling hash collisions",
    "Proper memory allocation and freeing",
    "String duplication with kstrdup",
    "Safe deletion patterns"
  ],
  "validation": {
    "exactRequirements": {
      "functionNames": [
        "kv_store_init",
        "kv_store_exit",
        "kv_hash",
        "kv_table_create",
        "kv_set",
        "kv_get",
        "kv_delete",
        "kv_table_destroy"
      ],
      "function_declarations": [
        {
          "name": "kv_hash",
          "returnType": "unsigned int",
          "parameters": ["const char *key"]
        },
        {
          "name": "kv_table_create",
          "returnType": "struct kv_table*",
          "parameters": ["int size"]
        },
        {
          "name": "kv_set",
          "returnType": "int",
          "parameters": ["struct kv_table *ht", "const char *key", "const char *value"]
        },
        {
          "name": "kv_get",
          "returnType": "char*",
          "parameters": ["struct kv_table *ht", "const char *key"]
        },
        {
          "name": "kv_delete",
          "returnType": "int",
          "parameters": ["struct kv_table *ht", "const char *key"]
        },
        {
          "name": "kv_table_destroy",
          "returnType": "void",
          "parameters": ["struct kv_table *ht"]
        }
      ],
      "variables_declarations": [
        {
          "name": "kv_entry",
          "type": "struct",
          "value": "{char *key; char *value; struct kv_entry *next;}",
          "storageClass": "none"
        },
        {
          "name": "kv_table",
          "type": "struct",
          "value": "{int size; struct kv_entry **buckets;}",
          "storageClass": "none"
        },
        {
          "name": "global_table",
          "type": "struct kv_table*",
          "storageClass": "extern"
        }
      ],
      "variables": [
        {
          "name": "global_table",
          "type": "struct kv_table*",
          "storageClass": "none"
        }
      ],
      "outputMessages": [
        "KV Store module loaded",
        "KV table created",
        "Inserted key:",
        "Updated key:",
        "Get",
        "Deleted key:",
        "KV table destroyed",
        "KV Store module unloaded"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/slab.h",
        "linux/string.h"
      ],
      "mustContain": [
        "h * 31",
        "% ht->size",
        "kmalloc(",
        "kcalloc(",
        "kfree(",
        "kstrdup(",
        "strcmp(",
        "->next",
        "module_param("
      ],
      "moduleInfo": {
        "license": "GPL"
      }
    },
    "testCases": [
      {
        "id": "function_declarations",
        "name": "Function Declarations in Header",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "unsigned int kv_hash(const char *key)",
          "int kv_set(struct kv_table *ht, const char *key, const char *value)",
          "int kv_delete(struct kv_table *ht, const char *key)",
          "void kv_table_destroy(struct kv_table *ht)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "function_signatures_source",
        "name": "Function Signatures in Source File",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "unsigned int kv_hash(const char *key)",
          "int kv_set(struct kv_table *ht, const char *key, const char *value)",
          "int kv_delete(struct kv_table *ht, const char *key)",
          "void kv_table_destroy(struct kv_table *ht)",
          "static int __init kv_store_init(void)",
          "static void __exit kv_store_exit(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "exact_output",
        "name": "Exact Output Messages",
        "type": "output_match",
        "critical": true,
        "expected": [
          {
            "pattern": "KV Store module loaded",
            "exact": true,
            "linkedFunction": "static int __init kv_store_init(void)"
          },
          {
            "pattern": "KV table created with .* buckets",
            "exact": false,
            "linkedFunction": "struct kv_table *kv_table_create(int size)"
          },
          {
            "pattern": "Inserted key:",
            "exact": false,
            "linkedFunction": "int kv_set(struct kv_table *ht, const char *key, const char *value)"
          },
          {
            "pattern": "KV Store tests completed",
            "exact": true,
            "linkedFunction": "static int __init kv_store_init(void)"
          },
          {
            "pattern": "KV Store module unloading",
            "exact": true,
            "linkedFunction": "static void __exit kv_store_exit(void)"
          },
          {
            "pattern": "KV table destroyed",
            "exact": true,
            "linkedFunction": "void kv_table_destroy(struct kv_table *ht)"
          },
          {
            "pattern": "KV Store module unloaded",
            "exact": true,
            "linkedFunction": "static void __exit kv_store_exit(void)"
          }
        ]
      },
      {
        "id": "kv_store_validation",
        "name": "KV Store Implementation with Anti-Hardcoding",
        "type": "kernel_project_test",
        "critical": true,
        "testScenario": {
          "userspaceApps": [
            {
              "name": "kv_store_tester",
              "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <time.h>\\n#include <string.h>\\n\\nint main() {\\n    printf(\\\"=== KV Store Anti-Hardcoding Test ===\\\\n\\\");\\n    srand(time(NULL));\\n    int r = rand() % 1000;\\n    char key[32], value[32];\\n    snprintf(key, 32, \\\"testkey%d\\\", r);\\n    snprintf(value, 32, \\\"testval%d\\\", r);\\n    printf(\\\"Test with key=%s value=%s\\\\n\\\", key, value);\\n    system(\\\"rmmod kv_store 2>/dev/null\\\");\\n    char cmd[256];\\n    snprintf(cmd, 256, \\\"insmod /lib/modules/kv_store.ko test_key=%s test_value=%s\\\", key, value);\\n    printf(\\\"Command: %s\\\\n\\\", cmd);\\n    system(cmd);\\n    printf(\\\"SUCCESS: Test completed\\\\n\\\");\\n    return 0;\\n}"
            }
          ],
          "setupCommands": [
            "echo 'Starting KV Store validation'"
          ],
          "testCommands": [
            "echo 'Phase 1: TCC Header Validation'",
            "mkdir -p /tmp/linux",
            "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
            "echo '#define KERN_ERR' >> /tmp/linux/kernel.h",
            "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
            "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
            "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
            "echo '#define module_init(x)' >> /tmp/linux/module.h",
            "echo '#define module_exit(x)' >> /tmp/linux/module.h",
            "echo '#define module_param(name, type, perm)' >> /tmp/linux/module.h",
            "echo '#define MODULE_PARM_DESC(var, desc)' >> /tmp/linux/module.h",
            "echo '#define __init' > /tmp/linux/init.h",
            "echo '#define __exit' >> /tmp/linux/init.h",
            "echo 'typedef unsigned long size_t;' > /tmp/linux/slab.h",
            "echo 'void* kmalloc(size_t size, int flags);' >> /tmp/linux/slab.h",
            "echo 'void* kcalloc(size_t n, size_t size, int flags);' >> /tmp/linux/slab.h",
            "echo 'void kfree(const void *ptr);' >> /tmp/linux/slab.h",
            "echo 'char* kstrdup(const char *s, int flags);' >> /tmp/linux/slab.h",
            "echo '#define GFP_KERNEL 0' >> /tmp/linux/slab.h",
            "echo 'int strcmp(const char *s1, const char *s2);' > /tmp/linux/string.h",
            "echo '#define ENOSYS 38' > /tmp/linux/errno.h",
            "echo '#define ENOMEM 12' >> /tmp/linux/errno.h",
            "echo '#define ENOENT 2' >> /tmp/linux/errno.h",
            "echo '#define EINVAL 22' >> /tmp/linux/errno.h",
            "echo '#include \"/lib/modules/kv_store.h\"' > /tmp/test.c",
            "echo 'int main() { struct kv_table *t; kv_hash(\"x\"); t = kv_table_create(16); kv_set(t, \"k\", \"v\"); kv_get(t, \"k\"); kv_delete(t, \"k\"); kv_table_destroy(t); return 0; }' >> /tmp/test.c",
            "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
            "TCC_EXIT=$?",
            "if [ $TCC_EXIT -ne 0 ]; then echo 'FAIL: Function declaration missing in header'; cat /tmp/tcc_error.log; else echo 'PASS: All function declarations found in header'; fi",
            "echo 'Phase 2: Anti-Hardcoding Test'",
            "/bin/kv_store_tester > /tmp/test_output.log",
            "cat /tmp/test_output.log",
            "sleep 1",
            "echo 'Phase 3: Validate Operations'",
            "TEST_KEY=$(grep -o 'key=testkey[0-9]*' /tmp/test_output.log | head -1 | cut -d= -f2)",
            "echo 'Extracted test key:' $TEST_KEY",
            "dmesg | grep \"Inserted key: $TEST_KEY\" && echo 'PASS: Insert with random key' || echo 'FAIL: Insert broken'",
            "dmesg | grep \"Get $TEST_KEY\" && echo 'PASS: Get with random key' || echo 'FAIL: Get broken'",
            "echo 'Phase 4: Core Function Validation'",
            "dmesg | grep 'KV Store module loaded' && echo 'PASS: Module init' || echo 'FAIL: Module init'",
            "dmesg | grep 'KV table created' && echo 'PASS: Table create' || echo 'FAIL: Table create'",
            "dmesg | grep 'Inserted key:' && echo 'PASS: Insert working' || echo 'FAIL: Insert broken'",
            "dmesg | grep 'Updated key:' && echo 'PASS: Update working' || echo 'FAIL: Update broken'",
            "dmesg | grep 'Deleted key:' && echo 'PASS: Delete working' || echo 'FAIL: Delete broken'",
            "dmesg | grep 'KV table destroyed' && echo 'PASS: Destroy working' || echo 'FAIL: Destroy broken'",
            "dmesg | grep 'KV Store module unloaded' && echo 'PASS: Module exit' || echo 'FAIL: Module exit'",
            "echo 'All validations completed'"
          ],
          "expected": {
            "dmesg": [
              "KV Store module loaded",
              "KV table created",
              "Inserted key:",
              "Updated key:",
              "Deleted key:",
              "KV table destroyed",
              "KV Store module unloaded"
            ],
            "stdout": [
              "PASS: All function declarations found in header",
              "SUCCESS: Test completed",
              "PASS: Insert with random key",
              "PASS: Module init",
              "PASS: Table create",
              "PASS: Insert working",
              "PASS: Update working",
              "PASS: Delete working",
              "PASS: Destroy working",
              "PASS: Module exit"
            ]
          },
          "timeout": 30
        }
      }
    ]
  }
}
