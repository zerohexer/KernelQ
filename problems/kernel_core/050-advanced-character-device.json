{
  "id": 50,
  "title": "Advanced Character Device with Hardware Emulation",
  "phase": "kernel_core",
  "difficulty": 8,
  "xp": 100,
  "description": "Create a complete character device driver that handles read/write operations and test it with hardware emulation. This problem demonstrates advanced kernel_project_test capabilities including QEMU device emulation and userspace testing.",
  "starter": "// SPDX-License-Identifier: GPL-2.0\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\n#define DEVICE_NAME \"mychardev\"\n#define CLASS_NAME \"myclass\"\n\nstatic dev_t device_number;\nstatic struct class *device_class;\nstatic struct device *device_struct;\nstatic struct cdev device_cdev;\n\n/* TODO: Implement your character device driver here */\n\nstatic int __init mydriver_init(void)\n{\n\tpr_info(\"mychardev: driver loaded\\n\");\n\t/* TODO: Initialize your device */\n\treturn 0;\n}\n\nstatic void __exit mydriver_exit(void)\n{\n\tpr_info(\"mychardev: driver unloaded\\n\");\n\t/* TODO: Cleanup your device */\n}\n\nmodule_init(mydriver_init);\nmodule_exit(mydriver_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Advanced Character Device Driver\");\nMODULE_VERSION(\"1.0\");",
  "concepts": ["character devices", "file operations", "device nodes", "hardware emulation", "userspace interface"],
  "skills": ["driver development", "QEMU testing", "device file operations", "kernel-userspace communication"],
  "displayRequirements": {
    "summary": "Implement file_operations (open, read, write, release) and register character device with name 'mychardev' to pass userspace tests.",
    "qemuArgs": [
      "QEMU provides hardware emulation environment with PCI devices",
      "Use standard kernel APIs: alloc_chrdev_region(), cdev_init(), cdev_add()"
    ],
    "userspaceApps": [
      "Test writes string 'Hello from userspace!' (21 bytes) and reads it back",
      "Must handle lseek(fd, 0, SEEK_SET) to reset file position",
      "Return exact byte counts: write() and read() must return same number of bytes",
      "Support copy_to_user() and copy_from_user() for data transfer"
    ],
    "setup": [
      "Device registration: use alloc_chrdev_region(&device_number, 0, 1, 'mychardev')",
      "File operations: implement .open, .release, .read, .write in struct file_operations",
      "Buffer management: maintain internal buffer to store/retrieve data between write/read calls",
      "Kernel messages: print 'mychardev: driver loaded' and 'mychardev: device.*registered' for test validation"
    ]
  },
  "validation": {
    "testCases": [
      {
        "id": "advanced_chardev_test",
        "name": "Advanced Character Device Test",
        "type": "kernel_project_test",
        "critical": true,
        "testScenario": {
          "qemuArgs": [
            "-device", "edu,id=test-edu-device",
            "-netdev", "user,id=net0",
            "-device", "rtl8139,netdev=net0"
          ],
          "userspaceApps": [
            {
              "name": "device_tester",
              "source": "#include <stdio.h>\\n#include <stdlib.h>\\n#include <fcntl.h>\\n#include <unistd.h>\\n#include <string.h>\\n\\n#define DEVICE_PATH \"/dev/mychardev\"\\n#define TEST_DATA \"Hello from userspace!\"\\n\\nint main() {\\n    int fd;\\n    char read_buffer[256] = {0};\\n    ssize_t bytes_written, bytes_read;\\n    \\n    printf(\"=== Character Device Test Started ===\\\\n\");\\n    \\n    // Test 1: Open device\\n    fd = open(DEVICE_PATH, O_RDWR);\\n    if (fd < 0) {\\n        printf(\"ERROR: Cannot open device %s\\\\n\", DEVICE_PATH);\\n        return 1;\\n    }\\n    printf(\"SUCCESS: Device opened successfully\\\\n\");\\n    \\n    // Test 2: Write data\\n    bytes_written = write(fd, TEST_DATA, strlen(TEST_DATA));\\n    if (bytes_written != strlen(TEST_DATA)) {\\n        printf(\"ERROR: Write failed (expected %zu, got %zd)\\\\n\", strlen(TEST_DATA), bytes_written);\\n        close(fd);\\n        return 1;\\n    }\\n    printf(\"SUCCESS: Written %zd bytes to device\\\\n\", bytes_written);\\n    \\n    // Test 3: Reset position and read data\\n    lseek(fd, 0, SEEK_SET);\\n    bytes_read = read(fd, read_buffer, sizeof(read_buffer) - 1);\\n    if (bytes_read <= 0) {\\n        printf(\"ERROR: Read failed\\\\n\");\\n        close(fd);\\n        return 1;\\n    }\\n    printf(\"SUCCESS: Read %zd bytes from device\\\\n\", bytes_read);\\n    printf(\"SUCCESS: Data read: %s\\\\n\", read_buffer);\\n    \\n    // Test 4: Verify data integrity\\n    if (strncmp(read_buffer, TEST_DATA, strlen(TEST_DATA)) == 0) {\\n        printf(\"SUCCESS: Data integrity verified\\\\n\");\\n    } else {\\n        printf(\"ERROR: Data corruption detected\\\\n\");\\n        close(fd);\\n        return 1;\\n    }\\n    \\n    // Test 5: Close device\\n    close(fd);\\n    printf(\"SUCCESS: Device closed successfully\\\\n\");\\n    \\n    printf(\"=== All device tests passed! ===\\\\n\");\\n    return 0;\\n}",
              "compileFlags": ["-O2"]
            }
          ],
          "setupCommands": [
            "echo 'Setting up hardware emulation environment'",
            "mkdir -p /dev",
            "echo 'Hardware devices available:'",
            "ls -la /dev/ | head -10",
            "echo 'PCI devices:'",
            "ls /sys/bus/pci/devices/ 2>/dev/null || echo 'PCI subsystem not ready'"
          ],
          "testCommands": [
            "echo 'Creating device node for mychardev...'",
            "major=$(grep mychardev /proc/devices | cut -d' ' -f1)",
            "if [ -z \"$major\" ]; then echo 'ERROR: mychardev not found in /proc/devices'; exit 1; fi",
            "mknod /dev/mychardev c $major 0",
            "chmod 666 /dev/mychardev",
            "echo 'Device node /dev/mychardev created'",
            "echo 'Checking device node creation'",
            "ls -la /dev/mychardev || echo 'Device node not found'",
            "echo 'Running comprehensive device test'",
            "/bin/device_tester",
            "echo 'Checking device permissions'",
            "ls -la /dev/mychardev 2>/dev/null || echo 'Device check failed'"
          ],
          "cleanupCommands": [
            "echo 'Cleaning up test environment'",
            "rm -f /dev/mychardev 2>/dev/null || true"
          ],
          "expected": {
            "exitCode": 0,
            "dmesg": [
              "mychardev.*driver loaded",
              "mychardev.*device.*registered"
            ],
            "stdout": [
              "SUCCESS: Device opened successfully",
              "SUCCESS: Written.*bytes to device",
              "SUCCESS: Read.*bytes from device",
              "SUCCESS: Data integrity verified",
              "All device tests passed"
            ]
          },
          "timeout": 60
        }
      }
    ]
  }
}