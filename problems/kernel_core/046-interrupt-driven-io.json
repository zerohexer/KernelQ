{
  "id": 46,
  "title": "Interrupt-Driven I/O and Bottom Halves",
  "difficulty": 9,
  "xp": 90,
  "phase": "kernel_core",
  "description": "Implement interrupt-driven I/O with proper top-half/bottom-half processing using tasklets and workqueues. This teaches critical interrupt handling patterns used in high-performance device drivers at enterprise companies.",
  "concepts": ["interrupt_handling", "top_half_bottom_half", "tasklets", "workqueues", "interrupt_context", "deferred_work"],
  "skills": ["interrupt_programming", "deferred_processing", "performance_optimization", "real_time_systems"],
  "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/interrupt.h>\n#include <linux/timer.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/jiffies.h>\n\n#define DEVICE_NAME \"irqdev\"\n#define CLASS_NAME \"irqclass\"\n#define BUFFER_SIZE 4096\n#define IRQ_SIMULATION_INTERVAL 3000  // 3 seconds\n\n// TODO: Interrupt statistics structure\nstruct irq_stats {\n    unsigned long irq_count;\n    unsigned long tasklet_count;\n    unsigned long workqueue_count;\n    unsigned long data_ready_count;\n    unsigned long last_irq_jiffies;\n    unsigned long total_processing_time;\n};\n\n// TODO: Data packet structure (simulates hardware data)\nstruct data_packet {\n    struct list_head list;\n    char data[64];\n    size_t len;\n    unsigned long timestamp;\n    int sequence;\n};\n\n// TODO: Device structure\nstruct irq_device {\n    struct cdev cdev;\n    struct device *device;\n    struct class *class;\n    dev_t dev_num;\n    \n    // Interrupt simulation\n    struct timer_list irq_timer;\n    int irq_number;\n    bool irq_enabled;\n    \n    // Buffers and queues\n    char *user_buffer;\n    size_t buffer_used;\n    struct list_head packet_queue;\n    \n    // Bottom half processing\n    struct tasklet_struct data_tasklet;\n    struct work_struct data_work;\n    struct workqueue_struct *irq_workqueue;\n    \n    // Synchronization\n    spinlock_t irq_lock;     // For interrupt context\n    struct mutex device_mutex;  // For process context\n    wait_queue_head_t read_wait;\n    \n    // Statistics\n    struct irq_stats stats;\n    atomic_t packet_sequence;\n};\n\nstatic struct irq_device irq_dev;\n\n// TODO: Simulated interrupt handler (top half)\nstatic irqreturn_t irq_handler(int irq, void *dev_data)\n{\n    struct irq_device *dev = (struct irq_device *)dev_data;\n    struct data_packet *packet;\n    unsigned long flags;\n    ktime_t start_time;\n    \n    start_time = ktime_get();\n    \n    // This is interrupt context - must be fast and atomic\n    spin_lock_irqsave(&dev->irq_lock, flags);\n    \n    dev->stats.irq_count++;\n    dev->stats.last_irq_jiffies = jiffies;\n    \n    // Create new data packet (simulates reading from hardware)\n    packet = kmalloc(sizeof(*packet), GFP_ATOMIC);  // Must use GFP_ATOMIC in IRQ context\n    if (packet) {\n        packet->len = snprintf(packet->data, sizeof(packet->data),\n                              \"IRQ_Data_%d_Time_%lu\\n\",\n                              atomic_inc_return(&dev->packet_sequence),\n                              jiffies);\n        packet->timestamp = jiffies;\n        packet->sequence = atomic_read(&dev->packet_sequence);\n        \n        // Add to packet queue for bottom half processing\n        list_add_tail(&packet->list, &dev->packet_queue);\n        \n        // Schedule bottom half processing\n        tasklet_schedule(&dev->data_tasklet);\n        \n        // Also schedule workqueue for complex processing\n        queue_work(dev->irq_workqueue, &dev->data_work);\n    }\n    \n    spin_unlock_irqrestore(&dev->irq_lock, flags);\n    \n    // Update timing statistics\n    dev->stats.total_processing_time += ktime_to_ns(ktime_sub(ktime_get(), start_time));\n    \n    printk(KERN_INFO \"IRQ %d handled: packet_count=%lu\\n\", irq, dev->stats.irq_count);\n    \n    return IRQ_HANDLED;\n}\n\n// TODO: Tasklet function (bottom half - atomic context)\nstatic void data_tasklet_handler(unsigned long data)\n{\n    struct irq_device *dev = (struct irq_device *)data;\n    struct data_packet *packet, *tmp;\n    unsigned long flags;\n    size_t bytes_to_copy;\n    \n    spin_lock_irqsave(&dev->irq_lock, flags);\n    \n    dev->stats.tasklet_count++;\n    \n    // Process packets from interrupt (fast processing only)\n    list_for_each_entry_safe(packet, tmp, &dev->packet_queue, list) {\n        // Check if we have space in user buffer\n        if (dev->buffer_used + packet->len <= BUFFER_SIZE) {\n            bytes_to_copy = packet->len;\n            memcpy(dev->user_buffer + dev->buffer_used, packet->data, bytes_to_copy);\n            dev->buffer_used += bytes_to_copy;\n            dev->stats.data_ready_count++;\n        }\n        \n        // Remove packet from queue\n        list_del(&packet->list);\n        kfree(packet);\n    }\n    \n    spin_unlock_irqrestore(&dev->irq_lock, flags);\n    \n    // Wake up any waiting readers\n    if (dev->buffer_used > 0) {\n        wake_up_interruptible(&dev->read_wait);\n    }\n    \n    printk(KERN_INFO \"Tasklet processed: buffer_used=%zu\\n\", dev->buffer_used);\n}\n\n// TODO: Work function (bottom half - process context)\nstatic void data_work_handler(struct work_struct *work)\n{\n    struct irq_device *dev = container_of(work, struct irq_device, data_work);\n    unsigned long flags;\n    \n    // This runs in process context - can sleep, use GFP_KERNEL, etc.\n    \n    spin_lock_irqsave(&dev->irq_lock, flags);\n    dev->stats.workqueue_count++;\n    spin_unlock_irqrestore(&dev->irq_lock, flags);\n    \n    // Simulate complex processing that can't be done in interrupt context\n    msleep(10);  // This would crash in interrupt context\n    \n    printk(KERN_INFO \"Workqueue processed: can sleep and do complex work\\n\");\n    \n    // Could perform tasks like:\n    // - Complex data processing\n    // - Memory allocation with GFP_KERNEL\n    // - File I/O operations\n    // - Network operations\n}\n\n// TODO: Timer callback to simulate hardware interrupts\nstatic void irq_simulation_timer(struct timer_list *timer)\n{\n    struct irq_device *dev = container_of(timer, struct irq_device, irq_timer);\n    \n    if (dev->irq_enabled) {\n        // Simulate hardware interrupt\n        irq_handler(dev->irq_number, dev);\n        \n        // Restart timer for next \"interrupt\"\n        mod_timer(&dev->irq_timer, jiffies + msecs_to_jiffies(IRQ_SIMULATION_INTERVAL));\n    }\n}\n\nstatic int device_open(struct inode *inode, struct file *file)\n{\n    struct irq_device *dev = &irq_dev;\n    \n    file->private_data = dev;\n    \n    mutex_lock(&dev->device_mutex);\n    \n    // Start interrupt simulation\n    if (!dev->irq_enabled) {\n        dev->irq_enabled = true;\n        mod_timer(&dev->irq_timer, jiffies + msecs_to_jiffies(1000));\n        printk(KERN_INFO \"Interrupt simulation started\\n\");\n    }\n    \n    mutex_unlock(&dev->device_mutex);\n    \n    printk(KERN_INFO \"IRQ device opened\\n\");\n    return 0;\n}\n\nstatic int device_release(struct inode *inode, struct file *file)\n{\n    struct irq_device *dev = file->private_data;\n    \n    printk(KERN_INFO \"IRQ device closed\\n\");\n    return 0;\n}\n\n// TODO: Read function with interrupt-driven data\nstatic ssize_t device_read(struct file *file, char __user *user_buffer,\n                          size_t count, loff_t *offset)\n{\n    struct irq_device *dev = file->private_data;\n    ssize_t bytes_read = 0;\n    unsigned long flags;\n    \n    // Wait for data to be available (filled by interrupt handler)\n    if (file->f_flags & O_NONBLOCK) {\n        spin_lock_irqsave(&dev->irq_lock, flags);\n        if (dev->buffer_used == 0) {\n            spin_unlock_irqrestore(&dev->irq_lock, flags);\n            return -EAGAIN;\n        }\n        spin_unlock_irqrestore(&dev->irq_lock, flags);\n    } else {\n        if (wait_event_interruptible(dev->read_wait, dev->buffer_used > 0)) {\n            return -ERESTARTSYS;\n        }\n    }\n    \n    mutex_lock(&dev->device_mutex);\n    spin_lock_irqsave(&dev->irq_lock, flags);\n    \n    if (dev->buffer_used > 0) {\n        bytes_read = min(count, dev->buffer_used);\n        \n        if (copy_to_user(user_buffer, dev->user_buffer, bytes_read)) {\n            spin_unlock_irqrestore(&dev->irq_lock, flags);\n            mutex_unlock(&dev->device_mutex);\n            return -EFAULT;\n        }\n        \n        // Move remaining data to beginning\n        if (bytes_read < dev->buffer_used) {\n            memmove(dev->user_buffer, dev->user_buffer + bytes_read,\n                   dev->buffer_used - bytes_read);\n        }\n        \n        dev->buffer_used -= bytes_read;\n    }\n    \n    spin_unlock_irqrestore(&dev->irq_lock, flags);\n    mutex_unlock(&dev->device_mutex);\n    \n    if (bytes_read > 0) {\n        printk(KERN_INFO \"Read %zu bytes of interrupt-driven data\\n\", bytes_read);\n    }\n    \n    return bytes_read;\n}\n\n// TODO: Write function to show statistics\nstatic ssize_t device_write(struct file *file, const char __user *user_buffer,\n                           size_t count, loff_t *offset)\n{\n    struct irq_device *dev = file->private_data;\n    char cmd[32];\n    unsigned long flags;\n    \n    if (count >= sizeof(cmd)) {\n        return -EINVAL;\n    }\n    \n    if (copy_from_user(cmd, user_buffer, count)) {\n        return -EFAULT;\n    }\n    \n    cmd[count] = '\\0';\n    \n    if (strncmp(cmd, \"stats\", 5) == 0) {\n        spin_lock_irqsave(&dev->irq_lock, flags);\n        printk(KERN_INFO \"IRQ Statistics:\\n\");\n        printk(KERN_INFO \"  IRQ Count: %lu\\n\", dev->stats.irq_count);\n        printk(KERN_INFO \"  Tasklet Count: %lu\\n\", dev->stats.tasklet_count);\n        printk(KERN_INFO \"  Workqueue Count: %lu\\n\", dev->stats.workqueue_count);\n        printk(KERN_INFO \"  Data Ready Count: %lu\\n\", dev->stats.data_ready_count);\n        printk(KERN_INFO \"  Last IRQ: %lu jiffies ago\\n\", \n               jiffies - dev->stats.last_irq_jiffies);\n        printk(KERN_INFO \"  Avg Processing Time: %lu ns\\n\",\n               dev->stats.irq_count > 0 ? \n               dev->stats.total_processing_time / dev->stats.irq_count : 0);\n        spin_unlock_irqrestore(&dev->irq_lock, flags);\n    } else if (strncmp(cmd, \"reset\", 5) == 0) {\n        spin_lock_irqsave(&dev->irq_lock, flags);\n        memset(&dev->stats, 0, sizeof(dev->stats));\n        atomic_set(&dev->packet_sequence, 0);\n        spin_unlock_irqrestore(&dev->irq_lock, flags);\n        printk(KERN_INFO \"Statistics reset\\n\");\n    }\n    \n    return count;\n}\n\nstatic const struct file_operations irq_dev_fops = {\n    .owner = THIS_MODULE,\n    .open = device_open,\n    .release = device_release,\n    .read = device_read,\n    .write = device_write,\n};\n\nstatic int __init irq_dev_init(void)\n{\n    int ret;\n    \n    printk(KERN_INFO \"Interrupt-driven device initializing...\\n\");\n    \n    // TODO: Initialize device structure\n    memset(&irq_dev, 0, sizeof(irq_dev));\n    mutex_init(&irq_dev.device_mutex);\n    spin_lock_init(&irq_dev.irq_lock);\n    init_waitqueue_head(&irq_dev.read_wait);\n    INIT_LIST_HEAD(&irq_dev.packet_queue);\n    atomic_set(&irq_dev.packet_sequence, 0);\n    \n    // TODO: Allocate buffer\n    irq_dev.user_buffer = kzalloc(BUFFER_SIZE, GFP_KERNEL);\n    if (!irq_dev.user_buffer) {\n        return -ENOMEM;\n    }\n    \n    // TODO: Initialize timer for interrupt simulation\n    timer_setup(&irq_dev.irq_timer, irq_simulation_timer, 0);\n    irq_dev.irq_number = 42;  // Fake IRQ number for simulation\n    \n    // TODO: Initialize tasklet\n    tasklet_init(&irq_dev.data_tasklet, data_tasklet_handler, (unsigned long)&irq_dev);\n    \n    // TODO: Initialize workqueue\n    irq_dev.irq_workqueue = create_singlethread_workqueue(\"irq_workqueue\");\n    if (!irq_dev.irq_workqueue) {\n        kfree(irq_dev.user_buffer);\n        return -ENOMEM;\n    }\n    \n    INIT_WORK(&irq_dev.data_work, data_work_handler);\n    \n    // TODO: Register character device\n    ret = alloc_chrdev_region(&irq_dev.dev_num, 0, 1, DEVICE_NAME);\n    if (ret < 0) {\n        destroy_workqueue(irq_dev.irq_workqueue);\n        kfree(irq_dev.user_buffer);\n        return ret;\n    }\n    \n    cdev_init(&irq_dev.cdev, &irq_dev_fops);\n    irq_dev.cdev.owner = THIS_MODULE;\n    \n    ret = cdev_add(&irq_dev.cdev, irq_dev.dev_num, 1);\n    if (ret < 0) {\n        unregister_chrdev_region(irq_dev.dev_num, 1);\n        destroy_workqueue(irq_dev.irq_workqueue);\n        kfree(irq_dev.user_buffer);\n        return ret;\n    }\n    \n    // TODO: Create device class and device\n    irq_dev.class = class_create(THIS_MODULE, CLASS_NAME);\n    if (IS_ERR(irq_dev.class)) {\n        cdev_del(&irq_dev.cdev);\n        unregister_chrdev_region(irq_dev.dev_num, 1);\n        destroy_workqueue(irq_dev.irq_workqueue);\n        kfree(irq_dev.user_buffer);\n        return PTR_ERR(irq_dev.class);\n    }\n    \n    irq_dev.device = device_create(irq_dev.class, NULL, irq_dev.dev_num,\n                                  NULL, DEVICE_NAME);\n    if (IS_ERR(irq_dev.device)) {\n        class_destroy(irq_dev.class);\n        cdev_del(&irq_dev.cdev);\n        unregister_chrdev_region(irq_dev.dev_num, 1);\n        destroy_workqueue(irq_dev.irq_workqueue);\n        kfree(irq_dev.user_buffer);\n        return PTR_ERR(irq_dev.device);\n    }\n    \n    printk(KERN_INFO \"Interrupt-driven device loaded successfully\\n\");\n    printk(KERN_INFO \"Device: /dev/%s with interrupt simulation\\n\", DEVICE_NAME);\n    printk(KERN_INFO \"Write 'stats' to show statistics, 'reset' to reset\\n\");\n    \n    return 0;\n}\n\nstatic void __exit irq_dev_exit(void)\n{\n    struct data_packet *packet, *tmp;\n    \n    printk(KERN_INFO \"Interrupt-driven device unloading...\\n\");\n    \n    // TODO: Stop interrupt simulation\n    irq_dev.irq_enabled = false;\n    del_timer_sync(&irq_dev.irq_timer);\n    \n    // TODO: Cleanup tasklet and workqueue\n    tasklet_kill(&irq_dev.data_tasklet);\n    flush_workqueue(irq_dev.irq_workqueue);\n    destroy_workqueue(irq_dev.irq_workqueue);\n    \n    // TODO: Clean up any remaining packets\n    list_for_each_entry_safe(packet, tmp, &irq_dev.packet_queue, list) {\n        list_del(&packet->list);\n        kfree(packet);\n    }\n    \n    // TODO: Wake up any waiting processes\n    wake_up_interruptible_all(&irq_dev.read_wait);\n    \n    // TODO: Clean up device\n    device_destroy(irq_dev.class, irq_dev.dev_num);\n    class_destroy(irq_dev.class);\n    cdev_del(&irq_dev.cdev);\n    unregister_chrdev_region(irq_dev.dev_num, 1);\n    kfree(irq_dev.user_buffer);\n    \n    printk(KERN_INFO \"Interrupt-driven device unloaded\\n\");\n    printk(KERN_INFO \"Final IRQ stats - Total: %lu, Tasklets: %lu, Work: %lu\\n\",\n           irq_dev.stats.irq_count, irq_dev.stats.tasklet_count, \n           irq_dev.stats.workqueue_count);\n}\n\nmodule_init(irq_dev_init);\nmodule_exit(irq_dev_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Interrupt-driven character device with top/bottom half processing\");\nMODULE_VERSION(\"1.0\");",
  "validation": {
    "exactRequirements": {
      "functionNames": [
        "irq_dev_init",
        "irq_dev_exit",
        "irq_handler",
        "data_tasklet_handler",
        "data_work_handler",
        "irq_simulation_timer"
      ],
      "variables": [
        {"name": "irq_dev", "type": "struct irq_device"},
        {"name": "irq_dev_fops", "type": "struct file_operations"}
      ],
      "outputMessages": [
        "Interrupt-driven device loaded successfully",
        "Device: /dev/irqdev with interrupt simulation",
        "Write 'stats' to show statistics, 'reset' to reset",
        "Interrupt-driven device unloaded",
        "Final IRQ stats - Total:"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/interrupt.h",
        "linux/timer.h",
        "linux/workqueue.h"
      ],
      "mustContain": [
        "irqreturn_t",
        "IRQ_HANDLED",
        "tasklet_init",
        "tasklet_schedule",
        "create_singlethread_workqueue",
        "queue_work",
        "GFP_ATOMIC",
        "spin_lock_irqsave",
        "spin_unlock_irqrestore"
      ]
    },
    "testCases": [
      {
        "id": "interrupt_handler",
        "name": "Interrupt Handler Implementation",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "irqreturn_t irq_handler",
          "return IRQ_HANDLED",
          "GFP_ATOMIC"
        ],
        "prohibitedSymbols": ["GFP_KERNEL", "msleep", "might_sleep"]
      },
      {
        "id": "top_bottom_half",
        "name": "Top/Bottom Half Architecture",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "tasklet_schedule(&dev->data_tasklet)",
          "queue_work(dev->irq_workqueue",
          "tasklet_init(&irq_dev.data_tasklet"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "atomic_context_safety",
        "name": "Atomic Context Safety",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "spin_lock_irqsave(&dev->irq_lock, flags)",
          "spin_unlock_irqrestore(&dev->irq_lock, flags)",
          "kmalloc(sizeof(*packet), GFP_ATOMIC)"
        ],
        "prohibitedSymbols": ["mutex_lock", "might_sleep"]
      },
      {
        "id": "process_context_work",
        "name": "Process Context Work",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "msleep(10)",
          "container_of(work, struct irq_device, data_work)",
          "INIT_WORK(&irq_dev.data_work"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "workqueue_management",
        "name": "Workqueue Management",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "create_singlethread_workqueue(\"irq_workqueue\")",
          "destroy_workqueue(irq_dev.irq_workqueue)",
          "flush_workqueue(irq_dev.irq_workqueue)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "tasklet_cleanup",
        "name": "Tasklet Cleanup",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "tasklet_kill(&irq_dev.data_tasklet)",
          "del_timer_sync(&irq_dev.irq_timer)"
        ],
        "prohibitedSymbols": ["del_timer"]
      },
      {
        "id": "interrupt_context_restrictions",
        "name": "Interrupt Context Restrictions",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "// This is interrupt context - must be fast and atomic",
          "// Must use GFP_ATOMIC in IRQ context"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "interrupt_simulation_message",
        "name": "Interrupt Simulation Message",
        "type": "output_match",
        "critical": true,
        "expected": [
          {"pattern": "Device: /dev/irqdev with interrupt simulation", "exact": true}
        ]
      }
    ]
  }
}