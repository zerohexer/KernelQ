{
  "id": 42,
  "title": "Workqueues and Timers",
  "difficulty": 8,
  "xp": 80,
  "phase": "kernel_core",
  "description": "Implement a kernel module that uses workqueues and timers for asynchronous task execution and periodic operations. This teaches essential kernel concurrency mechanisms used extensively in device drivers and kernel subsystems at enterprise companies.",
  "concepts": ["workqueue", "timer_list", "delayed_work", "periodic_timers", "asynchronous_execution", "kernel_threads"],
  "skills": ["async_programming", "timer_management", "workqueue_usage", "kernel_concurrency"],
  "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/workqueue.h>\n#include <linux/timer.h>\n#include <linux/jiffies.h>\n#include <linux/slab.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n\n#define TIMER_INTERVAL_MS 5000\n#define WORK_DELAY_MS 1000\n#define MAX_WORK_ITEMS 10\n\n// TODO: Define work item structure\nstruct work_item_data {\n    struct work_struct work;\n    int item_id;\n    unsigned long created_jiffies;\n    char description[64];\n};\n\n// TODO: Define statistics structure\nstatic struct {\n    unsigned long timer_fires;\n    unsigned long work_executed;\n    unsigned long work_scheduled;\n    unsigned long work_failed;\n    unsigned long last_timer_jiffies;\n    unsigned long last_work_jiffies;\n} stats = {0};\n\n// TODO: Define kernel objects\nstatic struct timer_list periodic_timer;\nstatic struct workqueue_struct *demo_workqueue;\nstatic struct delayed_work delayed_demo_work;\nstatic struct proc_dir_entry *proc_entry;\nstatic int next_work_id = 1;\nstatic DEFINE_SPINLOCK(stats_lock);\n\n// TODO: Implement work function for individual work items\nstatic void work_item_handler(struct work_struct *work)\n{\n    struct work_item_data *item;\n    unsigned long flags;\n    \n    // TODO: Get container structure\n    item = container_of(work, struct work_item_data, work);\n    \n    // TODO: Process the work item\n    // TODO: Update statistics\n    // TODO: Log the work execution\n    // TODO: Free the work item\n    \n    printk(KERN_INFO \"Work item %d executed: %s\\n\", item->item_id, item->description);\n    \n    spin_lock_irqsave(&stats_lock, flags);\n    stats.work_executed++;\n    stats.last_work_jiffies = jiffies;\n    spin_unlock_irqrestore(&stats_lock, flags);\n    \n    kfree(item);\n}\n\n// TODO: Implement delayed work handler\nstatic void delayed_work_handler(struct work_struct *work)\n{\n    unsigned long flags;\n    \n    // TODO: Update statistics\n    // TODO: Schedule next delayed work\n    // TODO: Create and schedule a new work item\n    \n    printk(KERN_INFO \"Delayed work executed at jiffies=%lu\\n\", jiffies);\n    \n    spin_lock_irqsave(&stats_lock, flags);\n    stats.work_executed++;\n    stats.last_work_jiffies = jiffies;\n    spin_unlock_irqrestore(&stats_lock, flags);\n    \n    // TODO: Schedule next delayed work in WORK_DELAY_MS milliseconds\n    if (demo_workqueue) {\n        queue_delayed_work(demo_workqueue, &delayed_demo_work, msecs_to_jiffies(WORK_DELAY_MS));\n    }\n}\n\n// TODO: Implement timer callback function\nstatic void timer_callback(struct timer_list *timer)\n{\n    struct work_item_data *new_item;\n    unsigned long flags;\n    \n    // TODO: Update timer statistics\n    spin_lock_irqsave(&stats_lock, flags);\n    stats.timer_fires++;\n    stats.last_timer_jiffies = jiffies;\n    spin_unlock_irqrestore(&stats_lock, flags);\n    \n    printk(KERN_INFO \"Timer fired at jiffies=%lu\\n\", jiffies);\n    \n    // TODO: Create new work item\n    new_item = kmalloc(sizeof(*new_item), GFP_ATOMIC);\n    if (!new_item) {\n        spin_lock_irqsave(&stats_lock, flags);\n        stats.work_failed++;\n        spin_unlock_irqrestore(&stats_lock, flags);\n        printk(KERN_ERR \"Failed to allocate work item\\n\");\n        goto restart_timer;\n    }\n    \n    // TODO: Initialize work item\n    INIT_WORK(&new_item->work, work_item_handler);\n    new_item->item_id = next_work_id++;\n    new_item->created_jiffies = jiffies;\n    snprintf(new_item->description, sizeof(new_item->description), \n             \"Timer-generated work item %d\", new_item->item_id);\n    \n    // TODO: Queue work item\n    if (demo_workqueue) {\n        if (queue_work(demo_workqueue, &new_item->work)) {\n            spin_lock_irqsave(&stats_lock, flags);\n            stats.work_scheduled++;\n            spin_unlock_irqrestore(&stats_lock, flags);\n        } else {\n            spin_lock_irqsave(&stats_lock, flags);\n            stats.work_failed++;\n            spin_unlock_irqrestore(&stats_lock, flags);\n            kfree(new_item);\n        }\n    } else {\n        kfree(new_item);\n    }\n    \nrestart_timer:\n    // TODO: Restart timer for next interval\n    mod_timer(&periodic_timer, jiffies + msecs_to_jiffies(TIMER_INTERVAL_MS));\n}\n\n// TODO: Implement proc show function for statistics\nstatic int stats_proc_show(struct seq_file *m, void *v)\n{\n    unsigned long flags;\n    \n    spin_lock_irqsave(&stats_lock, flags);\n    \n    // TODO: Display comprehensive statistics\n    seq_printf(m, \"Workqueue and Timer Statistics\\n\");\n    seq_printf(m, \"==============================\\n\");\n    seq_printf(m, \"Timer fires: %lu\\n\", stats.timer_fires);\n    seq_printf(m, \"Work scheduled: %lu\\n\", stats.work_scheduled);\n    seq_printf(m, \"Work executed: %lu\\n\", stats.work_executed);\n    seq_printf(m, \"Work failed: %lu\\n\", stats.work_failed);\n    seq_printf(m, \"Last timer: %lu (jiffies)\\n\", stats.last_timer_jiffies);\n    seq_printf(m, \"Last work: %lu (jiffies)\\n\", stats.last_work_jiffies);\n    seq_printf(m, \"Current time: %lu (jiffies)\\n\", jiffies);\n    seq_printf(m, \"Next work ID: %d\\n\", next_work_id);\n    \n    spin_unlock_irqrestore(&stats_lock, flags);\n    \n    return 0;\n}\n\n// TODO: Implement proc open function\nstatic int stats_proc_open(struct inode *inode, struct file *file)\n{\n    return single_open(file, stats_proc_show, NULL);\n}\n\n// TODO: Define proc file operations\nstatic const struct proc_ops stats_proc_ops = {\n    .proc_open = stats_proc_open,\n    .proc_read = seq_read,\n    .proc_lseek = seq_lseek,\n    .proc_release = single_release,\n};\n\nstatic int __init workqueue_module_init(void)\n{\n    int ret = 0;\n    \n    printk(KERN_INFO \"Workqueue and timer module initializing...\\n\");\n    \n    // TODO: Create dedicated workqueue\n    demo_workqueue = create_singlethread_workqueue(\"demo_wq\");\n    if (!demo_workqueue) {\n        printk(KERN_ERR \"Failed to create workqueue\\n\");\n        return -ENOMEM;\n    }\n    \n    // TODO: Initialize timer\n    timer_setup(&periodic_timer, timer_callback, 0);\n    \n    // TODO: Initialize delayed work\n    INIT_DELAYED_WORK(&delayed_demo_work, delayed_work_handler);\n    \n    // TODO: Create proc entry for statistics\n    proc_entry = proc_create(\"workqueue_stats\", 0444, NULL, &stats_proc_ops);\n    if (!proc_entry) {\n        printk(KERN_ERR \"Failed to create proc entry\\n\");\n        destroy_workqueue(demo_workqueue);\n        return -ENOMEM;\n    }\n    \n    // TODO: Start timer and delayed work\n    mod_timer(&periodic_timer, jiffies + msecs_to_jiffies(TIMER_INTERVAL_MS));\n    queue_delayed_work(demo_workqueue, &delayed_demo_work, msecs_to_jiffies(WORK_DELAY_MS));\n    \n    printk(KERN_INFO \"Workqueue and timer module loaded successfully\\n\");\n    printk(KERN_INFO \"Timer interval: %d ms, Work delay: %d ms\\n\", TIMER_INTERVAL_MS, WORK_DELAY_MS);\n    printk(KERN_INFO \"Statistics available at /proc/workqueue_stats\\n\");\n    \n    return ret;\n}\n\nstatic void __exit workqueue_module_exit(void)\n{\n    // TODO: Cancel timer\n    del_timer_sync(&periodic_timer);\n    \n    // TODO: Cancel delayed work\n    cancel_delayed_work_sync(&delayed_demo_work);\n    \n    // TODO: Flush and destroy workqueue\n    if (demo_workqueue) {\n        flush_workqueue(demo_workqueue);\n        destroy_workqueue(demo_workqueue);\n    }\n    \n    // TODO: Remove proc entry\n    if (proc_entry) {\n        proc_remove(proc_entry);\n    }\n    \n    printk(KERN_INFO \"Workqueue and timer module unloaded\\n\");\n    printk(KERN_INFO \"Final statistics - Timer: %lu, Work: %lu, Failed: %lu\\n\",\n           stats.timer_fires, stats.work_executed, stats.work_failed);\n}\n\nmodule_init(workqueue_module_init);\nmodule_exit(workqueue_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Workqueues and timers demonstration\");\nMODULE_VERSION(\"1.0\");",
  "validation": {
    "exactRequirements": {
      "functionNames": [
        "workqueue_module_init",
        "workqueue_module_exit", 
        "work_item_handler",
        "delayed_work_handler",
        "timer_callback",
        "stats_proc_show",
        "stats_proc_open"
      ],
      "variables": [
        {"name": "periodic_timer", "type": "struct timer_list"},
        {"name": "demo_workqueue", "type": "struct workqueue_struct*"},
        {"name": "delayed_demo_work", "type": "struct delayed_work"},
        {"name": "stats_lock", "type": "spinlock_t"}
      ],
      "outputMessages": [
        "Workqueue and timer module loaded successfully",
        "Timer interval: 5000 ms, Work delay: 1000 ms",
        "Statistics available at /proc/workqueue_stats",
        "Workqueue and timer module unloaded",
        "Final statistics - Timer:"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h", 
        "linux/workqueue.h",
        "linux/timer.h"
      ],
      "mustContain": [
        "timer_setup",
        "mod_timer",
        "del_timer_sync", 
        "create_singlethread_workqueue",
        "destroy_workqueue",
        "INIT_WORK",
        "INIT_DELAYED_WORK",
        "queue_work",
        "queue_delayed_work",
        "container_of",
        "spin_lock_irqsave",
        "spin_unlock_irqrestore"
      ]
    },
    "testCases": [
      {
        "id": "timer_setup",
        "name": "Timer Setup and Management",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "timer_setup(&periodic_timer, timer_callback, 0)",
          "mod_timer(&periodic_timer",
          "del_timer_sync(&periodic_timer)"
        ],
        "prohibitedSymbols": ["init_timer", "setup_timer"]
      },
      {
        "id": "workqueue_management",
        "name": "Workqueue Management",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "create_singlethread_workqueue(\"demo_wq\")",
          "destroy_workqueue(demo_workqueue)",
          "flush_workqueue(demo_workqueue)"
        ],
        "prohibitedSymbols": ["create_workqueue"]
      },
      {
        "id": "work_initialization",
        "name": "Work Initialization",
        "type": "code_analysis", 
        "critical": true,
        "expectedSymbols": [
          "INIT_WORK(&new_item->work, work_item_handler)",
          "INIT_DELAYED_WORK(&delayed_demo_work, delayed_work_handler)",
          "container_of(work, struct work_item_data, work)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "work_scheduling",
        "name": "Work Scheduling",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "queue_work(demo_workqueue",
          "queue_delayed_work(demo_workqueue",
          "cancel_delayed_work_sync(&delayed_demo_work)"
        ],
        "prohibitedSymbols": ["schedule_work"]
      },
      {
        "id": "synchronization",
        "name": "Proper Synchronization",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "DEFINE_SPINLOCK(stats_lock)",
          "spin_lock_irqsave(&stats_lock, flags)",
          "spin_unlock_irqrestore(&stats_lock, flags)"
        ],
        "prohibitedSymbols": ["mutex_lock"]
      },
      {
        "id": "memory_management",
        "name": "Memory Management in Atomic Context",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "kmalloc(sizeof(*new_item), GFP_ATOMIC)",
          "kfree(item)",
          "kfree(new_item)"
        ],
        "prohibitedSymbols": ["GFP_KERNEL"]
      },
      {
        "id": "statistics_message",
        "name": "Statistics Proc Interface",
        "type": "output_match",
        "critical": true,
        "expected": [
          {"pattern": "Statistics available at /proc/workqueue_stats", "exact": true}
        ]
      }
    ]
  }
}