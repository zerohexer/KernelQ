{
  "id": 45,
  "title": "IOCTL Interface Design",
  "difficulty": 9,
  "xp": 90,
  "phase": "kernel_core",
  "description": "Implement a kernel module with a proper IOCTL interface for userspace communication. This teaches advanced userspace-kernel communication patterns used in device drivers and system interfaces at enterprise companies like NVIDIA and Intel.",
  "concepts": ["ioctl", "_IO_macros", "copy_from_user", "copy_to_user", "file_operations", "device_interface"],
  "skills": ["ioctl_design", "userspace_interface", "data_marshaling", "device_communication"],
  "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ioctl.h>\n\n#define DEVICE_NAME \"demo_ioctl\"\n#define CLASS_NAME \"demo\"\n\n// TODO: Define IOCTL magic number and commands\n#define DEMO_IOC_MAGIC 'D'\n\n// TODO: Define IOCTL command structures\nstruct demo_config {\n    int mode;\n    int threshold;\n    char name[32];\n    bool enabled;\n};\n\nstruct demo_stats {\n    unsigned long operation_count;\n    unsigned long error_count;\n    unsigned long last_operation_jiffies;\n    int current_mode;\n};\n\nstruct demo_buffer {\n    char *data;\n    size_t size;\n    size_t used;\n};\n\n// TODO: Define IOCTL commands using _IO macros\n#define DEMO_IOC_GET_CONFIG    _IOR(DEMO_IOC_MAGIC, 1, struct demo_config)\n#define DEMO_IOC_SET_CONFIG    _IOW(DEMO_IOC_MAGIC, 2, struct demo_config)\n#define DEMO_IOC_GET_STATS     _IOR(DEMO_IOC_MAGIC, 3, struct demo_stats)\n#define DEMO_IOC_RESET_STATS   _IO(DEMO_IOC_MAGIC, 4)\n#define DEMO_IOC_READ_BUFFER   _IOWR(DEMO_IOC_MAGIC, 5, struct demo_buffer)\n#define DEMO_IOC_WRITE_BUFFER  _IOW(DEMO_IOC_MAGIC, 6, struct demo_buffer)\n#define DEMO_IOC_MAXNR 6\n\n// TODO: Module state variables\nstatic int major_number;\nstatic struct class *demo_class = NULL;\nstatic struct device *demo_device = NULL;\nstatic DEFINE_MUTEX(device_mutex);\n\n// TODO: Device state\nstatic struct demo_config device_config = {\n    .mode = 0,\n    .threshold = 100,\n    .name = \"default\",\n    .enabled = true\n};\n\nstatic struct demo_stats device_stats = {0};\nstatic char *device_buffer = NULL;\nstatic size_t buffer_size = 4096;\nstatic size_t buffer_used = 0;\n\n// TODO: Implement IOCTL handler function\nstatic long demo_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n    int ret = 0;\n    struct demo_config config;\n    struct demo_stats stats;\n    struct demo_buffer buffer_info;\n    void __user *argp = (void __user *)arg;\n    \n    // TODO: Validate IOCTL command\n    if (_IOC_TYPE(cmd) != DEMO_IOC_MAGIC) {\n        return -ENOTTY;\n    }\n    \n    if (_IOC_NR(cmd) > DEMO_IOC_MAXNR) {\n        return -ENOTTY;\n    }\n    \n    // TODO: Check access permissions\n    if (_IOC_DIR(cmd) & _IOC_READ) {\n        ret = !access_ok(argp, _IOC_SIZE(cmd));\n        if (ret) return -EFAULT;\n    }\n    \n    if (_IOC_DIR(cmd) & _IOC_WRITE) {\n        ret = !access_ok(argp, _IOC_SIZE(cmd));\n        if (ret) return -EFAULT;\n    }\n    \n    mutex_lock(&device_mutex);\n    \n    switch (cmd) {\n    case DEMO_IOC_GET_CONFIG:\n        // TODO: Copy current config to userspace\n        ret = copy_to_user(argp, &device_config, sizeof(device_config));\n        if (ret) {\n            ret = -EFAULT;\n            break;\n        }\n        device_stats.operation_count++;\n        printk(KERN_INFO \"Config read by userspace\\n\");\n        break;\n        \n    case DEMO_IOC_SET_CONFIG:\n        // TODO: Copy new config from userspace\n        ret = copy_from_user(&config, argp, sizeof(config));\n        if (ret) {\n            ret = -EFAULT;\n            break;\n        }\n        \n        // TODO: Validate configuration\n        if (config.mode < 0 || config.mode > 3) {\n            ret = -EINVAL;\n            device_stats.error_count++;\n            break;\n        }\n        \n        if (config.threshold < 0 || config.threshold > 1000) {\n            ret = -EINVAL;\n            device_stats.error_count++;\n            break;\n        }\n        \n        // TODO: Apply new configuration\n        device_config = config;\n        device_stats.operation_count++;\n        device_stats.last_operation_jiffies = jiffies;\n        printk(KERN_INFO \"Config updated: mode=%d, threshold=%d, name=%s\\n\",\n               config.mode, config.threshold, config.name);\n        break;\n        \n    case DEMO_IOC_GET_STATS:\n        // TODO: Prepare current statistics\n        stats = device_stats;\n        stats.current_mode = device_config.mode;\n        \n        ret = copy_to_user(argp, &stats, sizeof(stats));\n        if (ret) {\n            ret = -EFAULT;\n            break;\n        }\n        device_stats.operation_count++;\n        printk(KERN_INFO \"Statistics read by userspace\\n\");\n        break;\n        \n    case DEMO_IOC_RESET_STATS:\n        // TODO: Reset statistics\n        device_stats.operation_count = 0;\n        device_stats.error_count = 0;\n        device_stats.last_operation_jiffies = jiffies;\n        printk(KERN_INFO \"Statistics reset\\n\");\n        break;\n        \n    case DEMO_IOC_READ_BUFFER:\n        // TODO: Read data from device buffer\n        ret = copy_from_user(&buffer_info, argp, sizeof(buffer_info));\n        if (ret) {\n            ret = -EFAULT;\n            break;\n        }\n        \n        if (!buffer_info.data || buffer_info.size == 0) {\n            ret = -EINVAL;\n            break;\n        }\n        \n        // TODO: Copy available data to userspace\n        buffer_info.used = min(buffer_used, buffer_info.size);\n        if (buffer_info.used > 0 && device_buffer) {\n            ret = copy_to_user(buffer_info.data, device_buffer, buffer_info.used);\n            if (ret) {\n                ret = -EFAULT;\n                break;\n            }\n        }\n        \n        // TODO: Return updated buffer info\n        ret = copy_to_user(argp, &buffer_info, sizeof(buffer_info));\n        if (ret) {\n            ret = -EFAULT;\n            break;\n        }\n        \n        device_stats.operation_count++;\n        printk(KERN_INFO \"Buffer read: %zu bytes\\n\", buffer_info.used);\n        break;\n        \n    case DEMO_IOC_WRITE_BUFFER:\n        // TODO: Write data to device buffer\n        ret = copy_from_user(&buffer_info, argp, sizeof(buffer_info));\n        if (ret) {\n            ret = -EFAULT;\n            break;\n        }\n        \n        if (!buffer_info.data || buffer_info.size == 0) {\n            ret = -EINVAL;\n            break;\n        }\n        \n        if (buffer_info.size > buffer_size) {\n            ret = -ENOSPC;\n            device_stats.error_count++;\n            break;\n        }\n        \n        if (!device_buffer) {\n            ret = -ENOMEM;\n            device_stats.error_count++;\n            break;\n        }\n        \n        // TODO: Copy data from userspace to device buffer\n        ret = copy_from_user(device_buffer, buffer_info.data, buffer_info.size);\n        if (ret) {\n            ret = -EFAULT;\n            break;\n        }\n        \n        buffer_used = buffer_info.size;\n        device_stats.operation_count++;\n        device_stats.last_operation_jiffies = jiffies;\n        printk(KERN_INFO \"Buffer written: %zu bytes\\n\", buffer_info.size);\n        break;\n        \n    default:\n        ret = -ENOTTY;\n        device_stats.error_count++;\n        break;\n    }\n    \n    mutex_unlock(&device_mutex);\n    return ret;\n}\n\n// TODO: Implement basic file operations\nstatic int demo_open(struct inode *inode, struct file *file)\n{\n    printk(KERN_INFO \"Device opened\\n\");\n    return 0;\n}\n\nstatic int demo_release(struct inode *inode, struct file *file)\n{\n    printk(KERN_INFO \"Device closed\\n\");\n    return 0;\n}\n\n// TODO: Define file operations structure\nstatic const struct file_operations demo_fops = {\n    .owner = THIS_MODULE,\n    .open = demo_open,\n    .release = demo_release,\n    .unlocked_ioctl = demo_ioctl,\n    .compat_ioctl = demo_ioctl,\n};\n\nstatic int __init ioctl_module_init(void)\n{\n    int ret;\n    \n    printk(KERN_INFO \"IOCTL demo module initializing...\\n\");\n    \n    // TODO: Allocate device buffer\n    device_buffer = kmalloc(buffer_size, GFP_KERNEL);\n    if (!device_buffer) {\n        printk(KERN_ERR \"Failed to allocate device buffer\\n\");\n        return -ENOMEM;\n    }\n    \n    // TODO: Register character device\n    major_number = register_chrdev(0, DEVICE_NAME, &demo_fops);\n    if (major_number < 0) {\n        printk(KERN_ERR \"Failed to register character device\\n\");\n        kfree(device_buffer);\n        return major_number;\n    }\n    \n    // TODO: Create device class\n    demo_class = class_create(THIS_MODULE, CLASS_NAME);\n    if (IS_ERR(demo_class)) {\n        unregister_chrdev(major_number, DEVICE_NAME);\n        kfree(device_buffer);\n        return PTR_ERR(demo_class);\n    }\n    \n    // TODO: Create device\n    demo_device = device_create(demo_class, NULL, MKDEV(major_number, 0), NULL, DEVICE_NAME);\n    if (IS_ERR(demo_device)) {\n        class_destroy(demo_class);\n        unregister_chrdev(major_number, DEVICE_NAME);\n        kfree(device_buffer);\n        return PTR_ERR(demo_device);\n    }\n    \n    device_stats.last_operation_jiffies = jiffies;\n    \n    printk(KERN_INFO \"IOCTL demo module loaded successfully\\n\");\n    printk(KERN_INFO \"Device registered: /dev/%s (major %d)\\n\", DEVICE_NAME, major_number);\n    printk(KERN_INFO \"IOCTL commands: GET_CONFIG=0x%x, SET_CONFIG=0x%x\\n\", \n           DEMO_IOC_GET_CONFIG, DEMO_IOC_SET_CONFIG);\n    \n    return 0;\n}\n\nstatic void __exit ioctl_module_exit(void)\n{\n    // TODO: Clean up device and class\n    device_destroy(demo_class, MKDEV(major_number, 0));\n    class_destroy(demo_class);\n    unregister_chrdev(major_number, DEVICE_NAME);\n    \n    // TODO: Free device buffer\n    kfree(device_buffer);\n    \n    printk(KERN_INFO \"IOCTL demo module unloaded\\n\");\n    printk(KERN_INFO \"Final stats - Operations: %lu, Errors: %lu\\n\",\n           device_stats.operation_count, device_stats.error_count);\n}\n\nmodule_init(ioctl_module_init);\nmodule_exit(ioctl_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"IOCTL interface demonstration\");\nMODULE_VERSION(\"1.0\");",
  "validation": {
    "exactRequirements": {
      "functionNames": [
        "ioctl_module_init",
        "ioctl_module_exit",
        "demo_ioctl",
        "demo_open", 
        "demo_release"
      ],
      "variables": [
        {"name": "major_number", "type": "int"},
        {"name": "demo_class", "type": "struct class*"},
        {"name": "demo_device", "type": "struct device*"},
        {"name": "device_mutex", "type": "struct mutex"}
      ],
      "outputMessages": [
        "IOCTL demo module loaded successfully",
        "Device registered: /dev/demo_ioctl",
        "IOCTL commands: GET_CONFIG=",
        "IOCTL demo module unloaded",
        "Final stats - Operations:"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/fs.h",
        "linux/device.h",
        "linux/uaccess.h",
        "linux/ioctl.h"
      ],
      "mustContain": [
        "_IO",
        "_IOR",
        "_IOW", 
        "_IOWR",
        "_IOC_TYPE",
        "_IOC_NR",
        "_IOC_DIR",
        "_IOC_SIZE",
        "copy_from_user",
        "copy_to_user",
        "access_ok",
        "register_chrdev",
        "class_create",
        "device_create"
      ]
    },
    "testCases": [
      {
        "id": "ioctl_magic_definition",
        "name": "IOCTL Magic and Commands",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "#define DEMO_IOC_MAGIC",
          "_IOR(DEMO_IOC_MAGIC, 1",
          "_IOW(DEMO_IOC_MAGIC, 2",
          "_IO(DEMO_IOC_MAGIC, 4",
          "_IOWR(DEMO_IOC_MAGIC, 5"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "command_validation",
        "name": "IOCTL Command Validation",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "_IOC_TYPE(cmd) != DEMO_IOC_MAGIC",
          "_IOC_NR(cmd) > DEMO_IOC_MAXNR",
          "return -ENOTTY"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "access_checking",
        "name": "User Access Checking",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "access_ok(argp, _IOC_SIZE(cmd))",
          "_IOC_DIR(cmd) & _IOC_READ",
          "_IOC_DIR(cmd) & _IOC_WRITE"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "data_transfer",
        "name": "Safe Data Transfer",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "copy_from_user(&config, argp",
          "copy_to_user(argp, &device_config",
          "copy_to_user(argp, &stats",
          "return -EFAULT"
        ],
        "prohibitedSymbols": ["memcpy", "strcpy"]
      },
      {
        "id": "input_validation",
        "name": "Input Validation",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "if (config.mode < 0 || config.mode > 3)",
          "if (config.threshold < 0",
          "if (!buffer_info.data",
          "return -EINVAL"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "device_registration",
        "name": "Character Device Registration",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "register_chrdev(0, DEVICE_NAME",
          "class_create(THIS_MODULE, CLASS_NAME)",
          "device_create(demo_class"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "device_creation_message",
        "name": "Device Registration Message",
        "type": "output_match",
        "critical": true,
        "expected": [
          {"pattern": "Device registered: /dev/demo_ioctl", "exact": true}
        ]
      }
    ]
  }
}