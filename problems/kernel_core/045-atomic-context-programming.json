{
  "id": 45,
  "title": "Atomic Context Programming",
  "phase": "kernel_core",
  "difficulty": 7,
  "xp": 65,
  "description": "Learn how to write code that works correctly in atomic context (interrupt handlers). Understand the restrictions, proper memory allocation flags, and safe programming practices for interrupt-safe code.",
  "concepts": ["atomic_context", "interrupt_context", "gfp_atomic", "spinlocks", "atomic_operations"],
  "skills": ["atomic_programming", "interrupt_safe_code", "proper_memory_allocation"],
  "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/timer.h>\n#include <linux/jiffies.h>\n#include <linux/spinlock.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n\n// CONCEPT: Atomic Context Programming\n// Atomic Context = Code that cannot sleep or be interrupted\n// Examples: Interrupt handlers, spinlock-protected code, some kernel timers\n// \n// Rules for Atomic Context:\n// 1. Cannot sleep (no msleep, no mutex_lock)\n// 2. Use GFP_ATOMIC for memory allocation\n// 3. Use spinlocks, not mutexes\n// 4. Keep code fast and simple\n//\n// WHY: Sleeping in atomic context can cause deadlocks and system crashes\n\n// Data structures for demonstration\nstruct atomic_data {\n    atomic_t counter;\n    spinlock_t lock;\n    char *buffer;\n    size_t buffer_size;\n    unsigned long last_update;\n};\n\nstatic struct atomic_data demo_data;\nstatic struct timer_list atomic_timer;\nstatic unsigned long atomic_context_calls = 0;\n\n// TODO: Demonstrate proper atomic context programming\nstatic void atomic_context_handler(struct timer_list *timer)\n{\n    unsigned long flags;\n    char *temp_buffer;\n    \n    // This runs in ATOMIC CONTEXT (timer interrupt)\n    atomic_context_calls++;\n    \n    printk(KERN_INFO \"=== ATOMIC CONTEXT HANDLER #%lu ===\", atomic_context_calls);\n    printk(KERN_INFO \"Running in atomic context - following strict rules\\n\");\n    \n    // Rule 1: Use atomic operations for simple counters\n    atomic_inc(&demo_data.counter);\n    printk(KERN_INFO \"Atomic counter incremented to: %d\\n\", atomic_read(&demo_data.counter));\n    \n    // Rule 2: Use spinlocks, not mutexes\n    spin_lock_irqsave(&demo_data.lock, flags);\n    \n    // Rule 3: Use GFP_ATOMIC for memory allocation\n    temp_buffer = kmalloc(64, GFP_ATOMIC);\n    if (temp_buffer) {\n        snprintf(temp_buffer, 64, \"atomic_call_%lu\", atomic_context_calls);\n        printk(KERN_INFO \"Allocated buffer in atomic context: %s\\n\", temp_buffer);\n        \n        // Update shared data while holding spinlock\n        demo_data.last_update = jiffies;\n        \n        // Free immediately (just for demonstration)\n        kfree(temp_buffer);\n    } else {\n        printk(KERN_WARNING \"GFP_ATOMIC allocation failed (this is normal under memory pressure)\\n\");\n    }\n    \n    spin_unlock_irqrestore(&demo_data.lock, flags);\n    \n    // Rule 4: Keep it fast and simple\n    printk(KERN_INFO \"Atomic context handler completed quickly\\n\");\n    \n    // Schedule next call\n    if (atomic_context_calls < 10) {\n        mod_timer(&atomic_timer, jiffies + msecs_to_jiffies(1500));\n    }\n}\n\n// TODO: Demonstrate what NOT to do in atomic context\nstatic void demonstrate_atomic_context_violations(void)\n{\n    printk(KERN_INFO \"=== ATOMIC CONTEXT VIOLATIONS (DO NOT DO THIS!) ===\");\n    printk(KERN_INFO \"The following would cause problems in atomic context:\\n\");\n    \n    printk(KERN_INFO \"1. msleep() - FORBIDDEN (would sleep)\\n\");\n    printk(KERN_INFO \"   // msleep(100); // CRASH!\\n\");\n    \n    printk(KERN_INFO \"2. mutex_lock() - FORBIDDEN (might sleep)\\n\");\n    printk(KERN_INFO \"   // mutex_lock(&some_mutex); // CRASH!\\n\");\n    \n    printk(KERN_INFO \"3. kmalloc(..., GFP_KERNEL) - FORBIDDEN (might sleep)\\n\");\n    printk(KERN_INFO \"   // kmalloc(size, GFP_KERNEL); // CRASH!\\n\");\n    \n    printk(KERN_INFO \"4. copy_from_user() - FORBIDDEN (might sleep)\\n\");\n    printk(KERN_INFO \"   // copy_from_user(dest, src, size); // CRASH!\\n\");\n    \n    printk(KERN_INFO \"5. Taking too long - BAD (delays other interrupts)\\n\");\n    printk(KERN_INFO \"   // for (i = 0; i < 1000000; i++) {...} // BAD!\\n\");\n}\n\n// TODO: Demonstrate proper atomic context alternatives\nstatic void demonstrate_atomic_context_alternatives(void)\n{\n    printk(KERN_INFO \"=== ATOMIC CONTEXT ALTERNATIVES ===\");\n    printk(KERN_INFO \"Instead of forbidden operations, use:\\n\");\n    \n    printk(KERN_INFO \"1. Instead of msleep() -> udelay() (microsecond delays only)\\n\");\n    printk(KERN_INFO \"2. Instead of mutex_lock() -> spin_lock_irqsave()\\n\");\n    printk(KERN_INFO \"3. Instead of GFP_KERNEL -> GFP_ATOMIC\\n\");\n    printk(KERN_INFO \"4. Instead of copy_from_user() -> defer to workqueue\\n\");\n    printk(KERN_INFO \"5. Instead of long processing -> defer to bottom half\\n\");\n    \n    printk(KERN_INFO \"Next lesson: Top-half/Bottom-half processing\\n\");\n}\n\n// TODO: Demonstrate atomic operations\nstatic void demonstrate_atomic_operations(void)\n{\n    atomic_t test_atomic;\n    \n    printk(KERN_INFO \"=== ATOMIC OPERATIONS DEMONSTRATION ===\");\n    \n    // Initialize atomic variable\n    atomic_set(&test_atomic, 100);\n    printk(KERN_INFO \"Initial atomic value: %d\\n\", atomic_read(&test_atomic));\n    \n    // Demonstrate various atomic operations\n    atomic_inc(&test_atomic);\n    printk(KERN_INFO \"After atomic_inc: %d\\n\", atomic_read(&test_atomic));\n    \n    atomic_dec(&test_atomic);\n    printk(KERN_INFO \"After atomic_dec: %d\\n\", atomic_read(&test_atomic));\n    \n    atomic_add(10, &test_atomic);\n    printk(KERN_INFO \"After atomic_add(10): %d\\n\", atomic_read(&test_atomic));\n    \n    atomic_sub(5, &test_atomic);\n    printk(KERN_INFO \"After atomic_sub(5): %d\\n\", atomic_read(&test_atomic));\n    \n    // Test and set operations\n    if (atomic_dec_and_test(&test_atomic)) {\n        printk(KERN_INFO \"atomic_dec_and_test returned true (value is 0)\\n\");\n    } else {\n        printk(KERN_INFO \"atomic_dec_and_test returned false (value is %d)\\n\", atomic_read(&test_atomic));\n    }\n    \n    printk(KERN_INFO \"Atomic operations are safe in any context\\n\");\n}\n\n// TODO: Demonstrate proper spinlock usage\nstatic void demonstrate_spinlock_usage(void)\n{\n    unsigned long flags;\n    \n    printk(KERN_INFO \"=== SPINLOCK USAGE DEMONSTRATION ===\");\n    \n    // Proper spinlock usage in atomic context\n    spin_lock_irqsave(&demo_data.lock, flags);\n    \n    printk(KERN_INFO \"Spinlock acquired with interrupts disabled\\n\");\n    printk(KERN_INFO \"This is safe in atomic context\\n\");\n    \n    // Simulate critical section\n    demo_data.last_update = jiffies;\n    \n    spin_unlock_irqrestore(&demo_data.lock, flags);\n    \n    printk(KERN_INFO \"Spinlock released and interrupts restored\\n\");\n    \n    printk(KERN_INFO \"Why spin_lock_irqsave?\\n\");\n    printk(KERN_INFO \"- Disables interrupts on this CPU\\n\");\n    printk(KERN_INFO \"- Prevents deadlocks with interrupt handlers\\n\");\n    printk(KERN_INFO \"- Safe to use in both process and interrupt context\\n\");\n}\n\nstatic int __init atomic_context_init(void)\n{\n    printk(KERN_INFO \"Atomic context programming module loaded\\n\");\n    printk(KERN_INFO \"Learning interrupt-safe programming techniques\\n\");\n    \n    // Initialize data structures\n    atomic_set(&demo_data.counter, 0);\n    spin_lock_init(&demo_data.lock);\n    demo_data.buffer = kmalloc(256, GFP_KERNEL); // OK in process context\n    demo_data.buffer_size = 256;\n    demo_data.last_update = jiffies;\n    \n    if (!demo_data.buffer) {\n        printk(KERN_ERR \"Failed to allocate buffer\\n\");\n        return -ENOMEM;\n    }\n    \n    // This all runs in process context\n    demonstrate_atomic_context_violations();\n    demonstrate_atomic_context_alternatives();\n    demonstrate_atomic_operations();\n    demonstrate_spinlock_usage();\n    \n    // Set up timer to demonstrate atomic context\n    timer_setup(&atomic_timer, atomic_context_handler, 0);\n    printk(KERN_INFO \"Starting atomic context demonstrations...\\n\");\n    mod_timer(&atomic_timer, jiffies + msecs_to_jiffies(1000));\n    \n    return 0;\n}\n\nstatic void __exit atomic_context_exit(void)\n{\n    printk(KERN_INFO \"Stopping atomic context demonstrations...\\n\");\n    \n    // Stop timer\n    del_timer_sync(&atomic_timer);\n    \n    // Clean up\n    kfree(demo_data.buffer);\n    \n    printk(KERN_INFO \"Atomic context programming module unloaded\\n\");\n    printk(KERN_INFO \"Total atomic context calls: %lu\\n\", atomic_context_calls);\n    printk(KERN_INFO \"Final atomic counter: %d\\n\", atomic_read(&demo_data.counter));\n    printk(KERN_INFO \"Remember: GFP_ATOMIC, spinlocks, be fast!\\n\");\n}\n\nmodule_init(atomic_context_init);\nmodule_exit(atomic_context_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Atomic context programming techniques\");\nMODULE_VERSION(\"1.0\");",
  "validation": {
    "exactRequirements": {
      "functionNames": [
        "atomic_context_init",
        "atomic_context_exit",
        "atomic_context_handler",
        "demonstrate_atomic_context_violations",
        "demonstrate_atomic_context_alternatives",
        "demonstrate_atomic_operations",
        "demonstrate_spinlock_usage"
      ],
      "variables": [
        {"name": "demo_data", "type": "struct atomic_data"},
        {"name": "atomic_timer", "type": "struct timer_list"},
        {"name": "atomic_context_calls", "type": "unsigned long"}
      ],
      "outputMessages": [
        "Atomic context programming module loaded",
        "Learning interrupt-safe programming techniques",
        "=== ATOMIC CONTEXT HANDLER #1 ===",
        "Running in atomic context - following strict rules",
        "=== ATOMIC CONTEXT VIOLATIONS (DO NOT DO THIS!) ===",
        "=== ATOMIC CONTEXT ALTERNATIVES ===",
        "=== ATOMIC OPERATIONS DEMONSTRATION ===",
        "=== SPINLOCK USAGE DEMONSTRATION ===",
        "Remember: GFP_ATOMIC, spinlocks, be fast!"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/timer.h",
        "linux/spinlock.h",
        "linux/atomic.h",
        "linux/slab.h"
      ],
      "mustContain": [
        "GFP_ATOMIC",
        "spin_lock_irqsave",
        "spin_unlock_irqrestore",
        "atomic_inc",
        "atomic_read",
        "atomic_set"
      ]
    },
    "testCases": [
      {
        "id": "atomic_memory_allocation",
        "name": "Atomic Memory Allocation",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "kmalloc(64, GFP_ATOMIC)",
          "if (temp_buffer)",
          "kfree(temp_buffer)"
        ],
        "prohibitedSymbols": ["GFP_KERNEL", "msleep", "mutex_lock"]
      },
      {
        "id": "spinlock_usage",
        "name": "Proper Spinlock Usage",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "spin_lock_irqsave(&demo_data.lock, flags)",
          "spin_unlock_irqrestore(&demo_data.lock, flags)",
          "unsigned long flags"
        ],
        "prohibitedSymbols": ["mutex_lock", "mutex_unlock"]
      },
      {
        "id": "atomic_operations",
        "name": "Atomic Operations Usage",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "atomic_inc(&demo_data.counter)",
          "atomic_read(&demo_data.counter)",
          "atomic_set(&test_atomic, 100)",
          "atomic_dec(&test_atomic)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "violations_explanation",
        "name": "Violations Explanation",
        "type": "output_match",
        "critical": true,
        "expected": [
          {"pattern": "=== ATOMIC CONTEXT VIOLATIONS (DO NOT DO THIS!) ===", "exact": true},
          {"pattern": "msleep() - FORBIDDEN", "exact": false},
          {"pattern": "mutex_lock() - FORBIDDEN", "exact": false}
        ]
      },
      {
        "id": "alternatives_explanation",
        "name": "Alternatives Explanation",
        "type": "output_match",
        "critical": true,
        "expected": [
          {"pattern": "=== ATOMIC CONTEXT ALTERNATIVES ===", "exact": true},
          {"pattern": "Instead of GFP_KERNEL -> GFP_ATOMIC", "exact": true},
          {"pattern": "Instead of mutex_lock() -> spin_lock_irqsave()", "exact": true}
        ]
      },
      {
        "id": "educational_comments",
        "name": "Educational Comments Present",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "// CONCEPT: Atomic Context Programming",
          "// Rules for Atomic Context:",
          "// WHY: Sleeping in atomic context"
        ],
        "prohibitedSymbols": []
      }
    ]
  }
}