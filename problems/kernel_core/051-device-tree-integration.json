{
  "id": 51,
  "title": "Device Tree Integration and Platform Drivers",
  "difficulty": 8,
  "xp": 80,
  "phase": "kernel_core",
  "description": "Implement a platform driver with device tree integration, including property parsing and resource management. This teaches embedded system development techniques used in ARM-based systems and IoT devices.",
  "concepts": ["device_tree", "platform_driver", "of_device", "resource_management", "devicetree_properties", "embedded_systems"],
  "skills": ["embedded_programming", "devicetree_usage", "platform_driver_development", "resource_parsing"],
  "starter": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_platform.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/clk.h>\n#include <linux/reset.h>\n\n#define DEVICE_NAME \"dtdev\"\n#define CLASS_NAME \"dtclass\"\n#define BUFFER_SIZE 1024\n\n// TODO: Device configuration from device tree\nstruct dt_device_config {\n    const char *device_name;\n    u32 reg_base;\n    u32 reg_size;\n    u32 clock_frequency;\n    u32 buffer_size;\n    int irq_number;\n    bool enable_debug;\n    const char *compatible;\n};\n\n// TODO: Device structure\nstruct dt_device {\n    struct platform_device *pdev;\n    struct device *char_device;\n    struct class *class;\n    struct cdev cdev;\n    dev_t dev_num;\n    \n    // Device tree configuration\n    struct dt_device_config config;\n    \n    // Resources\n    struct resource *mem_resource;\n    void __iomem *reg_base;\n    struct clk *device_clock;\n    struct reset_control *reset_control;\n    \n    // Device data\n    char *buffer;\n    size_t buffer_used;\n    struct mutex device_mutex;\n    \n    // Statistics\n    unsigned long read_count;\n    unsigned long write_count;\n    unsigned long probe_time_jiffies;\n};\n\nstatic struct dt_device *dt_dev_instance = NULL;\nstatic struct class *dt_dev_class = NULL;\n\n// TODO: Parse device tree properties\nstatic int parse_dt_properties(struct platform_device *pdev, struct dt_device_config *config)\n{\n    struct device_node *np = pdev->dev.of_node;\n    int ret;\n    \n    if (!np) {\n        dev_err(&pdev->dev, \"No device tree node found\\n\");\n        return -ENODEV;\n    }\n    \n    // TODO: Parse compatible string\n    ret = of_property_read_string(np, \"compatible\", &config->compatible);\n    if (ret) {\n        dev_err(&pdev->dev, \"Failed to read compatible property\\n\");\n        return ret;\n    }\n    \n    // TODO: Parse device name\n    ret = of_property_read_string(np, \"device-name\", &config->device_name);\n    if (ret) {\n        config->device_name = \"default-dt-device\";\n        dev_info(&pdev->dev, \"Using default device name\\n\");\n    }\n    \n    // TODO: Parse register base and size\n    ret = of_property_read_u32_index(np, \"reg\", 0, &config->reg_base);\n    if (ret) {\n        dev_err(&pdev->dev, \"Failed to read reg base\\n\");\n        return ret;\n    }\n    \n    ret = of_property_read_u32_index(np, \"reg\", 1, &config->reg_size);\n    if (ret) {\n        dev_err(&pdev->dev, \"Failed to read reg size\\n\");\n        return ret;\n    }\n    \n    // TODO: Parse optional clock frequency\n    ret = of_property_read_u32(np, \"clock-frequency\", &config->clock_frequency);\n    if (ret) {\n        config->clock_frequency = 100000000; // Default 100MHz\n        dev_info(&pdev->dev, \"Using default clock frequency: %u Hz\\n\", config->clock_frequency);\n    }\n    \n    // TODO: Parse optional buffer size\n    ret = of_property_read_u32(np, \"buffer-size\", &config->buffer_size);\n    if (ret) {\n        config->buffer_size = BUFFER_SIZE;\n        dev_info(&pdev->dev, \"Using default buffer size: %u bytes\\n\", config->buffer_size);\n    }\n    \n    // TODO: Parse debug enable flag\n    config->enable_debug = of_property_read_bool(np, \"enable-debug\");\n    \n    dev_info(&pdev->dev, \"Device tree properties parsed successfully\\n\");\n    dev_info(&pdev->dev, \"  Compatible: %s\\n\", config->compatible);\n    dev_info(&pdev->dev, \"  Device name: %s\\n\", config->device_name);\n    dev_info(&pdev->dev, \"  Register: 0x%x (size: 0x%x)\\n\", config->reg_base, config->reg_size);\n    dev_info(&pdev->dev, \"  Clock frequency: %u Hz\\n\", config->clock_frequency);\n    dev_info(&pdev->dev, \"  Buffer size: %u bytes\\n\", config->buffer_size);\n    dev_info(&pdev->dev, \"  Debug enabled: %s\\n\", config->enable_debug ? \"yes\" : \"no\");\n    \n    return 0;\n}\n\n// TODO: Setup device resources\nstatic int setup_device_resources(struct dt_device *dev)\n{\n    struct platform_device *pdev = dev->pdev;\n    int ret;\n    \n    // TODO: Get memory resource\n    dev->mem_resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n    if (!dev->mem_resource) {\n        dev_err(&pdev->dev, \"Failed to get memory resource\\n\");\n        return -ENODEV;\n    }\n    \n    // TODO: Request and map memory region\n    if (!request_mem_region(dev->mem_resource->start,\n                           resource_size(dev->mem_resource),\n                           dev_name(&pdev->dev))) {\n        dev_err(&pdev->dev, \"Failed to request memory region\\n\");\n        return -EBUSY;\n    }\n    \n    dev->reg_base = ioremap(dev->mem_resource->start, resource_size(dev->mem_resource));\n    if (!dev->reg_base) {\n        dev_err(&pdev->dev, \"Failed to map memory region\\n\");\n        release_mem_region(dev->mem_resource->start, resource_size(dev->mem_resource));\n        return -ENOMEM;\n    }\n    \n    // TODO: Get optional clock\n    dev->device_clock = devm_clk_get(&pdev->dev, \"device-clock\");\n    if (IS_ERR(dev->device_clock)) {\n        if (PTR_ERR(dev->device_clock) == -EPROBE_DEFER) {\n            dev_info(&pdev->dev, \"Clock not ready, deferring probe\\n\");\n            ret = -EPROBE_DEFER;\n            goto err_unmap;\n        }\n        dev_info(&pdev->dev, \"No clock specified in device tree\\n\");\n        dev->device_clock = NULL;\n    } else {\n        ret = clk_prepare_enable(dev->device_clock);\n        if (ret) {\n            dev_err(&pdev->dev, \"Failed to enable clock: %d\\n\", ret);\n            goto err_unmap;\n        }\n        dev_info(&pdev->dev, \"Clock enabled successfully\\n\");\n    }\n    \n    // TODO: Get optional reset control\n    dev->reset_control = devm_reset_control_get_optional(&pdev->dev, \"device-reset\");\n    if (IS_ERR(dev->reset_control)) {\n        ret = PTR_ERR(dev->reset_control);\n        dev_err(&pdev->dev, \"Failed to get reset control: %d\\n\", ret);\n        goto err_disable_clock;\n    }\n    \n    if (dev->reset_control) {\n        ret = reset_control_deassert(dev->reset_control);\n        if (ret) {\n            dev_err(&pdev->dev, \"Failed to deassert reset: %d\\n\", ret);\n            goto err_disable_clock;\n        }\n        dev_info(&pdev->dev, \"Reset deasserted successfully\\n\");\n    }\n    \n    // TODO: Get optional interrupt\n    dev->config.irq_number = platform_get_irq(pdev, 0);\n    if (dev->config.irq_number < 0) {\n        dev_info(&pdev->dev, \"No interrupt specified in device tree\\n\");\n        dev->config.irq_number = -1;\n    } else {\n        dev_info(&pdev->dev, \"IRQ: %d\\n\", dev->config.irq_number);\n    }\n    \n    dev_info(&pdev->dev, \"Device resources setup successfully\\n\");\n    return 0;\n    \nerr_disable_clock:\n    if (dev->device_clock) {\n        clk_disable_unprepare(dev->device_clock);\n    }\nerr_unmap:\n    iounmap(dev->reg_base);\n    release_mem_region(dev->mem_resource->start, resource_size(dev->mem_resource));\n    return ret;\n}\n\n// TODO: Cleanup device resources\nstatic void cleanup_device_resources(struct dt_device *dev)\n{\n    if (dev->reset_control) {\n        reset_control_assert(dev->reset_control);\n    }\n    \n    if (dev->device_clock) {\n        clk_disable_unprepare(dev->device_clock);\n    }\n    \n    if (dev->reg_base) {\n        iounmap(dev->reg_base);\n    }\n    \n    if (dev->mem_resource) {\n        release_mem_region(dev->mem_resource->start, resource_size(dev->mem_resource));\n    }\n}\n\n// TODO: File operations\nstatic int device_open(struct inode *inode, struct file *file)\n{\n    struct dt_device *dev = dt_dev_instance;\n    \n    if (!dev) {\n        return -ENODEV;\n    }\n    \n    file->private_data = dev;\n    \n    if (dev->config.enable_debug) {\n        dev_info(&dev->pdev->dev, \"Device opened\\n\");\n    }\n    \n    return 0;\n}\n\nstatic int device_release(struct inode *inode, struct file *file)\n{\n    struct dt_device *dev = file->private_data;\n    \n    if (dev && dev->config.enable_debug) {\n        dev_info(&dev->pdev->dev, \"Device closed\\n\");\n    }\n    \n    return 0;\n}\n\nstatic ssize_t device_read(struct file *file, char __user *user_buffer,\n                          size_t count, loff_t *offset)\n{\n    struct dt_device *dev = file->private_data;\n    ssize_t bytes_read = 0;\n    char info_buffer[512];\n    size_t info_len;\n    \n    if (!dev) {\n        return -ENODEV;\n    }\n    \n    mutex_lock(&dev->device_mutex);\n    \n    // Create device information string\n    info_len = snprintf(info_buffer, sizeof(info_buffer),\n                       \"Device Tree Device Information\\n\"\n                       \"==============================\\n\"\n                       \"Compatible: %s\\n\"\n                       \"Device Name: %s\\n\"\n                       \"Register Base: 0x%x\\n\"\n                       \"Register Size: 0x%x\\n\"\n                       \"Clock Frequency: %u Hz\\n\"\n                       \"Buffer Size: %u bytes\\n\"\n                       \"IRQ: %d\\n\"\n                       \"Debug: %s\\n\"\n                       \"Read Count: %lu\\n\"\n                       \"Write Count: %lu\\n\"\n                       \"Probe Time: %lu jiffies\\n\",\n                       dev->config.compatible,\n                       dev->config.device_name,\n                       dev->config.reg_base,\n                       dev->config.reg_size,\n                       dev->config.clock_frequency,\n                       dev->config.buffer_size,\n                       dev->config.irq_number,\n                       dev->config.enable_debug ? \"enabled\" : \"disabled\",\n                       dev->read_count,\n                       dev->write_count,\n                       dev->probe_time_jiffies);\n    \n    if (*offset >= info_len) {\n        mutex_unlock(&dev->device_mutex);\n        return 0; // EOF\n    }\n    \n    bytes_read = min(count, info_len - *offset);\n    \n    if (copy_to_user(user_buffer, info_buffer + *offset, bytes_read)) {\n        mutex_unlock(&dev->device_mutex);\n        return -EFAULT;\n    }\n    \n    *offset += bytes_read;\n    dev->read_count++;\n    \n    mutex_unlock(&dev->device_mutex);\n    \n    if (dev->config.enable_debug) {\n        dev_info(&dev->pdev->dev, \"Read %zu bytes\\n\", bytes_read);\n    }\n    \n    return bytes_read;\n}\n\nstatic ssize_t device_write(struct file *file, const char __user *user_buffer,\n                           size_t count, loff_t *offset)\n{\n    struct dt_device *dev = file->private_data;\n    ssize_t bytes_written = 0;\n    \n    if (!dev) {\n        return -ENODEV;\n    }\n    \n    mutex_lock(&dev->device_mutex);\n    \n    if (*offset >= dev->config.buffer_size) {\n        mutex_unlock(&dev->device_mutex);\n        return -ENOSPC;\n    }\n    \n    bytes_written = min(count, dev->config.buffer_size - *offset);\n    \n    if (copy_from_user(dev->buffer + *offset, user_buffer, bytes_written)) {\n        mutex_unlock(&dev->device_mutex);\n        return -EFAULT;\n    }\n    \n    *offset += bytes_written;\n    if (*offset > dev->buffer_used) {\n        dev->buffer_used = *offset;\n    }\n    \n    dev->write_count++;\n    \n    mutex_unlock(&dev->device_mutex);\n    \n    if (dev->config.enable_debug) {\n        dev_info(&dev->pdev->dev, \"Wrote %zu bytes\\n\", bytes_written);\n    }\n    \n    return bytes_written;\n}\n\nstatic const struct file_operations dt_dev_fops = {\n    .owner = THIS_MODULE,\n    .open = device_open,\n    .release = device_release,\n    .read = device_read,\n    .write = device_write,\n};\n\n// TODO: Platform driver probe function\nstatic int dt_device_probe(struct platform_device *pdev)\n{\n    struct dt_device *dev;\n    int ret;\n    \n    dev_info(&pdev->dev, \"Probing device tree device\\n\");\n    \n    // TODO: Allocate device structure\n    dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n    if (!dev) {\n        return -ENOMEM;\n    }\n    \n    dev->pdev = pdev;\n    dev->probe_time_jiffies = jiffies;\n    mutex_init(&dev->device_mutex);\n    \n    // TODO: Parse device tree properties\n    ret = parse_dt_properties(pdev, &dev->config);\n    if (ret) {\n        return ret;\n    }\n    \n    // TODO: Setup device resources\n    ret = setup_device_resources(dev);\n    if (ret) {\n        return ret;\n    }\n    \n    // TODO: Allocate buffer\n    dev->buffer = devm_kzalloc(&pdev->dev, dev->config.buffer_size, GFP_KERNEL);\n    if (!dev->buffer) {\n        cleanup_device_resources(dev);\n        return -ENOMEM;\n    }\n    \n    // TODO: Register character device\n    ret = alloc_chrdev_region(&dev->dev_num, 0, 1, DEVICE_NAME);\n    if (ret < 0) {\n        dev_err(&pdev->dev, \"Failed to allocate character device region\\n\");\n        cleanup_device_resources(dev);\n        return ret;\n    }\n    \n    cdev_init(&dev->cdev, &dt_dev_fops);\n    dev->cdev.owner = THIS_MODULE;\n    \n    ret = cdev_add(&dev->cdev, dev->dev_num, 1);\n    if (ret < 0) {\n        dev_err(&pdev->dev, \"Failed to add character device\\n\");\n        unregister_chrdev_region(dev->dev_num, 1);\n        cleanup_device_resources(dev);\n        return ret;\n    }\n    \n    // TODO: Create device file\n    dev->char_device = device_create(dt_dev_class, &pdev->dev, dev->dev_num,\n                                    dev, \"%s\", dev->config.device_name);\n    if (IS_ERR(dev->char_device)) {\n        dev_err(&pdev->dev, \"Failed to create device file\\n\");\n        cdev_del(&dev->cdev);\n        unregister_chrdev_region(dev->dev_num, 1);\n        cleanup_device_resources(dev);\n        return PTR_ERR(dev->char_device);\n    }\n    \n    // TODO: Set platform driver data\n    platform_set_drvdata(pdev, dev);\n    dt_dev_instance = dev;\n    \n    dev_info(&pdev->dev, \"Device tree device probed successfully\\n\");\n    dev_info(&pdev->dev, \"Character device: /dev/%s\\n\", dev->config.device_name);\n    \n    return 0;\n}\n\n// TODO: Platform driver remove function\nstatic int dt_device_remove(struct platform_device *pdev)\n{\n    struct dt_device *dev = platform_get_drvdata(pdev);\n    \n    dev_info(&pdev->dev, \"Removing device tree device\\n\");\n    \n    if (dev) {\n        // TODO: Clean up character device\n        device_destroy(dt_dev_class, dev->dev_num);\n        cdev_del(&dev->cdev);\n        unregister_chrdev_region(dev->dev_num, 1);\n        \n        // TODO: Clean up resources\n        cleanup_device_resources(dev);\n        \n        dt_dev_instance = NULL;\n    }\n    \n    dev_info(&pdev->dev, \"Device tree device removed\\n\");\n    return 0;\n}\n\n// TODO: Device tree match table\nstatic const struct of_device_id dt_device_of_match[] = {\n    { .compatible = \"kernel-academy,dt-demo-device\" },\n    { .compatible = \"example,dt-device\" },\n    { /* sentinel */ }\n};\nMODULE_DEVICE_TABLE(of, dt_device_of_match);\n\n// TODO: Platform driver structure\nstatic struct platform_driver dt_device_driver = {\n    .probe = dt_device_probe,\n    .remove = dt_device_remove,\n    .driver = {\n        .name = \"dt-demo-device\",\n        .of_match_table = dt_device_of_match,\n    },\n};\n\nstatic int __init dt_dev_init(void)\n{\n    int ret;\n    \n    printk(KERN_INFO \"Device tree device driver initializing...\\n\");\n    \n    // TODO: Create device class\n    dt_dev_class = class_create(THIS_MODULE, CLASS_NAME);\n    if (IS_ERR(dt_dev_class)) {\n        printk(KERN_ERR \"Failed to create device class\\n\");\n        return PTR_ERR(dt_dev_class);\n    }\n    \n    // TODO: Register platform driver\n    ret = platform_driver_register(&dt_device_driver);\n    if (ret) {\n        printk(KERN_ERR \"Failed to register platform driver\\n\");\n        class_destroy(dt_dev_class);\n        return ret;\n    }\n    \n    printk(KERN_INFO \"Device tree device driver loaded successfully\\n\");\n    printk(KERN_INFO \"Waiting for device tree match...\\n\");\n    \n    return 0;\n}\n\nstatic void __exit dt_dev_exit(void)\n{\n    printk(KERN_INFO \"Device tree device driver unloading...\\n\");\n    \n    // TODO: Unregister platform driver\n    platform_driver_unregister(&dt_device_driver);\n    \n    // TODO: Destroy device class\n    class_destroy(dt_dev_class);\n    \n    printk(KERN_INFO \"Device tree device driver unloaded\\n\");\n}\n\nmodule_init(dt_dev_init);\nmodule_exit(dt_dev_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kernel Academy Student\");\nMODULE_DESCRIPTION(\"Device tree platform driver demonstration\");\nMODULE_VERSION(\"1.0\");\nMODULE_DEVICE_TABLE(of, dt_device_of_match);",
  "validation": {
    "exactRequirements": {
      "functionNames": [
        "dt_dev_init",
        "dt_dev_exit",
        "dt_device_probe",
        "dt_device_remove",
        "parse_dt_properties",
        "setup_device_resources",
        "cleanup_device_resources"
      ],
      "variables": [
        {"name": "dt_device_driver", "type": "struct platform_driver"},
        {"name": "dt_device_of_match", "type": "struct of_device_id[]"},
        {"name": "dt_dev_fops", "type": "struct file_operations"}
      ],
      "outputMessages": [
        "Device tree device driver loaded successfully",
        "Waiting for device tree match...",
        "Device tree device driver unloaded"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/platform_device.h",
        "linux/of.h",
        "linux/of_device.h",
        "linux/of_platform.h"
      ],
      "mustContain": [
        "of_property_read_string",
        "of_property_read_u32",
        "of_property_read_bool",
        "platform_get_resource",
        "platform_get_irq",
        "devm_clk_get",
        "devm_reset_control_get_optional",
        "ioremap",
        "iounmap",
        "request_mem_region",
        "release_mem_region"
      ]
    },
    "testCases": [
      {
        "id": "devicetree_match_table",
        "name": "Device Tree Match Table",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "struct of_device_id dt_device_of_match",
          ".compatible = \"kernel-academy,dt-demo-device\"",
          "MODULE_DEVICE_TABLE(of, dt_device_of_match)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "devicetree_property_parsing",
        "name": "Device Tree Property Parsing",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "of_property_read_string(np, \"compatible\"",
          "of_property_read_u32(np, \"clock-frequency\"",
          "of_property_read_bool(np, \"enable-debug\")",
          "of_property_read_u32_index(np, \"reg\""
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "platform_driver_structure",
        "name": "Platform Driver Structure",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "struct platform_driver dt_device_driver",
          ".probe = dt_device_probe",
          ".remove = dt_device_remove",
          ".of_match_table = dt_device_of_match"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "resource_management",
        "name": "Platform Resource Management",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "platform_get_resource(pdev, IORESOURCE_MEM",
          "request_mem_region(dev->mem_resource->start",
          "ioremap(dev->mem_resource->start",
          "iounmap(dev->reg_base)",
          "release_mem_region(dev->mem_resource->start"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "devm_resource_usage",
        "name": "Device Managed Resource Usage",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "devm_kzalloc(&pdev->dev",
          "devm_clk_get(&pdev->dev",
          "devm_reset_control_get_optional(&pdev->dev"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "clock_reset_management",
        "name": "Clock and Reset Management",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "clk_prepare_enable(dev->device_clock)",
          "clk_disable_unprepare(dev->device_clock)",
          "reset_control_deassert(dev->reset_control)",
          "reset_control_assert(dev->reset_control)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "probe_defer_handling",
        "name": "Probe Defer Handling",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "if (PTR_ERR(dev->device_clock) == -EPROBE_DEFER)",
          "return -EPROBE_DEFER"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "dt_match_message",
        "name": "Device Tree Match Message",
        "type": "output_match",
        "critical": true,
        "expected": [
          {"pattern": "Waiting for device tree match...", "exact": true}
        ]
      }
    ]
  }
}