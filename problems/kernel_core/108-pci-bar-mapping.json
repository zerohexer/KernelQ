{
  "id": 108,
  "title": "PCI BAR Mapping - Accessing GPU Memory Regions",
  "phase": "kernel_core",
  "difficulty": 7,
  "xp": 60,
  "description": "Learn how real GPU drivers map and access device memory. Every GPU driver (AMD amdgpu, NVIDIA nouveau, Intel i915) must map PCI Base Address Registers (BARs) to access GPU memory and registers. You'll learn memory-mapped I/O (MMIO), resource management, and reading GPU hardware registers - the foundation of all GPU operations.",
  "mainFile": "pci_bar_map.c",
  "files": [
    {
      "name": "pci_bar_map.h",
      "content": "#ifndef PCI_BAR_MAP_H\n#define PCI_BAR_MAP_H\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/io.h>\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: PCI BAR Mapping and MMIO Access */\n/* ========================================================================== */\n/* This problem teaches PRODUCTION GPU DRIVER patterns used in ALL GPU drivers!\n *\n * WHAT ARE PCI BARs (Base Address Registers)?\n * - BARs are hardware registers that tell the OS where device memory is located\n * - Each BAR points to a region of memory or I/O space\n * - GPUs typically have 3 BARs:\n *   - BAR 0: Framebuffer (VRAM) - where screen images are stored\n *   - BAR 2: MMIO Registers - control registers for GPU operations\n *   - BAR 4: I/O ports (some older GPUs)\n *\n * REAL-WORLD GPU BAR LAYOUTS:\n * AMD Radeon RX 6800:\n *   - BAR 0: 16GB VRAM (visible VRAM for CPU access)\n *   - BAR 2: 256KB MMIO registers (command registers, status, configuration)\n *   - BAR 5: 128MB doorbell pages (for GPU command submission)\n *\n * NVIDIA RTX 3070:\n *   - BAR 0: 8GB framebuffer (GPU memory window)\n *   - BAR 1: 16MB register space (control registers)\n *   - BAR 3: 32MB expansion ROM\n *\n * Intel Integrated Graphics (i915):\n *   - BAR 0: 16MB display registers and GTT\n *   - BAR 2: 256MB aperture (CPU-accessible GPU memory)\n *\n * BOCHS-DISPLAY GPU (Our QEMU Device):\n *   - BAR 0: 16MB framebuffer memory\n *   - BAR 2: 8KB MMIO registers\n */\n\n/* GPU device identification (bochs-display in QEMU) */\n#define GPU_VENDOR_ID 0x1234\n#define GPU_DEVICE_ID 0x1111\n\n/* BAR indices - which BAR contains what */\n#define GPU_BAR_FRAMEBUFFER 0  /* BAR 0 = framebuffer memory (where pixels are) */\n#define GPU_BAR_MMIO 2         /* BAR 2 = MMIO registers (control registers) */\n\n/* MMIO register offsets (bochs-display specific) */\n#define MMIO_ID_REGISTER 0x0   /* Device identification register at offset 0 */\n\n/* ========================================================================== */\n/* WHAT IS MEMORY-MAPPED I/O (MMIO)?\n * Instead of using special I/O instructions, we access device registers\n * just like regular memory reads/writes.\n *\n * PHYSICAL vs VIRTUAL ADDRESSES:\n * - PCI BAR gives us PHYSICAL address (hardware address on the bus)\n * - Kernel cannot access physical addresses directly\n * - We must MAP physical -> virtual using ioremap()\n *\n * EXAMPLE:\n * Physical address: 0xfe000000 (from PCI BAR)\n * ioremap(0xfe000000, 8192) -> virtual address: 0xffffc90000000000\n * Now we can read/write to 0xffffc90000000000 to talk to hardware!\n */\n\n/* ========================================================================== */\n/* FUNCTION DECLARATIONS */\n/* ========================================================================== */\n/* TODO: Declare PCI probe and remove functions */\n/* static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id); */\n/* static void gpu_pci_remove(struct pci_dev *pdev); */\n\n#endif /* PCI_BAR_MAP_H */\n",
      "readOnly": false,
      "language": "h"
    },
    {
      "name": "pci_bar_map.c",
      "content": "#include \"pci_bar_map.h\"\n\n/* ========================================================================== */\n/* GLOBAL VARIABLES: Mapped Memory Pointers */\n/* ========================================================================== */\n/* These pointers store the VIRTUAL addresses where we mapped the GPU memory.\n * - mmio_base: Points to control registers (read/write config, status)\n * - fb_base: Points to framebuffer memory (where pixel data goes)\n *\n * The __iomem annotation tells the kernel these point to I/O memory,\n * not regular RAM. We must use special ioread/iowrite functions to access them.\n */\nstatic void __iomem *mmio_base = NULL;    /* Virtual address of mapped MMIO */\nstatic void __iomem *fb_base = NULL;      /* Virtual address of mapped framebuffer */\nstatic resource_size_t mmio_size = 0;     /* Size of MMIO region */\nstatic resource_size_t fb_size = 0;       /* Size of framebuffer region */\n\n/* ========================================================================== */\n/* PCI DEVICE TABLE: Tells kernel which devices we support */\n/* ========================================================================== */\nstatic const struct pci_device_id gpu_pci_table[] = {\n    { PCI_DEVICE(GPU_VENDOR_ID, GPU_DEVICE_ID) },\n    { 0, }  /* Terminator */\n};\nMODULE_DEVICE_TABLE(pci, gpu_pci_table);\n\n/* ========================================================================== */\n/* PATTERN SCAFFOLDING: Understanding BAR Mapping Flow */\n/* ========================================================================== */\n/* STEP-BY-STEP BAR MAPPING PROCESS:\n *\n * 1. ENABLE PCI DEVICE\n *    pci_enable_device(pdev)\n *    - Powers on the device\n *    - Enables memory and I/O access\n *\n * 2. GET BAR INFORMATION\n *    phys_addr = pci_resource_start(pdev, BAR_NUMBER)\n *    size = pci_resource_len(pdev, BAR_NUMBER)\n *    flags = pci_resource_flags(pdev, BAR_NUMBER)\n *    - Reads the PCI configuration space\n *    - Gets physical address, size, and type of the BAR\n *\n * 3. REQUEST MEMORY REGIONS\n *    pci_request_regions(pdev, \"driver_name\")\n *    - Reserves the BARs so no other driver can use them\n *    - Prevents conflicts with other drivers\n *\n * 4. MAP PHYSICAL TO VIRTUAL\n *    For MMIO registers:\n *      virt_addr = ioremap(phys_addr, size)\n *      - Creates uncached mapping (every read/write goes to hardware)\n *      - Maintains strict ordering (important for registers)\n *\n *    For Framebuffer:\n *      virt_addr = ioremap_wc(phys_addr, size)\n *      - Creates write-combining mapping (better performance)\n *      - Allows CPU to batch writes for speed\n *\n * 5. ACCESS HARDWARE\n *    value = ioread32(virt_addr + offset)\n *    iowrite32(value, virt_addr + offset)\n *    - Use special I/O functions (never regular pointers!)\n *\n * 6. CLEANUP (in reverse order)\n *    iounmap(virt_addr)\n *    pci_release_regions(pdev)\n *    pci_disable_device(pdev)\n */\n\n/* ========================================================================== */\n/* FUNCTION: gpu_pci_probe */\n/* ========================================================================== */\n/* Called when kernel detects our GPU device.\n * This is where we:\n * - Enable the device\n * - Map the BARs to access GPU memory\n * - Initialize communication with the GPU\n */\nstatic int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n    resource_size_t fb_start, fb_len, fb_flags;\n    resource_size_t mmio_start, mmio_len, mmio_flags;\n    u32 device_id_reg;\n    int ret;\n\n    printk(KERN_INFO \"GPU Driver: Probing device\\n\");\n\n    /* TODO: STEP 1 - Enable PCI device */\n    /* Use pci_enable_device(pdev) to power on and enable the device */\n    /* Check return value: if (ret < 0) return error */\n    /* HINT: Store result in 'ret' variable */\n\n    /* TODO: STEP 2 - Get BAR 0 (Framebuffer) information */\n    /* Use pci_resource_start(pdev, GPU_BAR_FRAMEBUFFER) to get physical address */\n    /* Use pci_resource_len(pdev, GPU_BAR_FRAMEBUFFER) to get size */\n    /* Use pci_resource_flags(pdev, GPU_BAR_FRAMEBUFFER) to get flags */\n    /* Store in fb_start, fb_len, fb_flags (already declared above) */\n    /* HINT: fb_start = pci_resource_start(pdev, GPU_BAR_FRAMEBUFFER); */\n\n    /* TODO: Print BAR 0 information */\n    /* Format: \"GPU Driver: BAR 0 (Framebuffer): start=0x%llx, size=%lluMB, flags=0x%llx\\n\" */\n    /* HINT: Convert size to MB by dividing fb_len by (1024*1024) */\n    /* HINT: Use %llx for 64-bit hex, %llu for 64-bit decimal, %llx for flags */\n    /* printk(KERN_INFO \"GPU Driver: BAR 0 (Framebuffer): start=0x%llx, size=%lluMB, flags=0x%llx\\n\",\n              (unsigned long long)fb_start, (unsigned long long)fb_len / (1024*1024),\n              (unsigned long long)fb_flags); */\n\n    /* TODO: STEP 3 - Get BAR 2 (MMIO) information */\n    /* Same as BAR 0, but use GPU_BAR_MMIO instead */\n    /* Store in mmio_start, mmio_len, mmio_flags */\n\n    /* TODO: Print BAR 2 information */\n    /* Format: \"GPU Driver: BAR 2 (MMIO): start=0x%llx, size=%lluKB, flags=0x%llx\\n\" */\n    /* HINT: Convert size to KB by dividing mmio_len by 1024 */\n    /* HINT: Cast flags to (unsigned long long)mmio_flags */\n\n    /* TODO: STEP 4 - Request memory regions */\n    /* Use pci_request_regions(pdev, \"gpu_bar_driver\") to reserve BARs */\n    /* Check return value: if (ret < 0) goto error_disable; */\n    /* Print: \"GPU Driver: Requested memory regions\\n\" */\n\n    /* TODO: STEP 5 - Map BAR 2 (MMIO registers) */\n    /* Use ioremap(mmio_start, mmio_len) to map MMIO */\n    /* Store result in mmio_base global variable */\n    /* Check if mmio_base is NULL: if (!mmio_base) goto error_release; */\n    /* Store mmio_len in mmio_size global variable */\n    /* Print: \"GPU Driver: Mapped MMIO at virtual address %p\\n\", mmio_base */\n    /* WHY ioremap() not ioremap_wc()? */\n    /* - MMIO registers need strict ordering and no caching */\n    /* - Every write must reach hardware immediately */\n    /* - Example: Writing command register must happen before data register */\n\n    /* TODO: STEP 6 - Map BAR 0 (Framebuffer) with write-combining */\n    /* Use ioremap_wc(fb_start, fb_len) to map framebuffer */\n    /* Store result in fb_base global variable */\n    /* Check if fb_base is NULL: if (!fb_base) goto error_unmap_mmio; */\n    /* Store fb_len in fb_size global variable */\n    /* Print: \"GPU Driver: Mapped framebuffer at virtual address %p\\n\", fb_base */\n    /* WHY ioremap_wc()? */\n    /* - Framebuffer benefits from write-combining for performance */\n    /* - CPU can batch multiple writes into single bus transaction */\n    /* - Huge performance improvement for drawing pixels! */\n    /* - Real example: AMD amdgpu uses ioremap_wc() for 16GB VRAM BAR */\n\n    /* TODO: STEP 7 - Read GPU identification register from MMIO */\n    /* Use ioread32(mmio_base + MMIO_ID_REGISTER) to read device ID */\n    /* Store in device_id_reg variable */\n    /* Print: \"GPU Driver: Hardware register test read: 0x%08x\\n\", device_id_reg */\n    /* IMPORTANT: Never use regular pointer dereference like *mmio_base! */\n    /* MUST use ioread32() for proper hardware access */\n    /* NOTE: The value read may vary - this is just to demonstrate hardware access */\n\n    /* TODO: Print success message */\n    /* Print: \"GPU Driver: All BARs mapped successfully\\n\" */\n\n    return 0;\n\n    /* Error handling (cleanup in reverse order) */\nerror_unmap_mmio:\n    if (mmio_base) {\n        iounmap(mmio_base);\n        mmio_base = NULL;\n    }\nerror_release:\n    pci_release_regions(pdev);\nerror_disable:\n    pci_disable_device(pdev);\n    return -EIO;\n}\n\n/* ========================================================================== */\n/* FUNCTION: gpu_pci_remove */\n/* ========================================================================== */\n/* Called when device is removed or module is unloaded.\n * CRITICAL: Must cleanup in REVERSE order of probe!\n */\nstatic void gpu_pci_remove(struct pci_dev *pdev)\n{\n    printk(KERN_INFO \"GPU Driver: Removing device\\n\");\n\n    /* TODO: STEP 1 - Unmap MMIO (reverse of probe step 5) */\n    /* Check if mmio_base is not NULL */\n    /* Use iounmap(mmio_base) to unmap */\n    /* Set mmio_base = NULL for safety */\n    /* HINT: if (mmio_base) { iounmap(mmio_base); mmio_base = NULL; } */\n\n    /* TODO: STEP 2 - Unmap framebuffer (reverse of probe step 6) */\n    /* Check if fb_base is not NULL */\n    /* Use iounmap(fb_base) to unmap */\n    /* Set fb_base = NULL for safety */\n\n    /* TODO: Print cleanup message */\n    /* Print: \"GPU Driver: Unmapped MMIO and framebuffer\\n\" */\n\n    /* TODO: STEP 3 - Release memory regions (reverse of probe step 4) */\n    /* Use pci_release_regions(pdev) */\n    /* Print: \"GPU Driver: Released memory regions\\n\" */\n\n    /* TODO: STEP 4 - Disable device (reverse of probe step 1) */\n    /* Use pci_disable_device(pdev) */\n}\n\n/* ========================================================================== */\n/* PCI DRIVER STRUCTURE */\n/* ========================================================================== */\nstatic struct pci_driver gpu_pci_driver = {\n    .name = \"gpu_bar_driver\",\n    .id_table = gpu_pci_table,\n    .probe = gpu_pci_probe,\n    .remove = gpu_pci_remove,\n};\n\n/* ========================================================================== */\n/* MODULE INIT/EXIT */\n/* ========================================================================== */\nstatic int __init gpu_bar_init(void)\n{\n    printk(KERN_INFO \"GPU BAR Mapping Driver: Initializing\\n\");\n    return pci_register_driver(&gpu_pci_driver);\n}\n\nstatic void __exit gpu_bar_exit(void)\n{\n    printk(KERN_INFO \"GPU BAR Mapping Driver: Exiting\\n\");\n    pci_unregister_driver(&gpu_pci_driver);\n}\n\nmodule_init(gpu_bar_init);\nmodule_exit(gpu_bar_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Student\");\nMODULE_DESCRIPTION(\"Learning PCI BAR mapping and MMIO access for GPU drivers\");\nMODULE_VERSION(\"1.0\");\n",
      "readOnly": false,
      "language": "c"
    },
    {
      "name": "Makefile",
      "content": "# PCI BAR mapping module Makefile\nobj-m += pci_bar_map.o\n\n# Kernel build directory\nKDIR := /lib/modules/$(shell uname -r)/build\n\n# Default target\nall:\n\tmake -C $(KDIR) M=$(PWD) modules\n\nclean:\n\tmake -C $(KDIR) M=$(PWD) clean\n\ninstall: all\n\tmake -C $(KDIR) M=$(PWD) modules_install\n\nhelp:\n\tmake -C $(KDIR) M=$(PWD) help\n\n.PHONY: all clean install help\n",
      "readOnly": true,
      "language": "makefile"
    }
  ],
  "concepts": [
    "PCI Base Address Registers (BARs)",
    "Memory-mapped I/O (MMIO)",
    "Physical vs virtual address mapping",
    "Resource management and reservation",
    "ioremap vs ioremap_wc",
    "GPU memory regions (framebuffer vs registers)",
    "Hardware register access with ioread/iowrite",
    "Proper driver cleanup and resource release",
    "Write-combining for performance",
    "PCI resource flags and attributes"
  ],
  "skills": [
    "Mapping PCI BARs to virtual memory",
    "Using ioremap() for MMIO registers",
    "Using ioremap_wc() for framebuffer memory",
    "Reading PCI resource information",
    "Requesting and releasing PCI regions",
    "Reading hardware registers with ioread32()",
    "Proper error handling and cleanup",
    "Understanding GPU memory architecture",
    "Managing I/O memory mappings",
    "Professional driver resource management"
  ],
  "validation": {
    "exactRequirements": {
      "functionNames": [
        "gpu_bar_init",
        "gpu_bar_exit",
        "gpu_pci_probe",
        "gpu_pci_remove"
      ],
      "macro_declarations": [
        {
          "name": "GPU_VENDOR_ID",
          "type": "constant",
          "value": "0x1234",
          "description": "PCI vendor ID for bochs-display GPU"
        },
        {
          "name": "GPU_DEVICE_ID",
          "type": "constant",
          "value": "0x1111",
          "description": "PCI device ID for bochs-display GPU"
        },
        {
          "name": "GPU_BAR_FRAMEBUFFER",
          "type": "constant",
          "value": "0",
          "description": "BAR index for framebuffer memory"
        },
        {
          "name": "GPU_BAR_MMIO",
          "type": "constant",
          "value": "2",
          "description": "BAR index for MMIO registers"
        },
        {
          "name": "MMIO_ID_REGISTER",
          "type": "constant",
          "value": "0x0",
          "description": "Offset of device ID register in MMIO space"
        }
      ],
      "variables": [
        {
          "name": "mmio_base",
          "type": "void __iomem *",
          "value": "NULL",
          "storageClass": "static"
        },
        {
          "name": "fb_base",
          "type": "void __iomem *",
          "value": "NULL",
          "storageClass": "static"
        },
        {
          "name": "mmio_size",
          "type": "resource_size_t",
          "value": "0",
          "storageClass": "static"
        },
        {
          "name": "fb_size",
          "type": "resource_size_t",
          "value": "0",
          "storageClass": "static"
        },
        {
          "name": "gpu_pci_table",
          "type": "const struct pci_device_id",
          "value": "[{ PCI_DEVICE(GPU_VENDOR_ID, GPU_DEVICE_ID) }, { 0, }]",
          "storageClass": "static"
        },
        {
          "name": "gpu_pci_driver",
          "type": "struct pci_driver",
          "value": "{.name = \"gpu_bar_driver\", .id_table = gpu_pci_table, .probe = gpu_pci_probe, .remove = gpu_pci_remove}",
          "storageClass": "static"
        }
      ],
      "outputMessages": [
        "GPU BAR Mapping Driver: Initializing",
        "GPU Driver: Probing device",
        "GPU Driver: BAR 0 (Framebuffer): start=",
        "GPU Driver: BAR 2 (MMIO): start=",
        "GPU Driver: Requested memory regions",
        "GPU Driver: Mapped MMIO at virtual address",
        "GPU Driver: Mapped framebuffer at virtual address",
        "GPU Driver: Hardware register test read:",
        "GPU Driver: All BARs mapped successfully",
        "GPU Driver: Removing device",
        "GPU Driver: Unmapped MMIO and framebuffer",
        "GPU Driver: Released memory regions",
        "GPU BAR Mapping Driver: Exiting"
      ],
      "requiredIncludes": [
        "linux/module.h",
        "linux/kernel.h",
        "linux/init.h",
        "linux/pci.h",
        "linux/io.h"
      ],
      "mustContain": [
        "pci_enable_device",
        "pci_resource_start",
        "pci_resource_len",
        "pci_resource_flags",
        "pci_request_regions",
        "ioremap",
        "ioremap_wc",
        "ioread32",
        "iounmap",
        "pci_release_regions",
        "pci_disable_device",
        "GPU_BAR_FRAMEBUFFER",
        "GPU_BAR_MMIO",
        "MMIO_ID_REGISTER",
        "PCI_DEVICE(GPU_VENDOR_ID, GPU_DEVICE_ID)",
        "pci_register_driver",
        "pci_unregister_driver"
      ],
      "moduleInfo": {
        "license": "GPL"
      }
    },
    "testCases": [
      {
        "id": "macro_definitions",
        "name": "Macro Definitions in Header",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "#define GPU_VENDOR_ID",
          "0x1234",
          "#define GPU_DEVICE_ID",
          "0x1111",
          "#define GPU_BAR_FRAMEBUFFER",
          "#define GPU_BAR_MMIO",
          "#define MMIO_ID_REGISTER"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "function_signatures_source",
        "name": "Function Implementations in Source",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)",
          "static void gpu_pci_remove(struct pci_dev *pdev)",
          "static int __init gpu_bar_init(void)",
          "static void __exit gpu_bar_exit(void)"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "variable_declarations",
        "name": "Global Variable Declarations",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "static void __iomem *mmio_base",
          "static void __iomem *fb_base",
          "static resource_size_t mmio_size",
          "static resource_size_t fb_size",
          "static const struct pci_device_id gpu_pci_table",
          "static struct pci_driver gpu_pci_driver"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "pci_bar_api_usage",
        "name": "PCI BAR API Functions Usage",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "pci_enable_device",
          "pci_resource_start",
          "pci_resource_len",
          "pci_resource_flags",
          "pci_request_regions",
          "ioremap",
          "ioremap_wc",
          "ioread32",
          "iounmap",
          "pci_release_regions",
          "pci_disable_device"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "bar_macros_usage",
        "name": "BAR Macros Usage in Code",
        "type": "code_analysis",
        "critical": true,
        "expectedSymbols": [
          "GPU_BAR_FRAMEBUFFER",
          "GPU_BAR_MMIO",
          "MMIO_ID_REGISTER"
        ],
        "prohibitedSymbols": []
      },
      {
        "id": "exact_output",
        "name": "Exact Output Messages",
        "type": "output_match",
        "critical": true,
        "expected": [
          {
            "pattern": "GPU BAR Mapping Driver: Initializing",
            "exact": true,
            "linkedFunction": "static int __init gpu_bar_init(void)"
          },
          {
            "pattern": "GPU Driver: Probing device",
            "exact": true,
            "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
          },
          {
            "pattern": "GPU Driver: BAR 0 \\(Framebuffer\\):.*start=0x.*size=.*MB.*flags=0x",
            "exact": false,
            "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
          },
          {
            "pattern": "GPU Driver: BAR 2 \\(MMIO\\):.*start=0x.*size=.*KB.*flags=0x",
            "exact": false,
            "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
          },
          {
            "pattern": "GPU Driver: Requested memory regions",
            "exact": true,
            "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
          },
          {
            "pattern": "GPU Driver: Mapped MMIO at virtual address",
            "exact": false,
            "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
          },
          {
            "pattern": "GPU Driver: Mapped framebuffer at virtual address",
            "exact": false,
            "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
          },
          {
            "pattern": "GPU Driver: Hardware register test read: 0x",
            "exact": false,
            "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
          },
          {
            "pattern": "GPU Driver: All BARs mapped successfully",
            "exact": true,
            "linkedFunction": "static int gpu_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)"
          },
          {
            "pattern": "GPU Driver: Removing device",
            "exact": true,
            "linkedFunction": "static void gpu_pci_remove(struct pci_dev *pdev)"
          },
          {
            "pattern": "GPU Driver: Unmapped MMIO and framebuffer",
            "exact": true,
            "linkedFunction": "static void gpu_pci_remove(struct pci_dev *pdev)"
          },
          {
            "pattern": "GPU Driver: Released memory regions",
            "exact": true,
            "linkedFunction": "static void gpu_pci_remove(struct pci_dev *pdev)"
          },
          {
            "pattern": "GPU BAR Mapping Driver: Exiting",
            "exact": true,
            "linkedFunction": "static void __exit gpu_bar_exit(void)"
          }
        ]
      },
      {
        "id": "comprehensive_bar_mapping_validation",
        "name": "Comprehensive PCI BAR Mapping and MMIO Access Validation",
        "type": "kernel_project_test",
        "critical": true,
        "testScenario": {
          "qemuArgs": [
            "-device",
            "bochs-display,addr=05.0",
            "-vga",
            "none"
          ],
          "userspaceApps": [],
          "setupCommands": [
            "echo 'Starting comprehensive PCI BAR mapping validation'"
          ],
          "testCommands": [
            "echo 'Phase 1: TCC Header Validation'",
            "mkdir -p /tmp/linux",
            "echo '#define KERN_INFO' > /tmp/linux/kernel.h",
            "echo 'int printk(const char *fmt, ...);' >> /tmp/linux/kernel.h",
            "echo '#define MODULE_LICENSE(x)' > /tmp/linux/module.h",
            "echo '#define MODULE_AUTHOR(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_DESCRIPTION(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_VERSION(x)' >> /tmp/linux/module.h",
            "echo '#define MODULE_DEVICE_TABLE(type, table)' >> /tmp/linux/module.h",
            "echo '#define module_init(x)' >> /tmp/linux/module.h",
            "echo '#define module_exit(x)' >> /tmp/linux/module.h",
            "echo '#define __init' > /tmp/linux/init.h",
            "echo '#define __exit' >> /tmp/linux/init.h",
            "echo 'struct pci_dev;' > /tmp/linux/pci.h",
            "echo 'struct pci_device_id { unsigned int vendor; unsigned int device; };' >> /tmp/linux/pci.h",
            "echo '#define PCI_DEVICE(vend, dev) .vendor = (vend), .device = (dev)' >> /tmp/linux/pci.h",
            "echo 'int pci_enable_device(struct pci_dev *dev);' >> /tmp/linux/pci.h",
            "echo 'void pci_disable_device(struct pci_dev *dev);' >> /tmp/linux/pci.h",
            "echo 'int pci_register_driver(void *drv);' >> /tmp/linux/pci.h",
            "echo 'void pci_unregister_driver(void *drv);' >> /tmp/linux/pci.h",
            "echo 'typedef unsigned long long resource_size_t;' >> /tmp/linux/pci.h",
            "echo 'resource_size_t pci_resource_start(struct pci_dev *dev, int bar);' >> /tmp/linux/pci.h",
            "echo 'resource_size_t pci_resource_len(struct pci_dev *dev, int bar);' >> /tmp/linux/pci.h",
            "echo 'unsigned long pci_resource_flags(struct pci_dev *dev, int bar);' >> /tmp/linux/pci.h",
            "echo 'int pci_request_regions(struct pci_dev *pdev, const char *name);' >> /tmp/linux/pci.h",
            "echo 'void pci_release_regions(struct pci_dev *pdev);' >> /tmp/linux/pci.h",
            "echo 'struct pci_driver { const char *name; const struct pci_device_id *id_table; int (*probe)(struct pci_dev *, const struct pci_device_id *); void (*remove)(struct pci_dev *); };' >> /tmp/linux/pci.h",
            "echo '#define __iomem' > /tmp/linux/io.h",
            "echo 'typedef unsigned int u32;' >> /tmp/linux/io.h",
            "echo 'void __iomem *ioremap(unsigned long long phys_addr, unsigned long size);' >> /tmp/linux/io.h",
            "echo 'void __iomem *ioremap_wc(unsigned long long phys_addr, unsigned long size);' >> /tmp/linux/io.h",
            "echo 'void iounmap(volatile void __iomem *addr);' >> /tmp/linux/io.h",
            "echo 'u32 ioread32(const volatile void __iomem *addr);' >> /tmp/linux/io.h",
            "echo 'void iowrite32(u32 value, volatile void __iomem *addr);' >> /tmp/linux/io.h",
            "echo '#include \"/lib/modules/pci_bar_map.h\"' > /tmp/test.c",
            "echo 'int main() { return 0; }' >> /tmp/test.c",
            "/usr/bin/tcc -I/tmp -Wimplicit-function-declaration -Werror -c /tmp/test.c -o /tmp/test.o 2>/tmp/tcc_error.log",
            "TCC_EXIT_CODE=$?",
            "if [ $TCC_EXIT_CODE -ne 0 ]; then echo 'FAIL: Header validation failed'; cat /tmp/tcc_error.log; else echo 'PASS: All declarations found in header file'; fi",
            "",
            "echo 'Phase 2: Verify PCI Device Exists'",
            "ls /sys/bus/pci/devices/ | grep -q '0000:00:05.0' && echo 'PASS: PCI device 0000:00:05.0 exists' || echo 'FAIL: PCI device not found'",
            "",
            "echo 'Phase 3: Check PCI Device BARs'",
            "if [ -f /sys/bus/pci/devices/0000:00:05.0/resource ]; then",
            "  echo 'PASS: PCI device has resource file'",
            "  cat /sys/bus/pci/devices/0000:00:05.0/resource",
            "else",
            "  echo 'FAIL: No resource file found'",
            "fi",
            "",
            "echo 'Phase 4: Load Module and Verify Probe'",
            "sleep 1",
            "insmod /lib/modules/pci_bar_map.ko",
            "sleep 2",
            "",
            "echo 'Phase 5: Validate BAR Mapping in dmesg'",
            "dmesg | grep 'GPU BAR Mapping Driver: Initializing' && echo 'PASS: Module initialized' || echo 'FAIL: Module init missing'",
            "dmesg | grep 'GPU Driver: Probing device' && echo 'PASS: Probe function called' || echo 'FAIL: Probe not called'",
            "dmesg | grep 'GPU Driver: BAR 0 (Framebuffer)' && echo 'PASS: BAR 0 information printed' || echo 'FAIL: BAR 0 info missing'",
            "dmesg | grep 'GPU Driver: BAR 2 (MMIO)' && echo 'PASS: BAR 2 information printed' || echo 'FAIL: BAR 2 info missing'",
            "dmesg | grep 'GPU Driver: Requested memory regions' && echo 'PASS: Memory regions requested' || echo 'FAIL: Request regions missing'",
            "dmesg | grep 'GPU Driver: Mapped MMIO at virtual address' && echo 'PASS: MMIO mapped successfully' || echo 'FAIL: MMIO mapping missing'",
            "dmesg | grep 'GPU Driver: Mapped framebuffer at virtual address' && echo 'PASS: Framebuffer mapped successfully' || echo 'FAIL: FB mapping missing'",
            "dmesg | grep 'GPU Driver: Hardware register test read: 0x' && echo 'PASS: Hardware register read from MMIO' || echo 'FAIL: Hardware register read missing'",
            "dmesg | grep 'GPU Driver: All BARs mapped successfully' && echo 'PASS: All BAR mapping completed' || echo 'FAIL: BAR mapping incomplete'",
            "",
            "echo 'Phase 6: Verify Module is Loaded'",
            "lsmod | grep pci_bar_map && echo 'PASS: Module is loaded' || echo 'FAIL: Module not in lsmod'",
            "",
            "echo 'Phase 7: Unload Module and Verify Cleanup'",
            "rmmod pci_bar_map",
            "sleep 1",
            "dmesg | grep 'GPU Driver: Removing device' && echo 'PASS: Remove function called' || echo 'FAIL: Remove not called'",
            "dmesg | grep 'GPU Driver: Unmapped MMIO and framebuffer' && echo 'PASS: Memory unmapped' || echo 'FAIL: Unmap missing'",
            "dmesg | grep 'GPU Driver: Released memory regions' && echo 'PASS: Regions released' || echo 'FAIL: Release missing'",
            "dmesg | grep 'GPU BAR Mapping Driver: Exiting' && echo 'PASS: Module exited cleanly' || echo 'FAIL: Exit missing'",
            "",
            "echo 'Phase 8: Verify Module Unloaded'",
            "lsmod | grep -q pci_bar_map && echo 'FAIL: Module still loaded' || echo 'PASS: Module unloaded successfully'",
            "",
            "echo 'PASS: All comprehensive PCI BAR mapping validation completed successfully'"
          ],
          "expected": {
            "dmesg": [
              "GPU BAR Mapping Driver: Initializing",
              "GPU Driver: Probing device",
              "GPU Driver: BAR 0 \\(Framebuffer\\):.*start=0x.*size=.*MB.*flags=0x",
              "GPU Driver: BAR 2 \\(MMIO\\):.*start=0x.*size=.*KB.*flags=0x",
              "GPU Driver: Requested memory regions",
              "GPU Driver: Mapped MMIO at virtual address",
              "GPU Driver: Mapped framebuffer at virtual address",
              "GPU Driver: Hardware register test read: 0x",
              "GPU Driver: All BARs mapped successfully",
              "GPU Driver: Removing device",
              "GPU Driver: Unmapped MMIO and framebuffer",
              "GPU Driver: Released memory regions",
              "GPU BAR Mapping Driver: Exiting"
            ],
            "stdout": [
              "PASS: All declarations found in header file",
              "PASS: PCI device 0000:00:05.0 exists",
              "PASS: PCI device has resource file",
              "PASS: Module initialized",
              "PASS: Probe function called",
              "PASS: BAR 0 information printed",
              "PASS: BAR 2 information printed",
              "PASS: Memory regions requested",
              "PASS: MMIO mapped successfully",
              "PASS: Framebuffer mapped successfully",
              "PASS: Hardware register read from MMIO",
              "PASS: All BAR mapping completed",
              "PASS: Module is loaded",
              "PASS: Remove function called",
              "PASS: Memory unmapped",
              "PASS: Regions released",
              "PASS: Module exited cleanly",
              "PASS: Module unloaded successfully",
              "PASS: All comprehensive PCI BAR mapping validation completed successfully"
            ]
          },
          "timeout": 30
        }
      }
    ]
  }
}
